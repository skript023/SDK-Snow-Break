#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Distance

#include "Basic.hpp"

#include "Distance_classes.hpp"
#include "Distance_parameters.hpp"


namespace SDK
{

// Function Distance.Distance_C.FindMinorMaxDistanceResult
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector                          Center                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FQueryResult>             Results                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Far                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseNearestDistance                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FQueryResult                     Result                                                 (Parm, OutParm, ContainsInstancedReference)

void UDistance_C::FindMinorMaxDistanceResult(const struct FVector& Center, TArray<struct FQueryResult>& Results, bool Far, bool UseNearestDistance, struct FQueryResult* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Distance_C", "FindMinorMaxDistanceResult");

	Params::Distance_C_FindMinorMaxDistanceResult Parms{};

	Parms.Center = std::move(Center);
	Parms.Results = std::move(Results);
	Parms.Far = Far;
	Parms.UseNearestDistance = UseNearestDistance;

	UObject::ProcessEvent(Func, &Parms);

	Results = std::move(Parms.Results);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Distance.Distance_C.Sort by Distance
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   Priority                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Center                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FQueryResult>             InResults                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Far                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    UseNearestDistance                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFinish                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FTargetSortResult>        NewParam                                               (Parm, OutParm, ContainsInstancedReference)

void UDistance_C::Sort_by_Distance(int32& Priority, const struct FVector& Center, TArray<struct FQueryResult>& InResults, bool Far, bool UseNearestDistance, bool* bFinish, TArray<struct FTargetSortResult>* NewParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Distance_C", "Sort by Distance");

	Params::Distance_C_Sort_by_Distance Parms{};

	Parms.Priority = Priority;
	Parms.Center = std::move(Center);
	Parms.InResults = std::move(InResults);
	Parms.Far = Far;
	Parms.UseNearestDistance = UseNearestDistance;

	UObject::ProcessEvent(Func, &Parms);

	Priority = Parms.Priority;
	InResults = std::move(Parms.InResults);

	if (bFinish != nullptr)
		*bFinish = Parms.bFinish;

	if (NewParam != nullptr)
		*NewParam = std::move(Parms.NewParam);
}


// Function Distance.Distance_C.Rule
// (HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   Priority                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FQueryResult>             InResults                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UAbilityComponentBase*            Querier                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FParamInfo>               Infos                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           CastActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTargetSortResult>        Out                                                    (Parm, OutParm, ContainsInstancedReference)

void UDistance_C::Rule(int32& Priority, TArray<struct FQueryResult>& InResults, class UAbilityComponentBase* Querier, TArray<struct FParamInfo>& Infos, class AActor* CastActor, TArray<struct FTargetSortResult>* Out) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Distance_C", "Rule");

	Params::Distance_C_Rule Parms{};

	Parms.Priority = Priority;
	Parms.InResults = std::move(InResults);
	Parms.Querier = Querier;
	Parms.Infos = std::move(Infos);
	Parms.CastActor = CastActor;

	UObject::ProcessEvent(Func, &Parms);

	Priority = Parms.Priority;
	InResults = std::move(Parms.InResults);
	Infos = std::move(Parms.Infos);

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}

}


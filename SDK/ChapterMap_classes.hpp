#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ChapterMap

#include "Basic.hpp"

#include "ChapterMap_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameCore_classes.hpp"
#include "UMGSpline_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class ChapterMap.ChapterMap_UserWidget
// 0x0180 (0x0448 - 0x02C8)
class UChapterMap_UserWidget final : public UGameCoreWidget
{
public:
	class UPanelWidget*                           DragRegion;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineWidget*                          SplineStyleDefault;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImageFogMask*                          FogMask;                                           // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNodeId;                                         // 0x02E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLineId;                                         // 0x02E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPointId;                                        // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PreSize;                                           // 0x02EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNodeData>                      Nodes;                                             // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLineData>                      Lines;                                             // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRegionData>                    Regions;                                           // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUMGSplineInfo                         DefaultSplineInfo;                                 // 0x0328(0x00C0)(NativeAccessSpecifierPublic)
	struct FVector2D                              ImgMapSize;                                        // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    MRegionName2id;                                    // 0x03F0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D ConvertToWidgetCenterPos(float X, float Y);
	void DrawLinewithNodes();
	struct FVector2D GetImgMapSize();
	bool LoadMapData(int32 MapId, const class FString& DataPath);
	void LuaDrawBezierNodes(class UCanvasPanel* CanvasPanel);
	void OnStart();
	void SetFogMaskSettings();
	void UnlockRegion(int32 NodeId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapterMap_UserWidget">();
	}
	static class UChapterMap_UserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChapterMap_UserWidget>();
	}
};
static_assert(alignof(UChapterMap_UserWidget) == 0x000008, "Wrong alignment on UChapterMap_UserWidget");
static_assert(sizeof(UChapterMap_UserWidget) == 0x000448, "Wrong size on UChapterMap_UserWidget");
static_assert(offsetof(UChapterMap_UserWidget, DragRegion) == 0x0002C8, "Member 'UChapterMap_UserWidget::DragRegion' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, SplineStyleDefault) == 0x0002D0, "Member 'UChapterMap_UserWidget::SplineStyleDefault' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, FogMask) == 0x0002D8, "Member 'UChapterMap_UserWidget::FogMask' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, MaxNodeId) == 0x0002E0, "Member 'UChapterMap_UserWidget::MaxNodeId' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, MaxLineId) == 0x0002E4, "Member 'UChapterMap_UserWidget::MaxLineId' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, MaxPointId) == 0x0002E8, "Member 'UChapterMap_UserWidget::MaxPointId' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, PreSize) == 0x0002EC, "Member 'UChapterMap_UserWidget::PreSize' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, Nodes) == 0x0002F8, "Member 'UChapterMap_UserWidget::Nodes' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, Lines) == 0x000308, "Member 'UChapterMap_UserWidget::Lines' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, Regions) == 0x000318, "Member 'UChapterMap_UserWidget::Regions' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, DefaultSplineInfo) == 0x000328, "Member 'UChapterMap_UserWidget::DefaultSplineInfo' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, ImgMapSize) == 0x0003E8, "Member 'UChapterMap_UserWidget::ImgMapSize' has a wrong offset!");
static_assert(offsetof(UChapterMap_UserWidget, MRegionName2id) == 0x0003F0, "Member 'UChapterMap_UserWidget::MRegionName2id' has a wrong offset!");

// Class ChapterMap.ImageFogMask
// 0x0050 (0x0280 - 0x0230)
class UImageFogMask final : public UImage
{
public:
	int32                                         PixelScale;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridScale;                                         // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DynamicTexture;                                    // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0240(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x3C];                                     // 0x0244(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateFogGrids();
	class UTexture2D* GenerateTexture(int32 Width, int32 Height, bool IsReset);
	bool SetTexture(class UTexture2D* InTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageFogMask">();
	}
	static class UImageFogMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageFogMask>();
	}
};
static_assert(alignof(UImageFogMask) == 0x000008, "Wrong alignment on UImageFogMask");
static_assert(sizeof(UImageFogMask) == 0x000280, "Wrong size on UImageFogMask");
static_assert(offsetof(UImageFogMask, PixelScale) == 0x000230, "Member 'UImageFogMask::PixelScale' has a wrong offset!");
static_assert(offsetof(UImageFogMask, GridScale) == 0x000234, "Member 'UImageFogMask::GridScale' has a wrong offset!");
static_assert(offsetof(UImageFogMask, DynamicTexture) == 0x000238, "Member 'UImageFogMask::DynamicTexture' has a wrong offset!");
static_assert(offsetof(UImageFogMask, Interval) == 0x000240, "Member 'UImageFogMask::Interval' has a wrong offset!");

}


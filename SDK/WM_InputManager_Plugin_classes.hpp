#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: WM_InputManager_Plugin

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "WM_InputManager_Plugin_structs.hpp"
#include "InputCore_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class WM_InputManager_Plugin.WM_InputManagerBase
// 0x03E0 (0x0408 - 0x0028)
class UWM_InputManagerBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableErrorLogs;                                  // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSucessLogs;                                 // 0x0061(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable_LOG_DEBUG_HIDP_PARSING;                    // 0x0062(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollectRuntimeLogs;                               // 0x0063(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Runtime_PluginErrors;                              // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Runtime_PluginSucess;                              // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDevicesRegistered;                                // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumMessageAttempts;                                // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFoundJoysticks_Debug;                           // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPoolingDevices;                                 // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWindows;                                        // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DEBUG;                                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWM_Settings*                           WM_SettingsRW;                                     // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWM_InputManagerMode                          ManagerModeEnum;                                   // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSViewport;                                      // 0x00C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeviceConnected;                                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeviceDisconnected;                              // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJoystickButtonTrigger;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNumDevicesChanged;                               // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeviceSelected;                                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnButtonKeyPressed;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnButtonKeyReleased;                               // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSwitchManagerMode;                               // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSwitchManagerModeEnum;                           // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetNumberOfPlayers;                              // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             On_WM_InputManagerBegin;                           // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             On_WM_InputManagerEnd;                             // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnListenForKeyInput;                               // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ManagerMode;                                       // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPlayers;                                   // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWM_Device*                             SelectedDevice;                                    // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputSettings*                         InputSettings;                                     // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerInput*                           PlayerInput_Ref;                                   // 0x01C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWM_Device*>                     All_DevicesList;                                   // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_HID*>            HID_DeviceList;                                    // 0x01D8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_HID_Joystick*>          Joystick_DeviceList;                               // 0x0228(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_Keyboard*>       Keyboard_DevicesList;                              // 0x0278(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device*>                Mouse_DeviceList;                                  // 0x02C8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_HID_Joystick*>          Joystick_UniqueDeviceTypeList;                     // 0x0318(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_HID*>            XInputDevices;                                     // 0x0368(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct F_PCS_Device>              PC_Devices;                                        // 0x03B8(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	void GetActionInputs(TArray<class FName>* ButtonInputs);
	void GetActionsListStringForKey(const struct FKey& Key, class FString* ActionsListString);
	void GetAllInputBindingsForKey(const struct FKey& Key, TArray<class FName>* ActionsForKey);
	void GetAllKeysForAction(class FName ActionName, TArray<struct FKey>* Bindings);
	void GetAllKeysForAxis(class FName ActionName, TArray<struct FKey>* Bindings);
	void GetAxisInputs(TArray<class FName>* InputAxisActions);
	void InitializeAPI();
	void OnDeviceButtonKeyEvent(const struct FKey& WM_Key, class UWM_Device* Device, EWM_KeyTriggerState* TriggerState);
	void SetNumberOfPlayers(int32 NumPlayers);
	void SwitchManagerMode(const class FString& Mode);
	void SwitchManagerModeEnum(EWM_InputManagerMode Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_InputManagerBase">();
	}
	static class UWM_InputManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_InputManagerBase>();
	}
};
static_assert(alignof(UWM_InputManagerBase) == 0x000008, "Wrong alignment on UWM_InputManagerBase");
static_assert(sizeof(UWM_InputManagerBase) == 0x000408, "Wrong size on UWM_InputManagerBase");
static_assert(offsetof(UWM_InputManagerBase, Version) == 0x000030, "Member 'UWM_InputManagerBase::Version' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnableErrorLogs) == 0x000060, "Member 'UWM_InputManagerBase::bEnableErrorLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnableSucessLogs) == 0x000061, "Member 'UWM_InputManagerBase::bEnableSucessLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnable_LOG_DEBUG_HIDP_PARSING) == 0x000062, "Member 'UWM_InputManagerBase::bEnable_LOG_DEBUG_HIDP_PARSING' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bCollectRuntimeLogs) == 0x000063, "Member 'UWM_InputManagerBase::bCollectRuntimeLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Runtime_PluginErrors) == 0x000068, "Member 'UWM_InputManagerBase::Runtime_PluginErrors' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Runtime_PluginSucess) == 0x000078, "Member 'UWM_InputManagerBase::Runtime_PluginSucess' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bDevicesRegistered) == 0x000088, "Member 'UWM_InputManagerBase::bDevicesRegistered' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumMessageAttempts) == 0x00008C, "Member 'UWM_InputManagerBase::NumMessageAttempts' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumFoundJoysticks_Debug) == 0x000090, "Member 'UWM_InputManagerBase::NumFoundJoysticks_Debug' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumPoolingDevices) == 0x000094, "Member 'UWM_InputManagerBase::NumPoolingDevices' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumWindows) == 0x000098, "Member 'UWM_InputManagerBase::NumWindows' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, DEBUG) == 0x0000A0, "Member 'UWM_InputManagerBase::DEBUG' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, WM_SettingsRW) == 0x0000B8, "Member 'UWM_InputManagerBase::WM_SettingsRW' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, ManagerModeEnum) == 0x0000C0, "Member 'UWM_InputManagerBase::ManagerModeEnum' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, HasSViewport) == 0x0000C1, "Member 'UWM_InputManagerBase::HasSViewport' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceConnected) == 0x0000C8, "Member 'UWM_InputManagerBase::OnDeviceConnected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceDisconnected) == 0x0000D8, "Member 'UWM_InputManagerBase::OnDeviceDisconnected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnJoystickButtonTrigger) == 0x0000E8, "Member 'UWM_InputManagerBase::OnJoystickButtonTrigger' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnNumDevicesChanged) == 0x0000F8, "Member 'UWM_InputManagerBase::OnNumDevicesChanged' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceSelected) == 0x000108, "Member 'UWM_InputManagerBase::OnDeviceSelected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnButtonKeyPressed) == 0x000118, "Member 'UWM_InputManagerBase::OnButtonKeyPressed' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnButtonKeyReleased) == 0x000128, "Member 'UWM_InputManagerBase::OnButtonKeyReleased' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSwitchManagerMode) == 0x000138, "Member 'UWM_InputManagerBase::OnSwitchManagerMode' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSwitchManagerModeEnum) == 0x000148, "Member 'UWM_InputManagerBase::OnSwitchManagerModeEnum' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSetNumberOfPlayers) == 0x000158, "Member 'UWM_InputManagerBase::OnSetNumberOfPlayers' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, On_WM_InputManagerBegin) == 0x000168, "Member 'UWM_InputManagerBase::On_WM_InputManagerBegin' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, On_WM_InputManagerEnd) == 0x000178, "Member 'UWM_InputManagerBase::On_WM_InputManagerEnd' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnListenForKeyInput) == 0x000188, "Member 'UWM_InputManagerBase::OnListenForKeyInput' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, ManagerMode) == 0x000198, "Member 'UWM_InputManagerBase::ManagerMode' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumberOfPlayers) == 0x0001A8, "Member 'UWM_InputManagerBase::NumberOfPlayers' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, SelectedDevice) == 0x0001B0, "Member 'UWM_InputManagerBase::SelectedDevice' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, InputSettings) == 0x0001B8, "Member 'UWM_InputManagerBase::InputSettings' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, PlayerInput_Ref) == 0x0001C0, "Member 'UWM_InputManagerBase::PlayerInput_Ref' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, All_DevicesList) == 0x0001C8, "Member 'UWM_InputManagerBase::All_DevicesList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, HID_DeviceList) == 0x0001D8, "Member 'UWM_InputManagerBase::HID_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Joystick_DeviceList) == 0x000228, "Member 'UWM_InputManagerBase::Joystick_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Keyboard_DevicesList) == 0x000278, "Member 'UWM_InputManagerBase::Keyboard_DevicesList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Mouse_DeviceList) == 0x0002C8, "Member 'UWM_InputManagerBase::Mouse_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Joystick_UniqueDeviceTypeList) == 0x000318, "Member 'UWM_InputManagerBase::Joystick_UniqueDeviceTypeList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, XInputDevices) == 0x000368, "Member 'UWM_InputManagerBase::XInputDevices' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, PC_Devices) == 0x0003B8, "Member 'UWM_InputManagerBase::PC_Devices' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_ControllerFunctionLib
// 0x0000 (0x0028 - 0x0028)
class UWM_ControllerFunctionLib final : public UBlueprintFunctionLibrary
{
public:
	static class UWM_InputManager* Get_WM_InputManager();
	static class FName GetKeyName(const struct FKey& InKey);
	static void PrintDevicesInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_ControllerFunctionLib">();
	}
	static class UWM_ControllerFunctionLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_ControllerFunctionLib>();
	}
};
static_assert(alignof(UWM_ControllerFunctionLib) == 0x000008, "Wrong alignment on UWM_ControllerFunctionLib");
static_assert(sizeof(UWM_ControllerFunctionLib) == 0x000028, "Wrong size on UWM_ControllerFunctionLib");

// Class WM_InputManager_Plugin.WM_Device
// 0x00F8 (0x0120 - 0x0028)
class UWM_Device : public UObject
{
public:
	class UWM_InputManager*                       InputManager;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWM_Settings*                           WM_SettingsRW;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWM_BasicDeviceInfo                    BasicDeviceInfo;                                   // 0x0038(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRawDataInitialized;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RawDataWasInitialized;                             // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SAVESTRING;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWM_DeviceType                                DeviceType;                                        // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeviceSlot;                                        // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueDeviceSlot;                                  // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerAssigment;                               // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeviceActivityDetected;                            // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSelected;                                        // 0x00D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2E];                                      // 0x00DA(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueHandleString;                                // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PacketNum;                                         // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignDeviceToPlayerIndex(int32 Index_0);
	void ClearDeviceInput();
	bool IsValidPlayerIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device">();
	}
	static class UWM_Device* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device>();
	}
};
static_assert(alignof(UWM_Device) == 0x000008, "Wrong alignment on UWM_Device");
static_assert(sizeof(UWM_Device) == 0x000120, "Wrong size on UWM_Device");
static_assert(offsetof(UWM_Device, InputManager) == 0x000028, "Member 'UWM_Device::InputManager' has a wrong offset!");
static_assert(offsetof(UWM_Device, WM_SettingsRW) == 0x000030, "Member 'UWM_Device::WM_SettingsRW' has a wrong offset!");
static_assert(offsetof(UWM_Device, BasicDeviceInfo) == 0x000038, "Member 'UWM_Device::BasicDeviceInfo' has a wrong offset!");
static_assert(offsetof(UWM_Device, OnRawDataInitialized) == 0x0000A0, "Member 'UWM_Device::OnRawDataInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device, Enabled) == 0x0000B0, "Member 'UWM_Device::Enabled' has a wrong offset!");
static_assert(offsetof(UWM_Device, RawDataWasInitialized) == 0x0000B1, "Member 'UWM_Device::RawDataWasInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device, SAVESTRING) == 0x0000B8, "Member 'UWM_Device::SAVESTRING' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceType) == 0x0000C8, "Member 'UWM_Device::DeviceType' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceSlot) == 0x0000CC, "Member 'UWM_Device::DeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_Device, UniqueDeviceSlot) == 0x0000D0, "Member 'UWM_Device::UniqueDeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_Device, ControllerAssigment) == 0x0000D4, "Member 'UWM_Device::ControllerAssigment' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceActivityDetected) == 0x0000D8, "Member 'UWM_Device::DeviceActivityDetected' has a wrong offset!");
static_assert(offsetof(UWM_Device, IsSelected) == 0x0000D9, "Member 'UWM_Device::IsSelected' has a wrong offset!");
static_assert(offsetof(UWM_Device, UniqueHandleString) == 0x000108, "Member 'UWM_Device::UniqueHandleString' has a wrong offset!");
static_assert(offsetof(UWM_Device, PacketNum) == 0x000118, "Member 'UWM_Device::PacketNum' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Device_HID
// 0x08F0 (0x0A10 - 0x0120)
class UWM_Device_HID : public UWM_Device
{
public:
	struct FWM_HID_DeviceInfo                     DeviceInfo;                                        // 0x0120(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          Is_XInput;                                         // 0x01F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_XInputInitialized;                              // 0x01F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_XInputSlotGuess;                                // 0x01F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3[0x1];                                      // 0x01F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         X_I_D;                                             // 0x01F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Steam;                                          // 0x01F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x5D7];                                    // 0x01F9(0x05D7)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FirstPressedRawKey;                                // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D4[0x23C];                                    // 0x07D4(0x023C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<int32> GetRaw_Available_Axes();
	TArray<int32> GetRaw_Available_Buttons();
	TArray<int32> GetRaw_Available_DPADs();
	void GetRaw_ButtonValue(int32 Index_0, bool* ButtonValue, EWM_KeyTriggerState* KeyTriggerState);

	void GetAxisKeyValue(const struct FKey& Key, float* AxisValue, bool* IsValid_WM_Key) const;
	void GetButtonKeyValue(const struct FKey& Key, bool* ButtonValue, bool* IsValid_WM_Key) const;
	struct FWM_HID_AxisData GetRaw_AxisData(int32 Index_0) const;
	float GetRaw_AxisValue(int32 Index_0) const;
	void GetRaw_DPADData(int32 Index_0, bool* Up, bool* Down, bool* Left, bool* Right, EWM_AxisCodeTable* AxisEnum, class FString* AxisBindingCode, class FString* AxisHEX, int32* Instance, float* Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_HID">();
	}
	static class UWM_Device_HID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_HID>();
	}
};
static_assert(alignof(UWM_Device_HID) == 0x000008, "Wrong alignment on UWM_Device_HID");
static_assert(sizeof(UWM_Device_HID) == 0x000A10, "Wrong size on UWM_Device_HID");
static_assert(offsetof(UWM_Device_HID, DeviceInfo) == 0x000120, "Member 'UWM_Device_HID::DeviceInfo' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInput) == 0x0001F0, "Member 'UWM_Device_HID::Is_XInput' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInputInitialized) == 0x0001F1, "Member 'UWM_Device_HID::Is_XInputInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInputSlotGuess) == 0x0001F2, "Member 'UWM_Device_HID::Is_XInputSlotGuess' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, X_I_D) == 0x0001F4, "Member 'UWM_Device_HID::X_I_D' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_Steam) == 0x0001F8, "Member 'UWM_Device_HID::Is_Steam' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, FirstPressedRawKey) == 0x0007D0, "Member 'UWM_Device_HID::FirstPressedRawKey' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Device_Keyboard
// 0x0000 (0x0120 - 0x0120)
class UWM_Device_Keyboard final : public UWM_Device
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_Keyboard">();
	}
	static class UWM_Device_Keyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_Keyboard>();
	}
};
static_assert(alignof(UWM_Device_Keyboard) == 0x000008, "Wrong alignment on UWM_Device_Keyboard");
static_assert(sizeof(UWM_Device_Keyboard) == 0x000120, "Wrong size on UWM_Device_Keyboard");

// Class WM_InputManager_Plugin.WM_Device_Mouse
// 0x0000 (0x0120 - 0x0120)
class UWM_Device_Mouse final : public UWM_Device
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_Mouse">();
	}
	static class UWM_Device_Mouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_Mouse>();
	}
};
static_assert(alignof(UWM_Device_Mouse) == 0x000008, "Wrong alignment on UWM_Device_Mouse");
static_assert(sizeof(UWM_Device_Mouse) == 0x000120, "Wrong size on UWM_Device_Mouse");

// Class WM_InputManager_Plugin.WM_HID_Joystick
// 0x0068 (0x0A78 - 0x0A10)
class UWM_HID_Joystick final : public UWM_Device_HID
{
public:
	uint8                                         Pad_A10[0x18];                                     // 0x0A10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConfigMode;                                        // 0x0A28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnModeSwitched;                                    // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConfigChanged;                                   // 0x0A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsListeningForInput;                              // 0x0A50(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A51[0x7];                                      // 0x0A51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ListeningKey;                                      // 0x0A58(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWM_HID_Joystick_SAV*                   Savedata;                                          // 0x0A70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AutodetectAxisConfig(int32 Axis);
	void Bind_InputKey(const struct FKey& Key, const class FString& TargetBinding);
	void GetAxisConfig(int32 AxisNumber, struct FWM_HID_AxisConfiguration* Config);
	void GetBinding(const struct FKey& Key, class FString* BINDING);
	void GetBindingOptions(const struct FKey& Key, TArray<class FString>* Options);
	void GetConfigurationMode(int32* ConfigurationMode);
	void ListenForKeyInput(const struct FKey& Key, bool* Sucess);
	void PressButton(int32 Button);
	void RebindKeyInput(const struct FKey& Key, bool* Sucess);
	void ResetAxisConfig(int32 Axis);
	void ResetConfigurationMode();
	void SaveConfig();
	void SetAxisConfig(int32 AxisNumber, const struct FWM_HID_AxisConfiguration& Config);
	void SetConfigurationMode(int32 ConfigurationMode);
	void UpdateAxisValue(int32 Axis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_HID_Joystick">();
	}
	static class UWM_HID_Joystick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_HID_Joystick>();
	}
};
static_assert(alignof(UWM_HID_Joystick) == 0x000008, "Wrong alignment on UWM_HID_Joystick");
static_assert(sizeof(UWM_HID_Joystick) == 0x000A78, "Wrong size on UWM_HID_Joystick");
static_assert(offsetof(UWM_HID_Joystick, ConfigMode) == 0x000A28, "Member 'UWM_HID_Joystick::ConfigMode' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, OnModeSwitched) == 0x000A30, "Member 'UWM_HID_Joystick::OnModeSwitched' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, OnConfigChanged) == 0x000A40, "Member 'UWM_HID_Joystick::OnConfigChanged' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, bIsListeningForInput) == 0x000A50, "Member 'UWM_HID_Joystick::bIsListeningForInput' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, ListeningKey) == 0x000A58, "Member 'UWM_HID_Joystick::ListeningKey' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, Savedata) == 0x000A70, "Member 'UWM_HID_Joystick::Savedata' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_HID_Joystick_SAV
// 0x0078 (0x00A0 - 0x0028)
class UWM_HID_Joystick_SAV final : public USaveGame
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasInitialized;                                    // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveSlot;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMode;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FHID_Joystick_CONFIG>      HID_JoystickConfig;                                // 0x0050(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_HID_Joystick_SAV">();
	}
	static class UWM_HID_Joystick_SAV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_HID_Joystick_SAV>();
	}
};
static_assert(alignof(UWM_HID_Joystick_SAV) == 0x000008, "Wrong alignment on UWM_HID_Joystick_SAV");
static_assert(sizeof(UWM_HID_Joystick_SAV) == 0x0000A0, "Wrong size on UWM_HID_Joystick_SAV");
static_assert(offsetof(UWM_HID_Joystick_SAV, WasInitialized) == 0x000030, "Member 'UWM_HID_Joystick_SAV::WasInitialized' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, SaveSlot) == 0x000038, "Member 'UWM_HID_Joystick_SAV::SaveSlot' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, CurrentMode) == 0x000048, "Member 'UWM_HID_Joystick_SAV::CurrentMode' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, HID_JoystickConfig) == 0x000050, "Member 'UWM_HID_Joystick_SAV::HID_JoystickConfig' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_InputManager
// 0x0328 (0x0730 - 0x0408)
class UWM_InputManager final : public UWM_InputManagerBase
{
public:
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UClass>, struct FHidKeysByClass> HidInputKeys_ByClass;                              // 0x0420(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x50];                                     // 0x0470(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FDefaultDeviceMappings> DefaultMappings;                                   // 0x04C0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<struct FKey, EWM_GamepadKeyType>         HIDJoystick_KeysByType;                            // 0x0510(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FString>              HIDJoystick_Axes;                                  // 0x0560(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FString>              HIDJoystick_Buttons;                               // 0x05B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FDPADCollection>   HIDJoystick_DPADs;                                 // 0x0600(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            HIDJoystick_DPADDefaults;                          // 0x0650(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FString>              HIDJoystick_DPADButtons;                           // 0x06A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          EnableHIDInternalButtonEvents;                     // 0x06F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWM_InputManagerStatus                        Status;                                            // 0x06F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F2[0x2];                                      // 0x06F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumGamepads;                                       // 0x06F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumKeyboards;                                      // 0x06F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMouses;                                         // 0x06FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoAssignDevicesByDeviceSlot;                     // 0x0700(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_704[0x14];                                     // 0x0704(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowOnlyUsedInputs;                                // 0x0718(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_719[0x7];                                      // 0x0719(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentProfileName;                                // 0x0720(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BeginUMG();
	EWM_GamepadKeyType Get_HidJoystickKeyType(const struct FKey& Key);
	int32 GetActiveDevice__DelegateSignature();
	class UWM_HID_Joystick* GetActiveHID();
	class FString GetCurrentProfileName();
	class UWM_Device* GetSelectedDevice();
	class UWM_HID_Joystick* GetSelectedGamepad();
	void LoadProfile(const class FString& ProfileName);
	void SelectDevice(class UWM_Device* DeviceToSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_InputManager">();
	}
	static class UWM_InputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_InputManager>();
	}
};
static_assert(alignof(UWM_InputManager) == 0x000008, "Wrong alignment on UWM_InputManager");
static_assert(sizeof(UWM_InputManager) == 0x000730, "Wrong size on UWM_InputManager");
static_assert(offsetof(UWM_InputManager, HidInputKeys_ByClass) == 0x000420, "Member 'UWM_InputManager::HidInputKeys_ByClass' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, DefaultMappings) == 0x0004C0, "Member 'UWM_InputManager::DefaultMappings' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_KeysByType) == 0x000510, "Member 'UWM_InputManager::HIDJoystick_KeysByType' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_Axes) == 0x000560, "Member 'UWM_InputManager::HIDJoystick_Axes' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_Buttons) == 0x0005B0, "Member 'UWM_InputManager::HIDJoystick_Buttons' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_DPADs) == 0x000600, "Member 'UWM_InputManager::HIDJoystick_DPADs' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_DPADDefaults) == 0x000650, "Member 'UWM_InputManager::HIDJoystick_DPADDefaults' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_DPADButtons) == 0x0006A0, "Member 'UWM_InputManager::HIDJoystick_DPADButtons' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, EnableHIDInternalButtonEvents) == 0x0006F0, "Member 'UWM_InputManager::EnableHIDInternalButtonEvents' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, Status) == 0x0006F1, "Member 'UWM_InputManager::Status' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumGamepads) == 0x0006F4, "Member 'UWM_InputManager::NumGamepads' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumKeyboards) == 0x0006F8, "Member 'UWM_InputManager::NumKeyboards' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumMouses) == 0x0006FC, "Member 'UWM_InputManager::NumMouses' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, AutoAssignDevicesByDeviceSlot) == 0x000700, "Member 'UWM_InputManager::AutoAssignDevicesByDeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, ShowOnlyUsedInputs) == 0x000718, "Member 'UWM_InputManager::ShowOnlyUsedInputs' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, CurrentProfileName) == 0x000720, "Member 'UWM_InputManager::CurrentProfileName' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Settings
// 0x0090 (0x00C8 - 0x0038)
class UWM_Settings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultPlayerIndex_DeviceAssigment;                // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSensitivity;                                // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDeadzone;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bENABLE_AUTO_BUTTON_RELEASE;                       // 0x0064(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LogConnectDisconnect;                              // 0x0065(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitAPI_Manually;                                  // 0x0066(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SupportMe;                                         // 0x0067(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AllowVendorIds;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Settings">();
	}
	static class UWM_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Settings>();
	}
};
static_assert(alignof(UWM_Settings) == 0x000008, "Wrong alignment on UWM_Settings");
static_assert(sizeof(UWM_Settings) == 0x0000C8, "Wrong size on UWM_Settings");
static_assert(offsetof(UWM_Settings, DefaultPlayerIndex_DeviceAssigment) == 0x000058, "Member 'UWM_Settings::DefaultPlayerIndex_DeviceAssigment' has a wrong offset!");
static_assert(offsetof(UWM_Settings, DefaultSensitivity) == 0x00005C, "Member 'UWM_Settings::DefaultSensitivity' has a wrong offset!");
static_assert(offsetof(UWM_Settings, DefaultDeadzone) == 0x000060, "Member 'UWM_Settings::DefaultDeadzone' has a wrong offset!");
static_assert(offsetof(UWM_Settings, bENABLE_AUTO_BUTTON_RELEASE) == 0x000064, "Member 'UWM_Settings::bENABLE_AUTO_BUTTON_RELEASE' has a wrong offset!");
static_assert(offsetof(UWM_Settings, LogConnectDisconnect) == 0x000065, "Member 'UWM_Settings::LogConnectDisconnect' has a wrong offset!");
static_assert(offsetof(UWM_Settings, InitAPI_Manually) == 0x000066, "Member 'UWM_Settings::InitAPI_Manually' has a wrong offset!");
static_assert(offsetof(UWM_Settings, SupportMe) == 0x000067, "Member 'UWM_Settings::SupportMe' has a wrong offset!");
static_assert(offsetof(UWM_Settings, AllowVendorIds) == 0x000068, "Member 'UWM_Settings::AllowVendorIds' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_UmgBase
// 0x0000 (0x0280 - 0x0280)
class UWM_UmgBase final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_UmgBase">();
	}
	static class UWM_UmgBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_UmgBase>();
	}
};
static_assert(alignof(UWM_UmgBase) == 0x000008, "Wrong alignment on UWM_UmgBase");
static_assert(sizeof(UWM_UmgBase) == 0x000280, "Wrong size on UWM_UmgBase");

}


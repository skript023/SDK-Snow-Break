#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Game

#include "Basic.hpp"

#include "SeasunAnimGraph_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameCore_structs.hpp"
#include "MovieScene_structs.hpp"
#include "Engine_structs.hpp"
#include "UMG_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "PhysicsControl_structs.hpp"
#include "CharacterInteraction_structs.hpp"
#include "GameEx_structs.hpp"


namespace SDK
{

// Enum Game.EOnlineTDResourceType
// NumValues: 0x0009
enum class EOnlineTDResourceType : uint8
{
	OTT_A                                    = 0,
	OTT_B                                    = 1,
	OTT_C                                    = 2,
	OTT_D                                    = 3,
	OTT_E                                    = 4,
	OTT_E1                                   = 5,
	OTT_F                                    = 6,
	OTT_NONE                                 = 7,
	OTT_MAX                                  = 8,
};

// Enum Game.EAbilityState
// NumValues: 0x0025
enum class EAbilityState : uint8
{
	Movable                                  = 0,
	Turnable                                 = 1,
	AutoAim                                  = 2,
	Switchable                               = 3,
	Shootable                                = 4,
	Dodgable                                 = 5,
	Attractive                               = 6,
	OutControllable                          = 7,
	Treatable                                = 8,
	NoCostFightPower                         = 9,
	HalfSkill                                = 10,
	God                                      = 11,
	DodgeState                               = 12,
	Disarm                                   = 13,
	Silence                                  = 14,
	Restrain                                 = 15,
	CannotRepel                              = 16,
	CannotFloating                           = 17,
	CannotLie                                = 18,
	FireIgnore                               = 19,
	NoBulletConsume                          = 20,
	NoAoeSearch                              = 21,
	NotAttacked                              = 22,
	NotRushing                               = 23,
	NotSwitchTo                              = 24,
	NotAutoRolaod                            = 25,
	NotNormalSwitch                          = 26,
	CanNotInSkillAim                         = 27,
	CanNotReciveHitCurve                     = 28,
	CanNotReciveHitStrength                  = 29,
	NotAllowFollow                           = 30,
	AllowBreathless                          = 31,
	BunkerLeaned                             = 32,
	NoPlayerModifier                         = 33,
	NoRelaod                                 = 34,
	Max_State                                = 35,
	EAbilityState_MAX                        = 36,
};

// Enum Game.ESkillCastableType
// NumValues: 0x0007
enum class ESkillCastableType : uint8
{
	Castable                                 = 0,
	InRunning                                = 1,
	InCD                                     = 2,
	ConditionFail                            = 3,
	InFight                                  = 4,
	InAbnormal                               = 5,
	ESkillCastableType_MAX                   = 6,
};

// Enum Game.EQTESkillCastableType
// NumValues: 0x0007
enum class EQTESkillCastableType : uint8
{
	Castable                                 = 0,
	InCD                                     = 1,
	InRunning                                = 2,
	ConditionFail                            = 3,
	InBlock                                  = 4,
	InFight                                  = 5,
	EQTESkillCastableType_MAX                = 6,
};

// Enum Game.EDamageActualSourceType
// NumValues: 0x0004
enum class EDamageActualSourceType : uint8
{
	None                                     = 0,
	Emitter                                  = 1,
	Modifier                                 = 2,
	EDamageActualSourceType_MAX              = 3,
};

// Enum Game.ESkillInterruptedType
// NumValues: 0x0014
enum class ESkillInterruptedType : uint8
{
	Normal                                   = 0,
	Aim                                      = 1,
	Fire                                     = 2,
	Move                                     = 3,
	Jump                                     = 4,
	Falling                                  = 5,
	Skill                                    = 6,
	Die                                      = 7,
	Abnormal                                 = 8,
	SkillDeActive                            = 9,
	SpecializationSkillBlockUp               = 10,
	SelectorCancel                           = 11,
	BackBunkerEdge                           = 12,
	SwitchPlayer                             = 13,
	Rush                                     = 14,
	Frozen                                   = 15,
	Reload                                   = 16,
	Remove                                   = 17,
	LevelFinish                              = 18,
	Max                                      = 19,
};

// Enum Game.EAttributeType
// NumValues: 0x00C5
enum class EAttributeType : uint8
{
	Health                                   = 0,
	HealthBase                               = 1,
	HealthFace                               = 2,
	Shield                                   = 3,
	ShieldMax                                = 4,
	ShieldReciveAddition                     = 5,
	ShieldReciveMultiply                     = 6,
	ShieldApplyAddition                      = 7,
	ShieldApplyMultiply                      = 8,
	Attack                                   = 9,
	AttackBase                               = 10,
	AttackFace                               = 11,
	Defence                                  = 12,
	DefenceBase                              = 13,
	DefenceFace                              = 14,
	SkillIntensity                           = 15,
	NormalEnergy                             = 16,
	NormalEnergyBase                         = 17,
	NormalEnergyRecoverSpeed                 = 18,
	NormalEnergyRecoverSpeedAddtion          = 19,
	NormalEnergyCostAddtion                  = 20,
	NormalEnergyESKillCostAddtion            = 21,
	NormalEnergyQSKillCostAddtion            = 22,
	CharacterEnergyCostAddtion               = 23,
	EntityBulletResistance                   = 24,
	FireResistance                           = 25,
	IceResistance                            = 26,
	ThunderResistance                        = 27,
	SuperpowersResistance                    = 28,
	AllResistance                            = 29,
	AllEmentDamageBonus                      = 30,
	EntityBulletDamageBonus                  = 31,
	FireDamageBonus                          = 32,
	IceDamageBonus                           = 33,
	ThunderDamageBonus                       = 34,
	SuperpowersDamageBonus                   = 35,
	ShootDamageBonus                         = 36,
	AimDamageBonus                           = 37,
	AllShootDamageBonus                      = 38,
	SkillDamageBonus                         = 39,
	QTEDamageBonus                           = 40,
	SuperSkillDamageBonus                    = 41,
	AllSkillDamageBonus                      = 42,
	DamageCoefficient                        = 43,
	DamageCoefficient_Bomb                   = 44,
	CriticalValue                            = 45,
	CriticalDamage                           = 46,
	CriticalDamageAddtion                    = 47,
	CriticalResistance                       = 48,
	CriticalDamageReduce                     = 49,
	CriticalDamageFrail                      = 50,
	SpeedRatio                               = 51,
	SpeedRatio_Normal                        = 52,
	SpeedRatio_Rush                          = 53,
	SpeedRatio_Fire                          = 54,
	SpeedRatio_Aim                           = 55,
	AbnormalCoefficient                      = 56,
	AbnormalStrength                         = 57,
	AbnormalResistance                       = 58,
	SkinAttribute                            = 59,
	AttributeType_Max                        = 60,
	SwitchCharacterCD                        = 61,
	Vigour                                   = 62,
	VigourBase                               = 63,
	Vigour_RushRatio                         = 64,
	Vigour_NoFightRush                       = 65,
	Vigour_DodgeRatio                        = 66,
	Vigour_StorageRatio                      = 67,
	Vigour_OtherRatio                        = 68,
	Bullet                                   = 69,
	BulletBase                               = 70,
	VirtualBullet                            = 71,
	MixBullet                                = 72,
	Enmity                                   = 73,
	HitLag                                   = 74,
	CharacterEnergy                          = 75,
	CharacterEnergyBase                      = 76,
	CharacterEnergyEfficiency                = 77,
	CharacterEnergyMultiply                  = 78,
	MaxScatterRatio                          = 79,
	ShootAddScatterRatio                     = 80,
	RecoverScatterSpeedRatio                 = 81,
	ShieldDamageScaler                       = 82,
	SkillShieldDamageScaler                  = 83,
	AimTargetRangeRevise                     = 84,
	ExactRangeRevise                         = 85,
	Command                                  = 86,
	CDReducePer                              = 87,
	SkillCDReducePer                         = 88,
	NormalSkillCDReducePer                   = 89,
	QTECDReducePer                           = 90,
	PassiveSkillCDQuick                      = 91,
	SkillCDQuick                             = 92,
	NormalSkillCDQuick                       = 93,
	QTESkillCDQuick                          = 94,
	SuperSkillCDQuick                        = 95,
	DestroyValue                             = 96,
	DestroyValueAddtion                      = 97,
	DestroyValueMultiply                     = 98,
	HealAddtion                              = 99,
	HealMultiply                             = 100,
	BeHealedAddtion                          = 101,
	BeHealedMultiply                         = 102,
	HitLagValueAddtion                       = 103,
	HitLagValueMultiply                      = 104,
	MinionApplyDamageBonus                   = 105,
	ApplyDamageBonus                         = 106,
	ReceiveDamageBonus                       = 107,
	ReceiveAllShootDamageBonus               = 108,
	ReceiveAllSkillDamageBonus               = 109,
	ShootMastery                             = 110,
	SkillMastery                             = 111,
	FinalFireDealDamageRate                  = 112,
	FinalSkillDealDamageRate                 = 113,
	FinalDealDamageRate                      = 114,
	FinalReceiveDamageRate                   = 115,
	FinalDamageLimitMax                      = 116,
	ElemExplosionRateMultiply                = 117,
	ElemExplosionRateAddtion                 = 118,
	EntityExplosionRateAddtion               = 119,
	FireExplosionRateAddtion                 = 120,
	IceExplosionRateAddtion                  = 121,
	ThunderExplosionRateAddtion              = 122,
	SuperExplosionRateAddtion                = 123,
	ElemExplosionTriggerMultiply             = 124,
	ElemExplosionTriggerAddtion              = 125,
	EntityExplosionTriggerAddtion            = 126,
	FireExplosionTriggerAddtion              = 127,
	IceExplosionTriggerAddtion               = 128,
	ThunderExplosionTriggerAddtion           = 129,
	SuperExplosionTriggerAddtion             = 130,
	PreFireAbility                           = 131,
	KeepPreheatAbility                       = 132,
	WeaponOverload                           = 133,
	WeaponFireInterval                       = 134,
	WeaponFireStorage                        = 135,
	WeaponShootSpeedPer                      = 136,
	AddBulletLaunchCount                     = 137,
	AddBulletLaunchAddtion                   = 138,
	AddBulletCostCount                       = 139,
	WeaponAccuracyAddtion                    = 140,
	WeaponStabilityAddtion                   = 141,
	HitCriticalEnergyAddtion                 = 142,
	HitCriticalEnergyMultiply                = 143,
	HitEnergyAddtion                         = 144,
	HitEnergyMultiply                        = 145,
	SetBulletStrength                        = 146,
	GetBulletStrength                        = 147,
	ReloadSpeedRatio                         = 148,
	ReloadSpeedCoefficient                   = 149,
	ExtraThroughArmorRate                    = 150,
	BulletBounceAdd                          = 151,
	BulletBounceMulti                        = 152,
	WeaponShootRangeAddtion                  = 153,
	MaxScatterRatioSum                       = 154,
	DamageCoefficientSum                     = 155,
	DamageCoefficientBombSum                 = 156,
	CriticalValueSum                         = 157,
	CriticalDamageSum                        = 158,
	DestroyValueSum                          = 159,
	AddBulletLaunchCountSum                  = 160,
	AddBulletCostCountSum                    = 161,
	ReloadSpeedRatioSum                      = 162,
	ReloadSpeedCoefficientSum                = 163,
	GRHealth                                 = 164,
	GRHealthBase                             = 165,
	GRAttack                                 = 166,
	GRAttackBase                             = 167,
	GRDefence                                = 168,
	GRDefenceBase                            = 169,
	GRCriticalDamage                         = 170,
	GRHitEnergy                              = 171,
	GRDamageCoefficient                      = 172,
	GRFireInterval                           = 173,
	GRFireSpeedRatio                         = 174,
	GRFireStorage                            = 175,
	GRBulletNum                              = 176,
	GRBulletLaunchCount                      = 177,
	GRReloadSpeed                            = 178,
	GRReloadSpeedRatio                       = 179,
	GRDestroyValue                           = 180,
	GRBreathlessTime                         = 181,
	GRCriticalDamageAddition                 = 182,
	GREnergyEfficiency                       = 183,
	GRFireSpeedAddition                      = 184,
	GRAccuracyAddition                       = 185,
	GRStabilityAddition                      = 186,
	GRReloadSpeedAddition                    = 187,
	GRBeHealedAddition                       = 188,
	GRDestroyValueAddition                   = 189,
	GREnergy                                 = 190,
	GREnergyBase                             = 191,
	GRDamageLimit                            = 192,
	GRDamageAddition                         = 193,
	GRFinalDamageRate                        = 194,
	None                                     = 195,
	EAttributeType_MAX                       = 196,
};

// Enum Game.ECharacterActionState
// NumValues: 0x0012
enum class ECharacterActionState : uint8
{
	Walk                                     = 0,
	Dodge                                    = 1,
	Rush                                     = 2,
	Damage                                   = 3,
	Fire                                     = 4,
	Aim                                      = 5,
	Reload                                   = 6,
	Skill                                    = 7,
	Spawn                                    = 8,
	Death                                    = 9,
	Cross                                    = 10,
	BunkerInteract                           = 11,
	BunkerInputRot                           = 12,
	BunkerInputTurn                          = 13,
	Slide                                    = 14,
	ShootSkill                               = 15,
	Max_State                                = 16,
	ECharacterActionState_MAX                = 17,
};

// Enum Game.EAbnormalState
// NumValues: 0x000D
enum class EAbnormalState : uint8
{
	None                                     = 0,
	Additive                                 = 1,
	Repel                                    = 2,
	Floating                                 = 3,
	Lie                                      = 4,
	StandUp                                  = 5,
	Frozen                                   = 6,
	Breathless                               = 7,
	Stun                                     = 8,
	Paralysis                                = 9,
	SlomoDown                                = 10,
	MAX_STATE                                = 11,
	EAbnormalState_MAX                       = 12,
};

// Enum Game.ESkillCastType
// NumValues: 0x0009
enum class ESkillCastType : uint8
{
	Auto                                     = 0,
	Press                                    = 1,
	Release                                  = 2,
	LongPress                                = 3,
	LongRelease                              = 4,
	EnergyStorge                             = 5,
	EnergyStorge_Gate                        = 6,
	Invalid_CastType                         = 7,
	ESkillCastType_MAX                       = 8,
};

// Enum Game.ESkillRangeType
// NumValues: 0x0006
enum class ESkillRangeType : uint8
{
	Melee                                    = 0,
	MidRange                                 = 1,
	Range                                    = 2,
	Speical                                  = 3,
	Atmosphere                               = 4,
	ESkillRangeType_MAX                      = 5,
};

// Enum Game.EConditionCheckTargetType
// NumValues: 0x0005
enum class EConditionCheckTargetType : uint8
{
	None                                     = 0,
	Summoned                                 = 1,
	Owner                                    = 2,
	Creater                                  = 3,
	EConditionCheckTargetType_MAX            = 4,
};

// Enum Game.EEmitterCastType
// NumValues: 0x0009
enum class EEmitterCastType : uint8
{
	Notify                                   = 0,
	Passive                                  = 1,
	Auto                                     = 2,
	MultiAuto                                = 3,
	WithSkill                                = 4,
	PassiveNotify                            = 5,
	SkillEnd                                 = 6,
	SkillNatureEnd                           = 7,
	EEmitterCastType_MAX                     = 8,
};

// Enum Game.ESkillInBunkerType
// NumValues: 0x0004
enum class ESkillInBunkerType : uint8
{
	SkillLeaveBunker                         = 0,
	SkillKeepStandInBunker                   = 1,
	SkillKeepInBunker                        = 2,
	ESkillInBunkerType_MAX                   = 3,
};

// Enum Game.ESkillActionType
// NumValues: 0x0006
enum class ESkillActionType : uint8
{
	Normal                                   = 0,
	Advanced                                 = 1,
	Advanced_Delay                           = 2,
	Advanced_Run                             = 3,
	SkillToAdvanced                          = 4,
	ESkillActionType_MAX                     = 5,
};

// Enum Game.ESkillTurn
// NumValues: 0x0007
enum class ESkillTurn : uint8
{
	None                                     = 0,
	FaceToSelector                           = 1,
	FaceToAim                                = 2,
	FaceToSkillAim                           = 3,
	FaceToCamera                             = 4,
	MoveInputDirection                       = 5,
	ESkillTurn_MAX                           = 6,
};

// Enum Game.EReturnCDType
// NumValues: 0x0004
enum class EReturnCDType : uint8
{
	None                                     = 0,
	Value                                    = 1,
	Percent                                  = 2,
	EReturnCDType_MAX                        = 3,
};

// Enum Game.ECDType
// NumValues: 0x0006
enum class ECDType : uint8
{
	Begin                                    = 0,
	End                                      = 1,
	MarkedRunning                            = 2,
	CastSuccess                              = 3,
	OnlyMarkedRunning                        = 4,
	ECDType_MAX                              = 5,
};

// Enum Game.EAttributeChangeType
// NumValues: 0x0004
enum class EAttributeChangeType : uint8
{
	Add                                      = 0,
	Set                                      = 1,
	Multiply                                 = 2,
	EAttributeChangeType_MAX                 = 3,
};

// Enum Game.EModifySkillCastType
// NumValues: 0x0009
enum class EModifySkillCastType : uint8
{
	Invalid                                  = 0,
	Press                                    = 1,
	Release                                  = 2,
	LongPress                                = 3,
	LongRelease                              = 4,
	EnergyStorge                             = 5,
	EnergyStorge_Gate                        = 6,
	Invalid_CastType                         = 7,
	EModifySkillCastType_MAX                 = 8,
};

// Enum Game.ESkillType
// NumValues: 0x0005
enum class ESkillType : uint8
{
	Active                                   = 0,
	Passive                                  = 1,
	Sub                                      = 2,
	SpecializationSkill                      = 3,
	ESkillType_MAX                           = 4,
};

// Enum Game.EFightTipType
// NumValues: 0x000B
enum class EFightTipType : uint8
{
	TacticalSkillCD                          = 0,
	TacticalSkillEnergy                      = 1,
	UltimateSkillEnergy                      = 2,
	FightPowerExhaustion                     = 3,
	SkillConditionFail                       = 4,
	InvalidQuery                             = 5,
	SpecialItemResonanceRate                 = 6,
	SpecialItemDataSample                    = 7,
	Bullet                                   = 8,
	TurretBullet                             = 9,
	EFightTipType_MAX                        = 10,
};

// Enum Game.EModifierRemoveSourceType
// NumValues: 0x0007
enum class EModifierRemoveSourceType : uint8
{
	InValid                                  = 0,
	Emitter                                  = 1,
	Modifier                                 = 2,
	EndCondition                             = 3,
	Expired                                  = 4,
	BufferDeactive                           = 5,
	EModifierRemoveSourceType_MAX            = 6,
};

// Enum Game.ESkillCriteType
// NumValues: 0x0005
enum class ESkillCriteType : uint8
{
	NotCrite                                 = 0,
	Normal                                   = 1,
	Cirte                                    = 2,
	None                                     = 3,
	ESkillCriteType_MAX                      = 4,
};

// Enum Game.EEmitterDamageType
// NumValues: 0x0005
enum class EEmitterDamageType : uint8
{
	Natural                                  = 0,
	Weakness                                 = 1,
	Normal                                   = 2,
	Inefficiency                             = 3,
	EEmitterDamageType_MAX                   = 4,
};

// Enum Game.EModifyHPType
// NumValues: 0x0016
enum class EModifyHPType : uint8
{
	Other                                    = 0,
	Heal                                     = 1,
	Pure                                     = 2,
	EntityBullet                             = 3,
	Magic_1                                  = 4,
	Magic_2                                  = 5,
	Magic_3                                  = 6,
	Magic_4                                  = 7,
	None                                     = 8,
	VigourCost                               = 9,
	VigourRecover                            = 10,
	NomalEnergyCost                          = 11,
	NomalEnergyRecover                       = 12,
	CharacterEnergyCost                      = 13,
	CharacterEnergyRecover                   = 14,
	BulletCost                               = 15,
	BulletRecover                            = 16,
	ShieldRecover                            = 17,
	DestroyValue                             = 18,
	BasisDamageType                          = 19,
	Empty                                    = 20,
	EModifyHPType_MAX                        = 21,
};

// Enum Game.EShieldDisappearType
// NumValues: 0x0005
enum class EShieldDisappearType : uint8
{
	Damaged                                  = 0,
	Clear                                    = 1,
	Disappear                                = 2,
	Falloff                                  = 3,
	EShieldDisappearType_MAX                 = 4,
};

// Enum Game.EBulletMovementType
// NumValues: 0x0012
enum class EBulletMovementType : uint8
{
	Naturally                                = 0,
	Parabola                                 = 1,
	Projectile                               = 2,
	Homing                                   = 3,
	HomingGround                             = 4,
	HomingPoint                              = 5,
	HomingMultiPoint                         = 6,
	AimLocation                              = 7,
	AimTarget                                = 8,
	Circle                                   = 9,
	CustomTrack                              = 10,
	Null                                     = 11,
	Bomb                                     = 12,
	Bezier                                   = 13,
	BezierWithVelocity                       = 14,
	HigherBezier                             = 15,
	WaitSpawn                                = 16,
	EBulletMovementType_MAX                  = 17,
};

// Enum Game.EBulletThrouthType
// NumValues: 0x0004
enum class EBulletThrouthType : uint8
{
	ThrouthPawn                              = 0,
	ThrouthMesh                              = 1,
	ThrouthAll                               = 2,
	EBulletThrouthType_MAX                   = 3,
};

// Enum Game.ECampRelation
// NumValues: 0x0008
enum class ECampRelation : uint8
{
	Self                                     = 0,
	LittleFriendCamp                         = 1,
	Friendly                                 = 2,
	Neutrally                                = 4,
	UnFriendly                               = 8,
	Enermy                                   = 22,
	None                                     = 50,
	ECampRelation_MAX                        = 51,
};

// Enum Game.EBulletWorkType
// NumValues: 0x0004
enum class EBulletWorkType : uint8
{
	EntityBullet                             = 0,
	RayBullet                                = 1,
	KeepRayBullet                            = 2,
	EBulletWorkType_MAX                      = 3,
};

// Enum Game.EBulletHitType
// NumValues: 0x0004
enum class EBulletHitType : uint8
{
	EnergyBullet                             = 0,
	EntityBullet                             = 1,
	RayBullet                                = 2,
	EBulletHitType_MAX                       = 3,
};

// Enum Game.EHitOriginType
// NumValues: 0x0005
enum class EHitOriginType : uint8
{
	Anchor                                   = 0,
	CastActor                                = 1,
	Character                                = 2,
	CharacterCamera                          = 3,
	EHitOriginType_MAX                       = 4,
};

// Enum Game.ESearchTargetType
// NumValues: 0x0003
enum class ESearchTargetType : uint8
{
	Character                                = 0,
	TrapWithDestructible                     = 1,
	ESearchTargetType_MAX                    = 2,
};

// Enum Game.ESearchTargetPartType
// NumValues: 0x0004
enum class ESearchTargetPartType : uint8
{
	Acotr                                    = 0,
	Partition                                = 1,
	Part                                     = 2,
	ESearchTargetPartType_MAX                = 3,
};

// Enum Game.EHPBarTargetType
// NumValues: 0x000C
enum class EHPBarTargetType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Elite                                    = 2,
	Boss                                     = 3,
	Hostage                                  = 4,
	IsSpecialized                            = 5,
	Destructible                             = 6,
	Accessory                                = 7,
	Summon                                   = 8,
	Trap                                     = 9,
	FriendlyAI                               = 10,
	EHPBarTargetType_MAX                     = 11,
};

// Enum Game.EGamePlayerMoveState
// NumValues: 0x000D
enum class EGamePlayerMoveState : uint8
{
	Idle                                     = 0,
	Stop                                     = 1,
	StartMove                                = 2,
	Walk                                     = 3,
	Moving                                   = 4,
	Rushing                                  = 5,
	Pivoting                                 = 6,
	Skill                                    = 7,
	TurnInPlace                              = 8,
	Bunker                                   = 9,
	Max_State                                = 10,
	Slide                                    = 11,
	EGamePlayerMoveState_MAX                 = 12,
};

// Enum Game.EHandleFlyType
// NumValues: 0x0007
enum class EHandleFlyType : uint8
{
	DefaultHandleFly                         = 0,
	HpHandleFly                              = 1,
	ShieldHandleFly                          = 2,
	BounceHandleFly                          = 3,
	ImmuneControlHandleFly                   = 4,
	DestroyHandleFly                         = 5,
	EHandleFlyType_MAX                       = 6,
};

// Enum Game.EAnimTracType
// NumValues: 0x0014
enum class EAnimTracType : uint8
{
	RenderOpacity                            = 0,
	Percent                                  = 1,
	Translation0                             = 2,
	Translation1                             = 3,
	Rotation                                 = 4,
	Scale0                                   = 5,
	Scale1                                   = 6,
	RedCurve                                 = 7,
	GreenCurve                               = 8,
	BlueCurve                                = 9,
	AlphaCurve                               = 10,
	VisibilityCurve                          = 11,
	DesaturateCurve                          = 12,
	InitParamCurve                           = 13,
	TopCurve                                 = 14,
	LeftCurve                                = 15,
	RightCurve                               = 16,
	BottomCurve                              = 17,
	BrushWidthCurve                          = 18,
	EAnimTracType_MAX                        = 19,
};

// Enum Game.ESkillButtonState
// NumValues: 0x0007
enum class ESkillButtonState : uint8
{
	Normal                                   = 0,
	Down                                     = 1,
	Press                                    = 2,
	Up                                       = 3,
	LongPressUp                              = 4,
	Hold                                     = 5,
	ESkillButtonState_MAX                    = 6,
};

// Enum Game.ESensitivityType
// NumValues: 0x0049
enum class ESensitivityType : uint8
{
	None                                     = 0,
	Slide                                    = 2,
	AimFire                                  = 3,
	Aim                                      = 4,
	Fire                                     = 5,
	Skill                                    = 6,
	AccFactor                                = 7,
	AwmAimSlide                              = 8,
	AimAssistStrength                        = 9,
	FireAdsorb                               = 10,
	PC_SLIDE                                 = 13,
	GYROSCOPE_AIM                            = 14,
	GYROSCOPE_INVERT                         = 15,
	GYROSCOPE_Scale                          = 16,
	DAMAGE_SHOW                              = 17,
	MOUSE_INVERT                             = 18,
	JOYSTIC_FIXED                            = 19,
	SKILL_TIP                                = 20,
	SHOOT_AUTO                               = 21,
	SMART_CASTING                            = 22,
	SNIPER_FIRE                              = 23,
	SHOTGUN_FIRE                             = 24,
	PISTOL_FIRE                              = 25,
	MIX_AIM                                  = 26,
	LEFT_HAND_FIRE                           = 27,
	AIM_SWERVE                               = 28,
	AIM_MODEL                                = 29,
	TURNING_ACCELERATE                       = 30,
	RUSH_MODEL                               = 31,
	BOOM_WARN                                = 32,
	SHOOT_AUTO_GUNTYPE                       = 33,
	RUN_TYPE                                 = 34,
	DEFLECTION                               = 35,
	SHOOT_VIEW1                              = 36,
	SHOOT_VIEW2                              = 37,
	SHOOT_VIEW3                              = 38,
	SENSITIVITY                              = 39,
	SENSITIVITY_CAMERA_TURN_OFF              = 40,
	SENSITIVITY_CAMERA_TURN_ON               = 41,
	SENSITIVITY_CAMERA_TURN_ON_SNIPER        = 42,
	SENSITIVITY_FIRE_TURN_OFF                = 43,
	SENSITIVITY_FIRE_TURN_ON                 = 44,
	SENSITIVITY_FIRE_TURN_ON_SNIPER          = 45,
	SENSITIVITY_GYROSCOPE_TURN_OFF           = 46,
	SENSITIVITY_GYROSCOPE_TURN_ON            = 47,
	SENSITIVITY_GYROSCOPE_TURN_ON_SNIPER     = 48,
	SENSITIVITY_FIRE_GYROSCOPE_TURN_OFF      = 49,
	SENSITIVITY_FIRE_GYROSCOPE_TURN_ON       = 50,
	SENSITIVITY_FIRE_GYROSCOPE_TURN_ON_SNIPER = 51,
	DATAINPUT                                = 52,
	PC_MOUSE_SENSITIVITY_TURN_OFF            = 53,
	PC_MOUSE_SENSITIVITY_TURN_ON             = 54,
	PC_MOUSE_SENSITIVITY_TURN_ON_SNIPER      = 55,
	VERTICALSLIDE                            = 56,
	ACTION_MODE                              = 57,
	PLACEHOLDER_1                            = 58,
	QUICK_SUPPORT_SUPERSKILL_LEAVE           = 59,
	PLACEHOLDER_2                            = 60,
	AUTO_BUNKER_INTERACT                     = 61,
	AUTO_CROSS                               = 62,
	BABY_ASSIST                              = 64,
	HIDE_TEAMMATE_EFFECT                     = 65,
	ULTIMATE_PERFORM                         = 66,
	HIDE_TEAMMATE_HP                         = 67,
	PCAutoFireMode                           = 71,
	MobileAutoFireMode                       = 72,
	DAMAGE_SHOW_SWITCH                       = 90,
	SHOW_DAMAGE                              = 91,
	SHOW_RICOCHET                            = 92,
	SHOW_BREAK                               = 93,
	SHOW_IMMUNITY                            = 94,
	AUTO_FIRE_DESTRUCTIBLE                   = 101,
	ESensitivityType_MAX                     = 102,
};

// Enum Game.EApplyLocationType
// NumValues: 0x0005
enum class EApplyLocationType : uint8
{
	Center                                   = 0,
	Ground                                   = 1,
	CircleRand                               = 2,
	Collectible                              = 3,
	EApplyLocationType_MAX                   = 4,
};

// Enum Game.EQueryTargetType
// NumValues: 0x0007
enum class EQueryTargetType : uint8
{
	Character                                = 0,
	RandomPoint                              = 1,
	Accessory                                = 2,
	Trap                                     = 3,
	PartCenter                               = 4,
	Partition                                = 5,
	EQueryTargetType_MAX                     = 6,
};

// Enum Game.EButtonAimType
// NumValues: 0x0005
enum class EButtonAimType : uint8
{
	Default                                  = 0,
	AimButton                                = 1,
	CustomFireButtonAim                      = 2,
	LeftCancelAim                            = 3,
	EButtonAimType_MAX                       = 4,
};

// Enum Game.EFireButtonType
// NumValues: 0x0005
enum class EFireButtonType : uint8
{
	Default                                  = 0,
	FireButton                               = 1,
	CustomFireButton                         = 2,
	LeftFireButton                           = 3,
	EFireButtonType_MAX                      = 4,
};

// Enum Game.EPCKeyboardType
// NumValues: 0x002C
enum class EPCKeyboardType : uint8
{
	Fire                                     = 0,
	Aim                                      = 1,
	Skill_1                                  = 2,
	SupperSkill                              = 3,
	Dodge                                    = 4,
	Rush                                     = 5,
	Reload                                   = 6,
	SwitchPre                                = 7,
	SwitchNext                               = 8,
	Switch1                                  = 9,
	Switch2                                  = 10,
	Switch3                                  = 11,
	Move                                     = 12,
	Rot                                      = 13,
	OpenBox                                  = 14,
	MapWay                                   = 15,
	ExhaleMouse                              = 16,
	PauseGame                                = 17,
	BackSkill1                               = 18,
	BackSkill2                               = 19,
	BackSkill3                               = 20,
	BackSuperSkill1                          = 21,
	BackSuperSkill2                          = 22,
	BackSuperSkill3                          = 23,
	Jump                                     = 24,
	SwitchSkillIntro                         = 25,
	Cross                                    = 26,
	BunkerInteract                           = 27,
	Hook                                     = 28,
	OpenExpression                           = 29,
	Expression1                              = 30,
	Expression2                              = 31,
	Expression3                              = 32,
	Expression4                              = 33,
	Slide                                    = 34,
	MinGameCheck                             = 35,
	WPSelect1                                = 36,
	WPSelect2                                = 37,
	WPSelect3                                = 38,
	WPInteract                               = 39,
	WPOpenBag                                = 40,
	WPGamepadSwitchPreTag                    = 41,
	WPGamepadSwitchNextTag                   = 42,
	EPCKeyboardType_MAX                      = 43,
};

// Enum Game.EAbilityForceFeedbackType
// NumValues: 0x000A
enum class EAbilityForceFeedbackType : uint8
{
	None                                     = 0,
	AdditiveFeedback                         = 1,
	RepelFeedback                            = 2,
	FloatingFeedback                         = 3,
	NormalSkillFeedback                      = 4,
	SpecialSkillFeedback                     = 5,
	QTESkillFeedback                         = 6,
	Weapon                                   = 7,
	InfiniteType                             = 8,
	EAbilityForceFeedbackType_MAX            = 9,
};

// Enum Game.EWeaponHoldMode
// NumValues: 0x0004
enum class EWeaponHoldMode : uint8
{
	LeftDoubleHand                           = 0,
	RightDoubletHand                         = 1,
	DoubleHand                               = 2,
	EWeaponHoldMode_MAX                      = 3,
};

// Enum Game.EWeaponFireMode
// NumValues: 0x0007
enum class EWeaponFireMode : uint8
{
	Normal                                   = 0,
	Single                                   = 1,
	Continuity                               = 2,
	AimFire                                  = 3,
	ShootFire                                = 4,
	Max_FireMode                             = 5,
	EWeaponFireMode_MAX                      = 6,
};

// Enum Game.EWeaponBulletShootType
// NumValues: 0x0004
enum class EWeaponBulletShootType : uint8
{
	NotUse                                   = 0,
	UseDistance                              = 1,
	FullUse                                  = 2,
	EWeaponBulletShootType_MAX               = 3,
};

// Enum Game.EHitReactPerformance
// NumValues: 0x0006
enum class EHitReactPerformance : uint8
{
	None                                     = 0,
	One                                      = 1,
	Two                                      = 2,
	Three                                    = 3,
	Four                                     = 4,
	EHitReactPerformance_MAX                 = 5,
};

// Enum Game.ERangeAttackState
// NumValues: 0x0008
enum class ERangeAttackState : uint8
{
	Default                                  = 0,
	Standing                                 = 1,
	Standing_Aiming                          = 2,
	Moving                                   = 3,
	Moving_Aiming                            = 4,
	Falling                                  = 5,
	Falling_Aiming                           = 6,
	ERangeAttackState_MAX                    = 7,
};

// Enum Game.EWeaponDiffusionType
// NumValues: 0x0003
enum class EWeaponDiffusionType : uint8
{
	Default                                  = 0,
	HorizonDiffusion                         = 1,
	EWeaponDiffusionType_MAX                 = 2,
};

// Enum Game.EAimActionType
// NumValues: 0x0005
enum class EAimActionType : uint8
{
	Aim                                      = 0,
	StopAim                                  = 1,
	ToggleAim                                = 2,
	None                                     = 3,
	EAimActionType_MAX                       = 4,
};

// Enum Game.EExciteActionType
// NumValues: 0x0005
enum class EExciteActionType : uint8
{
	Fire                                     = 0,
	StopFire                                 = 1,
	SingleFire                               = 2,
	None                                     = 3,
	EExciteActionType_MAX                    = 4,
};

// Enum Game.EWeaponDriveType
// NumValues: 0x0003
enum class EWeaponDriveType : uint8
{
	KineticEnergyDrive                       = 0,
	HeatEnergyDrive                          = 1,
	EWeaponDriveType_MAX                     = 2,
};

// Enum Game.EWeaponType
// NumValues: 0x0024
enum class EWeaponType : uint8
{
	SubmachineGun                            = 0,
	ShotGun                                  = 1,
	AssaultRifle                             = 2,
	SniperRifle                              = 3,
	BoltSniper                               = 4,
	Pistal                                   = 5,
	CrossBow                                 = 6,
	DualSubmachineGun                        = 7,
	Bow                                      = 8,
	Gatling                                  = 9,
	EnergySubmachineGun                      = 10,
	EnergyShotGun                            = 11,
	EnergyAssaultRifle                       = 12,
	EnergySniperRifle                        = 13,
	EnergyBoltSniper                         = 14,
	EnergyPistal                             = 15,
	EnergyCrossBow                           = 16,
	DualEnergySubmachineGun                  = 17,
	EnergyBow                                = 18,
	EnergyGatling                            = 19,
	GRSubmachineGun                          = 20,
	GRShotGun                                = 21,
	GRAssaultRifle                           = 22,
	GRSniperRifle                            = 23,
	GRBoltSniper                             = 24,
	GRPistol                                 = 25,
	MachineGunTurret                         = 26,
	DLC7Turret                               = 27,
	DLC10Turret                              = 28,
	DLC11Turret                              = 29,
	DLC25Turret                              = 30,
	DLC26Turret                              = 31,
	DLC27Turret                              = 32,
	DLC32Turret                              = 33,
	Max_WeaponType                           = 34,
	EWeaponType_MAX                          = 35,
};

// Enum Game.ERecoilCurveDataType
// NumValues: 0x0005
enum class ERecoilCurveDataType : uint8
{
	Cloth                                    = 0,
	Hat                                      = 1,
	Hair                                     = 2,
	Weapon                                   = 3,
	ERecoilCurveDataType_MAX                 = 4,
};

// Enum Game.EHitState
// NumValues: 0x0005
enum class EHitState : uint8
{
	None                                     = 0,
	Floating                                 = 1,
	Repel                                    = 2,
	StandRepel                               = 3,
	EHitState_MAX                            = 4,
};

// Enum Game.EAllowedForbidAbnormalState
// NumValues: 0x000B
enum class EAllowedForbidAbnormalState : uint8
{
	None                                     = 0,
	Additive                                 = 1,
	Hit                                      = 2,
	Lie                                      = 4,
	StandUp                                  = 5,
	Frozen                                   = 6,
	Breathless                               = 7,
	Stun                                     = 8,
	Paralysis                                = 9,
	SlomoDown                                = 10,
	EAllowedForbidAbnormalState_MAX          = 11,
};

// Enum Game.ETriggerOnPressedSkillType
// NumValues: 0x0007
enum class ETriggerOnPressedSkillType : uint8
{
	None                                     = 99,
	FireSkill                                = 0,
	BaseSkillOne                             = 1,
	BaseSkillTwo                             = 2,
	SuperSkill                               = 4,
	AimSkill                                 = 19,
	Max                                      = 20,
};

// Enum Game.EModifierAllocationType
// NumValues: 0x0004
enum class EModifierAllocationType : uint8
{
	Default                                  = 0,
	Random                                   = 1,
	Average                                  = 2,
	EModifierAllocationType_MAX              = 3,
};

// Enum Game.EUIWidgetAnimType
// NumValues: 0x000F
enum class EUIWidgetAnimType : uint8
{
	Default                                  = 0,
	Main                                     = 1,
	Role_LvUp                                = 2,
	Role_Weapon                              = 3,
	Photograph                               = 4,
	Role_Spine                               = 5,
	Role_Break                               = 6,
	Role_Logistics                           = 7,
	Role_Growth_Up                           = 8,
	Role_Gacha                               = 9,
	Role_Fomation                            = 10,
	Role_Synchronize                         = 11,
	Role_Interaction                         = 12,
	Role_Appreciate                          = 13,
	EUIWidgetAnimType_MAX                    = 14,
};

// Enum Game.ECompletenessType
// NumValues: 0x0004
enum class ECompletenessType : uint8
{
	Complete                                 = 0,
	Broken                                   = 1,
	Disppaer                                 = 2,
	ECompletenessType_MAX                    = 3,
};

// Enum Game.ETriangleAttributeType
// NumValues: 0x0005
enum class ETriangleAttributeType : uint8
{
	LivingBody                               = 0,
	Spirit                                   = 1,
	Construct                                = 2,
	NoneBody                                 = 3,
	ETriangleAttributeType_MAX               = 4,
};

// Enum Game.EDivinityType
// NumValues: 0x0006
enum class EDivinityType : uint8
{
	China                                    = 0,
	NorthernEurope                           = 1,
	Greece                                   = 2,
	Japan                                    = 3,
	India                                    = 4,
	EDivinityType_MAX                        = 5,
};

// Enum Game.ECampType
// NumValues: 0x0004
enum class ECampType : uint8
{
	WorldTreeTeam                            = 0,
	SalvationSect                            = 1,
	Scavenger                                = 2,
	ECampType_MAX                            = 3,
};

// Enum Game.EFightType
// NumValues: 0x0004
enum class EFightType : uint8
{
	Stormer                                  = 0,
	Raider                                   = 1,
	Supporter                                = 2,
	EFightType_MAX                           = 3,
};

// Enum Game.EControlType
// NumValues: 0x000E
enum class EControlType : uint8
{
	BlockMove                                = 0,
	BlockSkill                               = 1,
	BlockFireAction                          = 2,
	BlockDodge                               = 3,
	BlockSwitch                              = 4,
	BlockQTE                                 = 5,
	BlockAimAction                           = 6,
	BlockCross                               = 7,
	BlockBunker                              = 8,
	BlockJump                                = 9,
	BlockReload                              = 10,
	BlockRush                                = 11,
	BlockUIAction                            = 12,
	EControlType_MAX                         = 13,
};

// Enum Game.EPlayerAction
// NumValues: 0x000B
enum class EPlayerAction : uint8
{
	Dodge                                    = 0,
	Rush                                     = 1,
	Aim                                      = 2,
	Fire                                     = 3,
	Reload                                   = 4,
	AimPressing                              = 5,
	Cross                                    = 6,
	BunkerInteract                           = 7,
	Slide                                    = 8,
	Max_State                                = 9,
	EPlayerAction_MAX                        = 10,
};

// Enum Game.EFireMode
// NumValues: 0x0004
enum class EFireMode : uint8
{
	None                                     = 0,
	Click                                    = 1,
	Release                                  = 2,
	EFireMode_MAX                            = 3,
};

// Enum Game.ELockCtrlReason
// NumValues: 0x000F
enum class ELockCtrlReason : uint8
{
	None                                     = 0,
	TaskEvent                                = 1,
	Interact                                 = 2,
	Skill                                    = 3,
	Custom1                                  = 4,
	Custom2                                  = 5,
	Custom3                                  = 6,
	Pause                                    = 7,
	Expression                               = 8,
	WaitRsp                                  = 9,
	AnimNotify                               = 10,
	Reset                                    = 11,
	GirlRushLeaveBunker                      = 12,
	QteUI                                    = 13,
	ELockCtrlReason_MAX                      = 14,
};

// Enum Game.EButtonAimMode
// NumValues: 0x0005
enum class EButtonAimMode : uint8
{
	ClickToggleMode                          = 0,
	LongPressMode                            = 1,
	MixAimMode                               = 2,
	LeftCancelAim                            = 3,
	EButtonAimMode_MAX                       = 4,
};

// Enum Game.EOnlineSeaGameEventType
// NumValues: 0x000B
enum class EOnlineSeaGameEventType : uint8
{
	OSGET_None                               = 0,
	OSGET_Broken                             = 1,
	OSGET_Fire                               = 2,
	OSGET_Broken_Cannon                      = 3,
	OSGET_Broken_MachineGun                  = 4,
	OSGET_Broken_AmmoStorage                 = 5,
	OSGET_Broken_Rudder                      = 6,
	OSGET_GetAmmo                            = 101,
	OSGET_RepairCore                         = 102,
	OSGET_MachineGunLevelUp                  = 103,
	OSGET_MAX                                = 104,
};

// Enum Game.ESummonType
// NumValues: 0x0005
enum class ESummonType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Accessory                                = 2,
	NormalCamp                               = 3,
	ESummonType_MAX                          = 4,
};

// Enum Game.ECharacterType
// NumValues: 0x000E
enum class ECharacterType : uint8
{
	AI                                       = 0,
	Summon                                   = 1,
	Player                                   = 2,
	Hostage                                  = 3,
	Destructible                             = 4,
	Vehicle                                  = 5,
	Trap                                     = 6,
	Bunker                                   = 7,
	LevelDrop                                = 8,
	FriendPal                                = 9,
	ZoneSkillNpc                             = 10,
	Interactor                               = 11,
	PlayerNPC                                = 12,
	Max                                      = 13,
};

// Enum Game.EOnlineTDBaseSkillType
// NumValues: 0x000B
enum class EOnlineTDBaseSkillType : uint8
{
	OTST_Attack                              = 0,
	OTST_Normal                              = 1,
	OTST_Summon                              = 2,
	OTST_Turreter                            = 3,
	OTST_Attacker                            = 4,
	OTST_Collecter                           = 5,
	OTST_Team                                = 6,
	OTST_PersonalSupplies                    = 7,
	OTST_TeamSupplies                        = 8,
	OTST_AirDrop                             = 9,
	OTST_MAX                                 = 10,
};

// Enum Game.EOnlineTDDuty
// NumValues: 0x0005
enum class EOnlineTDDuty : uint8
{
	OTD_None                                 = 0,
	OTD_Attacker                             = 1,
	OTD_Turreter                             = 2,
	OTD_Collector                            = 3,
	OTD_MAX                                  = 4,
};

// Enum Game.ESelectTargetMode
// NumValues: 0x0005
enum class ESelectTargetMode : uint8
{
	Normal                                   = 0,
	BasePawnView                             = 1,
	AbsorbPawnView                           = 2,
	Raycast                                  = 3,
	ESelectTargetMode_MAX                    = 4,
};

// Enum Game.ETargetShootItemType
// NumValues: 0x0006
enum class ETargetShootItemType : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	Bomb                                     = 2,
	Ammo                                     = 3,
	Mislead                                  = 4,
	ETargetShootItemType_MAX                 = 5,
};

// Enum Game.EActionStateCommand
// NumValues: 0x0006
enum class EActionStateCommand : uint8
{
	Start                                    = 0,
	Stop                                     = 1,
	Toggle                                   = 2,
	Dodge                                    = 3,
	Max_State                                = 4,
	EActionStateCommand_MAX                  = 5,
};

// Enum Game.EPostProcessType
// NumValues: 0x0010
enum class EPostProcessType : uint8
{
	RadialBlur                               = 0,
	MaskBlur                                 = 1,
	CaptureTarget                            = 2,
	Outline                                  = 3,
	Grayscale                                = 4,
	Simple                                   = 5,
	ScanLevel                                = 6,
	TintLevel                                = 7,
	MaskOutline                              = 8,
	FrameAnimation                           = 9,
	UMG3D                                    = 10,
	Material                                 = 11,
	ExplosiveOutline                         = 12,
	HighValueOutline                         = 13,
	Max_PostProcessType                      = 14,
	EPostProcessType_MAX                     = 15,
};

// Enum Game.EHiddenActorType
// NumValues: 0x000C
enum class EHiddenActorType : uint8
{
	IgnoreAll                                = 0,
	Aim                                      = 1,
	CameraOverlapActor                       = 2,
	Normal                                   = 3,
	Reload                                   = 4,
	RefreshAnimState                         = 5,
	Modifeir                                 = 6,
	Notify                                   = 7,
	Trap                                     = 8,
	Fishing                                  = 9,
	WeaponForceShow                          = 10,
	EHiddenActorType_MAX                     = 11,
};

// Enum Game.ESpecialThroughBulletType
// NumValues: 0x0007
enum class ESpecialThroughBulletType : uint8
{
	PlayerWeaponRay                          = 0,
	Bullet                                   = 1,
	RayBullet                                = 2,
	MultiRayBullet                           = 3,
	BulletSubTrace                           = 4,
	ScreenEditorBullet                       = 5,
	ESpecialThroughBulletType_MAX            = 6,
};

// Enum Game.ESingleFireModifierState
// NumValues: 0x0004
enum class ESingleFireModifierState : uint8
{
	ShootExecuteFinished                     = 0,
	ShootFire                                = 1,
	BulletHitFinished                        = 2,
	ESingleFireModifierState_MAX             = 3,
};

// Enum Game.EWeaponState
// NumValues: 0x0010
enum class EWeaponState : uint8
{
	Raise                                    = 0,
	StartFire                                = 1,
	StopFire                                 = 2,
	Retract                                  = 3,
	Aim                                      = 4,
	Reload                                   = 5,
	Idle                                     = 6,
	ReturnBunker_Retract                     = 7,
	ReturnBunker_StopAim                     = 8,
	ReturnBunker_RetractMoving               = 9,
	ReturnBunker_StopAimMoving               = 10,
	ReturnBunker_Default                     = 11,
	ExitBunker_Bolt                          = 12,
	Replay_Bolt                              = 13,
	Max_State                                = 14,
	EWeaponState_MAX                         = 15,
};

// Enum Game.EWeaponPreheadStateType
// NumValues: 0x0007
enum class EWeaponPreheadStateType : uint8
{
	None                                     = 0,
	Windup                                   = 1,
	BeforeShoot                              = 2,
	Keep                                     = 3,
	AfterShoot                               = 4,
	End                                      = 5,
	EWeaponPreheadStateType_MAX              = 6,
};

// Enum Game.ERecoilState
// NumValues: 0x0005
enum class ERecoilState : uint8
{
	RecoilIdle                               = 0,
	RecoilFire                               = 1,
	RecoilSteady                             = 2,
	RecoilRecovery                           = 3,
	ERecoilState_MAX                         = 4,
};

// Enum Game.EInteractComponentState
// NumValues: 0x0004
enum class EInteractComponentState : uint8
{
	Disable                                  = 0,
	CanInteract                              = 1,
	Interacting                              = 2,
	EInteractComponentState_MAX              = 3,
};

// Enum Game.EGatlingState
// NumValues: 0x0007
enum class EGatlingState : uint8
{
	Static                                   = 0,
	FireUp                                   = 1,
	AimUp                                    = 2,
	DelayDown                                = 3,
	Down                                     = 4,
	Pause                                    = 5,
	EGatlingState_MAX                        = 6,
};

// Enum Game.EMotionCurveModifierState
// NumValues: 0x0006
enum class EMotionCurveModifierState : uint8
{
	Waiting                                  = 0,
	Active                                   = 1,
	MarkedForRemoval                         = 2,
	Disabled                                 = 3,
	WaitingRemove                            = 4,
	EMotionCurveModifierState_MAX            = 5,
};

// Enum Game.EButtonCastType
// NumValues: 0x0004
enum class EButtonCastType : uint8
{
	Normal                                   = 0,
	LongRelease                              = 1,
	DoubleClick                              = 2,
	EButtonCastType_MAX                      = 3,
};

// Enum Game.EGamePlayLevelStreamingState
// NumValues: 0x0005
enum class EGamePlayLevelStreamingState : uint8
{
	Loaded                                   = 1,
	Visible                                  = 2,
	Hidden                                   = 3,
	UnLoaded                                 = 4,
	EGamePlayLevelStreamingState_MAX         = 5,
};

// Enum Game.EWheeledVehicleDriftState
// NumValues: 0x0005
enum class EWheeledVehicleDriftState : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Turn                                     = 2,
	End                                      = 3,
	EWheeledVehicleDriftState_MAX            = 4,
};

// Enum Game.EVehicleEvent
// NumValues: 0x0003
enum class EVehicleEvent : uint8
{
	MoveOn                                   = 0,
	MoveBack                                 = 1,
	EVehicleEvent_MAX                        = 2,
};

// Enum Game.EVehicleMovementMode
// NumValues: 0x0004
enum class EVehicleMovementMode : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Falling                                  = 2,
	EVehicleMovementMode_MAX                 = 3,
};

// Enum Game.EWheeledVehicleThrottleState
// NumValues: 0x0005
enum class EWheeledVehicleThrottleState : uint8
{
	None                                     = 0,
	MoveOn                                   = 1,
	Brake                                    = 2,
	MoveBack                                 = 3,
	EWheeledVehicleThrottleState_MAX         = 4,
};

// Enum Game.EWheeledVehicleSteerState
// NumValues: 0x0004
enum class EWheeledVehicleSteerState : uint8
{
	None                                     = 0,
	SteerLeft                                = 1,
	SteerRight                               = 2,
	EWheeledVehicleSteerState_MAX            = 3,
};

// Enum Game.EOnlineSeaShipType
// NumValues: 0x0006
enum class EOnlineSeaShipType : uint8
{
	OSST_NONE                                = 0,
	OSST_MyShip                              = 1,
	OSST_EnemyShip_S                         = 2,
	OSST_EnemyShip_M                         = 3,
	OSST_EnemyShip_B                         = 4,
	OSST_MAX                                 = 5,
};

// Enum Game.EGraphicsSettingCategory
// NumValues: 0x000F
enum class EGraphicsSettingCategory : uint8
{
	ScreenPercentage                         = 0,
	ShadowQuality                            = 1,
	EffectQuality                            = 2,
	AAQuality                                = 3,
	PPQuality                                = 4,
	ParticleQuality                          = 5,
	SceneQuality                             = 6,
	TextureQuality                           = 7,
	VSync                                    = 8,
	FPS                                      = 9,
	MotionBlur                               = 10,
	Reflection                               = 11,
	VolumetricFog                            = 12,
	CameraDither                             = 13,
	Max                                      = 14,
};

// Enum Game.EGraphicsSettingLevel
// NumValues: 0x0007
enum class EGraphicsSettingLevel : uint8
{
	Low                                      = 0,
	Middle                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	Cine                                     = 4,
	Custom                                   = 5,
	EGraphicsSettingLevel_MAX                = 6,
};

// Enum Game.EGamepadNavigation
// NumValues: 0x0006
enum class EGamepadNavigation : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	Down                                     = 4,
	EGamepadNavigation_MAX                   = 5,
};

// Enum Game.EGMLogEmun
// NumValues: 0x0005
enum class EGMLogEmun : uint8
{
	Command                                  = 0,
	Error                                    = 1,
	Warning                                  = 2,
	Normal                                   = 3,
	EGMLogEmun_MAX                           = 4,
};

// Enum Game.EKeyboardInputType
// NumValues: 0x0004
enum class EKeyboardInputType : uint8
{
	Keyboard                                 = 0,
	PS4                                      = 1,
	XBox360                                  = 2,
	EKeyboardInputType_MAX                   = 3,
};

// Enum Game.EWidgetNavigationIgnoreType
// NumValues: 0x0005
enum class EWidgetNavigationIgnoreType : uint8
{
	Not                                      = 0,
	Self                                     = 1,
	SelfAndAllChildren                       = 2,
	AllChildren                              = 3,
	EWidgetNavigationIgnoreType_MAX          = 4,
};

// Enum Game.ENavigationContainerModel
// NumValues: 0x0005
enum class ENavigationContainerModel : uint8
{
	Container                                = 0,
	Quick                                    = 1,
	ListNode                                 = 2,
	QuickList                                = 3,
	ENavigationContainerModel_MAX            = 4,
};

// Enum Game.EWidgetNavigationType
// NumValues: 0x0003
enum class EWidgetNavigationType : uint8
{
	Position                                 = 0,
	Order                                    = 1,
	EWidgetNavigationType_MAX                = 2,
};

// Enum Game.EKidRideEffectType
// NumValues: 0x000D
enum class EKidRideEffectType : uint8
{
	Normal                                   = 0,
	Nitrous                                  = 1,
	Brake                                    = 2,
	Drift                                    = 3,
	Collision                                = 4,
	AreaNitrous                              = 5,
	Falling                                  = 6,
	Landing                                  = 7,
	DriftNitrous1                            = 8,
	DriftNitrous2                            = 9,
	DriftNitrousReady1                       = 10,
	DriftNitrousReady2                       = 11,
	EKidRideEffectType_MAX                   = 12,
};

// Enum Game.EPartitionWorldDir
// NumValues: 0x0004
enum class EPartitionWorldDir : uint8
{
	All                                      = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	EPartitionWorldDir_MAX                   = 3,
};

// Enum Game.ECollisionPurposeType
// NumValues: 0x0009
enum class ECollisionPurposeType : uint8
{
	None                                     = 0,
	PerfectDodge                             = 1,
	MovementCollision                        = 2,
	MovementOuterCollision                   = 3,
	QueryTarget                              = 4,
	WarningTips                              = 5,
	CollisionNotify                          = 6,
	Type_Max                                 = 7,
	ECollisionPurposeType_MAX                = 8,
};

// Enum Game.EEnchantChangType
// NumValues: 0x0007
enum class EEnchantChangType : uint8
{
	Plus                                     = 0,
	Multi                                    = 1,
	Pre                                      = 2,
	Set                                      = 3,
	Add                                      = 4,
	Remove                                   = 5,
	EEnchantChangType_MAX                    = 6,
};

// Enum Game.EEnchantTableName
// NumValues: 0x0004
enum class EEnchantTableName : uint8
{
	Skill                                    = 0,
	Emitter                                  = 1,
	Modifer                                  = 2,
	EEnchantTableName_MAX                    = 3,
};

// Enum Game.EModifierSpecialEffectType
// NumValues: 0x0004
enum class EModifierSpecialEffectType : uint8
{
	BulletEffect                             = 0,
	BufferEffect                             = 1,
	WeaponEffect                             = 2,
	EModifierSpecialEffectType_MAX           = 3,
};

// Enum Game.EMarkLevel
// NumValues: 0x0004
enum class EMarkLevel : uint8
{
	Actor                                    = 0,
	Partition                                = 1,
	Part                                     = 2,
	EMarkLevel_MAX                           = 3,
};

// Enum Game.ETrapLimitLeaveChooseType
// NumValues: 0x0003
enum class ETrapLimitLeaveChooseType : uint8
{
	MinTrapLifeSpanTime                      = 0,
	MinTrapSpawnIndex                        = 1,
	ETrapLimitLeaveChooseType_MAX            = 2,
};

// Enum Game.EModifierUIEffectReduceCDSkillType
// NumValues: 0x0005
enum class EModifierUIEffectReduceCDSkillType : uint8
{
	None                                     = 0,
	NormalSkill                              = 1,
	SuperSkill                               = 2,
	QTESkill                                 = 3,
	EModifierUIEffectReduceCDSkillType_MAX   = 4,
};

// Enum Game.EModifierUIEffectReduceCDType
// NumValues: 0x0006
enum class EModifierUIEffectReduceCDType : uint8
{
	None                                     = 0,
	AllPlayer                                = 1,
	CurPlayer                                = 2,
	BackPlayer                               = 3,
	SkillID                                  = 4,
	EModifierUIEffectReduceCDType_MAX        = 5,
};

// Enum Game.EModifierUIEffect
// NumValues: 0x000D
enum class EModifierUIEffect : uint8
{
	None                                     = 0,
	BulletNext                               = 1,
	BulletEnd                                = 2,
	BulletTime                               = 3,
	Skill                                    = 4,
	FireSamll                                = 5,
	FireBig                                  = 6,
	PowerTime                                = 7,
	Power                                    = 8,
	ReduceCD                                 = 9,
	SkillKeepInterrupt                       = 10,
	SkillLongPress                           = 11,
	EModifierUIEffect_MAX                    = 12,
};

// Enum Game.EWeaponModeChangeRule
// NumValues: 0x0005
enum class EWeaponModeChangeRule : uint8
{
	Order                                    = 0,
	InvertedOrder                            = 1,
	OutOfOrder                               = 2,
	None                                     = 3,
	EWeaponModeChangeRule_MAX                = 4,
};

// Enum Game.EEnableAimMode
// NumValues: 0x0004
enum class EEnableAimMode : uint8
{
	Any                                      = 0,
	Aim                                      = 1,
	NoAim                                    = 2,
	EEnableAimMode_MAX                       = 3,
};

// Enum Game.EEnableBunkerMode
// NumValues: 0x0007
enum class EEnableBunkerMode : uint8
{
	Any                                      = 0,
	AnyHalf                                  = 1,
	AnyFull                                  = 2,
	LeftPeak                                 = 3,
	RightPeak                                = 4,
	Center                                   = 5,
	EEnableBunkerMode_MAX                    = 6,
};

// Enum Game.EEnableBunker
// NumValues: 0x0004
enum class EEnableBunker : uint8
{
	All                                      = 0,
	Enable                                   = 1,
	Disable                                  = 2,
	EEnableBunker_MAX                        = 3,
};

// Enum Game.EFightWidgetPartHideReason
// NumValues: 0x0007
enum class EFightWidgetPartHideReason : uint8
{
	Temp                                     = 0,
	Modifier                                 = 1,
	Level                                    = 2,
	Dead                                     = 3,
	GirlRush                                 = 4,
	Turret                                   = 5,
	EFightWidgetPartHideReason_MAX           = 6,
};

// Enum Game.EFightWidgetPart
// NumValues: 0x001A
enum class EFightWidgetPart : uint8
{
	None                                     = 0,
	NormalSkill                              = 1,
	SuperSkill                               = 2,
	QTESkill                                 = 3,
	BulletCount                              = 4,
	FightCross                               = 5,
	BackCharacter                            = 6,
	FightTime                                = 7,
	FightPower                               = 8,
	FightMonsterTips                         = 9,
	LevelTask                                = 10,
	PlayerHP                                 = 11,
	SpecialFightUI                           = 12,
	Interaction                              = 13,
	MobileJoystick                           = 14,
	MobileFightButton                        = 15,
	MultiPlayerName                          = 16,
	MultiExpression                          = 17,
	FightCrossHit                            = 18,
	Relaod                                   = 19,
	MonsterBar                               = 20,
	DestructibleBar                          = 21,
	NormalFire                               = 22,
	SpecialFire                              = 23,
	Aim                                      = 24,
	Max                                      = 25,
};

// Enum Game.EAuxiliaryLineDirection
// NumValues: 0x0004
enum class EAuxiliaryLineDirection : uint8
{
	ShowLeft                                 = 0,
	ShowRight                                = 1,
	AutoJudge                                = 2,
	EAuxiliaryLineDirection_MAX              = 3,
};

// Enum Game.EBloodBarType
// NumValues: 0x0004
enum class EBloodBarType : uint8
{
	HpBloodBar                               = 0,
	DestroyBloodBar                          = 1,
	PartHpBloodBar                           = 2,
	EBloodBarType_MAX                        = 3,
};

// Enum Game.EMonBodyType
// NumValues: 0x0005
enum class EMonBodyType : uint8
{
	Carbon                                   = 0,
	Machinery                                = 1,
	Titan                                    = 2,
	Energy                                   = 3,
	EMonBodyType_MAX                         = 4,
};

// Enum Game.ESkillTipSelectorType
// NumValues: 0x0003
enum class ESkillTipSelectorType : uint8
{
	Press                                    = 0,
	LongPress                                = 1,
	ESkillTipSelectorType_MAX                = 2,
};

// Enum Game.EDamageEffectFloatType
// NumValues: 0x0004
enum class EDamageEffectFloatType : uint8
{
	ActorLocation                            = 0,
	ApplyLocation                            = 1,
	BoneLocation                             = 2,
	EDamageEffectFloatType_MAX               = 3,
};

// Enum Game.EModifierEffectType
// NumValues: 0x0008
enum class EModifierEffectType : uint8
{
	ApplyEffect                              = 0,
	IntervalEffect                           = 1,
	KeepEffect                               = 2,
	PostApplyEffect                          = 3,
	EndEffect                                = 4,
	ConditionApplyEffect                     = 5,
	ConditionKeepEffect                      = 6,
	EModifierEffectType_MAX                  = 7,
};

// Enum Game.EPlayerFightEffectState
// NumValues: 0x0004
enum class EPlayerFightEffectState : uint8
{
	All                                      = 0,
	Major                                    = 1,
	Support                                  = 2,
	EPlayerFightEffectState_MAX              = 3,
};

// Enum Game.EEffectTargetType
// NumValues: 0x0008
enum class EEffectTargetType : uint8
{
	All                                      = 0,
	Character                                = 1,
	Team                                     = 2,
	Accessory                                = 3,
	Part                                     = 4,
	CharacterAndAccessory                    = 5,
	TeamPlayer                               = 6,
	EEffectTargetType_MAX                    = 7,
};

// Enum Game.EFightMonsterTipsType
// NumValues: 0x0017
enum class EFightMonsterTipsType : uint8
{
	Monster                                  = 0,
	Elite                                    = 1,
	TargetMonster                            = 2,
	HighLight                                = 3,
	Boss                                     = 4,
	Tips                                     = 5,
	Dialogue                                 = 6,
	Summon                                   = 7,
	Friend                                   = 8,
	DefendArea                               = 9,
	Retreat                                  = 10,
	Attack                                   = 11,
	DefendTarget                             = 12,
	Shop                                     = 13,
	Revive                                   = 14,
	Box                                      = 15,
	MapTarget                                = 16,
	HighLightAttack                          = 17,
	MapDot                                   = 18,
	MapQuest                                 = 19,
	Stealth                                  = 20,
	SpecialProgress                          = 21,
	EFightMonsterTipsType_MAX                = 22,
};

// Enum Game.EAttributeAgentType
// NumValues: 0x0003
enum class EAttributeAgentType : uint8
{
	Energy                                   = 0,
	Burn                                     = 1,
	EAttributeAgentType_MAX                  = 2,
};

// Enum Game.EBulletBombDamageType
// NumValues: 0x0004
enum class EBulletBombDamageType : uint8
{
	BombEmitterToBombTarget                  = 0,
	BombEmitterToHitTarget                   = 1,
	EmitterNoBombTarget                      = 2,
	EBulletBombDamageType_MAX                = 3,
};

// Enum Game.EBulletReboundDirection
// NumValues: 0x0006
enum class EBulletReboundDirection : uint8
{
	All                                      = 0,
	XY                                       = 1,
	Z                                        = 2,
	Target                                   = 3,
	Customize                                = 4,
	EBulletReboundDirection_MAX              = 5,
};

// Enum Game.EBulletReboundType
// NumValues: 0x0004
enum class EBulletReboundType : uint8
{
	ReboundPawn                              = 0,
	ReboundMesh                              = 1,
	ReboundAll                               = 2,
	EBulletReboundType_MAX                   = 3,
};

// Enum Game.EBulletCollision
// NumValues: 0x000A
enum class EBulletCollision : uint8
{
	All                                      = 0,
	WorldCollision                           = 1,
	PawnCollision                            = 2,
	None                                     = 3,
	TargetCollision                          = 4,
	TargetPartition                          = 5,
	Explosive                                = 6,
	Bunker                                   = 7,
	Land1                                    = 8,
	EBulletCollision_MAX                     = 9,
};

// Enum Game.EAiUseTargetType
// NumValues: 0x0004
enum class EAiUseTargetType : uint8
{
	Not                                      = 0,
	FullUse                                  = 1,
	FullUseToAnchor                          = 2,
	EAiUseTargetType_MAX                     = 3,
};

// Enum Game.EUseInheritEmitterDataType
// NumValues: 0x0006
enum class EUseInheritEmitterDataType : uint8
{
	Not                                      = 0,
	FullUse                                  = 1,
	Priority                                 = 2,
	FullUseToAnchor                          = 3,
	PriorityToAnchor                         = 4,
	EUseInheritEmitterDataType_MAX           = 5,
};

// Enum Game.EDamageSubTagType
// NumValues: 0x0004
enum class EDamageSubTagType : uint8
{
	SubDamage                                = 0,
	SubHeal                                  = 1,
	SubOtherEffect                           = 2,
	Max                                      = 3,
};

// Enum Game.EDamageSpecialTagsType
// NumValues: 0x000C
enum class EDamageSpecialTagsType : uint8
{
	DestructibleToParent                     = 0,
	NotApplyDamageEffect                     = 1,
	OtherApplyDamageEffect                   = 2,
	FireBulletBomb                           = 3,
	FieldSkill                               = 4,
	ParentApplyDamageEffect                  = 5,
	SkillAsShoot                             = 6,
	BlockDamage                              = 7,
	DelaySettlementDamage                    = 8,
	NotNotifyHurt                            = 9,
	AccessoryToParentDamage                  = 10,
	EDamageSpecialTagsType_MAX               = 11,
};

// Enum Game.EIgnoreDamageBonusType
// NumValues: 0x0016
enum class EIgnoreDamageBonusType : uint8
{
	Defence                                  = 0,
	AllEmentDamageBonus                      = 1,
	EntityBulletDamageBonus                  = 2,
	FireDamageBonus                          = 3,
	IceDamageBonus                           = 4,
	ThunderDamageBonus                       = 5,
	SuperpowersDamageBonus                   = 6,
	EntityBulletResistance                   = 7,
	FireResistance                           = 8,
	IceResistance                            = 9,
	ThunderResistance                        = 10,
	SuperpowersResistance                    = 11,
	AllResistance                            = 12,
	ReceiveDamageBonus                       = 13,
	ReceiveAllSkillDamageBonus               = 14,
	FinalDealDamageRate                      = 15,
	FinalReceiveDamageRate                   = 16,
	HealAddtion                              = 17,
	HealMultiply                             = 18,
	BeHealedAddtion                          = 19,
	BeHealedMultiply                         = 20,
	EIgnoreDamageBonusType_MAX               = 21,
};

// Enum Game.EShootDamageBonusType
// NumValues: 0x0006
enum class EShootDamageBonusType : uint8
{
	ShootDamageBonus                         = 0,
	AimDamageBonus                           = 1,
	AllShootDamageBonus                      = 2,
	ReceiveAllShootDamageBonus               = 3,
	DirectKill                               = 4,
	EShootDamageBonusType_MAX                = 5,
};

// Enum Game.EInheritDataTargetType
// NumValues: 0x000E
enum class EInheritDataTargetType : uint8
{
	EmitterData                              = 0,
	AutoAim                                  = 1,
	SkillAutoAim                             = 2,
	SkillAutoAimDetail                       = 3,
	SkillTipsSelector                        = 4,
	Selector                                 = 5,
	AITarget                                 = 6,
	AIEnmityTarget                           = 7,
	CollisionTarget                          = 8,
	SceneTargets                             = 9,
	TrapTargets                              = 10,
	ConditionTargets                         = 11,
	ConditionTrigger                         = 12,
	EInheritDataTargetType_MAX               = 13,
};

// Enum Game.EWeaponAttributeType
// NumValues: 0x0013
enum class EWeaponAttributeType : uint8
{
	Attack                                   = 0,
	DamageCoefficient                        = 1,
	FireSpeed                                = 2,
	BulletNum                                = 3,
	BulletCost                               = 4,
	ReloadSpeedCoefficient                   = 5,
	PreFire                                  = 6,
	DistAttenuationCoefficientA              = 7,
	DistAttenuationCoefficientB              = 8,
	DistAttenuationCoefficientC              = 9,
	AdditionalCritDamageInAimState           = 10,
	AdditionalCritPercentInAimState          = 11,
	ShieldDamageScaler                       = 12,
	CriticalValue                            = 13,
	CriticalDamage                           = 14,
	ReloadSpeed                              = 15,
	FiringRangeUltimateLimit                 = 16,
	BulletType                               = 17,
	EWeaponAttributeType_MAX                 = 18,
};

// Enum Game.EDamageTargetType
// NumValues: 0x0003
enum class EDamageTargetType : uint8
{
	ApplyDamage                              = 0,
	ReciveDamage                             = 1,
	EDamageTargetType_MAX                    = 2,
};

// Enum Game.ESearchShape
// NumValues: 0x0005
enum class ESearchShape : uint8
{
	Circle                                   = 0,
	Square                                   = 1,
	Capsule                                  = 2,
	Cylinder                                 = 3,
	ESearchShape_MAX                         = 4,
};

// Enum Game.EDirectionType
// NumValues: 0x0006
enum class EDirectionType : uint8
{
	None                                     = 0,
	Self                                     = 1,
	Camera                                   = 2,
	Selector                                 = 3,
	SkillTipsSelector                        = 4,
	EDirectionType_MAX                       = 5,
};

// Enum Game.EEmitterRolePickType
// NumValues: 0x0002
enum class EEmitterRolePickType : uint8
{
	OnlyPlayer                               = 0,
	EEmitterRolePickType_MAX                 = 1,
};

// Enum Game.ETargetType
// NumValues: 0x0007
enum class ETargetType : uint8
{
	Actor                                    = 0,
	RandomPoint                              = 1,
	TargetFirst                              = 2,
	TargetWithAccessory                      = 3,
	OnlyAccessory                            = 4,
	OnlyTrap                                 = 5,
	ETargetType_MAX                          = 6,
};

// Enum Game.EActorTargetType
// NumValues: 0x0003
enum class EActorTargetType : uint8
{
	Character                                = 0,
	Trap                                     = 1,
	EActorTargetType_MAX                     = 2,
};

// Enum Game.EPartTargetType
// NumValues: 0x0004
enum class EPartTargetType : uint8
{
	Character                                = 0,
	Partition                                = 1,
	PartCenter                               = 2,
	EPartTargetType_MAX                      = 3,
};

// Enum Game.ESelectCenterType
// NumValues: 0x0008
enum class ESelectCenterType : uint8
{
	Self                                     = 0,
	Self_Under                               = 1,
	Selector                                 = 2,
	SkillTipsSelector                        = 3,
	AimLocation                              = 4,
	ModifierOwner                            = 5,
	EmitterRuleBlueprint                     = 6,
	ESelectCenterType_MAX                    = 7,
};

// Enum Game.ESearchResultCommitRule
// NumValues: 0x0004
enum class ESearchResultCommitRule : uint8
{
	Union                                    = 0,
	Intersection                             = 1,
	FirstValidArray                          = 2,
	ESearchResultCommitRule_MAX              = 3,
};

// Enum Game.EQueryTargetPriority
// NumValues: 0x0003
enum class EQueryTargetPriority : uint8
{
	Same                                     = 0,
	Random                                   = 1,
	EQueryTargetPriority_MAX                 = 2,
};

// Enum Game.EAllowedCoolingAbnormalState
// NumValues: 0x0004
enum class EAllowedCoolingAbnormalState : uint8
{
	None                                     = 0,
	Repel                                    = 2,
	Floating                                 = 3,
	EAllowedCoolingAbnormalState_MAX         = 4,
};

// Enum Game.EAttributeAbnormalState
// NumValues: 0x0004
enum class EAttributeAbnormalState : uint8
{
	None                                     = 0,
	Exhaustion                               = 1,
	MAX_STATE                                = 2,
	EAttributeAbnormalState_MAX              = 3,
};

// Enum Game.EButtonType
// NumValues: 0x0004
enum class EButtonType : uint8
{
	None                                     = 0,
	SelectorPosition                         = 1,
	CharacterRotator                         = 2,
	EButtonType_MAX                          = 3,
};

// Enum Game.ETargetSortRule
// NumValues: 0x0005
enum class ETargetSortRule : uint8
{
	None                                     = 0,
	FarToClose                               = 1,
	CloseToFar                               = 2,
	Random                                   = 3,
	ETargetSortRule_MAX                      = 4,
};

// Enum Game.ESkillExecutionStage
// NumValues: 0x0006
enum class ESkillExecutionStage : uint8
{
	InAnim                                   = 0,
	InRunning                                = 1,
	InCancle                                 = 2,
	InEnd                                    = 3,
	InFail                                   = 4,
	ESkillExecutionStage_MAX                 = 5,
};

// Enum Game.EEmitterResult
// NumValues: 0x0004
enum class EEmitterResult : uint8
{
	Fail                                     = 0,
	InProgress                               = 1,
	Finish                                   = 2,
	EEmitterResult_MAX                       = 3,
};

// Enum Game.EModifierAddSpecialType
// NumValues: 0x0003
enum class EModifierAddSpecialType : uint8
{
	NotUseOptimizing                         = 0,
	UseEndCondition                          = 1,
	EModifierAddSpecialType_MAX              = 2,
};

// Enum Game.EModifierPostStartEffectType
// NumValues: 0x0004
enum class EModifierPostStartEffectType : uint8
{
	NotApply                                 = 0,
	ApplyStart                               = 1,
	ApplyEnd                                 = 2,
	EModifierPostStartEffectType_MAX         = 3,
};

// Enum Game.EModifierBackType
// NumValues: 0x0004
enum class EModifierBackType : uint8
{
	Noraml                                   = 0,
	Pause                                    = 1,
	Remove                                   = 2,
	EModifierBackType_MAX                    = 3,
};

// Enum Game.EModifierDEExecEmitterType
// NumValues: 0x0003
enum class EModifierDEExecEmitterType : uint8
{
	AttackLauncher                           = 0,
	ModifierLauncher                         = 1,
	EModifierDEExecEmitterType_MAX           = 2,
};

// Enum Game.EModifierExecEmitterType
// NumValues: 0x0003
enum class EModifierExecEmitterType : uint8
{
	Launcher                                 = 0,
	Target                                   = 1,
	EModifierExecEmitterType_MAX             = 2,
};

// Enum Game.EModifierOverlaidLimitType
// NumValues: 0x0004
enum class EModifierOverlaidLimitType : uint8
{
	AddAndRefreshTime                        = 0,
	Not                                      = 1,
	AddNotRefreshTime                        = 2,
	EModifierOverlaidLimitType_MAX           = 3,
};

// Enum Game.EModifierAloneLimitType
// NumValues: 0x0003
enum class EModifierAloneLimitType : uint8
{
	AddNew                                   = 0,
	KeepOld                                  = 1,
	EModifierAloneLimitType_MAX              = 2,
};

// Enum Game.EModifierAddType
// NumValues: 0x0003
enum class EModifierAddType : uint8
{
	Alone                                    = 0,
	Overlaid                                 = 1,
	EModifierAddType_MAX                     = 2,
};

// Enum Game.EModifierIncomeType
// NumValues: 0x0005
enum class EModifierIncomeType : uint8
{
	Noraml                                   = 0,
	Gain                                     = 1,
	Negative                                 = 2,
	Logic                                    = 3,
	EModifierIncomeType_MAX                  = 4,
};

// Enum Game.EModifyHPResult
// NumValues: 0x0021
enum class EModifyHPResult : uint8
{
	Heal                                     = 0,
	Miss                                     = 1,
	Hit                                      = 2,
	Crit                                     = 3,
	Inviolable                               = 4,
	ReduceDamage                             = 5,
	Destructible_Accessory                   = 6,
	DAccessory_HighEfficiency                = 7,
	DAccessory_LowEfficiency                 = 8,
	Weakness                                 = 9,
	Shiel                                    = 10,
	Inefficient                              = 11,
	ImmuneInjury                             = 12,
	Restraint                                = 13,
	BeRestrained                             = 14,
	Modifier                                 = 15,
	Dot                                      = 16,
	Entity                                   = 17,
	Fire                                     = 18,
	Ice                                      = 19,
	Thunder                                  = 20,
	Superpower                               = 21,
	ImmuneControl                            = 22,
	TargetShootScoreIncNormal                = 23,
	TargetShootScoreIncHigh                  = 24,
	TargetShootScoreDec                      = 25,
	TargetShootScoreAmmo                     = 26,
	Bounce                                   = 27,
	Destroy                                  = 28,
	AddShield                                = 29,
	SkillShield                              = 30,
	Max_State                                = 31,
	EModifyHPResult_MAX                      = 32,
};

// Enum Game.ENotifySkillCastFailType
// NumValues: 0x0011
enum class ENotifySkillCastFailType : uint8
{
	InAbnormal                               = 0,
	InQTE                                    = 1,
	Cached                                   = 2,
	InSilence                                = 3,
	CheckStateMachineFail                    = 4,
	Dead                                     = 5,
	SelfCasting                              = 6,
	ConditionFail                            = 7,
	InCD                                     = 8,
	CheckerFail                              = 9,
	Running                                  = 10,
	Moving                                   = 11,
	NotEnoughCost                            = 12,
	InvalidQueryResult                       = 13,
	InFight                                  = 14,
	Default                                  = 15,
	ENotifySkillCastFailType_MAX             = 16,
};

// Enum Game.ESkillButtonType
// NumValues: 0x0006
enum class ESkillButtonType : uint8
{
	Default                                  = 0,
	SkillButton                              = 1,
	SuperSkillButton                         = 2,
	BackSkillButton                          = 3,
	BackSuperSkillButton                     = 4,
	ESkillButtonType_MAX                     = 5,
};

// Enum Game.ERecordSkillCostType
// NumValues: 0x0006
enum class ERecordSkillCostType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Special                                  = 2,
	QTE                                      = 3,
	Passive                                  = 4,
	ERecordSkillCostType_MAX                 = 5,
};

// Enum Game.ESkillClassType
// NumValues: 0x0007
enum class ESkillClassType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Special                                  = 2,
	QTE                                      = 3,
	SQTE                                     = 4,
	AllSkill                                 = 5,
	ESkillClassType_MAX                      = 6,
};

// Enum Game.EModifyHPTypeBlockSource
// NumValues: 0x0004
enum class EModifyHPTypeBlockSource : uint8
{
	All                                      = 0,
	BlockSelf                                = 1,
	BlockOther                               = 2,
	EModifyHPTypeBlockSource_MAX             = 3,
};

// Enum Game.EEmitterPauseFrameType
// NumValues: 0x0004
enum class EEmitterPauseFrameType : uint8
{
	All                                      = 0,
	Other                                    = 1,
	Self                                     = 2,
	EEmitterPauseFrameType_MAX               = 3,
};

// Enum Game.EAnchorDirectionType
// NumValues: 0x000B
enum class EAnchorDirectionType : uint8
{
	None                                     = 0,
	Self                                     = 1,
	Camera                                   = 2,
	Camera_IgnorePitch                       = 3,
	AnchorOriginTargetDir                    = 4,
	AnchorOriginCameraDir                    = 5,
	AnchorOriginCameraDir_IgnorePitch        = 6,
	AnchorCharacterSkillStorageTransform     = 7,
	SummonedOwnerSkillStorageTransform       = 8,
	WorldRotation                            = 9,
	EAnchorDirectionType_MAX                 = 10,
};

// Enum Game.EAnchorPointFixType
// NumValues: 0x0008
enum class EAnchorPointFixType : uint8
{
	Center                                   = 0,
	Ground                                   = 1,
	Socket                                   = 2,
	FixRule                                  = 3,
	AimLocation                              = 4,
	Selector                                 = 5,
	SkillTipsSelector                        = 6,
	EAnchorPointFixType_MAX                  = 7,
};

// Enum Game.EAnchorPointType
// NumValues: 0x0012
enum class EAnchorPointType : uint8
{
	ActorResultPoint                         = 0,
	SkillCastTransform                       = 1,
	Self                                     = 2,
	Emitter                                  = 3,
	AutoSkillSelect                          = 4,
	AutoSkillSelectDetail                    = 5,
	InnerAutoSkillTarget                     = 6,
	SummonedOwnerSkillTarget                 = 7,
	SkillConditionTarget                     = 8,
	AiTarget                                 = 9,
	AiEnmityTarget                           = 10,
	ModifierOwner                            = 11,
	SceneTargets                             = 12,
	SummonedOwner                            = 13,
	ControlledPawn                           = 14,
	DamageEffectTarget                       = 15,
	DamageEffectLauncher                     = 16,
	EAnchorPointType_MAX                     = 17,
};

// Enum Game.EActorTargetUseType
// NumValues: 0x0012
enum class EActorTargetUseType : uint8
{
	Emitter                                  = 0,
	SkillAutoAim                             = 1,
	SkillAutoAimDetail                       = 2,
	InnerAutoSkillTarget                     = 3,
	SummonedOwnerSkillTarget                 = 4,
	SkillConditionTarget                     = 5,
	SkillConditionTrigger                    = 6,
	AITarget                                 = 7,
	AIEnmityTarget                           = 8,
	Selector                                 = 9,
	SkillTipsSelector                        = 10,
	SkillCollision                           = 11,
	SceneTargets                             = 12,
	TrapTargets                              = 13,
	DamageEffectTarget                       = 14,
	DamageEffectLauncher                     = 15,
	BlueprintSearch                          = 16,
	EActorTargetUseType_MAX                  = 17,
};

// Enum Game.EActorSelectType
// NumValues: 0x0004
enum class EActorSelectType : uint8
{
	AppointType                              = 0,
	OuterActor                               = 1,
	AnchorSelect                             = 2,
	EActorSelectType_MAX                     = 3,
};

// Enum Game.EAbilityCollisionSearchTargetType
// NumValues: 0x0005
enum class EAbilityCollisionSearchTargetType : uint8
{
	Acotr                                    = 0,
	Charcter                                 = 1,
	Partition                                = 2,
	Part                                     = 3,
	EAbilityCollisionSearchTargetType_MAX    = 4,
};

// Enum Game.EPointOutRangeRule
// NumValues: 0x0003
enum class EPointOutRangeRule : uint8
{
	DeletePoint                              = 0,
	NearestPointInRange                      = 1,
	EPointOutRangeRule_MAX                   = 2,
};

// Enum Game.EPointTargetSelectRule
// NumValues: 0x0005
enum class EPointTargetSelectRule : uint8
{
	UseAnchor                                = 0,
	MinDistance                              = 1,
	RandomInRange                            = 2,
	Collectible                              = 3,
	EPointTargetSelectRule_MAX               = 4,
};

// Enum Game.EPointTargetUseType
// NumValues: 0x0008
enum class EPointTargetUseType : uint8
{
	Emitter                                  = 0,
	Selector                                 = 1,
	SkillTipsSelector                        = 2,
	AimLoc                                   = 3,
	AimLocIgnoreBlock                        = 4,
	SkillConditionPoint                      = 5,
	BlueprintSearch                          = 6,
	EPointTargetUseType_MAX                  = 7,
};

// Enum Game.EPointSelectType
// NumValues: 0x0003
enum class EPointSelectType : uint8
{
	OuterPoint                               = 0,
	AnchorSelect                             = 1,
	EPointSelectType_MAX                     = 2,
};

// Enum Game.EBackToBunkerState
// NumValues: 0x0005
enum class EBackToBunkerState : uint8
{
	WeaponStopFire                           = 0,
	WeaponStopAim                            = 1,
	SkillStop                                = 2,
	Max_State                                = 3,
	EBackToBunkerState_MAX                   = 4,
};

// Enum Game.ECharacterCameraFade
// NumValues: 0x0004
enum class ECharacterCameraFade : uint8
{
	Default                                  = 0,
	NormalFade                               = 1,
	FollowOwner                              = 2,
	ECharacterCameraFade_MAX                 = 3,
};

// Enum Game.ECastSkillType
// NumValues: 0x0009
enum class ECastSkillType : uint8
{
	NormalSkill1                             = 0,
	NormalSkill2                             = 1,
	NormalSkill3                             = 2,
	CooperateSkill                           = 3,
	ExecutionSkill                           = 4,
	TeamCooperateSkill1                      = 5,
	TeamCooperateSkill2                      = 6,
	Max_Skill                                = 7,
	ECastSkillType_MAX                       = 8,
};

// Enum Game.EMonsterType
// NumValues: 0x0004
enum class EMonsterType : uint8
{
	E_Normal                                 = 0,
	E_Elite                                  = 1,
	E_Boss                                   = 2,
	E_MAX                                    = 3,
};

// Enum Game.EPhysiqueType
// NumValues: 0x0009
enum class EPhysiqueType : uint8
{
	Small                                    = 0,
	Middle                                   = 1,
	Big                                      = 2,
	EspeciallyBig                            = 3,
	EspeciallySmall                          = 4,
	MiddleSmall                              = 5,
	MiddleBig                                = 6,
	SuperBig                                 = 7,
	EPhysiqueType_MAX                        = 8,
};

// Enum Game.EAppointTargetType
// NumValues: 0x0013
enum class EAppointTargetType : uint8
{
	Self                                     = 0,
	Owner                                    = 1,
	Summoned                                 = 2,
	Teammate                                 = 3,
	TeamPlayer                               = 4,
	TeamMajor                                = 5,
	TeamSupport                              = 6,
	TeamRandom                               = 7,
	AllAppendage                             = 8,
	ModifierOwner                            = 9,
	CharacterID                              = 10,
	TrapClass                                = 11,
	OnlineTeam                               = 12,
	OnlineTeamNoMe                           = 13,
	OnlineTeamMajor                          = 14,
	MajorNoSuper                             = 15,
	GirlRushTeamPlayer                       = 16,
	DirectTeamMajor                          = 17,
	EAppointTargetType_MAX                   = 18,
};

// Enum Game.EMovementFilter
// NumValues: 0x0005
enum class EMovementFilter : uint8
{
	None                                     = 0,
	Character                                = 1,
	Bullet                                   = 2,
	Other                                    = 3,
	EMovementFilter_MAX                      = 4,
};

// Enum Game.BulletType
// NumValues: 0x0004
enum class Game::EBulletType : uint8
{
	NotSelect                                = 0,
	Water                                    = 1,
	Empty                                    = 2,
	BulletType_MAX                           = 3,
};

// Enum Game.ENpcInteractType
// NumValues: 0x0003
enum class ENpcInteractType : uint8
{
	None                                     = 0,
	Control                                  = 1,
	ENpcInteractType_MAX                     = 2,
};

// Enum Game.EPatrolMode
// NumValues: 0x0004
enum class EPatrolMode : uint8
{
	None                                     = 0,
	OWAreaPatrol                             = 1,
	PatrolBySpline                           = 2,
	EPatrolMode_MAX                          = 3,
};

// Enum Game.EAIMoveSpeedType
// NumValues: 0x0004
enum class EAIMoveSpeedType : uint8
{
	Normal                                   = 0,
	FastMove                                 = 1,
	SlowMovw                                 = 2,
	EAIMoveSpeedType_MAX                     = 3,
};

// Enum Game.EAIMoveAttitude
// NumValues: 0x0004
enum class EAIMoveAttitude : uint8
{
	Normal                                   = 0,
	PositiveMove                             = 1,
	NegativeMove                             = 2,
	EAIMoveAttitude_MAX                      = 3,
};

// Enum Game.EAIAttackAttitude
// NumValues: 0x0004
enum class EAIAttackAttitude : uint8
{
	Normal                                   = 0,
	PositiveAttack                           = 1,
	NegativeAttack                           = 2,
	EAIAttackAttitude_MAX                    = 3,
};

// Enum Game.EAIFightSignalType
// NumValues: 0x0004
enum class EAIFightSignalType : uint8
{
	AttackAttitude                           = 0,
	MoveAttitude                             = 1,
	MoveSpeedType                            = 2,
	EAIFightSignalType_MAX                   = 3,
};

// Enum Game.EAIAdvancedState
// NumValues: 0x0005
enum class EAIAdvancedState : uint8
{
	Bunker                                   = 0,
	AreaScoreModify                          = 1,
	Destroy                                  = 2,
	Occupy                                   = 3,
	EAIAdvancedState_MAX                     = 4,
};

// Enum Game.ESlotTowardType
// NumValues: 0x0005
enum class ESlotTowardType : uint8
{
	ToCaptainTarget                          = 0,
	ToCaptainForward                         = 1,
	ToCaptainMoveForward                     = 2,
	ToCaptainController                      = 3,
	ESlotTowardType_MAX                      = 4,
};

// Enum Game.EEnmityClearType
// NumValues: 0x0005
enum class EEnmityClearType : uint8
{
	None                                     = 0,
	ClearTarget                              = 1,
	ClearAll                                 = 2,
	ClearTargetToMin                         = 3,
	EEnmityClearType_MAX                     = 4,
};

// Enum Game.EEnmityType
// NumValues: 0x000C
enum class EEnmityType : uint8
{
	None                                     = 0,
	Sight                                    = 1,
	Hearing                                  = 2,
	Damage                                   = 3,
	GroupSight                               = 4,
	GroupHearing                             = 5,
	GroupDamage                              = 6,
	Distance                                 = 7,
	GroupDistance                            = 8,
	TargetDead                               = 9,
	LoseSight                                = 10,
	EEnmityType_MAX                          = 11,
};

// Enum Game.ETeamCharType
// NumValues: 0x0005
enum class ETeamCharType : uint8
{
	Shooter                                  = 0,
	Sniper                                   = 1,
	Warrior                                  = 2,
	Drone                                    = 3,
	ETeamCharType_MAX                        = 4,
};

// Enum Game.EAIFaceType
// NumValues: 0x0007
enum class EAIFaceType : uint8
{
	None                                     = 0,
	Target                                   = 1,
	Movement                                 = 2,
	CaptainFirePos                           = 3,
	Skilltracker                             = 4,
	HoldRotation                             = 5,
	EAIFaceType_MAX                          = 6,
};

// Enum Game.EOperationType
// NumValues: 0x0007
enum class EOperationType : uint8
{
	EqualTo                                  = 0,
	NotEqualTo                               = 1,
	LessThan                                 = 2,
	LessThanOrEqualTo                        = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqualTo                     = 5,
	EOperationType_MAX                       = 6,
};

// Enum Game.EAISimpleMoveForwardType
// NumValues: 0x0004
enum class EAISimpleMoveForwardType : uint8
{
	SelfForward                              = 0,
	TargetForward                            = 1,
	SelfToTarget                             = 2,
	EAISimpleMoveForwardType_MAX             = 3,
};

// Enum Game.EAI_STT_TargetType
// NumValues: 0x0003
enum class EAI_STT_TargetType : uint8
{
	TargetLoc                                = 0,
	TargetEyeLoc                             = 1,
	EAI_STT_MAX                              = 2,
};

// Enum Game.EMoveBlendToggleType
// NumValues: 0x0003
enum class EMoveBlendToggleType : uint8
{
	InFight                                  = 0,
	HasGun                                   = 1,
	EMoveBlendToggleType_MAX                 = 2,
};

// Enum Game.ECameraTargetMode
// NumValues: 0x0005
enum class ECameraTargetMode : uint8
{
	Normal                                   = 0,
	Aim                                      = 1,
	Fire                                     = 2,
	Rush                                     = 3,
	ECameraTargetMode_MAX                    = 4,
};

// Enum Game.ECameraAnimationType
// NumValues: 0x0005
enum class ECameraAnimationType : uint8
{
	SocketAnimation                          = 0,
	CustomAnimation                          = 1,
	ProvisionalAnimation                     = 2,
	ImportAnimation                          = 3,
	ECameraAnimationType_MAX                 = 4,
};

// Enum Game.EParticleDisappearType
// NumValues: 0x0003
enum class EParticleDisappearType : uint8
{
	Immediately                              = 0,
	Slow                                     = 1,
	EParticleDisappearType_MAX               = 2,
};

// Enum Game.EParticleEndPlayTriggerType
// NumValues: 0x0005
enum class EParticleEndPlayTriggerType : uint8
{
	Default                                  = 0,
	SkillEnd                                 = 1,
	EmitterEnd                               = 2,
	CharacterDeath                           = 3,
	EParticleEndPlayTriggerType_MAX          = 4,
};

// Enum Game.EStorageRotationType
// NumValues: 0x0004
enum class EStorageRotationType : uint8
{
	None                                     = 0,
	Camera                                   = 1,
	CameraWithNotPitch                       = 2,
	EStorageRotationType_MAX                 = 3,
};

// Enum Game.ELaunguageType
// NumValues: 0x0004
enum class ELaunguageType : uint8
{
	Chinese                                  = 0,
	English                                  = 1,
	Japanese                                 = 2,
	ELaunguageType_MAX                       = 3,
};

// Enum Game.ESlomoTarget
// NumValues: 0x0004
enum class ESlomoTarget : uint8
{
	Self                                     = 0,
	Others                                   = 1,
	All                                      = 2,
	ESlomoTarget_MAX                         = 3,
};

// Enum Game.EFaceDirection
// NumValues: 0x0004
enum class EFaceDirection : uint8
{
	MinDegree                                = 0,
	Clockwise                                = 1,
	AntiClockwise                            = 2,
	EFaceDirection_MAX                       = 3,
};

// Enum Game.EFaceToTargetType
// NumValues: 0x0006
enum class EFaceToTargetType : uint8
{
	EmitterResult_Actor                      = 0,
	EmitterResult_Loc                        = 1,
	AimTarget_Actor                          = 2,
	AimTarget_Loc                            = 3,
	AimLocation                              = 4,
	EFaceToTargetType_MAX                    = 5,
};

// Enum Game.EANS_MarkSkillCastSuccessType
// NumValues: 0x0004
enum class EANS_MarkSkillCastSuccessType : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	End                                      = 2,
	EANS_MAX                                 = 3,
};

// Enum Game.EBackTrackInteractMode
// NumValues: 0x0006
enum class EBackTrackInteractMode : uint8
{
	BackTrackWithCamera                      = 0,
	SplineWithCamera                         = 1,
	TransportShip                            = 2,
	AnimationSequence                        = 3,
	Unknown                                  = 4,
	EBackTrackInteractMode_MAX               = 5,
};

// Enum Game.EBalloonMoveType
// NumValues: 0x0004
enum class EBalloonMoveType : uint8
{
	Cycle                                    = 0,
	Loop                                     = 1,
	Single                                   = 2,
	EBalloonMoveType_MAX                     = 3,
};

// Enum Game.EBufferShopStateEnum
// NumValues: 0x0007
enum class EBufferShopStateEnum : uint8
{
	Disable                                  = 0,
	Enable                                   = 1,
	Complete                                 = 2,
	Refresh                                  = 3,
	TemporaryClose                           = 4,
	None                                     = 9,
	EBufferShopStateEnum_MAX                 = 10,
};

// Enum Game.EBulletCollisionType
// NumValues: 0x0003
enum class EBulletCollisionType : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	EBulletCollisionType_MAX                 = 2,
};

// Enum Game.EDealKillSceneEditor
// NumValues: 0x0004
enum class EDealKillSceneEditor : uint8
{
	KeepBullet                               = 0,
	BombBullet                               = 1,
	DisappearBullet                          = 2,
	EDealKillSceneEditor_MAX                 = 3,
};

// Enum Game.EDealKeepSceneEditor
// NumValues: 0x0003
enum class EDealKeepSceneEditor : uint8
{
	StopLaunch                               = 0,
	NotContrllBullet                         = 1,
	EDealKeepSceneEditor_MAX                 = 2,
};

// Enum Game.EBunkerHeightType
// NumValues: 0x0003
enum class EBunkerHeightType : uint8
{
	HalfBody                                 = 0,
	WholeBody                                = 1,
	EBunkerHeightType_MAX                    = 2,
};

// Enum Game.EBunkerAnimType
// NumValues: 0x0004
enum class EBunkerAnimType : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Middle                                   = 2,
	EBunkerAnimType_MAX                      = 3,
};

// Enum Game.EBunkerPointState
// NumValues: 0x0004
enum class EBunkerPointState : uint8
{
	None                                     = 0,
	PrepareEnter                             = 1,
	InBunker                                 = 2,
	EBunkerPointState_MAX                    = 3,
};

// Enum Game.EBunkerQuerier
// NumValues: 0x0003
enum class EBunkerQuerier : uint8
{
	MonsterSelf                              = 0,
	ActorTarget                              = 1,
	EBunkerQuerier_MAX                       = 2,
};

// Enum Game.EConditionNetMode
// NumValues: 0x0004
enum class EConditionNetMode : uint8
{
	Client                                   = 0,
	Server                                   = 1,
	Both                                     = 2,
	EConditionNetMode_MAX                    = 3,
};

// Enum Game.EWeaponQuality
// NumValues: 0x0005
enum class EWeaponQuality : uint8
{
	B                                        = 0,
	R                                        = 1,
	SR                                       = 2,
	SSR                                      = 3,
	EWeaponQuality_MAX                       = 4,
};

// Enum Game.ECharacterMaterialType
// NumValues: 0x0005
enum class ECharacterMaterialType : uint8
{
	Default                                  = 0,
	Masked                                   = 1,
	Translucent                              = 2,
	Opaque                                   = 3,
	ECharacterMaterialType_MAX               = 4,
};

// Enum Game.EAIStatePreLoadState
// NumValues: 0x0004
enum class EAIStatePreLoadState : uint8
{
	None                                     = 0,
	Loading                                  = 1,
	Loaded                                   = 2,
	EAIStatePreLoadState_MAX                 = 3,
};

// Enum Game.ECharacterRenderStateType
// NumValues: 0x0010
enum class ECharacterRenderStateType : uint8
{
	Opaque                                   = 0,
	Mask                                     = 1,
	Translucent                              = 2,
	Invisible                                = 3,
	Energy                                   = 4,
	Fire                                     = 5,
	Blink                                    = 6,
	Thermal                                  = 7,
	ParamModify_Deprecated                   = 8,
	HitDissolve                              = 9,
	VertexOffset                             = 10,
	Abnormal                                 = 11,
	Spread                                   = 12,
	Dither                                   = 13,
	Global                                   = 14,
	ECharacterRenderStateType_MAX            = 15,
};

// Enum Game.EMonsCareerType
// NumValues: 0x000C
enum class EMonsCareerType : uint8
{
	None                                     = 0,
	Tank                                     = 1,
	Warrior                                  = 2,
	Assassin                                 = 3,
	MidSingle                                = 4,
	MidAOE                                   = 5,
	AdSingle                                 = 6,
	AdAoe                                    = 7,
	Healer                                   = 8,
	Support                                  = 9,
	Boss                                     = 10,
	EMonsCareerType_MAX                      = 11,
};

// Enum Game.ECameraFollowType
// NumValues: 0x0006
enum class ECameraFollowType : uint8
{
	NotFollow                                = 0,
	AutoFollow                               = 1,
	ManualFollow                             = 2,
	CameraShow                               = 3,
	CameraShowStop                           = 4,
	ECameraFollowType_MAX                    = 5,
};

// Enum Game.EChessPathFindingType
// NumValues: 0x0004
enum class EChessPathFindingType : uint8
{
	None                                     = 0,
	AutoPathByClick                          = 1,
	AutoPathNonEdgeByClick                   = 2,
	EChessPathFindingType_MAX                = 3,
};

// Enum Game.EChessLandType
// NumValues: 0x0003
enum class EChessLandType : uint8
{
	Walkable                                 = 0,
	Block                                    = 1,
	EChessLandType_MAX                       = 2,
};

// Enum Game.EChessType
// NumValues: 0x0004
enum class EChessType : uint8
{
	Normal                                   = 0,
	RichMan                                  = 1,
	War                                      = 2,
	EChessType_MAX                           = 3,
};

// Enum Game.ECustomSpeedState
// NumValues: 0x0005
enum class ECustomSpeedState : uint8
{
	Nothing                                  = 0,
	Acc                                      = 1,
	Loop                                     = 2,
	Dec                                      = 3,
	ECustomSpeedState_MAX                    = 4,
};

// Enum Game.EMoveInterpType
// NumValues: 0x0008
enum class EMoveInterpType : uint8
{
	Linear                                   = 0,
	Sinusoidal                               = 1,
	Cubic                                    = 2,
	CircularIn                               = 3,
	CircularOut                              = 4,
	ExpIn                                    = 5,
	ExpOut                                   = 6,
	EMoveInterpType_MAX                      = 7,
};

// Enum Game.EDamageFloatDamageType
// NumValues: 0x0003
enum class EDamageFloatDamageType : uint8
{
	Shoot                                    = 0,
	Skill                                    = 1,
	EDamageFloatDamageType_MAX               = 2,
};

// Enum Game.EDarkZonePreLoadType
// NumValues: 0x0004
enum class EDarkZonePreLoadType : uint8
{
	None                                     = 0,
	GameTask                                 = 1,
	Patrol                                   = 2,
	EDarkZonePreLoadType_MAX                 = 3,
};

// Enum Game.EEnvMaterialLayerType
// NumValues: 0x0004
enum class EEnvMaterialLayerType : uint8
{
	None                                     = 0,
	Base                                     = 1,
	Snow                                     = 2,
	EEnvMaterialLayerType_MAX                = 3,
};

// Enum Game.EUpdateVectorType
// NumValues: 0x0003
enum class EUpdateVectorType : uint8
{
	Default                                  = 0,
	PlayerLocation                           = 1,
	EUpdateVectorType_MAX                    = 2,
};

// Enum Game.EUpdateScalarType
// NumValues: 0x0002
enum class EUpdateScalarType : uint8
{
	Default                                  = 0,
	EUpdateScalarType_MAX                    = 1,
};

// Enum Game.EFarmWarSuccessType
// NumValues: 0x0002
enum class EFarmWarSuccessType : uint8
{
	BossKill                                 = 0,
	EFarmWarSuccessType_MAX                  = 1,
};

// Enum Game.EVegAnimationState
// NumValues: 0x0009
enum class EVegAnimationState : uint8
{
	Born                                     = 0,
	Idle                                     = 1,
	Rotate                                   = 2,
	Skill                                    = 3,
	Death                                    = 4,
	BackForward                              = 5,
	Dance                                    = 6,
	WaitBorn                                 = 7,
	EVegAnimationState_MAX                   = 8,
};

// Enum Game.EBarPowerEntryGirl004BPhase
// NumValues: 0x0005
enum class EBarPowerEntryGirl004BPhase : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	AddPercent                               = 2,
	Full                                     = 3,
	EBarPowerEntryGirl004BPhase_MAX          = 4,
};

// Enum Game.EBarPowerEntryGirl020BPhase
// NumValues: 0x0007
enum class EBarPowerEntryGirl020BPhase : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	AddPercent                               = 2,
	Full                                     = 3,
	BaseSkillForceFull                       = 4,
	BaseSkillForceEmpty                      = 5,
	EBarPowerEntryGirl020BPhase_MAX          = 6,
};

// Enum Game.FightBarGirl004bDisplayState
// NumValues: 0x0004
enum class EFightBarGirl004bDisplayState : uint32
{
	None                                     = 0,
	Open                                     = 1,
	Close                                    = 2,
	FightBarGirl004bDisplayState_MAX         = 3,
};

// Enum Game.EFightBarGirl005bUseState
// NumValues: 0x0004
enum class EFightBarGirl005bUseState : uint8
{
	Initialize                               = 0,
	UseAnimation                             = 1,
	UnUseAnimation                           = 2,
	EFightBarGirl005bUseState_MAX            = 3,
};

// Enum Game.FFightBarGirl011bDisplayState
// NumValues: 0x0004
enum class EFFightBarGirl011bDisplayState : uint32
{
	None                                     = 0,
	Open                                     = 1,
	Close                                    = 2,
	FFightBarGirl011bDisplayState_MAX        = 3,
};

// Enum Game.EFightBarGirl021DisplayState
// NumValues: 0x0004
enum class EFightBarGirl021DisplayState : uint32
{
	None                                     = 0,
	Open                                     = 1,
	Close                                    = 2,
	EFightBarGirl021DisplayState_MAX         = 3,
};

// Enum Game.EAccessoryDisplayState
// NumValues: 0x0005
enum class EAccessoryDisplayState : uint8
{
	ADS_None                                 = 0,
	ADS_Green                                = 1,
	ADS_Yellow                               = 2,
	ADS_Red                                  = 3,
	ADS_Max                                  = 4,
};

// Enum Game.EBossHPHitType
// NumValues: 0x0004
enum class EBossHPHitType : uint8
{
	E_Normal                                 = 0,
	E_Hit                                    = 1,
	E_Recover                                = 2,
	E_MAX                                    = 3,
};

// Enum Game.EFightGridState
// NumValues: 0x0006
enum class EFightGridState : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	End                                      = 2,
	Stepped                                  = 3,
	Default                                  = 4,
	EFightGridState_MAX                      = 5,
};

// Enum Game.EPlayerBtnType
// NumValues: 0x0003
enum class EPlayerBtnType : uint8
{
	Normal                                   = 0,
	QTE                                      = 1,
	EPlayerBtnType_MAX                       = 2,
};

// Enum Game.EPlayerItemEffectType
// NumValues: 0x0004
enum class EPlayerItemEffectType : uint8
{
	CD                                       = 0,
	QTE                                      = 1,
	Skill                                    = 2,
	EPlayerItemEffectType_MAX                = 3,
};

// Enum Game.ETickAnimType
// NumValues: 0x0006
enum class ETickAnimType : uint8
{
	MoveUp                                   = 0,
	MoveDown                                 = 1,
	Appear                                   = 2,
	MoveUpAndDown                            = 3,
	None                                     = 4,
	ETickAnimType_MAX                        = 5,
};

// Enum Game.EUIDialogueType
// NumValues: 0x0005
enum class EUIDialogueType : uint8
{
	Plot                                     = 0,
	SimplePlot                               = 1,
	FragmentStory                            = 2,
	None                                     = 3,
	EUIDialogueType_MAX                      = 4,
};

// Enum Game.EAimAssistLevel
// NumValues: 0x0004
enum class EAimAssistLevel : uint8
{
	Close                                    = 0,
	Weak                                     = 1,
	Strong                                   = 2,
	EAimAssistLevel_MAX                      = 3,
};

// Enum Game.EBulletSubTraceConfigDisplay
// NumValues: 0x0003
enum class EBulletSubTraceConfigDisplay : uint8
{
	None                                     = 0,
	HiddenBulletSubTrace                     = 1,
	EBulletSubTraceConfigDisplay_MAX         = 2,
};

// Enum Game.EFishStageType
// NumValues: 0x0007
enum class EFishStageType : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Wait                                     = 2,
	Bite                                     = 3,
	Fishing                                  = 4,
	Hold                                     = 5,
	EFishStageType_MAX                       = 6,
};

// Enum Game.EFlyBirdVehicleState
// NumValues: 0x0007
enum class EFlyBirdVehicleState : uint8
{
	None                                     = 0,
	Following                                = 1,
	Entry                                    = 2,
	Exit                                     = 3,
	Running                                  = 4,
	Ascending                                = 5,
	EFlyBirdVehicleState_MAX                 = 6,
};

// Enum Game.EAbilityType
// NumValues: 0x0005
enum class EAbilityType : uint8
{
	Character                                = 0,
	Controller                               = 1,
	Weapon                                   = 2,
	Max_Type                                 = 3,
	EAbilityType_MAX                         = 4,
};

// Enum Game.EAttributeRoundType
// NumValues: 0x0004
enum class EAttributeRoundType : uint8
{
	Floor                                    = 0,
	Ceil                                     = 1,
	Round                                    = 2,
	EAttributeRoundType_MAX                  = 3,
};

// Enum Game.EAttributeAttachType
// NumValues: 0x0004
enum class EAttributeAttachType : uint8
{
	Charater                                 = 0,
	Weapon                                   = 1,
	Team                                     = 2,
	EAttributeAttachType_MAX                 = 3,
};

// Enum Game.EAttributeValueType
// NumValues: 0x0004
enum class EAttributeValueType : uint8
{
	Numerical                                = 0,
	Percentage                               = 1,
	Multiply                                 = 2,
	EAttributeValueType_MAX                  = 3,
};

// Enum Game.EBowArrowResidueType
// NumValues: 0x0006
enum class EBowArrowResidueType : uint8
{
	Scene                                    = 0,
	Bunker                                   = 1,
	Destructible                             = 2,
	Trap                                     = 3,
	Character                                = 4,
	EBowArrowResidueType_MAX                 = 5,
};

// Enum Game.EMarkEffectBufferType
// NumValues: 0x0005
enum class EMarkEffectBufferType : uint8
{
	Receive2Self                             = 0,
	Receive2Target                           = 1,
	Apply2Self                               = 2,
	Apply2Target                             = 3,
	EMarkEffectBufferType_MAX                = 4,
};

// Enum Game.EMotionCurveMoveType
// NumValues: 0x0006
enum class EMotionCurveMoveType : uint8
{
	None                                     = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	HorizontalAndVertical                    = 3,
	CheckAccelerationZeroStop_Horizontal     = 4,
	EMotionCurveMoveType_MAX                 = 5,
};

// Enum Game.EMotionCurveType
// NumValues: 0x0006
enum class EMotionCurveType : uint8
{
	Distance                                 = 0,
	Velocity                                 = 1,
	AccelerationDirDistance                  = 2,
	CustomCurveMove                          = 3,
	AccelerationInterpDirDistance            = 4,
	EMotionCurveType_MAX                     = 5,
};

// Enum Game.EBreastAnimNodeLimitType
// NumValues: 0x0007
enum class EBreastAnimNodeLimitType : uint8
{
	Default                                  = 0,
	Skill                                    = 1,
	Dodge                                    = 2,
	Abnormal                                 = 3,
	FrameRate                                = 4,
	Other                                    = 5,
	EBreastAnimNodeLimitType_MAX             = 6,
};

// Enum Game.EBowType
// NumValues: 0x0003
enum class EBowType : uint8
{
	RecurveBow                               = 0,
	CompoundBow                              = 1,
	EBowType_MAX                             = 2,
};

// Enum Game.EPhysicsAnimType
// NumValues: 0x0006
enum class EPhysicsAnimType : uint8
{
	AnimNode_RigidBody                       = 0,
	PhysicsControl                           = 1,
	PhysicsSimulate                          = 2,
	AnimNode_RigidBodyWithControl            = 3,
	Disable                                  = 4,
	EPhysicsAnimType_MAX                     = 5,
};

// Enum Game.ERecoilHandType
// NumValues: 0x0004
enum class ERecoilHandType : uint8
{
	BothHand                                 = 0,
	LeftHand                                 = 1,
	RightHand                                = 2,
	ERecoilHandType_MAX                      = 3,
};

// Enum Game.EHitDirectionType
// NumValues: 0x0006
enum class EHitDirectionType : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Left                                     = 2,
	Right                                    = 3,
	Backward                                 = 4,
	EHitDirectionType_MAX                    = 5,
};

// Enum Game.EFishingEvent
// NumValues: 0x0007
enum class EFishingEvent : uint8
{
	Begin                                    = 0,
	WaitThrow                                = 1,
	Throw                                    = 2,
	StarBattle                               = 3,
	Pull                                     = 4,
	Finish                                   = 5,
	EFishingEvent_MAX                        = 6,
};

// Enum Game.EFishingStage
// NumValues: 0x0004
enum class EFishingStage : uint8
{
	Idle                                     = 0,
	Wait                                     = 1,
	Battle                                   = 2,
	EFishingStage_MAX                        = 3,
};

// Enum Game.EAnimResType
// NumValues: 0x0006
enum class EAnimResType : uint8
{
	None                                     = 0,
	AnimResSequence                          = 1,
	AnimResMontage                           = 2,
	AnimResBlendSpace1D                      = 3,
	AnimResBlendSpace2D                      = 4,
	EAnimResType_MAX                         = 5,
};

// Enum Game.ECharacterInteractionType
// NumValues: 0x0006
enum class ECharacterInteractionType : uint8
{
	Idle                                     = 0,
	Touching                                 = 1,
	FeedbackAfterTouched                     = 2,
	IsReleaseAfterTouching                   = 3,
	NewAnimOfBSAndIK                         = 4,
	ECharacterInteractionType_MAX            = 5,
};

// Enum Game.EPreviewModelUIEventType
// NumValues: 0x0005
enum class EPreviewModelUIEventType : uint8
{
	None                                     = 0,
	EnterMain_FirstTime                      = 1,
	PlayerTouch                              = 2,
	Talk                                     = 3,
	EPreviewModelUIEventType_MAX             = 4,
};

// Enum Game.EAnimRunState
// NumValues: 0x0005
enum class EAnimRunState : uint8
{
	None                                     = 0,
	Run                                      = 1,
	PreRush                                  = 2,
	Rush                                     = 3,
	EAnimRunState_MAX                        = 4,
};

// Enum Game.EAnimForceState
// NumValues: 0x0007
enum class EAnimForceState : uint8
{
	None                                     = 0,
	ForceIdle                                = 1,
	ForceWalk                                = 2,
	ForceRun                                 = 3,
	ForceRush                                = 4,
	ForceBunker                              = 5,
	EAnimForceState_MAX                      = 6,
};

// Enum Game.EAnimBlendState
// NumValues: 0x0004
enum class EAnimBlendState : uint8
{
	BaseLoco                                 = 0,
	FullBodySkill                            = 1,
	HalfBodySkill                            = 2,
	EAnimBlendState_MAX                      = 3,
};

// Enum Game.ESimpleMoveType
// NumValues: 0x000A
enum class ESimpleMoveType : uint8
{
	Idle                                     = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Sprint                                   = 3,
	Pivot                                    = 4,
	Jump                                     = 5,
	Stop                                     = 6,
	RushStop                                 = 7,
	Bunkering                                = 8,
	ESimpleMoveType_MAX                      = 9,
};

// Enum Game.EPlayerTurnMode
// NumValues: 0x0005
enum class EPlayerTurnMode : uint8
{
	Idle                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Max_State                                = 3,
	EPlayerTurnMode_MAX                      = 4,
};

// Enum Game.EOnlineMapState
// NumValues: 0x0004
enum class EOnlineMapState : uint8
{
	None                                     = 0,
	Fighting                                 = 1,
	FightingEnd                              = 10,
	EOnlineMapState_MAX                      = 11,
};

// Enum Game.EPreLoadMode
// NumValues: 0x0003
enum class EPreLoadMode : uint8
{
	PLM_ASYNC                                = 0,
	PLM_SYNC                                 = 1,
	PLM_MAX                                  = 2,
};

// Enum Game.ELoadType
// NumValues: 0x0008
enum class ELoadType : uint8
{
	Character                                = 0,
	Monster                                  = 1,
	CharacterSkill                           = 2,
	MonsterSkill                             = 3,
	UI                                       = 4,
	Prop                                     = 5,
	Plot                                     = 6,
	ELoadType_MAX                            = 7,
};

// Enum Game.EShakeType
// NumValues: 0x0008
enum class EShakeType : uint8
{
	AxisX                                    = 0,
	AxisY                                    = 1,
	AxisZ                                    = 2,
	Pitch                                    = 3,
	Yaw                                      = 4,
	Roll                                     = 5,
	FOV                                      = 6,
	Max                                      = 7,
};

// Enum Game.EInteractionEmojiSourceType
// NumValues: 0x0003
enum class EInteractionEmojiSourceType : uint8
{
	Standby                                  = 0,
	ShowElement                              = 1,
	Max                                      = 2,
};

// Enum Game.EGameInteractorState
// NumValues: 0x0007
enum class EGameInteractorState : uint8
{
	None                                     = 0,
	Disable                                  = 1,
	Interactable                             = 2,
	Interacting                              = 3,
	Finish                                   = 4,
	End                                      = 5,
	EGameInteractorState_MAX                 = 6,
};

// Enum Game.EGameFeatureFlag
// NumValues: 0x0003
enum class EGameFeatureFlag : uint8
{
	None                                     = 0,
	OpenDropPool                             = 1,
	EGameFeatureFlag_MAX                     = 2,
};

// Enum Game.EHandleSettingType
// NumValues: 0x0024
enum class EHandleSettingType : uint8
{
	None                                     = 0,
	KEYBOARD                                 = 1,
	SHAKE                                    = 2,
	SENIOR_ANGLE_VIEW                        = 3,
	DETAIL_SETTING                           = 4,
	STEERING_SENSITIVITY                     = 5,
	AIMING_SENSITIVITY                       = 6,
	STEERING_CURVE                           = 7,
	STEERING_CORNER                          = 8,
	STEERING_INVERSE                         = 9,
	MOVE_CORNER                              = 10,
	CORNER                                   = 11,
	EXTERNAL_THRESHOLD                       = 12,
	RESPONSE_CURVE                           = 13,
	HANDLE_LR_SPEED                          = 14,
	HANDLE_UD_SPEED                          = 15,
	EXTRA_LR_SPEED                           = 16,
	EXTRA_UD_SPEED                           = 17,
	EXTRA_START_STEERING_TIME                = 18,
	EXTRA_START_STEERING_DELAY               = 19,
	AIMED_HANDLE_LR_SPEED                    = 20,
	AIMED_HANDLE_UD_SPEED                    = 21,
	AIMED_EXTRA_LR_SPEED                     = 22,
	AIMED_EXTRA_UD_SPEED                     = 23,
	AIMED_EXTRA_START_STEERING_TIME          = 24,
	AIMED_EXTRA_START_STEERING_DELAY         = 25,
	MOVE_CORNER_VALUE                        = 26,
	HANDLE_AUTO_AIM                          = 27,
	SNIPER_LR_SPEED                          = 28,
	SNIPER_UD_SPEED                          = 29,
	SNIPER_LR_EXTRA_SPEED                    = 30,
	SNIPER_UD_EXTRA_SPEED                    = 31,
	SNIPER_TURNS_EXTRA_STEERING_DELAY        = 32,
	SNIPER_TURNS_EXTRA_STEERING_TIME         = 33,
	SNIPER_SENSITIVITY                       = 34,
	EHandleSettingType_MAX                   = 35,
};

// Enum Game.ERockerTurnType
// NumValues: 0x0003
enum class ERockerTurnType : uint8
{
	Longitudinal                             = 0,
	Transverse                               = 1,
	ERockerTurnType_MAX                      = 2,
};

// Enum Game.EHandleRockerType
// NumValues: 0x0003
enum class EHandleRockerType : uint8
{
	LeftHandleRocker                         = 0,
	RightHandleRocker                        = 1,
	EHandleRockerType_MAX                    = 2,
};

// Enum Game.EGamepadOperateModel
// NumValues: 0x0007
enum class EGamepadOperateModel : uint8
{
	Disable                                  = 0,
	VirtualCursor                            = 1,
	GamepadNavigation                        = 2,
	GamepadNavigationCursor                  = 3,
	AttachTopUI                              = 4,
	Ignore                                   = 5,
	EGamepadOperateModel_MAX                 = 6,
};

// Enum Game.EGPSCPoolMethod
// NumValues: 0x0003
enum class EGPSCPoolMethod : uint8
{
	None                                     = 0,
	AutoRelease                              = 1,
	EGPSCPoolMethod_MAX                      = 2,
};

// Enum Game.EPhysicsControlModifierGroupType
// NumValues: 0x0003
enum class EPhysicsControlModifierGroupType : uint8
{
	Breast                                   = 0,
	Hip                                      = 1,
	EPhysicsControlModifierGroupType_MAX     = 2,
};

// Enum Game.EPhysicsControlGroupType
// NumValues: 0x0007
enum class EPhysicsControlGroupType : uint8
{
	None                                     = 0,
	Breast                                   = 1,
	Hip                                      = 2,
	ParentSpaceMark                          = 3,
	BreastParentSpace                        = 4,
	HipParentSpace                           = 5,
	EPhysicsControlGroupType_MAX             = 6,
};

// Enum Game.EDisablePhysicsControlReason
// NumValues: 0x0005
enum class EDisablePhysicsControlReason : uint8
{
	Simulate                                 = 0,
	DedicatedServer                          = 1,
	AllAge                                   = 2,
	NotifyState                              = 3,
	EDisablePhysicsControlReason_MAX         = 4,
};

// Enum Game.EPlayerCameraInfoType
// NumValues: 0x0007
enum class EPlayerCameraInfoType : uint8
{
	Aim                                      = 0,
	Rush                                     = 1,
	Fire                                     = 2,
	Normal                                   = 3,
	Temp                                     = 4,
	Turret                                   = 5,
	EPlayerCameraInfoType_MAX                = 6,
};

// Enum Game.SocketCameraType
// NumValues: 0x0004
enum class ESocketCameraType : uint8
{
	Anim                                     = 0,
	Blend                                    = 1,
	End                                      = 2,
	SocketCameraType_MAX                     = 3,
};

// Enum Game.EGamepadExecuteType
// NumValues: 0x0004
enum class EGamepadExecuteType : uint8
{
	InValid                                  = 0,
	ShortPress                               = 1,
	LongPress                                = 2,
	EGamepadExecuteType_MAX                  = 3,
};

// Enum Game.EDesignationType
// NumValues: 0x000B
enum class EDesignationType : uint8
{
	DT_None                                  = 0,
	DT_DamageAmount                          = 1,
	DT_HealAmount                            = 2,
	DT_NormalSkillCount                      = 3,
	DT_SuperSkillCount                       = 4,
	DT_ReceivedDamage                        = 5,
	DT_MaxSkillDamage                        = 6,
	DT_MaxShootDamage                        = 7,
	DT_DamagePerTenThousand                  = 8,
	DT_MaxCount                              = 9,
	DT_MAX                                   = 10,
};

// Enum Game.EBattleEventType
// NumValues: 0x0008
enum class EBattleEventType : uint8
{
	BET_None                                 = 0,
	BET_DamagePercent                        = 1,
	BET_HelpTeammate                         = 2,
	BET_DeathCount                           = 3,
	BET_CastSuperSkillCount                  = 4,
	BET_TD_ConsumeResource                   = 5,
	BET_FZ_ItemUseCount                      = 6,
	BET_MAX                                  = 7,
};

// Enum Game.ESlomPriority
// NumValues: 0x0015
enum class ESlomPriority : uint8
{
	Slom_High                                = 0,
	Slom_High0                               = 1,
	Slom_High1                               = 2,
	Slom_HighNormal                          = 3,
	Slom_HighNormal0                         = 4,
	Slom_HighNormal1                         = 5,
	Slom_HighLow                             = 6,
	Slom_HighLow0                            = 7,
	Slom_HighLow1                            = 8,
	Slom_Normal                              = 9,
	Slom_Normal0                             = 10,
	Slom_Normal1                             = 11,
	Slom_LowLow                              = 12,
	Slom_LowLow0                             = 13,
	Slom_LowLow1                             = 14,
	Slom_LowNormal                           = 15,
	Slom_LowNormal0                          = 16,
	Slom_LowNormal1                          = 17,
	Slom_Low                                 = 18,
	SlomPriority_Max                         = 19,
	ESlomPriority_MAX                        = 20,
};

// Enum Game.ETagType
// NumValues: 0x0004
enum class ETagType : uint8
{
	Normal                                   = 0,
	SpawnPointID                             = 1,
	SpawnInfiniteTag                         = 2,
	ETagType_MAX                             = 3,
};

// Enum Game.EGameTriggerType
// NumValues: 0x0004
enum class EGameTriggerType : uint8
{
	GTT_BeginOverlap                         = 0,
	GTT_EndOverlap                           = 1,
	GTT_All                                  = 2,
	GTT_MAX                                  = 3,
};

// Enum Game.EGameTriggerMode
// NumValues: 0x0006
enum class EGameTriggerMode : uint8
{
	GTM_Authority                            = 0,
	GTM_DedicatedServer                      = 1,
	GTM_Standalone                           = 2,
	GTM_Client                               = 3,
	GTM_AuthorityEX                          = 4,
	GTM_MAX                                  = 5,
};

// Enum Game.EGirlRushSensitivityType
// NumValues: 0x0004
enum class EGirlRushSensitivityType : uint8
{
	Default                                  = 0,
	FIREMODE                                 = 1,
	CROSSHAIR_SENSITIVITY                    = 2,
	EGirlRushSensitivityType_MAX             = 3,
};

// Enum Game.EGMFilterDamageType
// NumValues: 0x0004
enum class EGMFilterDamageType : uint8
{
	Damage                                   = 0,
	Heal                                     = 1,
	Bounce                                   = 2,
	EGMFilterDamageType_MAX                  = 3,
};

// Enum Game.EGraphicsSpecialSettingUpdateReason
// NumValues: 0x0005
enum class EGraphicsSpecialSettingUpdateReason : uint8
{
	UpdateSettings                           = 0,
	ToggleFullscreen                         = 1,
	LevelLoaded                              = 2,
	All                                      = 3,
	EGraphicsSpecialSettingUpdateReason_MAX  = 4,
};

// Enum Game.EGraphicsPlatform
// NumValues: 0x0006
enum class EGraphicsPlatform : uint8
{
	All                                      = 0,
	Editor                                   = 1,
	Windows                                  = 2,
	Android                                  = 3,
	IOS                                      = 4,
	EGraphicsPlatform_MAX                    = 5,
};

// Enum Game.EGraphicsSpecialSettingType
// NumValues: 0x0004
enum class EGraphicsSpecialSettingType : uint8
{
	MainMap                                  = 0,
	BattleMap                                = 1,
	HouseMap                                 = 2,
	Max                                      = 3,
};

// Enum Game.EGyroState
// NumValues: 0x0004
enum class EGyroState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Disable                                  = 2,
	EGyroState_MAX                           = 3,
};

// Enum Game.EHellDiversMonsType
// NumValues: 0x0004
enum class EHellDiversMonsType : uint8
{
	Wandering                                = 0,
	Patrolling                               = 1,
	Boss                                     = 2,
	EHellDiversMonsType_MAX                  = 3,
};

// Enum Game.EHouseHideCharReason
// NumValues: 0x0005
enum class EHouseHideCharReason : uint8
{
	None                                     = 0,
	Camera                                   = 1,
	Game                                     = 2,
	ChangeSuit                               = 3,
	EHouseHideCharReason_MAX                 = 4,
};

// Enum Game.EHouseBlockMoveType
// NumValues: 0x0006
enum class EHouseBlockMoveType : uint8
{
	NONE                                     = 0,
	HideUI                                   = 1,
	Sit                                      = 2,
	Interact                                 = 3,
	Teleport                                 = 4,
	EHouseBlockMoveType_MAX                  = 5,
};

// Enum Game.EHouseInteractType
// NumValues: 0x0003
enum class EHouseInteractType : uint8
{
	Normal                                   = 0,
	Constantly                               = 1,
	EHouseInteractType_MAX                   = 2,
};

// Enum Game.EBornActionType
// NumValues: 0x0004
enum class EBornActionType : uint8
{
	None                                     = 0,
	Furniture                                = 1,
	Nav                                      = 2,
	EBornActionType_MAX                      = 3,
};

// Enum Game.EAreaType
// NumValues: 0x0009
enum class EAreaType : uint8
{
	None                                     = 0,
	Hall                                     = 1,
	BedRoom                                  = 2,
	Other                                    = 3,
	Massage                                  = 4,
	HotSpring                                = 5,
	PubGame                                  = 6,
	Beach                                    = 7,
	EAreaType_MAX                            = 8,
};

// Enum Game.EHouseMassagePowerType
// NumValues: 0x0005
enum class EHouseMassagePowerType : uint8
{
	Impulse                                  = 0,
	Force                                    = 1,
	Torque                                   = 2,
	Spring                                   = 3,
	EHouseMassagePowerType_MAX               = 4,
};

// Enum Game.EHPPMoveType
// NumValues: 0x0004
enum class EHPPMoveType : uint8
{
	HPPForward                               = 0,
	HPPRight                                 = 1,
	HPPUp                                    = 2,
	EHPPMoveType_MAX                         = 3,
};

// Enum Game.EHouseTakePhotoMoveMode
// NumValues: 0x0003
enum class EHouseTakePhotoMoveMode : uint8
{
	Camera                                   = 0,
	Player                                   = 1,
	EHouseTakePhotoMoveMode_MAX              = 2,
};

// Enum Game.EHouseUIMode
// NumValues: 0x0003
enum class EHouseUIMode : uint8
{
	Normal                                   = 0,
	TakePhoto                                = 1,
	EHouseUIMode_MAX                         = 2,
};

// Enum Game.EHousePCKeyboardType
// NumValues: 0x0005
enum class EHousePCKeyboardType : uint8
{
	Rush                                     = 0,
	OpenBox                                  = 1,
	ExhaleMouse                              = 2,
	PauseGame                                = 3,
	EHousePCKeyboardType_MAX                 = 4,
};

// Enum Game.EHPState
// NumValues: 0x0005
enum class EHPState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hit                                      = 2,
	Recover                                  = 3,
	EHPState_MAX                             = 4,
};

// Enum Game.EInputBindType
// NumValues: 0x0004
enum class EInputBindType : uint8
{
	BindAction                               = 0,
	BindAxis                                 = 1,
	BindTouch                                = 2,
	EInputBindType_MAX                       = 3,
};

// Enum Game.EHouseMassageSmoothingType
// NumValues: 0x0006
enum class EHouseMassageSmoothingType : uint8
{
	None                                     = 0,
	Red                                      = 1,
	Orange                                   = 2,
	Green                                    = 3,
	Gray                                     = 4,
	EHouseMassageSmoothingType_MAX           = 5,
};

// Enum Game.EInteractionType
// NumValues: 0x0004
enum class EInteractionType : uint8
{
	None                                     = 0,
	Rotate                                   = 1,
	Move                                     = 2,
	EInteractionType_MAX                     = 3,
};

// Enum Game.ESpawnerType
// NumValues: 0x0004
enum class ESpawnerType : uint8
{
	None                                     = 0,
	Defend_Destructible                      = 1,
	Defend_HpDevice                          = 2,
	ESpawnerType_MAX                         = 3,
};

// Enum Game.EKideRideCameraState
// NumValues: 0x0006
enum class EKideRideCameraState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Drift                                    = 2,
	Falling                                  = 3,
	Complete                                 = 4,
	EKideRideCameraState_MAX                 = 5,
};

// Enum Game.ESpawnEffetMode
// NumValues: 0x0004
enum class ESpawnEffetMode : uint8
{
	Normal                                   = 0,
	AfterEffect                              = 1,
	SpawnDelay                               = 2,
	ESpawnEffetMode_MAX                      = 3,
};

// Enum Game.EOpenWorldExploreType
// NumValues: 0x0006
enum class EOpenWorldExploreType : uint8
{
	Destructable                             = 0,
	Important                                = 1,
	Common                                   = 2,
	Subordinate                              = 3,
	Special                                  = 4,
	EOpenWorldExploreType_MAX                = 5,
};

// Enum Game.ELevelDropType
// NumValues: 0x0006
enum class ELevelDropType : uint8
{
	Normal                                   = 0,
	CD                                       = 1,
	HP                                       = 2,
	SP                                       = 3,
	OpenWorld                                = 4,
	ELevelDropType_MAX                       = 5,
};

// Enum Game.EDropApplyMode
// NumValues: 0x0004
enum class EDropApplyMode : uint8
{
	Client                                   = 0,
	Server                                   = 1,
	Both                                     = 2,
	EDropApplyMode_MAX                       = 3,
};

// Enum Game.EOnlineMoneyState
// NumValues: 0x0005
enum class EOnlineMoneyState : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	Obtained                                 = 2,
	Death                                    = 3,
	EOnlineMoneyState_MAX                    = 4,
};

// Enum Game.ELevelPathEndType
// NumValues: 0x0004
enum class ELevelPathEndType : uint8
{
	Main                                     = 0,
	Secondary                                = 1,
	Dangerous                                = 2,
	ELevelPathEndType_MAX                    = 3,
};

// Enum Game.ELoadingStage
// NumValues: 0x0004
enum class ELoadingStage : uint8
{
	LoadingScene                             = 0,
	PreloadRes                               = 1,
	End                                      = 2,
	ELoadingStage_MAX                        = 3,
};

// Enum Game.ELoadingType
// NumValues: 0x0005
enum class ELoadingType : uint8
{
	Normal                                   = 0,
	Richman                                  = 1,
	RichmanLove                              = 2,
	WaterPark                                = 3,
	ELoadingType_MAX                         = 4,
};

// Enum Game.ELogicScriptEvent
// NumValues: 0x0002
enum class ELogicScriptEvent : uint8
{
	OnMonsReceiveDamage                      = 1,
	ELogicScriptEvent_MAX                    = 2,
};

// Enum Game.EUIType
// NumValues: 0x0004
enum class EUIType : uint8
{
	Stack                                    = 0,
	Child                                    = 1,
	Top                                      = 2,
	EUIType_MAX                              = 3,
};

// Enum Game.EMassMoveType
// NumValues: 0x0004
enum class EMassMoveType : uint8
{
	Player                                   = 0,
	Target                                   = 1,
	DynamicCustom                            = 2,
	EMassMoveType_MAX                        = 3,
};

// Enum Game.EModifyType
// NumValues: 0x0004
enum class EModifyType : uint8
{
	OnlyInShadow                             = 0,
	OnlyInLight                              = 1,
	BothInShadowAndLight                     = 2,
	EModifyType_MAX                          = 3,
};

// Enum Game.EMaterialType
// NumValues: 0x0003
enum class EMaterialType : uint8
{
	First                                    = 0,
	Secondary                                = 1,
	EMaterialType_MAX                        = 2,
};

// Enum Game.EModiferChangeBarDisplayState
// NumValues: 0x0004
enum class EModiferChangeBarDisplayState : uint8
{
	None                                     = 0,
	Display                                  = 1,
	Hidden                                   = 2,
	EModiferChangeBarDisplayState_MAX        = 3,
};

// Enum Game.EMonsFlyState
// NumValues: 0x0004
enum class EMonsFlyState : uint8
{
	Line                                     = 0,
	Quadratic                                = 1,
	Sin                                      = 2,
	EMonsFlyState_MAX                        = 3,
};

// Enum Game.EWarpPointAnimProvider
// NumValues: 0x0004
enum class EWarpPointAnimProvider : uint8
{
	None                                     = 0,
	Static                                   = 1,
	Bone                                     = 2,
	EWarpPointAnimProvider_MAX               = 3,
};

// Enum Game.EMotionWarpRotationType
// NumValues: 0x0003
enum class EMotionWarpRotationType : uint8
{
	Default                                  = 0,
	Facing                                   = 1,
	EMotionWarpRotationType_MAX              = 2,
};

// Enum Game.ENewFightSpecialDisplayState
// NumValues: 0x0004
enum class ENewFightSpecialDisplayState : uint8
{
	None                                     = 0,
	Display                                  = 1,
	Hidden                                   = 2,
	ENewFightSpecialDisplayState_MAX         = 3,
};

// Enum Game.EANRelativeTransformSpace
// NumValues: 0x0003
enum class EANRelativeTransformSpace : uint8
{
	World                                    = 0,
	Component                                = 1,
	EANRelativeTransformSpace_MAX            = 2,
};

// Enum Game.EANTransformType
// NumValues: 0x0003
enum class EANTransformType : uint8
{
	Position                                 = 0,
	Rotation                                 = 1,
	EANTransformType_MAX                     = 2,
};

// Enum Game.EANParameterType
// NumValues: 0x000C
enum class EANParameterType : uint8
{
	ColorCurve                               = 0,
	FloatCurve                               = 1,
	Int                                      = 2,
	Float                                    = 3,
	Vector2D                                 = 4,
	Vector                                   = 5,
	Color                                    = 6,
	StaticMesh                               = 7,
	SkeletonMesh                             = 8,
	Texture2D                                = 9,
	SocketTransform                          = 10,
	EANParameterType_MAX                     = 11,
};

// Enum Game.ENpcSpawnEffectState
// NumValues: 0x0006
enum class ENpcSpawnEffectState : uint8
{
	Default                                  = 0,
	Init                                     = 1,
	Delay                                    = 2,
	Flying                                   = 3,
	Finish                                   = 4,
	ENpcSpawnEffectState_MAX                 = 5,
};

// Enum Game.EBubbleType
// NumValues: 0x0005
enum class EBubbleType : uint8
{
	Normal                                   = 0,
	Random                                   = 1,
	Loop                                     = 2,
	RandomAndLoop                            = 3,
	EBubbleType_MAX                          = 4,
};

// Enum Game.EOnlineSeaShipPartType
// NumValues: 0x0007
enum class EOnlineSeaShipPartType : uint8
{
	OSSPT_None                               = 0,
	OSSPT_Body                               = 1,
	OSSPT_Deck                               = 2,
	OSSPT_ControlRoom                        = 3,
	OSSPT_Prop                               = 4,
	OSSPT_PropLeaf                           = 5,
	OSSPT_MAX                                = 6,
};

// Enum Game.EOnlineSeaModSkillOpcode
// NumValues: 0x0002
enum class EOnlineSeaModSkillOpcode : uint8
{
	EOSMS_None                               = 0,
	EOSMS_Max                                = 1,
};

// Enum Game.EOnlineSeaModSkillType
// NumValues: 0x0002
enum class EOnlineSeaModSkillType : uint8
{
	OSMST_None                               = 0,
	OSMST_MAX                                = 1,
};

// Enum Game.EOnlineSeaExpSource
// NumValues: 0x000D
enum class EOnlineSeaExpSource : uint8
{
	OS_None                                  = 0,
	OS_Supply                                = 1,
	OS_Mine                                  = 2,
	OS_EnemyShip                             = 3,
	OS_Repair                                = 4,
	OS_Fire                                  = 5,
	OS_Monster_Normal                        = 6,
	OS_Monster_Elite                         = 7,
	OS_Monster_Boss                          = 8,
	OS_EnemyShip_Small                       = 9,
	OS_EnemyShip_Mid                         = 10,
	OS_EnemyShip_Big                         = 11,
	OS_MAX                                   = 12,
};

// Enum Game.EEndlessBattleRandomEventOpCode
// NumValues: 0x0007
enum class EEndlessBattleRandomEventOpCode : uint8
{
	EEBOC_None                               = 0,
	EEBOC_SpawnMonster                       = 1,
	EEBOC_GodlenShop                         = 2,
	EEBOC_DoublePoints                       = 3,
	EEBOC_ChooseBuff                         = 4,
	EEBOC_AddMoney                           = 5,
	EEBOC_Max                                = 6,
};

// Enum Game.EOnlineTDBestTitleType
// NumValues: 0x0004
enum class EOnlineTDBestTitleType : uint8
{
	BTT_None                                 = 0,
	BTT_COLLECT                              = 1,
	BTT_DAMAGE                               = 2,
	BTT_MAX                                  = 3,
};

// Enum Game.EBaseSkillOpCode
// NumValues: 0x0024
enum class EBaseSkillOpCode : uint8
{
	EBSOC_None                               = 0,
	EBSOC_ADD_MODIFIER_TO_TAG                = 1,
	EBSOC_ADD_Modifier_TO_TURRET             = 2,
	EBSOC_ACTIVE_TURRET                      = 3,
	EBSOC_ADD_SKILL_TO_TAG                   = 4,
	EBSOC_GET_MODIFIER_AFTER_COLLECT         = 5,
	EBSOC_RESOURCE_COLLECTION_RATE           = 6,
	EBSOC_MONSTER_DROP                       = 7,
	EBSOC_CONSUME_RESOURCE                   = 8,
	EBSOC_MAXLEVEL_RESOURCE_TRANSFER         = 9,
	EBSOC_MAXLEVEL_ADD_DAMAGE                = 10,
	EBSOC_ACTIVE_TRAP                        = 11,
	EBSOC_SPAWN_FRIEND_NPC                   = 12,
	EBSOC_ADD_AURA                           = 13,
	EBSOC_DUTY_TURRET_HIT_ADD_RESOURCE       = 14,
	EBSOC_DUTY_TURRETER_ADD_RES              = 15,
	EBSOC_DUTY_ATTACKER_CHOOSE_BUFF          = 16,
	EBSOC_DUTY_COLLECTER_USE_PORT            = 17,
	EBSOC_DUTY_COLLECTER_DATA_UP             = 18,
	EBSOC_ADD_MODIFIER_TO_PLAYER             = 19,
	EBSOC_ADD_SKILL_TO_PLAYER                = 20,
	EBSOC_ADD_MAKEBUFF_COUNT                 = 21,
	EBSOC_DUTY_COLLECTER_AMMO_UP             = 22,
	EBSOC_DUTY_COLLECTER_BIG_UP              = 23,
	EBSOC_DUTY_COLLECTER_SMALL_UP            = 24,
	EBSOC_SHARE_TO_COLLECTER                 = 25,
	EBSOC_COLLECT_ADD_BUFF                   = 26,
	EBSOC_TURRETER_AMMO_UP                   = 27,
	EBSOC_TURRETER_TURNRES_UP                = 28,
	EBSOC_BASE_RECOVER_HP                    = 29,
	EBSOC_PLAYER_ADD_AMMO                    = 30,
	EBSOC_DUTY_COLLECTER_BUY_GRENADE_AMMO_UP = 31,
	EBSOC_DUTY_COLLECTER_ADD_TURRET_BUFF     = 32,
	EBSOC_TEAM_RES_RATE_UP                   = 33,
	EBSOC_ADD_RESOURCE_TO_PLAYER             = 34,
	EBSOC_MAX                                = 35,
};

// Enum Game.EOnlineTRBuffType
// NumValues: 0x0003
enum class EOnlineTRBuffType : uint8
{
	OTBT_Common                              = 0,
	OTBT_TowerRush                           = 1,
	OTBT_MAX                                 = 2,
};

// Enum Game.EPalGenerateType
// NumValues: 0x0004
enum class EPalGenerateType : uint8
{
	FirstVirsion                             = 0,
	Random                                   = 1,
	Circle                                   = 2,
	EPalGenerateType_MAX                     = 3,
};

// Enum Game.EPalMonsType
// NumValues: 0x0004
enum class EPalMonsType : uint8
{
	Wandering                                = 0,
	Patrolling                               = 1,
	Boss                                     = 2,
	EPalMonsType_MAX                         = 3,
};

// Enum Game.ECustomPhysicsType
// NumValues: 0x0005
enum class ECustomPhysicsType : uint8
{
	Phy                                      = 0,
	Anim                                     = 1,
	Both                                     = 2,
	None                                     = 3,
	ECustomPhysicsType_MAX                   = 4,
};

// Enum Game.ECustomInteractionType
// NumValues: 0x0004
enum class ECustomInteractionType : uint8
{
	IK                                       = 0,
	BlendSpace                               = 1,
	None                                     = 2,
	ECustomInteractionType_MAX               = 3,
};

// Enum Game.ECustomInteractionBodyPartsType
// NumValues: 0x000B
enum class ECustomInteractionBodyPartsType : uint8
{
	Head                                     = 0,
	LeftHand                                 = 1,
	RightHand                                = 2,
	LeftAnkle                                = 3,
	RightAnkle                               = 4,
	LeftKnee                                 = 5,
	RightKnee                                = 6,
	Breast                                   = 7,
	Butt                                     = 8,
	None                                     = 9,
	ECustomInteractionBodyPartsType_MAX      = 10,
};

// Enum Game.EPerformanceTriggerConditionRelationType
// NumValues: 0x0003
enum class EPerformanceTriggerConditionRelationType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EPerformanceTriggerConditionRelationType_MAX = 2,
};

// Enum Game.ECharacterPerformanceAnimTriggerType
// NumValues: 0x0004
enum class ECharacterPerformanceAnimTriggerType : uint8
{
	Default                                  = 0,
	Click                                    = 1,
	Max_State                                = 2,
	ECharacterPerformanceAnimTriggerType_MAX = 3,
};

// Enum Game.EPSMoveType
// NumValues: 0x0004
enum class EPSMoveType : uint8
{
	PSForward                                = 0,
	PSRight                                  = 1,
	PSUp                                     = 2,
	EPSMoveType_MAX                          = 3,
};

// Enum Game.EWeaponSoundPlayMode
// NumValues: 0x0003
enum class EWeaponSoundPlayMode : uint8
{
	PlayPerBulletFire                        = 0,
	PlayDuringFiring                         = 1,
	EWeaponSoundPlayMode_MAX                 = 2,
};

// Enum Game.EScatterState
// NumValues: 0x0005
enum class EScatterState : uint8
{
	Normal                                   = 0,
	Add                                      = 1,
	Wait                                     = 2,
	Recover                                  = 3,
	EScatterState_MAX                        = 4,
};

// Enum Game.EPreviewWeaponStage
// NumValues: 0x0004
enum class EPreviewWeaponStage : uint8
{
	Idle                                     = 0,
	Rotate                                   = 1,
	Reset                                    = 2,
	EPreviewWeaponStage_MAX                  = 3,
};

// Enum Game.EPropellerType
// NumValues: 0x0004
enum class EPropellerType : uint8
{
	Translation                              = 0,
	Up                                       = 1,
	Down                                     = 2,
	EPropellerType_MAX                       = 3,
};

// Enum Game.EPSCharacterPose
// NumValues: 0x0004
enum class EPSCharacterPose : uint8
{
	LeftHandPose                             = 0,
	RightHandPose                            = 1,
	HeadPose                                 = 2,
	EPSCharacterPose_MAX                     = 3,
};

// Enum Game.EPSCharacterPos
// NumValues: 0x0005
enum class EPSCharacterPos : uint8
{
	CharacterPosPos01                        = 0,
	CharacterPosPos02                        = 1,
	CharacterPosPos03                        = 2,
	CharacterPosPos04                        = 3,
	EPSCharacterPos_MAX                      = 4,
};

// Enum Game.ERAEmpty
// NumValues: 0x0002
enum class ERAEmpty : uint8
{
	None                                     = 0,
	ERAEmpty_MAX                             = 1,
};

// Enum Game.ERocketGameItemType
// NumValues: 0x0004
enum class ERocketGameItemType : uint8
{
	Revive                                   = 0,
	Coin                                     = 1,
	Double                                   = 2,
	ERocketGameItemType_MAX                  = 3,
};

// Enum Game.ERocketGamePosType
// NumValues: 0x0005
enum class ERocketGamePosType : uint8
{
	Custom                                   = 0,
	Top                                      = 1,
	Middle                                   = 2,
	Down                                     = 3,
	ERocketGamePosType_MAX                   = 4,
};

// Enum Game.ERocketGameTrapType
// NumValues: 0x0007
enum class ERocketGameTrapType : uint8
{
	None                                     = 0,
	Fence                                    = 1,
	Saw                                      = 2,
	Laser                                    = 3,
	Ball                                     = 4,
	Item                                     = 5,
	ERocketGameTrapType_MAX                  = 6,
};

// Enum Game.ERogue3DPointType
// NumValues: 0x000A
enum class ERogue3DPointType : uint8
{
	Default                                  = 0,
	OpenDoor                                 = 1,
	OpenDoor2                                = 2,
	OpenDoor3                                = 3,
	Point1                                   = 11,
	Point2                                   = 12,
	Point3                                   = 13,
	Point4                                   = 14,
	Point5                                   = 15,
	ERogue3DPointType_MAX                    = 16,
};

// Enum Game.ERogue3DState
// NumValues: 0x0009
enum class ERogue3DState : uint8
{
	None                                     = 0,
	Init                                     = 1,
	Loading                                  = 2,
	Running                                  = 3,
	LoadingMainRoom                          = 4,
	LoadTransfersRoom                        = 5,
	Fighting                                 = 6,
	Resting                                  = 7,
	ERogue3DState_MAX                        = 8,
};

// Enum Game.EGameLevelType
// NumValues: 0x000B
enum class EGameLevelType : uint8
{
	GameTimeShoot                            = 0,
	GameLimitShoot                           = 1,
	GameSpeedRun                             = 2,
	GameZumaShoot                            = 3,
	GameCarRace                              = 4,
	GameTimeSurvival                         = 5,
	GameElimination                          = 6,
	GamePortal                               = 7,
	GameTarget                               = 8,
	GamePushKill                             = 9,
	EGameLevelType_MAX                       = 10,
};

// Enum Game.ESkillCastFailType
// NumValues: 0x0005
enum class ESkillCastFailType : uint8
{
	Default                                  = 0,
	NotEnoughCost                            = 1,
	InvalidQueryResult                       = 2,
	NotEnoughBullet                          = 3,
	Max                                      = 4,
};

// Enum Game.ESkillEffectState
// NumValues: 0x0006
enum class ESkillEffectState : uint8
{
	InActive                                 = 0,
	Active                                   = 1,
	Blocking                                 = 2,
	Stoped                                   = 3,
	Max_State                                = 4,
	ESkillEffectState_MAX                    = 5,
};

// Enum Game.EHitExhibitionLocationType
// NumValues: 0x0006
enum class EHitExhibitionLocationType : uint8
{
	HitLocation                              = 0,
	Center                                   = 1,
	Ground                                   = 2,
	Socket                                   = 3,
	HitOrgLoc                                = 4,
	EHitExhibitionLocationType_MAX           = 5,
};

// Enum Game.EHitOriginLocation
// NumValues: 0x0004
enum class EHitOriginLocation : uint8
{
	Center                                   = 0,
	Ground                                   = 1,
	Socket                                   = 2,
	EHitOriginLocation_MAX                   = 3,
};

// Enum Game.EHitEffectTimePoint
// NumValues: 0x0005
enum class EHitEffectTimePoint : uint8
{
	BeforeHit                                = 0,
	BeforeDamage                             = 1,
	BeforeDamageClear                        = 2,
	AfterDamageClear                         = 3,
	EHitEffectTimePoint_MAX                  = 4,
};

// Enum Game.ESearchSettingType
// NumValues: 0x0003
enum class ESearchSettingType : uint8
{
	Point                                    = 0,
	Actor                                    = 1,
	ESearchSettingType_MAX                   = 2,
};

// Enum Game.EBulletType
// NumValues: 0x0004
enum class Game::EBulletType : uint8
{
	Bullet                                   = 0,
	BulletScreenEditor                       = 1,
	BulletToAll                              = 2,
	EBulletType_MAX                          = 3,
};

// Enum Game.EBulletSpawnPointFixRule
// NumValues: 0x0005
enum class EBulletSpawnPointFixRule : uint8
{
	CenterLoc                                = 0,
	GroundLoc                                = 1,
	SocketLoc                                = 2,
	SpecifyDirectly                          = 3,
	EBulletSpawnPointFixRule_MAX             = 4,
};

// Enum Game.EBulletSpawnPointType
// NumValues: 0x0003
enum class EBulletSpawnPointType : uint8
{
	Self                                     = 0,
	Anchor                                   = 1,
	EBulletSpawnPointType_MAX                = 2,
};

// Enum Game.EEmitterResultEffectPriority
// NumValues: 0x0004
enum class EEmitterResultEffectPriority : uint8
{
	PreferredSameActor                       = 0,
	PreferredNewActor                        = 1,
	SameAsSortResut                          = 2,
	EEmitterResultEffectPriority_MAX         = 3,
};

// Enum Game.EAbnormalFloatingType
// NumValues: 0x0006
enum class EAbnormalFloatingType : uint8
{
	None                                     = 0,
	NormalFloating                           = 1,
	VortexWhirlInfo                          = 2,
	ControlVelocity                          = 3,
	All                                      = 4,
	EAbnormalFloatingType_MAX                = 5,
};

// Enum Game.ESelectorFinishType
// NumValues: 0x0003
enum class ESelectorFinishType : uint8
{
	ButtonPress                              = 0,
	SkillCancel                              = 1,
	ESelectorFinishType_MAX                  = 2,
};

// Enum Game.ESelectorTargetType
// NumValues: 0x0004
enum class ESelectorTargetType : uint8
{
	Center                                   = 0,
	RandomLocation                           = 1,
	Character                                = 2,
	ESelectorTargetType_MAX                  = 3,
};

// Enum Game.EMultipleProgressBarFillType
// NumValues: 0x0006
enum class EMultipleProgressBarFillType : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	FillFromCenter                           = 2,
	TopToBottom                              = 3,
	BottomToTop                              = 4,
	EMultipleProgressBarFillType_MAX         = 5,
};

// Enum Game.ESplineAutoLineType
// NumValues: 0x0004
enum class ESplineAutoLineType : uint8
{
	None                                     = 0,
	Line                                     = 1,
	Circle                                   = 2,
	ESplineAutoLineType_MAX                  = 3,
};

// Enum Game.ESplineLineAxis
// NumValues: 0x0005
enum class ESplineLineAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	ESplineLineAxis_MAX                      = 4,
};

// Enum Game.EPreReleaseState
// NumValues: 0x0006
enum class EPreReleaseState : uint8
{
	UnOpen                                   = 0,
	Ready                                    = 1,
	Downloading                              = 2,
	Pause                                    = 3,
	Done                                     = 4,
	EPreReleaseState_MAX                     = 5,
};

// Enum Game.ELoginState
// NumValues: 0x0011
enum class ELoginState : uint8
{
	InitSdk                                  = 0,
	RequstLoginParam                         = 1,
	RecvLoginParam                           = 2,
	CheckDevice                              = 3,
	SelectVoice                              = 4,
	GetIpRegion                              = 5,
	RecvIpRegion                             = 6,
	SelectServerList                         = 7,
	RequestServerAddr                        = 8,
	RecvServerAddr                           = 9,
	ConnectServer                            = 10,
	ConnectServerSucc                        = 11,
	RequstAccountInfo                        = 12,
	RecvAccountInfo                          = 13,
	RequestLogin                             = 14,
	LoginSucc                                = 15,
	ELoginState_MAX                          = 16,
};

// Enum Game.EProgressDisplayStage
// NumValues: 0x000A
enum class EProgressDisplayStage : uint8
{
	Hide                                     = 0,
	Prepare                                  = 1,
	Mounting                                 = 2,
	Verifing                                 = 3,
	HotPatch_Primary                         = 4,
	PSO_Primary                              = 5,
	HotPatch_All                             = 6,
	PSO_All                                  = 7,
	Finish                                   = 8,
	EProgressDisplayStage_MAX                = 9,
};

// Enum Game.EResourceStage
// NumValues: 0x0004
enum class EResourceStage : uint8
{
	HotPatch                                 = 0,
	PSO                                      = 1,
	Finish                                   = 2,
	EResourceStage_MAX                       = 3,
};

// Enum Game.ESubtitlePartType
// NumValues: 0x0006
enum class ESubtitlePartType : uint8
{
	Body                                     = 0,
	Face                                     = 1,
	Prop                                     = 2,
	Skm                                      = 3,
	All                                      = 10,
	ESubtitlePartType_MAX                    = 11,
};

// Enum Game.EOneTakeType
// NumValues: 0x0005
enum class EOneTakeType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	End                                      = 2,
	StartAndEnd                              = 3,
	EOneTakeType_MAX                         = 4,
};

// Enum Game.ESubtitleSequenceType
// NumValues: 0x0006
enum class ESubtitleSequenceType : uint8
{
	None                                     = 0,
	FightVictory                             = 1,
	LevelSequence                            = 2,
	Cartoon                                  = 3,
	FightVictoryUI                           = 4,
	ESubtitleSequenceType_MAX                = 5,
};

// Enum Game.ESwitchState
// NumValues: 0x000C
enum class ESwitchState : uint8
{
	None                                     = 0,
	PreLeave                                 = 1,
	Leaving                                  = 2,
	PreEnter                                 = 3,
	Entering                                 = 4,
	Hiding                                   = 5,
	QTEPreLeave                              = 6,
	QTELeaving                               = 7,
	QTEPreEnter                              = 8,
	QTEEntering                              = 9,
	QTEHiding                                = 10,
	ESwitchState_MAX                         = 11,
};

// Enum Game.ELevelTaskEvent
// NumValues: 0x0003
enum class ELevelTaskEvent : uint8
{
	None                                     = 0,
	OnTimerAdd                               = 1,
	ELevelTaskEvent_MAX                      = 2,
};

// Enum Game.ELevelTaskAction
// NumValues: 0x0015
enum class ELevelTaskAction : uint8
{
	None                                     = 0,
	FinishExecute                            = 1,
	FailExecute                              = 2,
	SetTaskData                              = 3,
	TaskDataAdd                              = 4,
	ExChangeData                             = 5,
	ReSpawnDevice                            = 6,
	SetDefendWaveTimer                       = 7,
	SetDefendMonsLevel_ByWave                = 8,
	ReviveGamePlayer                         = 9,
	SurPlusData                              = 10,
	DivisionData                             = 11,
	RandomData                               = 12,
	ReadLevelGuidInfoById                    = 13,
	SetMultiDefendMonsLevel_ByWave           = 14,
	RefreshDefendTargetHPPercent             = 15,
	SpawnNpcInRange                          = 16,
	AddModifierOrSkillToPlayer               = 17,
	SetKillDownCount                         = 18,
	ScoreTakeProfits                         = 19,
	ELevelTaskAction_MAX                     = 20,
};

// Enum Game.EBindCondition
// NumValues: 0x0006
enum class EBindCondition : uint8
{
	Equal                                    = 0,
	GreaterThan                              = 1,
	EqualOrGreaterThan                       = 2,
	LessThan                                 = 3,
	EqualOrLessThan                          = 4,
	EBindCondition_MAX                       = 5,
};

// Enum Game.ERegionTimeType
// NumValues: 0x0004
enum class ERegionTimeType : uint8
{
	None                                     = 0,
	Day                                      = 1,
	Night                                    = 2,
	ERegionTimeType_MAX                      = 3,
};

// Enum Game.ETaskPointType
// NumValues: 0x000D
enum class ETaskPointType : uint8
{
	None                                     = 0,
	WildMons                                 = 1,
	TaskMons                                 = 2,
	CollectItems                             = 3,
	Task                                     = 4,
	Fish                                     = 5,
	Dungeon                                  = 6,
	Teleport                                 = 7,
	Boss                                     = 8,
	Herb                                     = 9,
	Trap                                     = 10,
	Build                                    = 11,
	ETaskPointType_MAX                       = 12,
};

// Enum Game.EMapRegionType
// NumValues: 0x000B
enum class EMapRegionType : uint8
{
	None                                     = 0,
	Region1                                  = 1,
	Region2                                  = 2,
	Region3                                  = 3,
	Region4                                  = 4,
	Region5                                  = 5,
	Region6                                  = 6,
	Region7                                  = 7,
	Region8                                  = 8,
	Region9                                  = 9,
	EMapRegionType_MAX                       = 10,
};

// Enum Game.ETeamSpawnerState
// NumValues: 0x0005
enum class ETeamSpawnerState : uint32
{
	ReadyToSpawned                           = 0,
	Spawned_Normal                           = 1,
	Spawned_InFight                          = 2,
	Spawned_OutofFight                       = 3,
	ETeamSpawnerState_MAX                    = 4,
};

// Enum Game.ENavFilterFlagDesc
// NumValues: 0x0003
enum class ENavFilterFlagDesc : uint8
{
	Default                                  = 0,
	Air                                      = 1,
	ENavFilterFlagDesc_MAX                   = 2,
};

// Enum Game.ETowerRushMonsterType
// NumValues: 0x0007
enum class ETowerRushMonsterType : uint8
{
	Normal                                   = 0,
	Explosive                                = 1,
	ChangeColor                              = 2,
	DoubleScore                              = 3,
	LineStop                                 = 4,
	ExtraScore                               = 5,
	ETowerRushMonsterType_MAX                = 6,
};

// Enum Game.ETurretAmmoType
// NumValues: 0x0004
enum class ETurretAmmoType : uint8
{
	MachineGun                               = 0,
	Grenade                                  = 1,
	Laser                                    = 2,
	ETurretAmmoType_MAX                      = 3,
};

// Enum Game.ETurretAttackType
// NumValues: 0x0003
enum class ETurretAttackType : uint8
{
	Repeat                                   = 0,
	Add                                      = 1,
	ETurretAttackType_MAX                    = 2,
};

// Enum Game.EHPBarPriorityRule
// NumValues: 0x0004
enum class EHPBarPriorityRule : uint8
{
	Latest                                   = 0,
	CameraDot                                = 1,
	Distance                                 = 2,
	EHPBarPriorityRule_MAX                   = 3,
};

// Enum Game.EWheeledVehicleDriftRPMScaleType
// NumValues: 0x0003
enum class EWheeledVehicleDriftRPMScaleType : uint8
{
	Normal                                   = 0,
	NitrousAccelerating                      = 1,
	EWheeledVehicleDriftRPMScaleType_MAX     = 2,
};

// Enum Game.EVehicleCameraShakeAnchor
// NumValues: 0x0003
enum class EVehicleCameraShakeAnchor : uint8
{
	VehicleCameraShake_Root                  = 0,
	VehicleCameraShake_CrashLocation         = 1,
	VehicleCameraShake_MAX                   = 2,
};

// Enum Game.EVehicleCameraShakeTriggerType
// NumValues: 0x0003
enum class EVehicleCameraShakeTriggerType : uint8
{
	VehicleCameraShake_Crash                 = 0,
	VehicleCameraShake_Nitrous               = 1,
	VehicleCameraShake_MAX                   = 2,
};

// Enum Game.EVehicleFixOrientationCondition
// NumValues: 0x0003
enum class EVehicleFixOrientationCondition : uint8
{
	VehicleFixOrientation_Switch             = 0,
	VehicleFixOrientation_Speed              = 1,
	VehicleFixOrientation_MAX                = 2,
};

// Enum Game.EVehileFixCameraCondition
// NumValues: 0x0003
enum class EVehileFixCameraCondition : uint8
{
	VehicleCameraCondition_Switch            = 0,
	VehicleCameraCondition_Speed             = 1,
	VehicleCameraCondition_MAX               = 2,
};

// Enum Game.EVehicleCameraState
// NumValues: 0x0004
enum class EVehicleCameraState : uint8
{
	VehicleCameraState_Normal                = 0,
	VehicleCameraState_Drifting              = 1,
	VehicleCameraState_Nitrous               = 2,
	VehicleCameraState_MAX                   = 3,
};

// Enum Game.EVehicleNitrousType
// NumValues: 0x0004
enum class EVehicleNitrousType : uint8
{
	Item                                     = 0,
	AccBelt                                  = 1,
	DriftBoost                               = 2,
	EVehicleNitrousType_MAX                  = 3,
};

// Enum Game.EVehicleState
// NumValues: 0x0005
enum class EVehicleState : uint8
{
	None                                     = 0,
	Entry                                    = 1,
	Exit                                     = 2,
	Running                                  = 3,
	EVehicleState_MAX                        = 4,
};

// Enum Game.EWednesdayDroneState
// NumValues: 0x0006
enum class EWednesdayDroneState : uint8
{
	Follow                                   = 0,
	Attack                                   = 1,
	Bomb                                     = 2,
	QTE                                      = 3,
	Leave                                    = 4,
	EWednesdayDroneState_MAX                 = 5,
};

// ScriptStruct Game.LimbControlData
// 0x0028 (0x0028 - 0x0000)
struct FLimbControlData final
{
public:
	class FName                                   SetName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicsControlData                    ControlData;                                       // 0x0008(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimbControlData) == 0x000004, "Wrong alignment on FLimbControlData");
static_assert(sizeof(FLimbControlData) == 0x000028, "Wrong size on FLimbControlData");
static_assert(offsetof(FLimbControlData, SetName) == 0x000000, "Member 'FLimbControlData::SetName' has a wrong offset!");
static_assert(offsetof(FLimbControlData, ControlData) == 0x000008, "Member 'FLimbControlData::ControlData' has a wrong offset!");

// ScriptStruct Game.ForbidSkillInfo
// 0x002C (0x002C - 0x0000)
struct FForbidSkillInfo final
{
public:
	int32                                         TrapId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectorSkillId;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadyTime;                                         // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrapDuration;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseTime;                                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUseTime;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextUseTime;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForbidSkillInfo) == 0x000004, "Wrong alignment on FForbidSkillInfo");
static_assert(sizeof(FForbidSkillInfo) == 0x00002C, "Wrong size on FForbidSkillInfo");
static_assert(offsetof(FForbidSkillInfo, TrapId) == 0x000000, "Member 'FForbidSkillInfo::TrapId' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, ConfigId) == 0x000004, "Member 'FForbidSkillInfo::ConfigId' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, SelectorSkillId) == 0x000008, "Member 'FForbidSkillInfo::SelectorSkillId' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, ReadyTime) == 0x00000C, "Member 'FForbidSkillInfo::ReadyTime' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, CD) == 0x000010, "Member 'FForbidSkillInfo::CD' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, Type) == 0x000014, "Member 'FForbidSkillInfo::Type' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, TrapDuration) == 0x000018, "Member 'FForbidSkillInfo::TrapDuration' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, Level) == 0x00001C, "Member 'FForbidSkillInfo::Level' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, UseTime) == 0x000020, "Member 'FForbidSkillInfo::UseTime' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, MaxUseTime) == 0x000024, "Member 'FForbidSkillInfo::MaxUseTime' has a wrong offset!");
static_assert(offsetof(FForbidSkillInfo, NextUseTime) == 0x000028, "Member 'FForbidSkillInfo::NextUseTime' has a wrong offset!");

// ScriptStruct Game.ParamInfo
// 0x0010 (0x0010 - 0x0000)
struct FParamInfo final
{
public:
	class FString                                 ParamValue;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParamInfo) == 0x000008, "Wrong alignment on FParamInfo");
static_assert(sizeof(FParamInfo) == 0x000010, "Wrong size on FParamInfo");
static_assert(offsetof(FParamInfo, ParamValue) == 0x000000, "Member 'FParamInfo::ParamValue' has a wrong offset!");

// ScriptStruct Game.AbnormalInfo
// 0x0060 (0x0060 - 0x0000)
struct FAbnormalInfo final
{
public:
	class FString                                 BoneName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLoc;                                         // 0x001C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AbnormalCauser;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalState                                AbnormalState;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AnimType;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RandomIndex;                                       // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepTime;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     AbnormalInfos;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AppliedModifierRunTimeID;                          // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppliedModifierID;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppliedEmitterID;                                  // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scaler;                                            // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnormalInfo) == 0x000008, "Wrong alignment on FAbnormalInfo");
static_assert(sizeof(FAbnormalInfo) == 0x000060, "Wrong size on FAbnormalInfo");
static_assert(offsetof(FAbnormalInfo, BoneName) == 0x000000, "Member 'FAbnormalInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, Direction) == 0x000010, "Member 'FAbnormalInfo::Direction' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, OriginLoc) == 0x00001C, "Member 'FAbnormalInfo::OriginLoc' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AbnormalCauser) == 0x000028, "Member 'FAbnormalInfo::AbnormalCauser' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AbnormalState) == 0x000030, "Member 'FAbnormalInfo::AbnormalState' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AnimType) == 0x000031, "Member 'FAbnormalInfo::AnimType' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, RandomIndex) == 0x000032, "Member 'FAbnormalInfo::RandomIndex' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, KeepTime) == 0x000034, "Member 'FAbnormalInfo::KeepTime' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AnimTime) == 0x000038, "Member 'FAbnormalInfo::AnimTime' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, CurrentTime) == 0x00003C, "Member 'FAbnormalInfo::CurrentTime' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AbnormalInfos) == 0x000040, "Member 'FAbnormalInfo::AbnormalInfos' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AppliedModifierRunTimeID) == 0x000050, "Member 'FAbnormalInfo::AppliedModifierRunTimeID' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AppliedModifierID) == 0x000054, "Member 'FAbnormalInfo::AppliedModifierID' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, AppliedEmitterID) == 0x000058, "Member 'FAbnormalInfo::AppliedEmitterID' has a wrong offset!");
static_assert(offsetof(FAbnormalInfo, Scaler) == 0x00005C, "Member 'FAbnormalInfo::Scaler' has a wrong offset!");

// ScriptStruct Game.GMLogInfo
// 0x0018 (0x0018 - 0x0000)
struct FGMLogInfo final
{
public:
	class FString                                 LogText;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGMLogEmun                                    Type;                                              // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGMLogInfo) == 0x000008, "Wrong alignment on FGMLogInfo");
static_assert(sizeof(FGMLogInfo) == 0x000018, "Wrong size on FGMLogInfo");
static_assert(offsetof(FGMLogInfo, LogText) == 0x000000, "Member 'FGMLogInfo::LogText' has a wrong offset!");
static_assert(offsetof(FGMLogInfo, Type) == 0x000010, "Member 'FGMLogInfo::Type' has a wrong offset!");

// ScriptStruct Game.AttributeChangeValueGrowupBase
// 0x01F8 (0x01F8 - 0x0000)
struct FAttributeChangeValueGrowupBase
{
public:
	TMap<int32, float>                            Value;                                             // 0x0000(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, struct FVector2D>                 RandomValue;                                       // 0x0050(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributeFunc;                                 // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributeParams;                               // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            MaxFixedValues;                                    // 0x00C8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseSummoner;                                      // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseModifierLauncher;                              // 0x0119(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLuancherSourceValueAttribute;                  // 0x011A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B[0x5];                                      // 0x011B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityAttribute*                      SourceValueAttributeClass;                         // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            UseCurSourceValuePrecent;                          // 0x0128(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributePerFunc;                              // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributePerParams;                            // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseAttributeMulti;                                // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            AttributeMaxFixedValues;                           // 0x01A8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeChangeValueGrowupBase) == 0x000008, "Wrong alignment on FAttributeChangeValueGrowupBase");
static_assert(sizeof(FAttributeChangeValueGrowupBase) == 0x0001F8, "Wrong size on FAttributeChangeValueGrowupBase");
static_assert(offsetof(FAttributeChangeValueGrowupBase, Value) == 0x000000, "Member 'FAttributeChangeValueGrowupBase::Value' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, RandomValue) == 0x000050, "Member 'FAttributeChangeValueGrowupBase::RandomValue' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, CalcAttributeFunc) == 0x0000A0, "Member 'FAttributeChangeValueGrowupBase::CalcAttributeFunc' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, CalcAttributeParams) == 0x0000B8, "Member 'FAttributeChangeValueGrowupBase::CalcAttributeParams' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, MaxFixedValues) == 0x0000C8, "Member 'FAttributeChangeValueGrowupBase::MaxFixedValues' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, bUseSummoner) == 0x000118, "Member 'FAttributeChangeValueGrowupBase::bUseSummoner' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, bUseModifierLauncher) == 0x000119, "Member 'FAttributeChangeValueGrowupBase::bUseModifierLauncher' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, bUseLuancherSourceValueAttribute) == 0x00011A, "Member 'FAttributeChangeValueGrowupBase::bUseLuancherSourceValueAttribute' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, SourceValueAttributeClass) == 0x000120, "Member 'FAttributeChangeValueGrowupBase::SourceValueAttributeClass' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, UseCurSourceValuePrecent) == 0x000128, "Member 'FAttributeChangeValueGrowupBase::UseCurSourceValuePrecent' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, CalcAttributePerFunc) == 0x000178, "Member 'FAttributeChangeValueGrowupBase::CalcAttributePerFunc' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, CalcAttributePerParams) == 0x000190, "Member 'FAttributeChangeValueGrowupBase::CalcAttributePerParams' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, bUseAttributeMulti) == 0x0001A0, "Member 'FAttributeChangeValueGrowupBase::bUseAttributeMulti' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowupBase, AttributeMaxFixedValues) == 0x0001A8, "Member 'FAttributeChangeValueGrowupBase::AttributeMaxFixedValues' has a wrong offset!");

// ScriptStruct Game.ModifierEffectParticleInfo
// 0x0070 (0x0070 - 0x0000)
struct FModifierEffectParticleInfo final
{
public:
	struct FSoftObjectPath                        ParticlePath;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComposite;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParticleSpawnHitPos;                              // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParticleSocketName;                                // 0x001C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParticleAttach;                                   // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollowRotation;                                   // 0x0025(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0xA];                                       // 0x0026(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ParticleRelativeTransform;                         // 0x0030(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RandomRot;                                         // 0x0060(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEffectFaceToLauncher;                             // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParticleDestroyImmediately;                       // 0x006D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierEffectParticleInfo) == 0x000010, "Wrong alignment on FModifierEffectParticleInfo");
static_assert(sizeof(FModifierEffectParticleInfo) == 0x000070, "Wrong size on FModifierEffectParticleInfo");
static_assert(offsetof(FModifierEffectParticleInfo, ParticlePath) == 0x000000, "Member 'FModifierEffectParticleInfo::ParticlePath' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bComposite) == 0x000018, "Member 'FModifierEffectParticleInfo::bComposite' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bParticleSpawnHitPos) == 0x000019, "Member 'FModifierEffectParticleInfo::bParticleSpawnHitPos' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, ParticleSocketName) == 0x00001C, "Member 'FModifierEffectParticleInfo::ParticleSocketName' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bParticleAttach) == 0x000024, "Member 'FModifierEffectParticleInfo::bParticleAttach' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bFollowRotation) == 0x000025, "Member 'FModifierEffectParticleInfo::bFollowRotation' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, ParticleRelativeTransform) == 0x000030, "Member 'FModifierEffectParticleInfo::ParticleRelativeTransform' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, RandomRot) == 0x000060, "Member 'FModifierEffectParticleInfo::RandomRot' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bEffectFaceToLauncher) == 0x00006C, "Member 'FModifierEffectParticleInfo::bEffectFaceToLauncher' has a wrong offset!");
static_assert(offsetof(FModifierEffectParticleInfo, bParticleDestroyImmediately) == 0x00006D, "Member 'FModifierEffectParticleInfo::bParticleDestroyImmediately' has a wrong offset!");

// ScriptStruct Game.MagicParameter
// 0x0018 (0x0018 - 0x0000)
struct FMagicParameter final
{
public:
	class UMagicAssets*                           Magic;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     Params;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagicParameter) == 0x000008, "Wrong alignment on FMagicParameter");
static_assert(sizeof(FMagicParameter) == 0x000018, "Wrong size on FMagicParameter");
static_assert(offsetof(FMagicParameter, Magic) == 0x000000, "Member 'FMagicParameter::Magic' has a wrong offset!");
static_assert(offsetof(FMagicParameter, Params) == 0x000008, "Member 'FMagicParameter::Params' has a wrong offset!");

// ScriptStruct Game.AttributeChangeValueGrowup
// 0x0010 (0x0208 - 0x01F8)
struct FAttributeChangeValueGrowup final : public FAttributeChangeValueGrowupBase
{
public:
	class UAbilityAttribute*                      AttributeClass;                                    // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeChangeType                          ChangeType;                                        // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTeam;                                        // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyMax;                                         // 0x0202(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyWeapon;                                      // 0x0203(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeChangeValueGrowup) == 0x000008, "Wrong alignment on FAttributeChangeValueGrowup");
static_assert(sizeof(FAttributeChangeValueGrowup) == 0x000208, "Wrong size on FAttributeChangeValueGrowup");
static_assert(offsetof(FAttributeChangeValueGrowup, AttributeClass) == 0x0001F8, "Member 'FAttributeChangeValueGrowup::AttributeClass' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowup, ChangeType) == 0x000200, "Member 'FAttributeChangeValueGrowup::ChangeType' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowup, bApplyTeam) == 0x000201, "Member 'FAttributeChangeValueGrowup::bApplyTeam' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowup, bApplyMax) == 0x000202, "Member 'FAttributeChangeValueGrowup::bApplyMax' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValueGrowup, bApplyWeapon) == 0x000203, "Member 'FAttributeChangeValueGrowup::bApplyWeapon' has a wrong offset!");

// ScriptStruct Game.ConditionInfo
// 0x0078 (0x0078 - 0x0000)
struct FConditionInfo final
{
public:
	bool                                          bLauncherCheck;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionCheckTargetType                     CheckTargetType;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCacheTargetsInSameTime;                           // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         ConditionTypePath;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param2;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param3;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param4;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param5;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bInverse;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionInfo) == 0x000008, "Wrong alignment on FConditionInfo");
static_assert(sizeof(FConditionInfo) == 0x000078, "Wrong size on FConditionInfo");
static_assert(offsetof(FConditionInfo, bLauncherCheck) == 0x000000, "Member 'FConditionInfo::bLauncherCheck' has a wrong offset!");
static_assert(offsetof(FConditionInfo, CheckTargetType) == 0x000001, "Member 'FConditionInfo::CheckTargetType' has a wrong offset!");
static_assert(offsetof(FConditionInfo, bCacheTargetsInSameTime) == 0x000002, "Member 'FConditionInfo::bCacheTargetsInSameTime' has a wrong offset!");
static_assert(offsetof(FConditionInfo, ConditionTypePath) == 0x000008, "Member 'FConditionInfo::ConditionTypePath' has a wrong offset!");
static_assert(offsetof(FConditionInfo, Param) == 0x000020, "Member 'FConditionInfo::Param' has a wrong offset!");
static_assert(offsetof(FConditionInfo, Param2) == 0x000030, "Member 'FConditionInfo::Param2' has a wrong offset!");
static_assert(offsetof(FConditionInfo, Param3) == 0x000040, "Member 'FConditionInfo::Param3' has a wrong offset!");
static_assert(offsetof(FConditionInfo, Param4) == 0x000050, "Member 'FConditionInfo::Param4' has a wrong offset!");
static_assert(offsetof(FConditionInfo, Param5) == 0x000060, "Member 'FConditionInfo::Param5' has a wrong offset!");
static_assert(offsetof(FConditionInfo, bInverse) == 0x000070, "Member 'FConditionInfo::bInverse' has a wrong offset!");

// ScriptStruct Game.ConditionSetting
// 0x0018 (0x0018 - 0x0000)
struct FConditionSetting final
{
public:
	bool                                          bTeamCheck;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerCheck;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionInfo>                 ConditionsInfo;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionSetting) == 0x000008, "Wrong alignment on FConditionSetting");
static_assert(sizeof(FConditionSetting) == 0x000018, "Wrong size on FConditionSetting");
static_assert(offsetof(FConditionSetting, bTeamCheck) == 0x000000, "Member 'FConditionSetting::bTeamCheck' has a wrong offset!");
static_assert(offsetof(FConditionSetting, bOwnerCheck) == 0x000001, "Member 'FConditionSetting::bOwnerCheck' has a wrong offset!");
static_assert(offsetof(FConditionSetting, ConditionsInfo) == 0x000008, "Member 'FConditionSetting::ConditionsInfo' has a wrong offset!");

// ScriptStruct Game.DamageValueInfo
// 0x0120 (0x0120 - 0x0000)
struct FDamageValueInfo final
{
public:
	TArray<struct FConditionSetting>              Condition;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         OutDamageValueID;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            FixValue;                                          // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributeFunc;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributeParams;                               // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAbilityAttribute*                      AttributeClass;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetAttribute;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSummoner;                                      // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            AttributePercent;                                  // 0x00A0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributePerFunc;                              // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributePerParams;                            // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseMulti;                                         // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageValueInfo) == 0x000008, "Wrong alignment on FDamageValueInfo");
static_assert(sizeof(FDamageValueInfo) == 0x000120, "Wrong size on FDamageValueInfo");
static_assert(offsetof(FDamageValueInfo, Condition) == 0x000000, "Member 'FDamageValueInfo::Condition' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, OutDamageValueID) == 0x000010, "Member 'FDamageValueInfo::OutDamageValueID' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, FixValue) == 0x000018, "Member 'FDamageValueInfo::FixValue' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, CalcAttributeFunc) == 0x000068, "Member 'FDamageValueInfo::CalcAttributeFunc' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, CalcAttributeParams) == 0x000080, "Member 'FDamageValueInfo::CalcAttributeParams' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, AttributeClass) == 0x000090, "Member 'FDamageValueInfo::AttributeClass' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, bUseTargetAttribute) == 0x000098, "Member 'FDamageValueInfo::bUseTargetAttribute' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, bUseSummoner) == 0x000099, "Member 'FDamageValueInfo::bUseSummoner' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, AttributePercent) == 0x0000A0, "Member 'FDamageValueInfo::AttributePercent' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, CalcAttributePerFunc) == 0x0000F0, "Member 'FDamageValueInfo::CalcAttributePerFunc' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, CalcAttributePerParams) == 0x000108, "Member 'FDamageValueInfo::CalcAttributePerParams' has a wrong offset!");
static_assert(offsetof(FDamageValueInfo, bUseMulti) == 0x000118, "Member 'FDamageValueInfo::bUseMulti' has a wrong offset!");

// ScriptStruct Game.DamageValueGrowup
// 0x0210 (0x0210 - 0x0000)
struct FDamageValueGrowup final
{
public:
	struct FDamageValueInfo                       DamageValue;                                       // 0x0000(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            DestroyBunkerValueMap;                             // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            HitEnergyMap;                                      // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            CriticalHitEnergyMap;                              // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageValueGrowup) == 0x000008, "Wrong alignment on FDamageValueGrowup");
static_assert(sizeof(FDamageValueGrowup) == 0x000210, "Wrong size on FDamageValueGrowup");
static_assert(offsetof(FDamageValueGrowup, DamageValue) == 0x000000, "Member 'FDamageValueGrowup::DamageValue' has a wrong offset!");
static_assert(offsetof(FDamageValueGrowup, DestroyBunkerValueMap) == 0x000120, "Member 'FDamageValueGrowup::DestroyBunkerValueMap' has a wrong offset!");
static_assert(offsetof(FDamageValueGrowup, HitEnergyMap) == 0x000170, "Member 'FDamageValueGrowup::HitEnergyMap' has a wrong offset!");
static_assert(offsetof(FDamageValueGrowup, CriticalHitEnergyMap) == 0x0001C0, "Member 'FDamageValueGrowup::CriticalHitEnergyMap' has a wrong offset!");

// ScriptStruct Game.SpecialDamageFloat
// 0x0030 (0x0030 - 0x0000)
struct FSpecialDamageFloat final
{
public:
	struct FSoftClassPath                         AnimWidget;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecialType;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWorldPos;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialDamageFloat) == 0x000008, "Wrong alignment on FSpecialDamageFloat");
static_assert(sizeof(FSpecialDamageFloat) == 0x000030, "Wrong size on FSpecialDamageFloat");
static_assert(offsetof(FSpecialDamageFloat, AnimWidget) == 0x000000, "Member 'FSpecialDamageFloat::AnimWidget' has a wrong offset!");
static_assert(offsetof(FSpecialDamageFloat, SpecialType) == 0x000018, "Member 'FSpecialDamageFloat::SpecialType' has a wrong offset!");
static_assert(offsetof(FSpecialDamageFloat, bUseWorldPos) == 0x000028, "Member 'FSpecialDamageFloat::bUseWorldPos' has a wrong offset!");
static_assert(offsetof(FSpecialDamageFloat, bCritical) == 0x000029, "Member 'FSpecialDamageFloat::bCritical' has a wrong offset!");

// ScriptStruct Game.PropertyChangeValueGrowup
// 0x00B8 (0x00B8 - 0x0000)
struct FPropertyChangeValueGrowup final
{
public:
	EModifyHPType                                 HealthChangeType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageValueGrowup>             DamageInfo;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EEmitterDamageType                            OverrideDamageType;                                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDamage;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialDamageFloat>            SpecialDamageFloats;                               // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DamageOriginSkillID;                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DamageTag;                                         // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         ShootDamageBonusType;                              // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IgnoreDamageBonusType;                             // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillToShootSkill;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSkillDamageType;                             // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCriteType                               CriteType;                                         // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotApplyDamageEffect;                             // 0x0063(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageSubTagTypes;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            SkillIntensity;                                    // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertyChangeValueGrowup) == 0x000008, "Wrong alignment on FPropertyChangeValueGrowup");
static_assert(sizeof(FPropertyChangeValueGrowup) == 0x0000B8, "Wrong size on FPropertyChangeValueGrowup");
static_assert(offsetof(FPropertyChangeValueGrowup, HealthChangeType) == 0x000000, "Member 'FPropertyChangeValueGrowup::HealthChangeType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, DamageInfo) == 0x000008, "Member 'FPropertyChangeValueGrowup::DamageInfo' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, OverrideDamageType) == 0x000018, "Member 'FPropertyChangeValueGrowup::OverrideDamageType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, bShowDamage) == 0x000019, "Member 'FPropertyChangeValueGrowup::bShowDamage' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, SpecialDamageFloats) == 0x000020, "Member 'FPropertyChangeValueGrowup::SpecialDamageFloats' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, DamageOriginSkillID) == 0x000030, "Member 'FPropertyChangeValueGrowup::DamageOriginSkillID' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, DamageTag) == 0x000038, "Member 'FPropertyChangeValueGrowup::DamageTag' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, ShootDamageBonusType) == 0x000058, "Member 'FPropertyChangeValueGrowup::ShootDamageBonusType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, IgnoreDamageBonusType) == 0x00005C, "Member 'FPropertyChangeValueGrowup::IgnoreDamageBonusType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, bSkillToShootSkill) == 0x000060, "Member 'FPropertyChangeValueGrowup::bSkillToShootSkill' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, IgnoreSkillDamageType) == 0x000061, "Member 'FPropertyChangeValueGrowup::IgnoreSkillDamageType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, CriteType) == 0x000062, "Member 'FPropertyChangeValueGrowup::CriteType' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, bNotApplyDamageEffect) == 0x000063, "Member 'FPropertyChangeValueGrowup::bNotApplyDamageEffect' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, DamageSubTagTypes) == 0x000064, "Member 'FPropertyChangeValueGrowup::DamageSubTagTypes' has a wrong offset!");
static_assert(offsetof(FPropertyChangeValueGrowup, SkillIntensity) == 0x000068, "Member 'FPropertyChangeValueGrowup::SkillIntensity' has a wrong offset!");

// ScriptStruct Game.ModifierDamageEffect
// 0x00E0 (0x00E0 - 0x0000)
struct FModifierDamageEffect final
{
public:
	EDamageTargetType                             DamageTargetType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllowOtherDamageEffectTypes;                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageEffectDerivedTagTypes;                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              Conditions;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDamageEndTrigger;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLuancherAtttibuteChange;                          // 0x0021(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeChangeValueGrowup>    AtttibuteChange;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FPropertyChangeValueGrowup>     PropertyChangeGrowup;                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                Magics;                                            // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 EmitterIDs;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EModifierDEExecEmitterType                    EmitterExecType;                                   // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEmitterSearchTarget;                           // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeChangeValueGrowup>    DelaySettlementDamageValue;                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CDTime;                                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetTimingAlone;                                // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAbilityComponentBase*, float>     ExecuteTime;                                       // 0x0088(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ExecuteTimingAlone;                                // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierDamageEffect) == 0x000008, "Wrong alignment on FModifierDamageEffect");
static_assert(sizeof(FModifierDamageEffect) == 0x0000E0, "Wrong size on FModifierDamageEffect");
static_assert(offsetof(FModifierDamageEffect, DamageTargetType) == 0x000000, "Member 'FModifierDamageEffect::DamageTargetType' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, AllowOtherDamageEffectTypes) == 0x000004, "Member 'FModifierDamageEffect::AllowOtherDamageEffectTypes' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, DamageEffectDerivedTagTypes) == 0x000008, "Member 'FModifierDamageEffect::DamageEffectDerivedTagTypes' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, Conditions) == 0x000010, "Member 'FModifierDamageEffect::Conditions' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, bDamageEndTrigger) == 0x000020, "Member 'FModifierDamageEffect::bDamageEndTrigger' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, bLuancherAtttibuteChange) == 0x000021, "Member 'FModifierDamageEffect::bLuancherAtttibuteChange' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, AtttibuteChange) == 0x000028, "Member 'FModifierDamageEffect::AtttibuteChange' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, PropertyChangeGrowup) == 0x000038, "Member 'FModifierDamageEffect::PropertyChangeGrowup' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, Magics) == 0x000048, "Member 'FModifierDamageEffect::Magics' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, EmitterIDs) == 0x000058, "Member 'FModifierDamageEffect::EmitterIDs' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, EmitterExecType) == 0x000068, "Member 'FModifierDamageEffect::EmitterExecType' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, bUseEmitterSearchTarget) == 0x000069, "Member 'FModifierDamageEffect::bUseEmitterSearchTarget' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, DelaySettlementDamageValue) == 0x000070, "Member 'FModifierDamageEffect::DelaySettlementDamageValue' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, CDTime) == 0x000080, "Member 'FModifierDamageEffect::CDTime' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, bTargetTimingAlone) == 0x000084, "Member 'FModifierDamageEffect::bTargetTimingAlone' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, ExecuteTime) == 0x000088, "Member 'FModifierDamageEffect::ExecuteTime' has a wrong offset!");
static_assert(offsetof(FModifierDamageEffect, ExecuteTimingAlone) == 0x0000D8, "Member 'FModifierDamageEffect::ExecuteTimingAlone' has a wrong offset!");

// ScriptStruct Game.AbnormalStateApplyInfo
// 0x0018 (0x0018 - 0x0000)
struct FAbnormalStateApplyInfo final
{
public:
	float                                         AbnormalApplyChance;                               // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalState                                AbnormalState;                                     // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParamInfo>                     AbnormalInfos;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnormalStateApplyInfo) == 0x000008, "Wrong alignment on FAbnormalStateApplyInfo");
static_assert(sizeof(FAbnormalStateApplyInfo) == 0x000018, "Wrong size on FAbnormalStateApplyInfo");
static_assert(offsetof(FAbnormalStateApplyInfo, AbnormalApplyChance) == 0x000000, "Member 'FAbnormalStateApplyInfo::AbnormalApplyChance' has a wrong offset!");
static_assert(offsetof(FAbnormalStateApplyInfo, AbnormalState) == 0x000004, "Member 'FAbnormalStateApplyInfo::AbnormalState' has a wrong offset!");
static_assert(offsetof(FAbnormalStateApplyInfo, AbnormalInfos) == 0x000008, "Member 'FAbnormalStateApplyInfo::AbnormalInfos' has a wrong offset!");

// ScriptStruct Game.ModifierEffectInfo
// 0x0178 (0x0178 - 0x0000)
struct FModifierEffectInfo
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectRange;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECampRelation>                         EffectCampRelations;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 CustomEffectActorClassesPath;                      // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FModifierEffectParticleInfo>    ParticleInfo;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 SoundEvent;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundSocketName;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FloatValue;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloatSocket;                                       // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeChangeValueGrowup>    AtttibuteChange;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNotifyAttackOnApply;                              // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPropertyChangeValueGrowup>     PropertyChangeGrowup;                              // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FModifierDamageEffect>          DamageEffects;                                     // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EDamageEffectFloatType                        DamageEffectFloatType;                             // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbnormalStateApplyInfo>        AbnormalApplyInfos;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CameraShakePath;                                   // 0x00C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShakeEffectSelfOnly;                              // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeMaxValidDistance;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShakeAttenuation;                                 // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 EmitterID;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EModifierExecEmitterType                      EmitterExecType;                                   // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AddModifiers;                                      // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveModifiers;                                   // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RemoveModifierTags;                                // 0x0120(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BuffPath;                                          // 0x0140(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     BuffParams;                                        // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                Magics;                                            // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierEffectInfo) == 0x000008, "Wrong alignment on FModifierEffectInfo");
static_assert(sizeof(FModifierEffectInfo) == 0x000178, "Wrong size on FModifierEffectInfo");
static_assert(offsetof(FModifierEffectInfo, EffectRange) == 0x000008, "Member 'FModifierEffectInfo::EffectRange' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, EffectCampRelations) == 0x000010, "Member 'FModifierEffectInfo::EffectCampRelations' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, CustomEffectActorClassesPath) == 0x000020, "Member 'FModifierEffectInfo::CustomEffectActorClassesPath' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, ParticleInfo) == 0x000030, "Member 'FModifierEffectInfo::ParticleInfo' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, SoundEvent) == 0x000040, "Member 'FModifierEffectInfo::SoundEvent' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, SoundSocketName) == 0x000050, "Member 'FModifierEffectInfo::SoundSocketName' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, FloatValue) == 0x000058, "Member 'FModifierEffectInfo::FloatValue' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, FloatSocket) == 0x000068, "Member 'FModifierEffectInfo::FloatSocket' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, AtttibuteChange) == 0x000070, "Member 'FModifierEffectInfo::AtttibuteChange' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, bNotifyAttackOnApply) == 0x000080, "Member 'FModifierEffectInfo::bNotifyAttackOnApply' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, PropertyChangeGrowup) == 0x000088, "Member 'FModifierEffectInfo::PropertyChangeGrowup' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, DamageEffects) == 0x000098, "Member 'FModifierEffectInfo::DamageEffects' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, DamageEffectFloatType) == 0x0000A8, "Member 'FModifierEffectInfo::DamageEffectFloatType' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, AbnormalApplyInfos) == 0x0000B0, "Member 'FModifierEffectInfo::AbnormalApplyInfos' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, CameraShakePath) == 0x0000C0, "Member 'FModifierEffectInfo::CameraShakePath' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, bShakeEffectSelfOnly) == 0x0000D8, "Member 'FModifierEffectInfo::bShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, ShakeMaxValidDistance) == 0x0000DC, "Member 'FModifierEffectInfo::ShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, bShakeAttenuation) == 0x0000E0, "Member 'FModifierEffectInfo::bShakeAttenuation' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, EmitterID) == 0x0000E8, "Member 'FModifierEffectInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, EmitterExecType) == 0x0000F8, "Member 'FModifierEffectInfo::EmitterExecType' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, AddModifiers) == 0x000100, "Member 'FModifierEffectInfo::AddModifiers' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, RemoveModifiers) == 0x000110, "Member 'FModifierEffectInfo::RemoveModifiers' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, RemoveModifierTags) == 0x000120, "Member 'FModifierEffectInfo::RemoveModifierTags' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, BuffPath) == 0x000140, "Member 'FModifierEffectInfo::BuffPath' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, BuffParams) == 0x000158, "Member 'FModifierEffectInfo::BuffParams' has a wrong offset!");
static_assert(offsetof(FModifierEffectInfo, Magics) == 0x000168, "Member 'FModifierEffectInfo::Magics' has a wrong offset!");

// ScriptStruct Game.ModifierIntervalEffectInfo
// 0x01F8 (0x0370 - 0x0178)
struct FModifierIntervalEffectInfo final : public FModifierEffectInfo
{
public:
	struct FAttributeChangeValueGrowupBase        FalloffShield;                                     // 0x0178(0x01F8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierIntervalEffectInfo) == 0x000008, "Wrong alignment on FModifierIntervalEffectInfo");
static_assert(sizeof(FModifierIntervalEffectInfo) == 0x000370, "Wrong size on FModifierIntervalEffectInfo");
static_assert(offsetof(FModifierIntervalEffectInfo, FalloffShield) == 0x000178, "Member 'FModifierIntervalEffectInfo::FalloffShield' has a wrong offset!");

// ScriptStruct Game.PSExpressionElementConfig
// 0x0188 (0x0190 - 0x0008)
struct FPSExpressionElementConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpressionAnimID;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpressionAnimName;                                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ExpressionAnim;                                    // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecilExpress;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequence>           SpecilExpress;                                     // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlinkEyeLeft;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlinkEyeRight;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            BlinkEyeMontage;                                   // 0x0098(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkEyeLeft;                                     // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkEyeRight;                                    // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeBothAnim;                                  // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeRightAnim;                                 // 0x00F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeLeftAnim;                                  // 0x0118(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x0140(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSExpressionElementConfig) == 0x000008, "Wrong alignment on FPSExpressionElementConfig");
static_assert(sizeof(FPSExpressionElementConfig) == 0x000190, "Wrong size on FPSExpressionElementConfig");
static_assert(offsetof(FPSExpressionElementConfig, ID) == 0x000008, "Member 'FPSExpressionElementConfig::ID' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, ExpressionAnimID) == 0x00000C, "Member 'FPSExpressionElementConfig::ExpressionAnimID' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, ExpressionAnimName) == 0x000010, "Member 'FPSExpressionElementConfig::ExpressionAnimName' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, ExpressionAnim) == 0x000020, "Member 'FPSExpressionElementConfig::ExpressionAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, bSpecilExpress) == 0x000048, "Member 'FPSExpressionElementConfig::bSpecilExpress' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, SpecilExpress) == 0x000050, "Member 'FPSExpressionElementConfig::SpecilExpress' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeLeft) == 0x000078, "Member 'FPSExpressionElementConfig::BlinkEyeLeft' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeRight) == 0x000088, "Member 'FPSExpressionElementConfig::BlinkEyeRight' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeMontage) == 0x000098, "Member 'FPSExpressionElementConfig::BlinkEyeMontage' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, bBlinkEyeLeft) == 0x0000C0, "Member 'FPSExpressionElementConfig::bBlinkEyeLeft' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, bBlinkEyeRight) == 0x0000C1, "Member 'FPSExpressionElementConfig::bBlinkEyeRight' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeBothAnim) == 0x0000C8, "Member 'FPSExpressionElementConfig::BlinkEyeBothAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeRightAnim) == 0x0000F0, "Member 'FPSExpressionElementConfig::BlinkEyeRightAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, BlinkEyeLeftAnim) == 0x000118, "Member 'FPSExpressionElementConfig::BlinkEyeLeftAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig, OtherParams) == 0x000140, "Member 'FPSExpressionElementConfig::OtherParams' has a wrong offset!");

// ScriptStruct Game.WeaponPreviewModelAttachFix
// 0x0030 (0x0030 - 0x0000)
struct FWeaponPreviewModelAttachFix final
{
public:
	EUIWidgetAnimType                             WidgetAnimType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponType;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponPreviewModelAttachFix) == 0x000008, "Wrong alignment on FWeaponPreviewModelAttachFix");
static_assert(sizeof(FWeaponPreviewModelAttachFix) == 0x000030, "Wrong size on FWeaponPreviewModelAttachFix");
static_assert(offsetof(FWeaponPreviewModelAttachFix, WidgetAnimType) == 0x000000, "Member 'FWeaponPreviewModelAttachFix::WidgetAnimType' has a wrong offset!");
static_assert(offsetof(FWeaponPreviewModelAttachFix, WeaponType) == 0x000008, "Member 'FWeaponPreviewModelAttachFix::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponPreviewModelAttachFix, Offset) == 0x000018, "Member 'FWeaponPreviewModelAttachFix::Offset' has a wrong offset!");
static_assert(offsetof(FWeaponPreviewModelAttachFix, Rotator) == 0x000024, "Member 'FWeaponPreviewModelAttachFix::Rotator' has a wrong offset!");

// ScriptStruct Game.SkinMaterialOverrideInfo
// 0x0030 (0x0030 - 0x0000)
struct FSkinMaterialOverrideInfo final
{
public:
	uint8                                         MaterialIndex;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      MaterialRef;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinMaterialOverrideInfo) == 0x000008, "Wrong alignment on FSkinMaterialOverrideInfo");
static_assert(sizeof(FSkinMaterialOverrideInfo) == 0x000030, "Wrong size on FSkinMaterialOverrideInfo");
static_assert(offsetof(FSkinMaterialOverrideInfo, MaterialIndex) == 0x000000, "Member 'FSkinMaterialOverrideInfo::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FSkinMaterialOverrideInfo, MaterialRef) == 0x000008, "Member 'FSkinMaterialOverrideInfo::MaterialRef' has a wrong offset!");

// ScriptStruct Game.PreviewModelOverrideData
// 0x00C8 (0x00C8 - 0x0000)
struct FPreviewModelOverrideData final
{
public:
	struct FSoftObjectPath                        PreviewMeshOverride_Body;                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreviewMeshOverride_Body_AllAges;                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewAnimClassOverride_Body;                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinMaterialOverrideInfo>      CharacterSkinMeshMaterialOverrideContainer_Body;   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinMaterialOverrideInfo>      CharacterSkinMeshMaterialOverrideContainer_Body_AllAges; // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreviewMeshOverride_Head;                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewAnimClassOverride_Head;                     // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinMaterialOverrideInfo>      CharacterSkinMeshMaterialOverrideContainer_Head;   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 PreviewModelGirlName_Suffix;                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreviewModelGirlName_Original;                     // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewModelOverrideData) == 0x000008, "Wrong alignment on FPreviewModelOverrideData");
static_assert(sizeof(FPreviewModelOverrideData) == 0x0000C8, "Wrong size on FPreviewModelOverrideData");
static_assert(offsetof(FPreviewModelOverrideData, PreviewMeshOverride_Body) == 0x000000, "Member 'FPreviewModelOverrideData::PreviewMeshOverride_Body' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewMeshOverride_Body_AllAges) == 0x000018, "Member 'FPreviewModelOverrideData::PreviewMeshOverride_Body_AllAges' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewAnimClassOverride_Body) == 0x000030, "Member 'FPreviewModelOverrideData::PreviewAnimClassOverride_Body' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, CharacterSkinMeshMaterialOverrideContainer_Body) == 0x000048, "Member 'FPreviewModelOverrideData::CharacterSkinMeshMaterialOverrideContainer_Body' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, CharacterSkinMeshMaterialOverrideContainer_Body_AllAges) == 0x000058, "Member 'FPreviewModelOverrideData::CharacterSkinMeshMaterialOverrideContainer_Body_AllAges' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewMeshOverride_Head) == 0x000068, "Member 'FPreviewModelOverrideData::PreviewMeshOverride_Head' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewAnimClassOverride_Head) == 0x000080, "Member 'FPreviewModelOverrideData::PreviewAnimClassOverride_Head' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, CharacterSkinMeshMaterialOverrideContainer_Head) == 0x000098, "Member 'FPreviewModelOverrideData::CharacterSkinMeshMaterialOverrideContainer_Head' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewModelGirlName_Suffix) == 0x0000A8, "Member 'FPreviewModelOverrideData::PreviewModelGirlName_Suffix' has a wrong offset!");
static_assert(offsetof(FPreviewModelOverrideData, PreviewModelGirlName_Original) == 0x0000B8, "Member 'FPreviewModelOverrideData::PreviewModelGirlName_Original' has a wrong offset!");

// ScriptStruct Game.AccessoryCompletenessItemData
// 0x0040 (0x0040 - 0x0000)
struct FAccessoryCompletenessItemData final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           AccessorySkinMesh;                                 // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AccessoryAnimClass;                                // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryCompletenessItemData) == 0x000008, "Wrong alignment on FAccessoryCompletenessItemData");
static_assert(sizeof(FAccessoryCompletenessItemData) == 0x000040, "Wrong size on FAccessoryCompletenessItemData");
static_assert(offsetof(FAccessoryCompletenessItemData, AccessorySkinMesh) == 0x000000, "Member 'FAccessoryCompletenessItemData::AccessorySkinMesh' has a wrong offset!");
static_assert(offsetof(FAccessoryCompletenessItemData, AccessoryAnimClass) == 0x000028, "Member 'FAccessoryCompletenessItemData::AccessoryAnimClass' has a wrong offset!");

// ScriptStruct Game.AccessoryCompletenessInfo
// 0x0050 (0x0050 - 0x0000)
struct FAccessoryCompletenessInfo final
{
public:
	TMap<ECompletenessType, struct FAccessoryCompletenessItemData> AccessoryCompletenessRefContainer;                 // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryCompletenessInfo) == 0x000008, "Wrong alignment on FAccessoryCompletenessInfo");
static_assert(sizeof(FAccessoryCompletenessInfo) == 0x000050, "Wrong size on FAccessoryCompletenessInfo");
static_assert(offsetof(FAccessoryCompletenessInfo, AccessoryCompletenessRefContainer) == 0x000000, "Member 'FAccessoryCompletenessInfo::AccessoryCompletenessRefContainer' has a wrong offset!");

// ScriptStruct Game.AccessorySkinInfo
// 0x0050 (0x0050 - 0x0000)
struct FAccessorySkinInfo final
{
public:
	TMap<int32, struct FAccessoryCompletenessInfo> AccessoryCompletenessContainer;                    // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessorySkinInfo) == 0x000008, "Wrong alignment on FAccessorySkinInfo");
static_assert(sizeof(FAccessorySkinInfo) == 0x000050, "Wrong size on FAccessorySkinInfo");
static_assert(offsetof(FAccessorySkinInfo, AccessoryCompletenessContainer) == 0x000000, "Member 'FAccessorySkinInfo::AccessoryCompletenessContainer' has a wrong offset!");

// ScriptStruct Game.AccessoryVisibleData
// 0x0068 (0x0068 - 0x0000)
struct FAccessoryVisibleData final
{
public:
	struct FSoftClassPath                         Accessory;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccessorySkinInfo                     AccessorySkinInfo;                                 // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryVisibleData) == 0x000008, "Wrong alignment on FAccessoryVisibleData");
static_assert(sizeof(FAccessoryVisibleData) == 0x000068, "Wrong size on FAccessoryVisibleData");
static_assert(offsetof(FAccessoryVisibleData, Accessory) == 0x000000, "Member 'FAccessoryVisibleData::Accessory' has a wrong offset!");
static_assert(offsetof(FAccessoryVisibleData, AccessorySkinInfo) == 0x000018, "Member 'FAccessoryVisibleData::AccessorySkinInfo' has a wrong offset!");

// ScriptStruct Game.CharacterWeaponScale
// 0x0020 (0x0020 - 0x0000)
struct FCharacterWeaponScale final
{
public:
	class FString                                 WeaponModel;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponScale;                                       // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterWeaponScale) == 0x000008, "Wrong alignment on FCharacterWeaponScale");
static_assert(sizeof(FCharacterWeaponScale) == 0x000020, "Wrong size on FCharacterWeaponScale");
static_assert(offsetof(FCharacterWeaponScale, WeaponModel) == 0x000000, "Member 'FCharacterWeaponScale::WeaponModel' has a wrong offset!");
static_assert(offsetof(FCharacterWeaponScale, WeaponScale) == 0x000010, "Member 'FCharacterWeaponScale::WeaponScale' has a wrong offset!");

// ScriptStruct Game.MainBodyCompletenessItemData
// 0x0050 (0x0050 - 0x0000)
struct FMainBodyCompletenessItemData final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MainBodySkinMesh;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainBodyAnimClass;                                 // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimNameSuffix;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainBodyCompletenessItemData) == 0x000008, "Wrong alignment on FMainBodyCompletenessItemData");
static_assert(sizeof(FMainBodyCompletenessItemData) == 0x000050, "Wrong size on FMainBodyCompletenessItemData");
static_assert(offsetof(FMainBodyCompletenessItemData, MainBodySkinMesh) == 0x000000, "Member 'FMainBodyCompletenessItemData::MainBodySkinMesh' has a wrong offset!");
static_assert(offsetof(FMainBodyCompletenessItemData, MainBodyAnimClass) == 0x000028, "Member 'FMainBodyCompletenessItemData::MainBodyAnimClass' has a wrong offset!");
static_assert(offsetof(FMainBodyCompletenessItemData, AnimNameSuffix) == 0x000040, "Member 'FMainBodyCompletenessItemData::AnimNameSuffix' has a wrong offset!");

// ScriptStruct Game.MainBodyCompletenessInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FMainBodyCompletenessInfo final
{
public:
	TMap<ECompletenessType, struct FMainBodyCompletenessItemData> MainBodyCompletenessRefContainer;                  // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ECompletenessType, struct FMainBodyCompletenessItemData> MainBodyCompletenessRefContainer_AllAges;          // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainBodyCompletenessInfo) == 0x000008, "Wrong alignment on FMainBodyCompletenessInfo");
static_assert(sizeof(FMainBodyCompletenessInfo) == 0x0000A0, "Wrong size on FMainBodyCompletenessInfo");
static_assert(offsetof(FMainBodyCompletenessInfo, MainBodyCompletenessRefContainer) == 0x000000, "Member 'FMainBodyCompletenessInfo::MainBodyCompletenessRefContainer' has a wrong offset!");
static_assert(offsetof(FMainBodyCompletenessInfo, MainBodyCompletenessRefContainer_AllAges) == 0x000050, "Member 'FMainBodyCompletenessInfo::MainBodyCompletenessRefContainer_AllAges' has a wrong offset!");

// ScriptStruct Game.MainBodySkinInfo
// 0x0050 (0x0050 - 0x0000)
struct FMainBodySkinInfo final
{
public:
	TMap<int32, struct FMainBodyCompletenessInfo> MainBodyCompletenessContainer;                     // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainBodySkinInfo) == 0x000008, "Wrong alignment on FMainBodySkinInfo");
static_assert(sizeof(FMainBodySkinInfo) == 0x000050, "Wrong size on FMainBodySkinInfo");
static_assert(offsetof(FMainBodySkinInfo, MainBodyCompletenessContainer) == 0x000000, "Member 'FMainBodySkinInfo::MainBodyCompletenessContainer' has a wrong offset!");

// ScriptStruct Game.PreviewModelAccessoryVisibleData
// 0x0078 (0x0078 - 0x0000)
struct FPreviewModelAccessoryVisibleData final
{
public:
	struct FSoftClassPath                         PreviewAccessory;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     HiddenWidgetContainer;                             // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAccessorySkinInfo                     AccessorySkinInfo;                                 // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewModelAccessoryVisibleData) == 0x000008, "Wrong alignment on FPreviewModelAccessoryVisibleData");
static_assert(sizeof(FPreviewModelAccessoryVisibleData) == 0x000078, "Wrong size on FPreviewModelAccessoryVisibleData");
static_assert(offsetof(FPreviewModelAccessoryVisibleData, PreviewAccessory) == 0x000000, "Member 'FPreviewModelAccessoryVisibleData::PreviewAccessory' has a wrong offset!");
static_assert(offsetof(FPreviewModelAccessoryVisibleData, HiddenWidgetContainer) == 0x000018, "Member 'FPreviewModelAccessoryVisibleData::HiddenWidgetContainer' has a wrong offset!");
static_assert(offsetof(FPreviewModelAccessoryVisibleData, AccessorySkinInfo) == 0x000028, "Member 'FPreviewModelAccessoryVisibleData::AccessorySkinInfo' has a wrong offset!");

// ScriptStruct Game.PreviewCharacterData
// 0x0034 (0x0034 - 0x0000)
struct FPreviewCharacterData final
{
public:
	struct FRotator                               LightDirection;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIWidgetAnimType                             UIWidgetAnimType;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWeapon;                                       // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewCharacterData) == 0x000004, "Wrong alignment on FPreviewCharacterData");
static_assert(sizeof(FPreviewCharacterData) == 0x000034, "Wrong size on FPreviewCharacterData");
static_assert(offsetof(FPreviewCharacterData, LightDirection) == 0x000000, "Member 'FPreviewCharacterData::LightDirection' has a wrong offset!");
static_assert(offsetof(FPreviewCharacterData, Location) == 0x00000C, "Member 'FPreviewCharacterData::Location' has a wrong offset!");
static_assert(offsetof(FPreviewCharacterData, Rotation) == 0x000018, "Member 'FPreviewCharacterData::Rotation' has a wrong offset!");
static_assert(offsetof(FPreviewCharacterData, Scale) == 0x000024, "Member 'FPreviewCharacterData::Scale' has a wrong offset!");
static_assert(offsetof(FPreviewCharacterData, UIWidgetAnimType) == 0x000030, "Member 'FPreviewCharacterData::UIWidgetAnimType' has a wrong offset!");
static_assert(offsetof(FPreviewCharacterData, bHideWeapon) == 0x000031, "Member 'FPreviewCharacterData::bHideWeapon' has a wrong offset!");

// ScriptStruct Game.AccessoriesInfo
// 0x0028 (0x0028 - 0x0000)
struct FAccessoriesInfo final
{
public:
	struct FSoftObjectPath                        Accessorie;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SokectName;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoriesInfo) == 0x000008, "Wrong alignment on FAccessoriesInfo");
static_assert(sizeof(FAccessoriesInfo) == 0x000028, "Wrong size on FAccessoriesInfo");
static_assert(offsetof(FAccessoriesInfo, Accessorie) == 0x000000, "Member 'FAccessoriesInfo::Accessorie' has a wrong offset!");
static_assert(offsetof(FAccessoriesInfo, SokectName) == 0x000018, "Member 'FAccessoriesInfo::SokectName' has a wrong offset!");

// ScriptStruct Game.CastModifierCondition
// 0x00D0 (0x00D0 - 0x0000)
struct FCastModifierCondition final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverlaidNum;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverlaidNumID;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierAllocationType                       AllocationType;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            Rate;                                              // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FConditionSetting>              Condition;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         InverseModifierID;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            RandModifierID;                                    // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bMarkRunning;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCastModifierCondition) == 0x000008, "Wrong alignment on FCastModifierCondition");
static_assert(sizeof(FCastModifierCondition) == 0x0000D0, "Wrong size on FCastModifierCondition");
static_assert(offsetof(FCastModifierCondition, ID) == 0x000000, "Member 'FCastModifierCondition::ID' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, OverlaidNum) == 0x000004, "Member 'FCastModifierCondition::OverlaidNum' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, OverlaidNumID) == 0x000008, "Member 'FCastModifierCondition::OverlaidNumID' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, AllocationType) == 0x00000C, "Member 'FCastModifierCondition::AllocationType' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, Rate) == 0x000010, "Member 'FCastModifierCondition::Rate' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, Condition) == 0x000060, "Member 'FCastModifierCondition::Condition' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, InverseModifierID) == 0x000070, "Member 'FCastModifierCondition::InverseModifierID' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, RandModifierID) == 0x000078, "Member 'FCastModifierCondition::RandModifierID' has a wrong offset!");
static_assert(offsetof(FCastModifierCondition, bMarkRunning) == 0x0000C8, "Member 'FCastModifierCondition::bMarkRunning' has a wrong offset!");

// ScriptStruct Game.TriggerOnPressedSkillEnableInfo
// 0x0008 (0x0008 - 0x0000)
struct FTriggerOnPressedSkillEnableInfo final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefineLongPressedTime;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerOnPressedSkillEnableInfo) == 0x000004, "Wrong alignment on FTriggerOnPressedSkillEnableInfo");
static_assert(sizeof(FTriggerOnPressedSkillEnableInfo) == 0x000008, "Wrong size on FTriggerOnPressedSkillEnableInfo");
static_assert(offsetof(FTriggerOnPressedSkillEnableInfo, bEnable) == 0x000000, "Member 'FTriggerOnPressedSkillEnableInfo::bEnable' has a wrong offset!");
static_assert(offsetof(FTriggerOnPressedSkillEnableInfo, DefineLongPressedTime) == 0x000004, "Member 'FTriggerOnPressedSkillEnableInfo::DefineLongPressedTime' has a wrong offset!");

// ScriptStruct Game.HitLag
// 0x0014 (0x0014 - 0x0000)
struct FHitLag final
{
public:
	float                                         MaxHitLag;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagRecoverDelay;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagRecoverInterval;                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagInvalidTimeAfterTrigger;                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagRecoverPercent;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitLag) == 0x000004, "Wrong alignment on FHitLag");
static_assert(sizeof(FHitLag) == 0x000014, "Wrong size on FHitLag");
static_assert(offsetof(FHitLag, MaxHitLag) == 0x000000, "Member 'FHitLag::MaxHitLag' has a wrong offset!");
static_assert(offsetof(FHitLag, HitLagRecoverDelay) == 0x000004, "Member 'FHitLag::HitLagRecoverDelay' has a wrong offset!");
static_assert(offsetof(FHitLag, HitLagRecoverInterval) == 0x000008, "Member 'FHitLag::HitLagRecoverInterval' has a wrong offset!");
static_assert(offsetof(FHitLag, HitLagInvalidTimeAfterTrigger) == 0x00000C, "Member 'FHitLag::HitLagInvalidTimeAfterTrigger' has a wrong offset!");
static_assert(offsetof(FHitLag, HitLagRecoverPercent) == 0x000010, "Member 'FHitLag::HitLagRecoverPercent' has a wrong offset!");

// ScriptStruct Game.BunkerCameraInfo
// 0x003C (0x003C - 0x0000)
struct FBunkerCameraInfo final
{
public:
	struct FVector                                LeftSocketOffset;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterMinSocketOffset;                             // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterMaxSocketOffset;                             // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightSocketOffset;                                 // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InLerpSpeed;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutLerpSpeed;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBunkerCameraInfo) == 0x000004, "Wrong alignment on FBunkerCameraInfo");
static_assert(sizeof(FBunkerCameraInfo) == 0x00003C, "Wrong size on FBunkerCameraInfo");
static_assert(offsetof(FBunkerCameraInfo, LeftSocketOffset) == 0x000000, "Member 'FBunkerCameraInfo::LeftSocketOffset' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, CenterMinSocketOffset) == 0x00000C, "Member 'FBunkerCameraInfo::CenterMinSocketOffset' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, CenterMaxSocketOffset) == 0x000018, "Member 'FBunkerCameraInfo::CenterMaxSocketOffset' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, RightSocketOffset) == 0x000024, "Member 'FBunkerCameraInfo::RightSocketOffset' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, FOV) == 0x000030, "Member 'FBunkerCameraInfo::FOV' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, InLerpSpeed) == 0x000034, "Member 'FBunkerCameraInfo::InLerpSpeed' has a wrong offset!");
static_assert(offsetof(FBunkerCameraInfo, OutLerpSpeed) == 0x000038, "Member 'FBunkerCameraInfo::OutLerpSpeed' has a wrong offset!");

// ScriptStruct Game.CameraInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FCameraInfo final
{
public:
	uint8                                         CameraID;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetCameraPosition;                              // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CameraArmLengthCurvePath;                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraArmLength;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CameraFOVCurvePath;                                // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraArmPosition;                                 // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraSocketOffsetCurvePath;                       // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraSocketOffset;                                // 0x0078(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBunkerCameraInfo                      BunkerCameraInfo;                                  // 0x0084(0x003C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraRotatorCurvePath;                            // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCameraOffset;                                // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpSpeed;                                         // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelSkillStopCamera;                            // 0x00E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0xB];                                       // 0x00E5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraInfo) == 0x000008, "Wrong alignment on FCameraInfo");
static_assert(sizeof(FCameraInfo) == 0x0000F0, "Wrong size on FCameraInfo");
static_assert(offsetof(FCameraInfo, CameraID) == 0x000000, "Member 'FCameraInfo::CameraID' has a wrong offset!");
static_assert(offsetof(FCameraInfo, Priority) == 0x000004, "Member 'FCameraInfo::Priority' has a wrong offset!");
static_assert(offsetof(FCameraInfo, TargetCameraPosition) == 0x000008, "Member 'FCameraInfo::TargetCameraPosition' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraArmLengthCurvePath) == 0x000018, "Member 'FCameraInfo::CameraArmLengthCurvePath' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraArmLength) == 0x000030, "Member 'FCameraInfo::CameraArmLength' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraFOVCurvePath) == 0x000038, "Member 'FCameraInfo::CameraFOVCurvePath' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraFOV) == 0x000050, "Member 'FCameraInfo::CameraFOV' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraArmPosition) == 0x000054, "Member 'FCameraInfo::CameraArmPosition' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraSocketOffsetCurvePath) == 0x000060, "Member 'FCameraInfo::CameraSocketOffsetCurvePath' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraSocketOffset) == 0x000078, "Member 'FCameraInfo::CameraSocketOffset' has a wrong offset!");
static_assert(offsetof(FCameraInfo, BunkerCameraInfo) == 0x000084, "Member 'FCameraInfo::BunkerCameraInfo' has a wrong offset!");
static_assert(offsetof(FCameraInfo, CameraRotatorCurvePath) == 0x0000C0, "Member 'FCameraInfo::CameraRotatorCurvePath' has a wrong offset!");
static_assert(offsetof(FCameraInfo, bAllowCameraOffset) == 0x0000D8, "Member 'FCameraInfo::bAllowCameraOffset' has a wrong offset!");
static_assert(offsetof(FCameraInfo, LerpSpeed) == 0x0000DC, "Member 'FCameraInfo::LerpSpeed' has a wrong offset!");
static_assert(offsetof(FCameraInfo, EndTime) == 0x0000E0, "Member 'FCameraInfo::EndTime' has a wrong offset!");
static_assert(offsetof(FCameraInfo, bCancelSkillStopCamera) == 0x0000E4, "Member 'FCameraInfo::bCancelSkillStopCamera' has a wrong offset!");

// ScriptStruct Game.CustomSpeedCurve
// 0x0030 (0x0030 - 0x0000)
struct FCustomSpeedCurve final
{
public:
	struct FSoftObjectPath                        AccelerateSpeedCurvePath;                          // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ReduceSpeedCurvePath;                              // 0x0018(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSpeedCurve) == 0x000008, "Wrong alignment on FCustomSpeedCurve");
static_assert(sizeof(FCustomSpeedCurve) == 0x000030, "Wrong size on FCustomSpeedCurve");
static_assert(offsetof(FCustomSpeedCurve, AccelerateSpeedCurvePath) == 0x000000, "Member 'FCustomSpeedCurve::AccelerateSpeedCurvePath' has a wrong offset!");
static_assert(offsetof(FCustomSpeedCurve, ReduceSpeedCurvePath) == 0x000018, "Member 'FCustomSpeedCurve::ReduceSpeedCurvePath' has a wrong offset!");

// ScriptStruct Game.WeaponRecoilData
// 0x0028 (0x0028 - 0x0000)
struct FWeaponRecoilData final
{
public:
	TSoftObjectPtr<class UCurveSequence_RecoilAnimation> RecoilCurveAsset;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRecoilData) == 0x000008, "Wrong alignment on FWeaponRecoilData");
static_assert(sizeof(FWeaponRecoilData) == 0x000028, "Wrong size on FWeaponRecoilData");
static_assert(offsetof(FWeaponRecoilData, RecoilCurveAsset) == 0x000000, "Member 'FWeaponRecoilData::RecoilCurveAsset' has a wrong offset!");

// ScriptStruct Game.RangedWeaponPreStateData
// 0x0028 (0x0028 - 0x0000)
struct FRangedWeaponPreStateData final
{
public:
	struct FWeaponRecoilData                      RecoilData;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedWeaponPreStateData) == 0x000008, "Wrong alignment on FRangedWeaponPreStateData");
static_assert(sizeof(FRangedWeaponPreStateData) == 0x000028, "Wrong size on FRangedWeaponPreStateData");
static_assert(offsetof(FRangedWeaponPreStateData, RecoilData) == 0x000000, "Member 'FRangedWeaponPreStateData::RecoilData' has a wrong offset!");

// ScriptStruct Game.WeaponRecoilData_Physical
// 0x0028 (0x0028 - 0x0000)
struct FWeaponRecoilData_Physical final
{
public:
	TSoftObjectPtr<class UCurveSequence_PhysicalRecoilAnimation> RecoilCurveAsset;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRecoilData_Physical) == 0x000008, "Wrong alignment on FWeaponRecoilData_Physical");
static_assert(sizeof(FWeaponRecoilData_Physical) == 0x000028, "Wrong size on FWeaponRecoilData_Physical");
static_assert(offsetof(FWeaponRecoilData_Physical, RecoilCurveAsset) == 0x000000, "Member 'FWeaponRecoilData_Physical::RecoilCurveAsset' has a wrong offset!");

// ScriptStruct Game.RangedWeaponPreStateData_Physical
// 0x0028 (0x0028 - 0x0000)
struct FRangedWeaponPreStateData_Physical final
{
public:
	struct FWeaponRecoilData_Physical             RecoilData;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedWeaponPreStateData_Physical) == 0x000008, "Wrong alignment on FRangedWeaponPreStateData_Physical");
static_assert(sizeof(FRangedWeaponPreStateData_Physical) == 0x000028, "Wrong size on FRangedWeaponPreStateData_Physical");
static_assert(offsetof(FRangedWeaponPreStateData_Physical, RecoilData) == 0x000000, "Member 'FRangedWeaponPreStateData_Physical::RecoilData' has a wrong offset!");

// ScriptStruct Game.RangedWeaponPreStateDataGroup_Physical
// 0x0050 (0x0050 - 0x0000)
struct FRangedWeaponPreStateDataGroup_Physical final
{
public:
	TMap<ERangeAttackState, struct FRangedWeaponPreStateData_Physical> RecoilDatas;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedWeaponPreStateDataGroup_Physical) == 0x000008, "Wrong alignment on FRangedWeaponPreStateDataGroup_Physical");
static_assert(sizeof(FRangedWeaponPreStateDataGroup_Physical) == 0x000050, "Wrong size on FRangedWeaponPreStateDataGroup_Physical");
static_assert(offsetof(FRangedWeaponPreStateDataGroup_Physical, RecoilDatas) == 0x000000, "Member 'FRangedWeaponPreStateDataGroup_Physical::RecoilDatas' has a wrong offset!");

// ScriptStruct Game.CharacterAtrributeTemplate
// 0x0B48 (0x0B50 - 0x0008)
struct FCharacterAtrributeTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResNameDec;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialRating;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterName;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Character_WwiseGroupName;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDescribeID;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFightType                                    FightType;                                         // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTemplateId                            DefaultWeaponId;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterWeaponScale>          WeaponScale;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponPreviewModelAttachFix>   WeaponAttachFix;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ECampType                                     Camp;                                              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathTime;                                         // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDivinityType                                 FaithType;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GirlType;                                          // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriangleAttributeType                        TriangleType;                                      // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         CharacterClass;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMainBodySkinInfo                      MainBodySkinInfo;                                  // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAccessoryVisibleData>          AccessoryContainer;                                // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Skeletal;                                          // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewModel;                                      // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EUIWidgetAnimType, struct FSoftClassPath> OverridePreviewModel;                              // 0x0140(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPreviewModelAccessoryVisibleData> OverrideAccessoryContainer;                        // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPreviewModelAccessoryVisibleData> PreviewAccessoryContainer;                         // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SpinResKey;                                        // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPreviewCharacterData> PreviewData;                                       // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EUIWidgetAnimType, struct FPreviewModelOverrideData> PreviewModelOverrideData;                          // 0x0210(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         UICameraID;                                        // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MontagePath;                                       // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccessoriesInfo>               AccessoriesSkeletal;                               // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Live2D;                                            // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcesID;                                       // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrowAttributeID;                                   // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeed;                                         // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfBunkerSpeed;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullBunkerSpeed;                                   // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushSpeed;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoRushTime;                                      // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushCostFightPower;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseMoveSpeedCoefficient;                         // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimMoveSpeedCoefficient;                           // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkMoveSpeedCoefficient;                          // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              ShieldSurfaceType;                                 // 0x02C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ShowSkills;                                        // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SkillTagName;                                      // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FireSkill;                                         // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AimSkill;                                          // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllBulletHitModifierId;                            // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCastModifierCondition>         FireHitModifiers;                                  // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NormalSkillID1;                                    // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NormalSkillID2;                                    // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 QTESkillIDs;                                       // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SupSkillID;                                        // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveSkills;                                     // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDodgeSkillsUseCondition;                          // 0x0378(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DodgeSkills;                                       // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SpecialDodgeSkills;                                // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SlideSkills;                                       // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 HookSkills;                                        // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CrossSkills;                                       // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BunkerInteractSkills;                              // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BunkerSwitchInteractSkills;                        // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SkillEndBackLeftBunkerID;                          // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillEndBackRightBunkerID;                         // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReplaceDodgeSkills;                                // 0x03F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReloadSkill;                                       // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RushSkill;                                         // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SwitchEnterSkill;                                  // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwitchLeaveSkill;                                  // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETriggerOnPressedSkillType, struct FTriggerOnPressedSkillEnableInfo> TriggerOnPressedSkillInfoMap;                      // 0x0430(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveModifierID;                                 // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillFixIDx;                                       // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PublicSkillCD;                                     // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         FightUISpecialData;                                // 0x04A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 SpecialAttributes;                                 // 0x04C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Hardness;                                          // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAllowedForbidAbnormalState>           ForbiddenAbnormal;                                 // 0x04D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EHitState>                             HitStateResistance;                                // 0x04E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLieDown;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitLag                                MaxHitLag;                                         // 0x04FC(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraInfo                            NormalCameraInfo;                                  // 0x0510(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCameraInfo                            FireCameraInfo;                                    // 0x0600(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCameraInfo                            AimCameraInfo;                                     // 0x06F0(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCameraInfo                            RushCameraInfo;                                    // 0x07E0(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RushToNormalSpeed;                                 // 0x08D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMin;                                      // 0x08D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x08D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchedEyeHeight;                                 // 0x08DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseEyeHeight;                                     // 0x08E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E4[0x4];                                      // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomSpeedCurve                      NormalCustomSpeedCurve;                            // 0x08E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCustomSpeedCurve                      FireCustomSpeedCurve;                              // 0x0918(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BaseRotationSpeed;                                 // 0x0948(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRotationRatio;                                 // 0x094C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpAirControl;                                    // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultAirControl;                                 // 0x0954(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRotationSpeed;                                // 0x0958(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleAimRotationSpeed;                             // 0x095C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x0960(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerRotationRatio;                               // 0x0964(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScatterRatio;                                   // 0x0968(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootAddScatterRatio;                              // 0x096C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverScatterSpeedRatio;                          // 0x0970(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_974[0x4];                                      // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMassPointType, struct FMassPointSetup>  MassPointSetups;                                   // 0x0978(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUseRecoilDirection;                               // 0x09C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C9[0x3];                                      // 0x09C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecoilActivateRatio_Head;                          // 0x09CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ERangeAttackState, struct FRangedWeaponPreStateData> PreStateRecoilData;                                // 0x09D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         RecoilActivateRatio;                               // 0x0A20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A24[0x4];                                      // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERecoilCurveDataType, struct FRangedWeaponPreStateDataGroup_Physical> PreStatePhysicalRecoilData;                        // 0x0A28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PhysicalRecoilActivateRatio_Hair;                  // 0x0A78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalRecoilActivateRatio_Cloth;                 // 0x0A7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalRecoilActivateRatio_Hat;                   // 0x0A80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A84[0x4];                                      // 0x0A84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERangeAttackState, TSoftObjectPtr<class UHitReactData>> StateHitReactionData;                              // 0x0A88(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHitReactPhysicalData>   HitPhysData;                                       // 0x0AD8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAbnormalReactData>      AbnormalReactData;                                 // 0x0B00(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAttributeAbnormalReactData> AttributeAbnormalReactData;                        // 0x0B28(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAtrributeTemplate) == 0x000008, "Wrong alignment on FCharacterAtrributeTemplate");
static_assert(sizeof(FCharacterAtrributeTemplate) == 0x000B50, "Wrong size on FCharacterAtrributeTemplate");
static_assert(offsetof(FCharacterAtrributeTemplate, ID) == 0x000008, "Member 'FCharacterAtrributeTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ResNameDec) == 0x000010, "Member 'FCharacterAtrributeTemplate::ResNameDec' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, InitialRating) == 0x000020, "Member 'FCharacterAtrributeTemplate::InitialRating' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, CharacterName) == 0x000028, "Member 'FCharacterAtrributeTemplate::CharacterName' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, Character_WwiseGroupName) == 0x000038, "Member 'FCharacterAtrributeTemplate::Character_WwiseGroupName' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ItemDescribeID) == 0x000048, "Member 'FCharacterAtrributeTemplate::ItemDescribeID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FightType) == 0x00004C, "Member 'FCharacterAtrributeTemplate::FightType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, WeaponType) == 0x00004D, "Member 'FCharacterAtrributeTemplate::WeaponType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, DefaultWeaponId) == 0x000050, "Member 'FCharacterAtrributeTemplate::DefaultWeaponId' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, WeaponScale) == 0x000060, "Member 'FCharacterAtrributeTemplate::WeaponScale' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, WeaponAttachFix) == 0x000070, "Member 'FCharacterAtrributeTemplate::WeaponAttachFix' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, Camp) == 0x000080, "Member 'FCharacterAtrributeTemplate::Camp' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, DeathTime) == 0x000084, "Member 'FCharacterAtrributeTemplate::DeathTime' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FaithType) == 0x000088, "Member 'FCharacterAtrributeTemplate::FaithType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, GirlType) == 0x00008C, "Member 'FCharacterAtrributeTemplate::GirlType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, TriangleType) == 0x000094, "Member 'FCharacterAtrributeTemplate::TriangleType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, CharacterClass) == 0x000098, "Member 'FCharacterAtrributeTemplate::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, MainBodySkinInfo) == 0x0000B0, "Member 'FCharacterAtrributeTemplate::MainBodySkinInfo' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AccessoryContainer) == 0x000100, "Member 'FCharacterAtrributeTemplate::AccessoryContainer' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, Skeletal) == 0x000110, "Member 'FCharacterAtrributeTemplate::Skeletal' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreviewModel) == 0x000128, "Member 'FCharacterAtrributeTemplate::PreviewModel' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, OverridePreviewModel) == 0x000140, "Member 'FCharacterAtrributeTemplate::OverridePreviewModel' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, OverrideAccessoryContainer) == 0x000190, "Member 'FCharacterAtrributeTemplate::OverrideAccessoryContainer' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreviewAccessoryContainer) == 0x0001A0, "Member 'FCharacterAtrributeTemplate::PreviewAccessoryContainer' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SpinResKey) == 0x0001B0, "Member 'FCharacterAtrributeTemplate::SpinResKey' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreviewData) == 0x0001C0, "Member 'FCharacterAtrributeTemplate::PreviewData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreviewModelOverrideData) == 0x000210, "Member 'FCharacterAtrributeTemplate::PreviewModelOverrideData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, UICameraID) == 0x000260, "Member 'FCharacterAtrributeTemplate::UICameraID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, MontagePath) == 0x000268, "Member 'FCharacterAtrributeTemplate::MontagePath' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AccessoriesSkeletal) == 0x000280, "Member 'FCharacterAtrributeTemplate::AccessoriesSkeletal' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, Live2D) == 0x000290, "Member 'FCharacterAtrributeTemplate::Live2D' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ResourcesID) == 0x000294, "Member 'FCharacterAtrributeTemplate::ResourcesID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, GrowAttributeID) == 0x000298, "Member 'FCharacterAtrributeTemplate::GrowAttributeID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, WalkSpeed) == 0x00029C, "Member 'FCharacterAtrributeTemplate::WalkSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, HalfBunkerSpeed) == 0x0002A0, "Member 'FCharacterAtrributeTemplate::HalfBunkerSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FullBunkerSpeed) == 0x0002A4, "Member 'FCharacterAtrributeTemplate::FullBunkerSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RushSpeed) == 0x0002A8, "Member 'FCharacterAtrributeTemplate::RushSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AutoRushTime) == 0x0002AC, "Member 'FCharacterAtrributeTemplate::AutoRushTime' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RushCostFightPower) == 0x0002B0, "Member 'FCharacterAtrributeTemplate::RushCostFightPower' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RaiseMoveSpeedCoefficient) == 0x0002B4, "Member 'FCharacterAtrributeTemplate::RaiseMoveSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AimMoveSpeedCoefficient) == 0x0002B8, "Member 'FCharacterAtrributeTemplate::AimMoveSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, WalkMoveSpeedCoefficient) == 0x0002BC, "Member 'FCharacterAtrributeTemplate::WalkMoveSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SurfaceType) == 0x0002C0, "Member 'FCharacterAtrributeTemplate::SurfaceType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ShieldSurfaceType) == 0x0002C1, "Member 'FCharacterAtrributeTemplate::ShieldSurfaceType' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ShowSkills) == 0x0002C8, "Member 'FCharacterAtrributeTemplate::ShowSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SkillTagName) == 0x0002D8, "Member 'FCharacterAtrributeTemplate::SkillTagName' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FireSkill) == 0x0002E8, "Member 'FCharacterAtrributeTemplate::FireSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AimSkill) == 0x0002F8, "Member 'FCharacterAtrributeTemplate::AimSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AllBulletHitModifierId) == 0x000308, "Member 'FCharacterAtrributeTemplate::AllBulletHitModifierId' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FireHitModifiers) == 0x000318, "Member 'FCharacterAtrributeTemplate::FireHitModifiers' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, NormalSkillID1) == 0x000328, "Member 'FCharacterAtrributeTemplate::NormalSkillID1' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, NormalSkillID2) == 0x000338, "Member 'FCharacterAtrributeTemplate::NormalSkillID2' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, QTESkillIDs) == 0x000348, "Member 'FCharacterAtrributeTemplate::QTESkillIDs' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SupSkillID) == 0x000358, "Member 'FCharacterAtrributeTemplate::SupSkillID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PassiveSkills) == 0x000368, "Member 'FCharacterAtrributeTemplate::PassiveSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, bDodgeSkillsUseCondition) == 0x000378, "Member 'FCharacterAtrributeTemplate::bDodgeSkillsUseCondition' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, DodgeSkills) == 0x000380, "Member 'FCharacterAtrributeTemplate::DodgeSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SpecialDodgeSkills) == 0x000390, "Member 'FCharacterAtrributeTemplate::SpecialDodgeSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SlideSkills) == 0x0003A0, "Member 'FCharacterAtrributeTemplate::SlideSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, HookSkills) == 0x0003B0, "Member 'FCharacterAtrributeTemplate::HookSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, CrossSkills) == 0x0003C0, "Member 'FCharacterAtrributeTemplate::CrossSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, BunkerInteractSkills) == 0x0003D0, "Member 'FCharacterAtrributeTemplate::BunkerInteractSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, BunkerSwitchInteractSkills) == 0x0003E0, "Member 'FCharacterAtrributeTemplate::BunkerSwitchInteractSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SkillEndBackLeftBunkerID) == 0x0003F0, "Member 'FCharacterAtrributeTemplate::SkillEndBackLeftBunkerID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SkillEndBackRightBunkerID) == 0x0003F4, "Member 'FCharacterAtrributeTemplate::SkillEndBackRightBunkerID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ReplaceDodgeSkills) == 0x0003F8, "Member 'FCharacterAtrributeTemplate::ReplaceDodgeSkills' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ReloadSkill) == 0x000408, "Member 'FCharacterAtrributeTemplate::ReloadSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RushSkill) == 0x000418, "Member 'FCharacterAtrributeTemplate::RushSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SwitchEnterSkill) == 0x000428, "Member 'FCharacterAtrributeTemplate::SwitchEnterSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SwitchLeaveSkill) == 0x00042C, "Member 'FCharacterAtrributeTemplate::SwitchLeaveSkill' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, TriggerOnPressedSkillInfoMap) == 0x000430, "Member 'FCharacterAtrributeTemplate::TriggerOnPressedSkillInfoMap' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PassiveModifierID) == 0x000480, "Member 'FCharacterAtrributeTemplate::PassiveModifierID' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SkillFixIDx) == 0x000490, "Member 'FCharacterAtrributeTemplate::SkillFixIDx' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PublicSkillCD) == 0x0004A0, "Member 'FCharacterAtrributeTemplate::PublicSkillCD' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FightUISpecialData) == 0x0004A8, "Member 'FCharacterAtrributeTemplate::FightUISpecialData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, SpecialAttributes) == 0x0004C0, "Member 'FCharacterAtrributeTemplate::SpecialAttributes' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, Hardness) == 0x0004D0, "Member 'FCharacterAtrributeTemplate::Hardness' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ForbiddenAbnormal) == 0x0004D8, "Member 'FCharacterAtrributeTemplate::ForbiddenAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, HitStateResistance) == 0x0004E8, "Member 'FCharacterAtrributeTemplate::HitStateResistance' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, bIgnoreLieDown) == 0x0004F8, "Member 'FCharacterAtrributeTemplate::bIgnoreLieDown' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, MaxHitLag) == 0x0004FC, "Member 'FCharacterAtrributeTemplate::MaxHitLag' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, NormalCameraInfo) == 0x000510, "Member 'FCharacterAtrributeTemplate::NormalCameraInfo' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FireCameraInfo) == 0x000600, "Member 'FCharacterAtrributeTemplate::FireCameraInfo' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AimCameraInfo) == 0x0006F0, "Member 'FCharacterAtrributeTemplate::AimCameraInfo' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RushCameraInfo) == 0x0007E0, "Member 'FCharacterAtrributeTemplate::RushCameraInfo' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RushToNormalSpeed) == 0x0008D0, "Member 'FCharacterAtrributeTemplate::RushToNormalSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ViewPitchMin) == 0x0008D4, "Member 'FCharacterAtrributeTemplate::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ViewPitchMax) == 0x0008D8, "Member 'FCharacterAtrributeTemplate::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, CrouchedEyeHeight) == 0x0008DC, "Member 'FCharacterAtrributeTemplate::CrouchedEyeHeight' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, BaseEyeHeight) == 0x0008E0, "Member 'FCharacterAtrributeTemplate::BaseEyeHeight' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, NormalCustomSpeedCurve) == 0x0008E8, "Member 'FCharacterAtrributeTemplate::NormalCustomSpeedCurve' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, FireCustomSpeedCurve) == 0x000918, "Member 'FCharacterAtrributeTemplate::FireCustomSpeedCurve' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, BaseRotationSpeed) == 0x000948, "Member 'FCharacterAtrributeTemplate::BaseRotationSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, JumpRotationRatio) == 0x00094C, "Member 'FCharacterAtrributeTemplate::JumpRotationRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, JumpAirControl) == 0x000950, "Member 'FCharacterAtrributeTemplate::JumpAirControl' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, DefaultAirControl) == 0x000954, "Member 'FCharacterAtrributeTemplate::DefaultAirControl' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ScaleRotationSpeed) == 0x000958, "Member 'FCharacterAtrributeTemplate::ScaleRotationSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ScaleAimRotationSpeed) == 0x00095C, "Member 'FCharacterAtrributeTemplate::ScaleAimRotationSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, TurnSpeed) == 0x000960, "Member 'FCharacterAtrributeTemplate::TurnSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, BunkerRotationRatio) == 0x000964, "Member 'FCharacterAtrributeTemplate::BunkerRotationRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, MaxScatterRatio) == 0x000968, "Member 'FCharacterAtrributeTemplate::MaxScatterRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, ShootAddScatterRatio) == 0x00096C, "Member 'FCharacterAtrributeTemplate::ShootAddScatterRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RecoverScatterSpeedRatio) == 0x000970, "Member 'FCharacterAtrributeTemplate::RecoverScatterSpeedRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, MassPointSetups) == 0x000978, "Member 'FCharacterAtrributeTemplate::MassPointSetups' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, bUseRecoilDirection) == 0x0009C8, "Member 'FCharacterAtrributeTemplate::bUseRecoilDirection' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RecoilActivateRatio_Head) == 0x0009CC, "Member 'FCharacterAtrributeTemplate::RecoilActivateRatio_Head' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreStateRecoilData) == 0x0009D0, "Member 'FCharacterAtrributeTemplate::PreStateRecoilData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, RecoilActivateRatio) == 0x000A20, "Member 'FCharacterAtrributeTemplate::RecoilActivateRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PreStatePhysicalRecoilData) == 0x000A28, "Member 'FCharacterAtrributeTemplate::PreStatePhysicalRecoilData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PhysicalRecoilActivateRatio_Hair) == 0x000A78, "Member 'FCharacterAtrributeTemplate::PhysicalRecoilActivateRatio_Hair' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PhysicalRecoilActivateRatio_Cloth) == 0x000A7C, "Member 'FCharacterAtrributeTemplate::PhysicalRecoilActivateRatio_Cloth' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, PhysicalRecoilActivateRatio_Hat) == 0x000A80, "Member 'FCharacterAtrributeTemplate::PhysicalRecoilActivateRatio_Hat' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, StateHitReactionData) == 0x000A88, "Member 'FCharacterAtrributeTemplate::StateHitReactionData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, HitPhysData) == 0x000AD8, "Member 'FCharacterAtrributeTemplate::HitPhysData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AbnormalReactData) == 0x000B00, "Member 'FCharacterAtrributeTemplate::AbnormalReactData' has a wrong offset!");
static_assert(offsetof(FCharacterAtrributeTemplate, AttributeAbnormalReactData) == 0x000B28, "Member 'FCharacterAtrributeTemplate::AttributeAbnormalReactData' has a wrong offset!");

// ScriptStruct Game.BoneResult
// 0x0030 (0x0030 - 0x0000)
struct FBoneResult final
{
public:
	class FString                                 ValueName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScareCrow;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoneOffsetLocation;                                // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneResult) == 0x000008, "Wrong alignment on FBoneResult");
static_assert(sizeof(FBoneResult) == 0x000030, "Wrong size on FBoneResult");
static_assert(offsetof(FBoneResult, ValueName) == 0x000000, "Member 'FBoneResult::ValueName' has a wrong offset!");
static_assert(offsetof(FBoneResult, MeshComp) == 0x000010, "Member 'FBoneResult::MeshComp' has a wrong offset!");
static_assert(offsetof(FBoneResult, OwnerActor) == 0x000018, "Member 'FBoneResult::OwnerActor' has a wrong offset!");
static_assert(offsetof(FBoneResult, bScareCrow) == 0x000020, "Member 'FBoneResult::bScareCrow' has a wrong offset!");
static_assert(offsetof(FBoneResult, BoneOffsetLocation) == 0x000024, "Member 'FBoneResult::BoneOffsetLocation' has a wrong offset!");

// ScriptStruct Game.TargetWarpingWindowData
// 0x0010 (0x0010 - 0x0000)
struct FTargetWarpingWindowData final
{
public:
	class UAnimNotifyState_TargetWarping*         AnimNotify;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetWarpingWindowData) == 0x000008, "Wrong alignment on FTargetWarpingWindowData");
static_assert(sizeof(FTargetWarpingWindowData) == 0x000010, "Wrong size on FTargetWarpingWindowData");
static_assert(offsetof(FTargetWarpingWindowData, AnimNotify) == 0x000000, "Member 'FTargetWarpingWindowData::AnimNotify' has a wrong offset!");
static_assert(offsetof(FTargetWarpingWindowData, StartTime) == 0x000008, "Member 'FTargetWarpingWindowData::StartTime' has a wrong offset!");
static_assert(offsetof(FTargetWarpingWindowData, EndTime) == 0x00000C, "Member 'FTargetWarpingWindowData::EndTime' has a wrong offset!");

// ScriptStruct Game.WeaponEnchantEmitterInfo
// 0x001C (0x001C - 0x0000)
struct FWeaponEnchantEmitterInfo final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   SourceAbility;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBySource;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EmitterLevel;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ApplyCount;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurApplyCount;                                     // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponEnchantEmitterInfo) == 0x000004, "Wrong alignment on FWeaponEnchantEmitterInfo");
static_assert(sizeof(FWeaponEnchantEmitterInfo) == 0x00001C, "Wrong size on FWeaponEnchantEmitterInfo");
static_assert(offsetof(FWeaponEnchantEmitterInfo, EmitterID) == 0x000000, "Member 'FWeaponEnchantEmitterInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FWeaponEnchantEmitterInfo, SourceAbility) == 0x000004, "Member 'FWeaponEnchantEmitterInfo::SourceAbility' has a wrong offset!");
static_assert(offsetof(FWeaponEnchantEmitterInfo, bApplyBySource) == 0x00000C, "Member 'FWeaponEnchantEmitterInfo::bApplyBySource' has a wrong offset!");
static_assert(offsetof(FWeaponEnchantEmitterInfo, EmitterLevel) == 0x000010, "Member 'FWeaponEnchantEmitterInfo::EmitterLevel' has a wrong offset!");
static_assert(offsetof(FWeaponEnchantEmitterInfo, ApplyCount) == 0x000014, "Member 'FWeaponEnchantEmitterInfo::ApplyCount' has a wrong offset!");
static_assert(offsetof(FWeaponEnchantEmitterInfo, CurApplyCount) == 0x000018, "Member 'FWeaponEnchantEmitterInfo::CurApplyCount' has a wrong offset!");

// ScriptStruct Game.MatiralParameterData
// 0x0030 (0x0030 - 0x0000)
struct FMatiralParameterData final
{
public:
	TArray<struct FScalarParameterNameAndCurve>   ScalarParameterNamesAndCurves;                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColorParameterNameAndCurves>   ColorParameterNamesAndCurves;                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BrushPropertyNamePath;                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatiralParameterData) == 0x000008, "Wrong alignment on FMatiralParameterData");
static_assert(sizeof(FMatiralParameterData) == 0x000030, "Wrong size on FMatiralParameterData");
static_assert(offsetof(FMatiralParameterData, ScalarParameterNamesAndCurves) == 0x000000, "Member 'FMatiralParameterData::ScalarParameterNamesAndCurves' has a wrong offset!");
static_assert(offsetof(FMatiralParameterData, ColorParameterNamesAndCurves) == 0x000010, "Member 'FMatiralParameterData::ColorParameterNamesAndCurves' has a wrong offset!");
static_assert(offsetof(FMatiralParameterData, BrushPropertyNamePath) == 0x000020, "Member 'FMatiralParameterData::BrushPropertyNamePath' has a wrong offset!");

// ScriptStruct Game.AnimTrackData
// 0x01B8 (0x01B8 - 0x0000)
struct FAnimTrackData final
{
public:
	class FName                                   WidgetName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           LowerBound;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           UpperBound;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimTracType, struct FMovieSceneFloatChannel> Channels;                                          // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	struct FMovieScene2DTransformMask             TransformMask;                                     // 0x0060(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneByteChannel                 VisibilityCurve;                                   // 0x0068(0x0098)(NativeAccessSpecifierPublic)
	struct FMovieSceneBoolChannel                 DesaturateCurve;                                   // 0x0100(0x0090)(NativeAccessSpecifierPublic)
	TArray<struct FMatiralParameterData>          MatiralParameterDatas;                             // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAnimVisibility;                                   // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesaturateVisibility;                             // 0x01A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                WidgetObject;                                      // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameTime                             LastTime;                                          // 0x01B0(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimTrackData) == 0x000008, "Wrong alignment on FAnimTrackData");
static_assert(sizeof(FAnimTrackData) == 0x0001B8, "Wrong size on FAnimTrackData");
static_assert(offsetof(FAnimTrackData, WidgetName) == 0x000000, "Member 'FAnimTrackData::WidgetName' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, LowerBound) == 0x000008, "Member 'FAnimTrackData::LowerBound' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, UpperBound) == 0x00000C, "Member 'FAnimTrackData::UpperBound' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, Channels) == 0x000010, "Member 'FAnimTrackData::Channels' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, TransformMask) == 0x000060, "Member 'FAnimTrackData::TransformMask' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, VisibilityCurve) == 0x000068, "Member 'FAnimTrackData::VisibilityCurve' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, DesaturateCurve) == 0x000100, "Member 'FAnimTrackData::DesaturateCurve' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, MatiralParameterDatas) == 0x000190, "Member 'FAnimTrackData::MatiralParameterDatas' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, bAnimVisibility) == 0x0001A0, "Member 'FAnimTrackData::bAnimVisibility' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, bDesaturateVisibility) == 0x0001A1, "Member 'FAnimTrackData::bDesaturateVisibility' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, WidgetObject) == 0x0001A8, "Member 'FAnimTrackData::WidgetObject' has a wrong offset!");
static_assert(offsetof(FAnimTrackData, LastTime) == 0x0001B0, "Member 'FAnimTrackData::LastTime' has a wrong offset!");

// ScriptStruct Game.RuntimeDamageInfo
// 0x0020 (0x0020 - 0x0000)
struct FRuntimeDamageInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkillRuntimeIDs;                                   // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   LauncherAbility;                                   // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeDamageInfo) == 0x000008, "Wrong alignment on FRuntimeDamageInfo");
static_assert(sizeof(FRuntimeDamageInfo) == 0x000020, "Wrong size on FRuntimeDamageInfo");
static_assert(offsetof(FRuntimeDamageInfo, SkillID) == 0x000000, "Member 'FRuntimeDamageInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FRuntimeDamageInfo, SkillRuntimeIDs) == 0x000008, "Member 'FRuntimeDamageInfo::SkillRuntimeIDs' has a wrong offset!");
static_assert(offsetof(FRuntimeDamageInfo, LauncherAbility) == 0x000018, "Member 'FRuntimeDamageInfo::LauncherAbility' has a wrong offset!");

// ScriptStruct Game.GraphicsSpecialSettingRow
// 0x0088 (0x0090 - 0x0008)
struct FGraphicsSpecialSettingRow final : public FTableRowBase
{
public:
	TArray<EGraphicsSpecialSettingType>           Type;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 VarName;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 QualityValues;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 QualityVariable;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGraphicsPlatform>                     Platforms;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferredToLevelLoaded;                            // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustNetLevel;                                     // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustDarkZoneLevel;                                // 0x006A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustMassLevel;                                    // 0x006B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGraphicsSpecialSettingUpdateReason>   Reasons;                                           // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ForSpecifiedMapType;                               // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraphicsSpecialSettingRow) == 0x000008, "Wrong alignment on FGraphicsSpecialSettingRow");
static_assert(sizeof(FGraphicsSpecialSettingRow) == 0x000090, "Wrong size on FGraphicsSpecialSettingRow");
static_assert(offsetof(FGraphicsSpecialSettingRow, Type) == 0x000008, "Member 'FGraphicsSpecialSettingRow::Type' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, VarName) == 0x000018, "Member 'FGraphicsSpecialSettingRow::VarName' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, Value) == 0x000028, "Member 'FGraphicsSpecialSettingRow::Value' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, QualityValues) == 0x000030, "Member 'FGraphicsSpecialSettingRow::QualityValues' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, QualityVariable) == 0x000040, "Member 'FGraphicsSpecialSettingRow::QualityVariable' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, Platforms) == 0x000050, "Member 'FGraphicsSpecialSettingRow::Platforms' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, bForce) == 0x000060, "Member 'FGraphicsSpecialSettingRow::bForce' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, Priority) == 0x000064, "Member 'FGraphicsSpecialSettingRow::Priority' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, bDeferredToLevelLoaded) == 0x000068, "Member 'FGraphicsSpecialSettingRow::bDeferredToLevelLoaded' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, bJustNetLevel) == 0x000069, "Member 'FGraphicsSpecialSettingRow::bJustNetLevel' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, bJustDarkZoneLevel) == 0x00006A, "Member 'FGraphicsSpecialSettingRow::bJustDarkZoneLevel' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, bJustMassLevel) == 0x00006B, "Member 'FGraphicsSpecialSettingRow::bJustMassLevel' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, Reasons) == 0x000070, "Member 'FGraphicsSpecialSettingRow::Reasons' has a wrong offset!");
static_assert(offsetof(FGraphicsSpecialSettingRow, ForSpecifiedMapType) == 0x000080, "Member 'FGraphicsSpecialSettingRow::ForSpecifiedMapType' has a wrong offset!");

// ScriptStruct Game.BeakInvisibleData
// 0x000C (0x000C - 0x0000)
struct FBeakInvisibleData final
{
public:
	ECharacterActionState                         BreakType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InBreakID;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakInvisibleDamageScaler;                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeakInvisibleData) == 0x000004, "Wrong alignment on FBeakInvisibleData");
static_assert(sizeof(FBeakInvisibleData) == 0x00000C, "Wrong size on FBeakInvisibleData");
static_assert(offsetof(FBeakInvisibleData, BreakType) == 0x000000, "Member 'FBeakInvisibleData::BreakType' has a wrong offset!");
static_assert(offsetof(FBeakInvisibleData, InBreakID) == 0x000004, "Member 'FBeakInvisibleData::InBreakID' has a wrong offset!");
static_assert(offsetof(FBeakInvisibleData, BreakInvisibleDamageScaler) == 0x000008, "Member 'FBeakInvisibleData::BreakInvisibleDamageScaler' has a wrong offset!");

// ScriptStruct Game.PSHandShowElement
// 0x00E8 (0x00F0 - 0x0008)
struct FPSHandShowElement final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandShowAnimID;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HandShowAnimName;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           HandShowAnim;                                      // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecilHandShow;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPSCharacterPose, TSoftObjectPtr<class UAnimSequence>> SpecilHandShows;                                   // 0x0050(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSHandShowElement) == 0x000008, "Wrong alignment on FPSHandShowElement");
static_assert(sizeof(FPSHandShowElement) == 0x0000F0, "Wrong size on FPSHandShowElement");
static_assert(offsetof(FPSHandShowElement, ID) == 0x000008, "Member 'FPSHandShowElement::ID' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, HandShowAnimID) == 0x00000C, "Member 'FPSHandShowElement::HandShowAnimID' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, HandShowAnimName) == 0x000010, "Member 'FPSHandShowElement::HandShowAnimName' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, HandShowAnim) == 0x000020, "Member 'FPSHandShowElement::HandShowAnim' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, bSpecilHandShow) == 0x000048, "Member 'FPSHandShowElement::bSpecilHandShow' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, SpecilHandShows) == 0x000050, "Member 'FPSHandShowElement::SpecilHandShows' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement, OtherParams) == 0x0000A0, "Member 'FPSHandShowElement::OtherParams' has a wrong offset!");

// ScriptStruct Game.PatrolPathPointParam
// 0x0060 (0x0060 - 0x0000)
struct FPatrolPathPointParam final
{
public:
	struct FVector2D                              DelayBefore;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DelayAfter;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UAnimMontage*, int32>              Animations;                                        // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolPathPointParam) == 0x000008, "Wrong alignment on FPatrolPathPointParam");
static_assert(sizeof(FPatrolPathPointParam) == 0x000060, "Wrong size on FPatrolPathPointParam");
static_assert(offsetof(FPatrolPathPointParam, DelayBefore) == 0x000000, "Member 'FPatrolPathPointParam::DelayBefore' has a wrong offset!");
static_assert(offsetof(FPatrolPathPointParam, DelayAfter) == 0x000008, "Member 'FPatrolPathPointParam::DelayAfter' has a wrong offset!");
static_assert(offsetof(FPatrolPathPointParam, Animations) == 0x000010, "Member 'FPatrolPathPointParam::Animations' has a wrong offset!");

// ScriptStruct Game.PatrolPathPoint
// 0x0018 (0x0018 - 0x0000)
struct FPatrolPathPoint final
{
public:
	class APatrolPoint*                           Point;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPatrolPathPointParam>          AnimParams;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolPathPoint) == 0x000008, "Wrong alignment on FPatrolPathPoint");
static_assert(sizeof(FPatrolPathPoint) == 0x000018, "Wrong size on FPatrolPathPoint");
static_assert(offsetof(FPatrolPathPoint, Point) == 0x000000, "Member 'FPatrolPathPoint::Point' has a wrong offset!");
static_assert(offsetof(FPatrolPathPoint, AnimParams) == 0x000008, "Member 'FPatrolPathPoint::AnimParams' has a wrong offset!");

// ScriptStruct Game.CastEmitterCondition
// 0x0078 (0x0078 - 0x0000)
struct FCastEmitterCondition final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterCastType                              CastType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              Condition;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            TriggerProbability;                                // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         TriggerProbabilityID;                              // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InverseConditionID;                                // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkRunning;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCastEmitterCondition) == 0x000008, "Wrong alignment on FCastEmitterCondition");
static_assert(sizeof(FCastEmitterCondition) == 0x000078, "Wrong size on FCastEmitterCondition");
static_assert(offsetof(FCastEmitterCondition, ID) == 0x000000, "Member 'FCastEmitterCondition::ID' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, CastType) == 0x000004, "Member 'FCastEmitterCondition::CastType' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, Condition) == 0x000008, "Member 'FCastEmitterCondition::Condition' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, TriggerProbability) == 0x000018, "Member 'FCastEmitterCondition::TriggerProbability' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, TriggerProbabilityID) == 0x000068, "Member 'FCastEmitterCondition::TriggerProbabilityID' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, InverseConditionID) == 0x00006C, "Member 'FCastEmitterCondition::InverseConditionID' has a wrong offset!");
static_assert(offsetof(FCastEmitterCondition, bMarkRunning) == 0x000070, "Member 'FCastEmitterCondition::bMarkRunning' has a wrong offset!");

// ScriptStruct Game.SkillInfo
// 0x0380 (0x0388 - 0x0008)
struct FSkillInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BlueprintSkillPath;                                // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncSkill;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedActive;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   SkillTags;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CoolDownTag;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillType                                    Type;                                              // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCastType                                CastType;                                          // 0x007D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamOnlyOneSkill;                                 // 0x007E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSilenceCanCast;                                   // 0x007F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyLongPressedReleaseButtonCastType;           // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifySkillCastType                          ModifyLongPressedReleaseCastType;                  // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomLongPressedReleaseModifyCastTypeTime;        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLongPressedNeedAutoCastSkill;                     // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyStorge_GateMinReleaseTime;                   // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnergyStorge_GateNeedReleaseTriggerStop;           // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShortPressTriggerStorage;                      // 0x0091(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ValidStorageTime;                                  // 0x0094(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CostDelta;                                         // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAttributeChangeValueGrowup>    SkillStorageCost;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCostDecimalValue;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveEndStorageIfNotStart;                      // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillTips_SelectorID;                              // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSelector;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectorID;                                        // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectorUseInSkill;                               // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOnDeath;                                    // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActiveSkill;                                  // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x5];                                       // 0x00D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              AutoCastCondition;                                 // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseQTELauncherWhenCheckCast;                      // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              CastCondition;                                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxActiveTimesInCastable;                          // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndCondition;                                  // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreshKeepCastableTime;                            // 0x0105(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              EndCondition;                                      // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EAbnormalState>                        ApplyAbnormalStates;                               // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAttributeChangeValueGrowup>    SkillCost;                                         // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            SkillCostEnergyMap;                                // 0x0138(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECDType                                       CDType;                                            // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              CDCondition;                                       // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bTeamSharedCD;                                     // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            CDTimes;                                           // 0x01A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EReturnCDType                                 ReturnCDType;                                      // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnCDTimes;                                     // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargeTimeChangeable;                             // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            MaxChargeTimesMap;                                 // 0x0208(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         FreshChargeTimes;                                  // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAttenuationRatio;                            // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillTurn                                    TurnType;                                          // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnTime;                                          // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeCameraRotation;                             // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotInterruptedType;                                // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSkillUseMovelean;                              // 0x0270(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSkillUseInputlean;                             // 0x0271(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnCDTime;                                       // 0x0272(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273[0x1];                                      // 0x0273(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarnTime;                                          // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoAim;                                       // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchable;                                       // 0x0279(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMove;                                          // 0x027A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTurn;                                          // 0x027B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveWillInterrupt;                                // 0x027C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndSKillTimeCanSkipRushStart;                      // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendToAimOnEnd;                                  // 0x0284(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearKeyboardInputStateCache;                     // 0x0285(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBlendToAim;                                   // 0x0286(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireInterruptToAim;                               // 0x0287(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendToAimOnStart;                                // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHalfSkill;                                        // 0x0289(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForbidHalfSkill_Falling;                          // 0x028A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShootSkill;                                       // 0x028B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirSkill;                                         // 0x028C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFloatingSkill;                                    // 0x028D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakAimAction;                                   // 0x028E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakAimState;                                    // 0x028F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakSpecialFireGroup;                            // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearWeaponFireInterval;                          // 0x0291(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillActionType                              SkillActionType;                                   // 0x0292(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillInBunkerType                            InFullBunkerType;                                  // 0x0293(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillInBunkerType                            InHalfBunkerType;                                  // 0x0294(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBunkerKeepSkillAction;                        // 0x0295(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitBunkerBackPlaySkill;                          // 0x0296(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBunkerReachPeakLeave;                             // 0x0297(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerReachRightPeakLeaveDis;                      // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerReachLeftPeakLeaveDis;                       // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillLeaveBunkerTime;                              // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillLeaveBunkerBackTime;                          // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBunkerKeepInputRot;                               // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBunkerKeepInputTurn;                              // 0x02A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepBunkerCanInterrupt;                           // 0x02AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckUseSkillMontage;                             // 0x02AB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SkillMontage;                                      // 0x02B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurtailMontage;                                    // 0x02C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitWeaponAnim;                                    // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FSoftObjectPath>   WeaponSkillMontage;                                // 0x02E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ForceLOD;                                          // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDodgeSkillLookInputDir;                           // 0x033C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCastEmitterCondition>          EmitterID;                                         // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESkillRangeType                               SkillRangeType;                                    // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFieldSkill;                                       // 0x0351(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLifeSpanAllowedFinish;                            // 0x0352(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsSummonedSkill;                                  // 0x0353(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSkillClearAbnormal;                          // 0x0354(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQTENotLeaveCharacter;                             // 0x0355(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQTEEndSwitchBack;                                 // 0x0356(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQTEClearAbnormal;                                 // 0x0357(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQTEFollowCameraRotation;                          // 0x0358(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsStaySkill;                                      // 0x0359(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35A[0x2];                                      // 0x035A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillDamageOriginReplace;                          // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 DerivedSkills;                                     // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDeadSaveSkill : 1;                                // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNeedCastFailTips;                                 // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_372[0x2];                                      // 0x0372(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueryTargetsEmitterID;                             // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCastSuccess;                                // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoReleaseWhenFlushCache;                        // 0x0379(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bAutoReleaseKeepTime;                              // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastSkillSwitch;                                  // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuperSkillAutoSwitchBackLock;                     // 0x0381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuperSkillAutoSwitchBack;                         // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchCharacterIfAutoSkillConditionAllow;         // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurtailMontage;                                // 0x0384(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptReloadComplete;                          // 0x0385(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_386[0x2];                                      // 0x0386(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillInfo) == 0x000008, "Wrong alignment on FSkillInfo");
static_assert(sizeof(FSkillInfo) == 0x000388, "Wrong size on FSkillInfo");
static_assert(offsetof(FSkillInfo, ID) == 0x000008, "Member 'FSkillInfo::ID' has a wrong offset!");
static_assert(offsetof(FSkillInfo, BlueprintSkillPath) == 0x000010, "Member 'FSkillInfo::BlueprintSkillPath' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSyncSkill) == 0x000028, "Member 'FSkillInfo::bSyncSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bNeedActive) == 0x000029, "Member 'FSkillInfo::bNeedActive' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bRepaceData) == 0x00002A, "Member 'FSkillInfo::bRepaceData' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ReplaceParamArray) == 0x000030, "Member 'FSkillInfo::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FSkillInfo, Icon) == 0x000040, "Member 'FSkillInfo::Icon' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillTags) == 0x000058, "Member 'FSkillInfo::SkillTags' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CoolDownTag) == 0x000068, "Member 'FSkillInfo::CoolDownTag' has a wrong offset!");
static_assert(offsetof(FSkillInfo, Priority) == 0x000078, "Member 'FSkillInfo::Priority' has a wrong offset!");
static_assert(offsetof(FSkillInfo, Type) == 0x00007C, "Member 'FSkillInfo::Type' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CastType) == 0x00007D, "Member 'FSkillInfo::CastType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bTeamOnlyOneSkill) == 0x00007E, "Member 'FSkillInfo::bTeamOnlyOneSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSilenceCanCast) == 0x00007F, "Member 'FSkillInfo::bSilenceCanCast' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bModifyLongPressedReleaseButtonCastType) == 0x000080, "Member 'FSkillInfo::bModifyLongPressedReleaseButtonCastType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ModifyLongPressedReleaseCastType) == 0x000081, "Member 'FSkillInfo::ModifyLongPressedReleaseCastType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CustomLongPressedReleaseModifyCastTypeTime) == 0x000084, "Member 'FSkillInfo::CustomLongPressedReleaseModifyCastTypeTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bLongPressedNeedAutoCastSkill) == 0x000088, "Member 'FSkillInfo::bLongPressedNeedAutoCastSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, EnergyStorge_GateMinReleaseTime) == 0x00008C, "Member 'FSkillInfo::EnergyStorge_GateMinReleaseTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, EnergyStorge_GateNeedReleaseTriggerStop) == 0x000090, "Member 'FSkillInfo::EnergyStorge_GateNeedReleaseTriggerStop' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bUseShortPressTriggerStorage) == 0x000091, "Member 'FSkillInfo::bUseShortPressTriggerStorage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ValidStorageTime) == 0x000094, "Member 'FSkillInfo::ValidStorageTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CostDelta) == 0x0000A0, "Member 'FSkillInfo::CostDelta' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillStorageCost) == 0x0000B0, "Member 'FSkillInfo::SkillStorageCost' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCostDecimalValue) == 0x0000C0, "Member 'FSkillInfo::bCostDecimalValue' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bReceiveEndStorageIfNotStart) == 0x0000C1, "Member 'FSkillInfo::bReceiveEndStorageIfNotStart' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillTips_SelectorID) == 0x0000C4, "Member 'FSkillInfo::SkillTips_SelectorID' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bHasSelector) == 0x0000C8, "Member 'FSkillInfo::bHasSelector' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SelectorID) == 0x0000CC, "Member 'FSkillInfo::SelectorID' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSelectorUseInSkill) == 0x0000D0, "Member 'FSkillInfo::bSelectorUseInSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bEnableOnDeath) == 0x0000D1, "Member 'FSkillInfo::bEnableOnDeath' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAutoActiveSkill) == 0x0000D2, "Member 'FSkillInfo::bAutoActiveSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, AutoCastCondition) == 0x0000D8, "Member 'FSkillInfo::AutoCastCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bUseQTELauncherWhenCheckCast) == 0x0000E8, "Member 'FSkillInfo::bUseQTELauncherWhenCheckCast' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CastCondition) == 0x0000F0, "Member 'FSkillInfo::CastCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfo, MaxActiveTimesInCastable) == 0x000100, "Member 'FSkillInfo::MaxActiveTimesInCastable' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bUseEndCondition) == 0x000104, "Member 'FSkillInfo::bUseEndCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFreshKeepCastableTime) == 0x000105, "Member 'FSkillInfo::bFreshKeepCastableTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, EndCondition) == 0x000108, "Member 'FSkillInfo::EndCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ApplyAbnormalStates) == 0x000118, "Member 'FSkillInfo::ApplyAbnormalStates' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillCost) == 0x000128, "Member 'FSkillInfo::SkillCost' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillCostEnergyMap) == 0x000138, "Member 'FSkillInfo::SkillCostEnergyMap' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CDType) == 0x000188, "Member 'FSkillInfo::CDType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CDCondition) == 0x000190, "Member 'FSkillInfo::CDCondition' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bTeamSharedCD) == 0x0001A0, "Member 'FSkillInfo::bTeamSharedCD' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CDTimes) == 0x0001A8, "Member 'FSkillInfo::CDTimes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ReturnCDType) == 0x0001F8, "Member 'FSkillInfo::ReturnCDType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ReturnCDTimes) == 0x0001FC, "Member 'FSkillInfo::ReturnCDTimes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bChargeTimeChangeable) == 0x000200, "Member 'FSkillInfo::bChargeTimeChangeable' has a wrong offset!");
static_assert(offsetof(FSkillInfo, MaxChargeTimesMap) == 0x000208, "Member 'FSkillInfo::MaxChargeTimesMap' has a wrong offset!");
static_assert(offsetof(FSkillInfo, FreshChargeTimes) == 0x000258, "Member 'FSkillInfo::FreshChargeTimes' has a wrong offset!");
static_assert(offsetof(FSkillInfo, DamageAttenuationRatio) == 0x00025C, "Member 'FSkillInfo::DamageAttenuationRatio' has a wrong offset!");
static_assert(offsetof(FSkillInfo, TurnType) == 0x000260, "Member 'FSkillInfo::TurnType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, TurnTime) == 0x000264, "Member 'FSkillInfo::TurnTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bChangeCameraRotation) == 0x000268, "Member 'FSkillInfo::bChangeCameraRotation' has a wrong offset!");
static_assert(offsetof(FSkillInfo, NotInterruptedType) == 0x00026C, "Member 'FSkillInfo::NotInterruptedType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCanSkillUseMovelean) == 0x000270, "Member 'FSkillInfo::bCanSkillUseMovelean' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCanSkillUseInputlean) == 0x000271, "Member 'FSkillInfo::bCanSkillUseInputlean' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bWarnCDTime) == 0x000272, "Member 'FSkillInfo::bWarnCDTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, WarnTime) == 0x000274, "Member 'FSkillInfo::WarnTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bUseAutoAim) == 0x000278, "Member 'FSkillInfo::bUseAutoAim' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSwitchable) == 0x000279, "Member 'FSkillInfo::bSwitchable' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCanMove) == 0x00027A, "Member 'FSkillInfo::bCanMove' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCanTurn) == 0x00027B, "Member 'FSkillInfo::bCanTurn' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bMoveWillInterrupt) == 0x00027C, "Member 'FSkillInfo::bMoveWillInterrupt' has a wrong offset!");
static_assert(offsetof(FSkillInfo, EndSKillTimeCanSkipRushStart) == 0x000280, "Member 'FSkillInfo::EndSKillTimeCanSkipRushStart' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBlendToAimOnEnd) == 0x000284, "Member 'FSkillInfo::bBlendToAimOnEnd' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bClearKeyboardInputStateCache) == 0x000285, "Member 'FSkillInfo::bClearKeyboardInputStateCache' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAutoBlendToAim) == 0x000286, "Member 'FSkillInfo::bAutoBlendToAim' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFireInterruptToAim) == 0x000287, "Member 'FSkillInfo::bFireInterruptToAim' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBlendToAimOnStart) == 0x000288, "Member 'FSkillInfo::bBlendToAimOnStart' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bHalfSkill) == 0x000289, "Member 'FSkillInfo::bHalfSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bForbidHalfSkill_Falling) == 0x00028A, "Member 'FSkillInfo::bForbidHalfSkill_Falling' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bShootSkill) == 0x00028B, "Member 'FSkillInfo::bShootSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAirSkill) == 0x00028C, "Member 'FSkillInfo::bAirSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFloatingSkill) == 0x00028D, "Member 'FSkillInfo::bFloatingSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBreakAimAction) == 0x00028E, "Member 'FSkillInfo::bBreakAimAction' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBreakAimState) == 0x00028F, "Member 'FSkillInfo::bBreakAimState' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBreakSpecialFireGroup) == 0x000290, "Member 'FSkillInfo::bBreakSpecialFireGroup' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bClearWeaponFireInterval) == 0x000291, "Member 'FSkillInfo::bClearWeaponFireInterval' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillActionType) == 0x000292, "Member 'FSkillInfo::SkillActionType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, InFullBunkerType) == 0x000293, "Member 'FSkillInfo::InFullBunkerType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, InHalfBunkerType) == 0x000294, "Member 'FSkillInfo::InHalfBunkerType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFullBunkerKeepSkillAction) == 0x000295, "Member 'FSkillInfo::bFullBunkerKeepSkillAction' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bWaitBunkerBackPlaySkill) == 0x000296, "Member 'FSkillInfo::bWaitBunkerBackPlaySkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBunkerReachPeakLeave) == 0x000297, "Member 'FSkillInfo::bBunkerReachPeakLeave' has a wrong offset!");
static_assert(offsetof(FSkillInfo, BunkerReachRightPeakLeaveDis) == 0x000298, "Member 'FSkillInfo::BunkerReachRightPeakLeaveDis' has a wrong offset!");
static_assert(offsetof(FSkillInfo, BunkerReachLeftPeakLeaveDis) == 0x00029C, "Member 'FSkillInfo::BunkerReachLeftPeakLeaveDis' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillLeaveBunkerTime) == 0x0002A0, "Member 'FSkillInfo::SkillLeaveBunkerTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillLeaveBunkerBackTime) == 0x0002A4, "Member 'FSkillInfo::SkillLeaveBunkerBackTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBunkerKeepInputRot) == 0x0002A8, "Member 'FSkillInfo::bBunkerKeepInputRot' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bBunkerKeepInputTurn) == 0x0002A9, "Member 'FSkillInfo::bBunkerKeepInputTurn' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bKeepBunkerCanInterrupt) == 0x0002AA, "Member 'FSkillInfo::bKeepBunkerCanInterrupt' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCheckUseSkillMontage) == 0x0002AB, "Member 'FSkillInfo::bCheckUseSkillMontage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillMontage) == 0x0002B0, "Member 'FSkillInfo::SkillMontage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, CurtailMontage) == 0x0002C8, "Member 'FSkillInfo::CurtailMontage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFitWeaponAnim) == 0x0002E0, "Member 'FSkillInfo::bFitWeaponAnim' has a wrong offset!");
static_assert(offsetof(FSkillInfo, WeaponSkillMontage) == 0x0002E8, "Member 'FSkillInfo::WeaponSkillMontage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, ForceLOD) == 0x000338, "Member 'FSkillInfo::ForceLOD' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bDodgeSkillLookInputDir) == 0x00033C, "Member 'FSkillInfo::bDodgeSkillLookInputDir' has a wrong offset!");
static_assert(offsetof(FSkillInfo, EmitterID) == 0x000340, "Member 'FSkillInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillRangeType) == 0x000350, "Member 'FSkillInfo::SkillRangeType' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bFieldSkill) == 0x000351, "Member 'FSkillInfo::bFieldSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bLifeSpanAllowedFinish) == 0x000352, "Member 'FSkillInfo::bLifeSpanAllowedFinish' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAsSummonedSkill) == 0x000353, "Member 'FSkillInfo::bAsSummonedSkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bStartSkillClearAbnormal) == 0x000354, "Member 'FSkillInfo::bStartSkillClearAbnormal' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bQTENotLeaveCharacter) == 0x000355, "Member 'FSkillInfo::bQTENotLeaveCharacter' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bQTEEndSwitchBack) == 0x000356, "Member 'FSkillInfo::bQTEEndSwitchBack' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bQTEClearAbnormal) == 0x000357, "Member 'FSkillInfo::bQTEClearAbnormal' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bQTEFollowCameraRotation) == 0x000358, "Member 'FSkillInfo::bQTEFollowCameraRotation' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAsStaySkill) == 0x000359, "Member 'FSkillInfo::bAsStaySkill' has a wrong offset!");
static_assert(offsetof(FSkillInfo, SkillDamageOriginReplace) == 0x00035C, "Member 'FSkillInfo::SkillDamageOriginReplace' has a wrong offset!");
static_assert(offsetof(FSkillInfo, DerivedSkills) == 0x000360, "Member 'FSkillInfo::DerivedSkills' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bNeedCastFailTips) == 0x000371, "Member 'FSkillInfo::bNeedCastFailTips' has a wrong offset!");
static_assert(offsetof(FSkillInfo, QueryTargetsEmitterID) == 0x000374, "Member 'FSkillInfo::QueryTargetsEmitterID' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bEnableCastSuccess) == 0x000378, "Member 'FSkillInfo::bEnableCastSuccess' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAutoReleaseWhenFlushCache) == 0x000379, "Member 'FSkillInfo::bAutoReleaseWhenFlushCache' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bAutoReleaseKeepTime) == 0x00037C, "Member 'FSkillInfo::bAutoReleaseKeepTime' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bCastSkillSwitch) == 0x000380, "Member 'FSkillInfo::bCastSkillSwitch' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSuperSkillAutoSwitchBackLock) == 0x000381, "Member 'FSkillInfo::bSuperSkillAutoSwitchBackLock' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSuperSkillAutoSwitchBack) == 0x000382, "Member 'FSkillInfo::bSuperSkillAutoSwitchBack' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bSwitchCharacterIfAutoSkillConditionAllow) == 0x000383, "Member 'FSkillInfo::bSwitchCharacterIfAutoSkillConditionAllow' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bUseCurtailMontage) == 0x000384, "Member 'FSkillInfo::bUseCurtailMontage' has a wrong offset!");
static_assert(offsetof(FSkillInfo, bInterruptReloadComplete) == 0x000385, "Member 'FSkillInfo::bInterruptReloadComplete' has a wrong offset!");

// ScriptStruct Game.CharacterAbnormalRenderPool
// 0x0020 (0x0020 - 0x0000)
struct FCharacterAbnormalRenderPool final
{
public:
	TArray<class UCharacterAbnormalRenderState*>  Free;                                              // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCharacterAbnormalRenderState*>  Used;                                              // 0x0010(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAbnormalRenderPool) == 0x000008, "Wrong alignment on FCharacterAbnormalRenderPool");
static_assert(sizeof(FCharacterAbnormalRenderPool) == 0x000020, "Wrong size on FCharacterAbnormalRenderPool");
static_assert(offsetof(FCharacterAbnormalRenderPool, Free) == 0x000000, "Member 'FCharacterAbnormalRenderPool::Free' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderPool, Used) == 0x000010, "Member 'FCharacterAbnormalRenderPool::Used' has a wrong offset!");

// ScriptStruct Game.DSDebugInfo
// 0x0030 (0x0030 - 0x0000)
struct FDSDebugInfo final
{
public:
	class FString                                 AddressURL;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PID;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogName;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LevelID;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDSDebugInfo) == 0x000008, "Wrong alignment on FDSDebugInfo");
static_assert(sizeof(FDSDebugInfo) == 0x000030, "Wrong size on FDSDebugInfo");
static_assert(offsetof(FDSDebugInfo, AddressURL) == 0x000000, "Member 'FDSDebugInfo::AddressURL' has a wrong offset!");
static_assert(offsetof(FDSDebugInfo, PID) == 0x000010, "Member 'FDSDebugInfo::PID' has a wrong offset!");
static_assert(offsetof(FDSDebugInfo, LogName) == 0x000018, "Member 'FDSDebugInfo::LogName' has a wrong offset!");
static_assert(offsetof(FDSDebugInfo, LevelID) == 0x000028, "Member 'FDSDebugInfo::LevelID' has a wrong offset!");

// ScriptStruct Game.CompositeParticleInfo
// 0x0198 (0x0198 - 0x0000)
struct alignas(0x08) FCompositeParticleInfo final
{
public:
	TWeakObjectPtr<class UNiagaraComponent>       Niagara;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x190];                                      // 0x0008(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeParticleInfo) == 0x000008, "Wrong alignment on FCompositeParticleInfo");
static_assert(sizeof(FCompositeParticleInfo) == 0x000198, "Wrong size on FCompositeParticleInfo");
static_assert(offsetof(FCompositeParticleInfo, Niagara) == 0x000000, "Member 'FCompositeParticleInfo::Niagara' has a wrong offset!");

// ScriptStruct Game.FlyBirdConfig
// 0x0020 (0x0020 - 0x0000)
struct FFlyBirdConfig final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginMoveDistance;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeDistance;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDistance;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acc;                                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlyBirdConfig) == 0x000004, "Wrong alignment on FFlyBirdConfig");
static_assert(sizeof(FFlyBirdConfig) == 0x000020, "Wrong size on FFlyBirdConfig");
static_assert(offsetof(FFlyBirdConfig, Offset) == 0x000000, "Member 'FFlyBirdConfig::Offset' has a wrong offset!");
static_assert(offsetof(FFlyBirdConfig, BeginMoveDistance) == 0x00000C, "Member 'FFlyBirdConfig::BeginMoveDistance' has a wrong offset!");
static_assert(offsetof(FFlyBirdConfig, BrakeDistance) == 0x000010, "Member 'FFlyBirdConfig::BrakeDistance' has a wrong offset!");
static_assert(offsetof(FFlyBirdConfig, StopDistance) == 0x000014, "Member 'FFlyBirdConfig::StopDistance' has a wrong offset!");
static_assert(offsetof(FFlyBirdConfig, Speed) == 0x000018, "Member 'FFlyBirdConfig::Speed' has a wrong offset!");
static_assert(offsetof(FFlyBirdConfig, Acc) == 0x00001C, "Member 'FFlyBirdConfig::Acc' has a wrong offset!");

// ScriptStruct Game.WeaponFirePattern
// 0x0008 (0x0008 - 0x0000)
struct FWeaponFirePattern final
{
public:
	int32                                         PatternID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletEnchantID;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponFirePattern) == 0x000004, "Wrong alignment on FWeaponFirePattern");
static_assert(sizeof(FWeaponFirePattern) == 0x000008, "Wrong size on FWeaponFirePattern");
static_assert(offsetof(FWeaponFirePattern, PatternID) == 0x000000, "Member 'FWeaponFirePattern::PatternID' has a wrong offset!");
static_assert(offsetof(FWeaponFirePattern, BulletEnchantID) == 0x000004, "Member 'FWeaponFirePattern::BulletEnchantID' has a wrong offset!");

// ScriptStruct Game.CompositeIdArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCompositeIdArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeIdArray) == 0x000008, "Wrong alignment on FCompositeIdArray");
static_assert(sizeof(FCompositeIdArray) == 0x000010, "Wrong size on FCompositeIdArray");

// ScriptStruct Game.BlindageTickFunc
// 0x0008 (0x0030 - 0x0028)
struct FBlindageTickFunc final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlindageTickFunc) == 0x000008, "Wrong alignment on FBlindageTickFunc");
static_assert(sizeof(FBlindageTickFunc) == 0x000030, "Wrong size on FBlindageTickFunc");

// ScriptStruct Game.BulletBezierData
// 0x0028 (0x0028 - 0x0000)
struct FBulletBezierData final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TimeCurve;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P1;                                                // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P2;                                                // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletBezierData) == 0x000008, "Wrong alignment on FBulletBezierData");
static_assert(sizeof(FBulletBezierData) == 0x000028, "Wrong size on FBulletBezierData");
static_assert(offsetof(FBulletBezierData, Time) == 0x000000, "Member 'FBulletBezierData::Time' has a wrong offset!");
static_assert(offsetof(FBulletBezierData, TimeCurve) == 0x000008, "Member 'FBulletBezierData::TimeCurve' has a wrong offset!");
static_assert(offsetof(FBulletBezierData, P1) == 0x000010, "Member 'FBulletBezierData::P1' has a wrong offset!");
static_assert(offsetof(FBulletBezierData, P2) == 0x00001C, "Member 'FBulletBezierData::P2' has a wrong offset!");

// ScriptStruct Game.AnimLoadConfig
// 0x0038 (0x0038 - 0x0000)
struct FAnimLoadConfig final
{
public:
	class FString                                 GirlName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponName;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RecoilSuffixName;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimLoadConfig) == 0x000008, "Wrong alignment on FAnimLoadConfig");
static_assert(sizeof(FAnimLoadConfig) == 0x000038, "Wrong size on FAnimLoadConfig");
static_assert(offsetof(FAnimLoadConfig, GirlName) == 0x000000, "Member 'FAnimLoadConfig::GirlName' has a wrong offset!");
static_assert(offsetof(FAnimLoadConfig, SkinID) == 0x000010, "Member 'FAnimLoadConfig::SkinID' has a wrong offset!");
static_assert(offsetof(FAnimLoadConfig, WeaponName) == 0x000018, "Member 'FAnimLoadConfig::WeaponName' has a wrong offset!");
static_assert(offsetof(FAnimLoadConfig, RecoilSuffixName) == 0x000028, "Member 'FAnimLoadConfig::RecoilSuffixName' has a wrong offset!");

// ScriptStruct Game.AbilityAttributeItem
// 0x004C (0x0058 - 0x000C)
struct FAbilityAttributeItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityAttribute*                      AbilityAttribute;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseValue;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AdditionRate;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AdditionValue;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentAttributeValue;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxValue;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TempAttributeValue;                                // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DynamicAttributeValue;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CacheModifiedData;                                 // 0x0038(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityAttributeItem) == 0x000008, "Wrong alignment on FAbilityAttributeItem");
static_assert(sizeof(FAbilityAttributeItem) == 0x000058, "Wrong size on FAbilityAttributeItem");
static_assert(offsetof(FAbilityAttributeItem, AbilityAttribute) == 0x000010, "Member 'FAbilityAttributeItem::AbilityAttribute' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, BaseValue) == 0x000018, "Member 'FAbilityAttributeItem::BaseValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, AdditionRate) == 0x00001C, "Member 'FAbilityAttributeItem::AdditionRate' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, AdditionValue) == 0x000020, "Member 'FAbilityAttributeItem::AdditionValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, CurrentAttributeValue) == 0x000024, "Member 'FAbilityAttributeItem::CurrentAttributeValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, MaxValue) == 0x000028, "Member 'FAbilityAttributeItem::MaxValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, TempAttributeValue) == 0x00002C, "Member 'FAbilityAttributeItem::TempAttributeValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, DynamicAttributeValue) == 0x000030, "Member 'FAbilityAttributeItem::DynamicAttributeValue' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeItem, CacheModifiedData) == 0x000038, "Member 'FAbilityAttributeItem::CacheModifiedData' has a wrong offset!");

// ScriptStruct Game.AbilityAttributeArray
// 0x0028 (0x0130 - 0x0108)
struct FAbilityAttributeArray final : public FFastArraySerializer
{
public:
	TArray<struct FAbilityAttributeItem>          RepAttributes;                                     // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAbilityAttributeItem>          NotRepAttributes;                                  // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UGameAbilityComponent*                  AbilityComponent;                                  // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAbilityAttributeArray) == 0x000008, "Wrong alignment on FAbilityAttributeArray");
static_assert(sizeof(FAbilityAttributeArray) == 0x000130, "Wrong size on FAbilityAttributeArray");
static_assert(offsetof(FAbilityAttributeArray, RepAttributes) == 0x000108, "Member 'FAbilityAttributeArray::RepAttributes' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeArray, NotRepAttributes) == 0x000118, "Member 'FAbilityAttributeArray::NotRepAttributes' has a wrong offset!");
static_assert(offsetof(FAbilityAttributeArray, AbilityComponent) == 0x000128, "Member 'FAbilityAttributeArray::AbilityComponent' has a wrong offset!");

// ScriptStruct Game.CharacterAbnormalRenderStateCurve
// 0x00F8 (0x00F8 - 0x0000)
struct FCharacterAbnormalRenderStateCurve final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UCurveFloat*>         FloatParameters;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveLinearColor*>   ColorParameters;                                   // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class UCurveVector*>        VectorParameters;                                  // 0x00A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAbnormalRenderStateCurve) == 0x000008, "Wrong alignment on FCharacterAbnormalRenderStateCurve");
static_assert(sizeof(FCharacterAbnormalRenderStateCurve) == 0x0000F8, "Wrong size on FCharacterAbnormalRenderStateCurve");
static_assert(offsetof(FCharacterAbnormalRenderStateCurve, Time) == 0x000000, "Member 'FCharacterAbnormalRenderStateCurve::Time' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateCurve, FloatParameters) == 0x000008, "Member 'FCharacterAbnormalRenderStateCurve::FloatParameters' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateCurve, ColorParameters) == 0x000058, "Member 'FCharacterAbnormalRenderStateCurve::ColorParameters' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateCurve, VectorParameters) == 0x0000A8, "Member 'FCharacterAbnormalRenderStateCurve::VectorParameters' has a wrong offset!");

// ScriptStruct Game.CharacterAbnormalRenderStateEffect
// 0x0070 (0x0070 - 0x0000)
struct FCharacterAbnormalRenderStateEffect final
{
public:
	class FName                                   Socket;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bComposite;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Niagara;                                           // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundEvent;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundIntervalTime;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRotation;                                     // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockLocation;                                     // 0x0065(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0xA];                                       // 0x0066(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAbnormalRenderStateEffect) == 0x000010, "Wrong alignment on FCharacterAbnormalRenderStateEffect");
static_assert(sizeof(FCharacterAbnormalRenderStateEffect) == 0x000070, "Wrong size on FCharacterAbnormalRenderStateEffect");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, Socket) == 0x000000, "Member 'FCharacterAbnormalRenderStateEffect::Socket' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, Offset) == 0x000010, "Member 'FCharacterAbnormalRenderStateEffect::Offset' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, bComposite) == 0x000040, "Member 'FCharacterAbnormalRenderStateEffect::bComposite' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, Niagara) == 0x000048, "Member 'FCharacterAbnormalRenderStateEffect::Niagara' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, SoundEvent) == 0x000050, "Member 'FCharacterAbnormalRenderStateEffect::SoundEvent' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, SoundIntervalTime) == 0x000060, "Member 'FCharacterAbnormalRenderStateEffect::SoundIntervalTime' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, bLockRotation) == 0x000064, "Member 'FCharacterAbnormalRenderStateEffect::bLockRotation' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalRenderStateEffect, bLockLocation) == 0x000065, "Member 'FCharacterAbnormalRenderStateEffect::bLockLocation' has a wrong offset!");

// ScriptStruct Game.SkinPartMaterial
// 0x01D0 (0x01D0 - 0x0000)
struct FSkinPartMaterial final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInstance>       Material;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       Outline;                                           // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterAbnormalRenderStateCurve     MaterialCurve;                                     // 0x0060(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAbnormalRenderStateEffect    Particle;                                          // 0x0160(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinPartMaterial) == 0x000010, "Wrong alignment on FSkinPartMaterial");
static_assert(sizeof(FSkinPartMaterial) == 0x0001D0, "Wrong size on FSkinPartMaterial");
static_assert(offsetof(FSkinPartMaterial, SlotName) == 0x000004, "Member 'FSkinPartMaterial::SlotName' has a wrong offset!");
static_assert(offsetof(FSkinPartMaterial, Material) == 0x000010, "Member 'FSkinPartMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSkinPartMaterial, Outline) == 0x000038, "Member 'FSkinPartMaterial::Outline' has a wrong offset!");
static_assert(offsetof(FSkinPartMaterial, MaterialCurve) == 0x000060, "Member 'FSkinPartMaterial::MaterialCurve' has a wrong offset!");
static_assert(offsetof(FSkinPartMaterial, Particle) == 0x000160, "Member 'FSkinPartMaterial::Particle' has a wrong offset!");

// ScriptStruct Game.CharacterAbnormalParams
// 0x0140 (0x0140 - 0x0000)
struct FCharacterAbnormalParams final
{
public:
	TArray<struct FCharacterAbnormalRenderStateEffect> Particles;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDestroyEffectImmediately;                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartParticle;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAbnormalRenderStateEffect    StartParticle;                                     // 0x0020(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHasEndParticle;                                   // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAbnormalRenderStateEffect    EndParticle;                                       // 0x00A0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIce;                                              // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEffect;                                        // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PostProcess;                                       // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeIn;                                            // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PostProcessCurveIn;                                // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PostProcessCurveOut;                               // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAbnormalParams) == 0x000010, "Wrong alignment on FCharacterAbnormalParams");
static_assert(sizeof(FCharacterAbnormalParams) == 0x000140, "Wrong size on FCharacterAbnormalParams");
static_assert(offsetof(FCharacterAbnormalParams, Particles) == 0x000000, "Member 'FCharacterAbnormalParams::Particles' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, bDestroyEffectImmediately) == 0x000010, "Member 'FCharacterAbnormalParams::bDestroyEffectImmediately' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, bHasStartParticle) == 0x000011, "Member 'FCharacterAbnormalParams::bHasStartParticle' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, StartParticle) == 0x000020, "Member 'FCharacterAbnormalParams::StartParticle' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, bHasEndParticle) == 0x000090, "Member 'FCharacterAbnormalParams::bHasEndParticle' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, EndParticle) == 0x0000A0, "Member 'FCharacterAbnormalParams::EndParticle' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, bIce) == 0x000110, "Member 'FCharacterAbnormalParams::bIce' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, bHasEffect) == 0x000111, "Member 'FCharacterAbnormalParams::bHasEffect' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, PostProcess) == 0x000118, "Member 'FCharacterAbnormalParams::PostProcess' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, TimeIn) == 0x000120, "Member 'FCharacterAbnormalParams::TimeIn' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, PostProcessCurveIn) == 0x000128, "Member 'FCharacterAbnormalParams::PostProcessCurveIn' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, Timeout) == 0x000130, "Member 'FCharacterAbnormalParams::Timeout' has a wrong offset!");
static_assert(offsetof(FCharacterAbnormalParams, PostProcessCurveOut) == 0x000138, "Member 'FCharacterAbnormalParams::PostProcessCurveOut' has a wrong offset!");

// ScriptStruct Game.SkinPartParticle
// 0x0240 (0x0240 - 0x0000)
struct FSkinPartParticle final
{
public:
	bool                                          bHasEffect;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAbnormalRenderStateCurve     MaterialCurve;                                     // 0x0008(0x00F8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCharacterAbnormalParams               LoopParticle;                                      // 0x0100(0x0140)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinPartParticle) == 0x000010, "Wrong alignment on FSkinPartParticle");
static_assert(sizeof(FSkinPartParticle) == 0x000240, "Wrong size on FSkinPartParticle");
static_assert(offsetof(FSkinPartParticle, bHasEffect) == 0x000000, "Member 'FSkinPartParticle::bHasEffect' has a wrong offset!");
static_assert(offsetof(FSkinPartParticle, MaterialCurve) == 0x000008, "Member 'FSkinPartParticle::MaterialCurve' has a wrong offset!");
static_assert(offsetof(FSkinPartParticle, LoopParticle) == 0x000100, "Member 'FSkinPartParticle::LoopParticle' has a wrong offset!");

// ScriptStruct Game.SkinPartMesh
// 0x0280 (0x0280 - 0x0000)
struct FSkinPartMesh final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PartActorClass;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PartMesh;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkinPartParticle                      ParticleBP;                                        // 0x0040(0x0240)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinPartMesh) == 0x000010, "Wrong alignment on FSkinPartMesh");
static_assert(sizeof(FSkinPartMesh) == 0x000280, "Wrong size on FSkinPartMesh");
static_assert(offsetof(FSkinPartMesh, SlotName) == 0x000000, "Member 'FSkinPartMesh::SlotName' has a wrong offset!");
static_assert(offsetof(FSkinPartMesh, PartActorClass) == 0x000008, "Member 'FSkinPartMesh::PartActorClass' has a wrong offset!");
static_assert(offsetof(FSkinPartMesh, PartMesh) == 0x000020, "Member 'FSkinPartMesh::PartMesh' has a wrong offset!");
static_assert(offsetof(FSkinPartMesh, ParticleBP) == 0x000040, "Member 'FSkinPartMesh::ParticleBP' has a wrong offset!");

// ScriptStruct Game.SkinPartTemplate
// 0x0138 (0x0140 - 0x0008)
struct FSkinPartTemplate final : public FTableRowBase
{
public:
	int32                                         SkinPartID;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMaterial>              MaterialModifyInterface;                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMaterial>              MaterialModifyBattle;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMaterial>              MaterialModifyInterface_AllAges;                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMaterial>              MaterialModifyBattle_AllAges;                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMesh>                  SkinPartModifyInterface;                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMesh>                  SkinPartModifyBattle;                              // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMesh>                  SkinPartModifyInterface_AllAges;                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinPartMesh>                  SkinPartModifyBattle_AllAges;                      // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinPartBodyMesh_Interface;                        // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinPartBodyMesh_Interface_AllAges;                // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinPartBodyMesh_Battle;                           // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinPartBodyMesh_Battle_AllAges;                   // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinPartBodyName;                                  // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinPartTemplate) == 0x000008, "Wrong alignment on FSkinPartTemplate");
static_assert(sizeof(FSkinPartTemplate) == 0x000140, "Wrong size on FSkinPartTemplate");
static_assert(offsetof(FSkinPartTemplate, SkinPartID) == 0x000008, "Member 'FSkinPartTemplate::SkinPartID' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinID) == 0x00000C, "Member 'FSkinPartTemplate::SkinID' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, MaterialModifyInterface) == 0x000010, "Member 'FSkinPartTemplate::MaterialModifyInterface' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, MaterialModifyBattle) == 0x000020, "Member 'FSkinPartTemplate::MaterialModifyBattle' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, MaterialModifyInterface_AllAges) == 0x000030, "Member 'FSkinPartTemplate::MaterialModifyInterface_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, MaterialModifyBattle_AllAges) == 0x000040, "Member 'FSkinPartTemplate::MaterialModifyBattle_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartModifyInterface) == 0x000050, "Member 'FSkinPartTemplate::SkinPartModifyInterface' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartModifyBattle) == 0x000060, "Member 'FSkinPartTemplate::SkinPartModifyBattle' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartModifyInterface_AllAges) == 0x000070, "Member 'FSkinPartTemplate::SkinPartModifyInterface_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartModifyBattle_AllAges) == 0x000080, "Member 'FSkinPartTemplate::SkinPartModifyBattle_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartBodyMesh_Interface) == 0x000090, "Member 'FSkinPartTemplate::SkinPartBodyMesh_Interface' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartBodyMesh_Interface_AllAges) == 0x0000B8, "Member 'FSkinPartTemplate::SkinPartBodyMesh_Interface_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartBodyMesh_Battle) == 0x0000E0, "Member 'FSkinPartTemplate::SkinPartBodyMesh_Battle' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartBodyMesh_Battle_AllAges) == 0x000108, "Member 'FSkinPartTemplate::SkinPartBodyMesh_Battle_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinPartTemplate, SkinPartBodyName) == 0x000130, "Member 'FSkinPartTemplate::SkinPartBodyName' has a wrong offset!");

// ScriptStruct Game.TestCharacter
// 0x0060 (0x0068 - 0x0008)
struct FTestCharacter final : public FTableRowBase
{
public:
	class FString                                 ShowName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewCharacter;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewWeapon;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSocket;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SkeletalAnim;                                      // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestCharacter) == 0x000008, "Wrong alignment on FTestCharacter");
static_assert(sizeof(FTestCharacter) == 0x000068, "Wrong size on FTestCharacter");
static_assert(offsetof(FTestCharacter, ShowName) == 0x000008, "Member 'FTestCharacter::ShowName' has a wrong offset!");
static_assert(offsetof(FTestCharacter, PreviewCharacter) == 0x000018, "Member 'FTestCharacter::PreviewCharacter' has a wrong offset!");
static_assert(offsetof(FTestCharacter, PreviewWeapon) == 0x000030, "Member 'FTestCharacter::PreviewWeapon' has a wrong offset!");
static_assert(offsetof(FTestCharacter, WeaponSocket) == 0x000048, "Member 'FTestCharacter::WeaponSocket' has a wrong offset!");
static_assert(offsetof(FTestCharacter, SkeletalAnim) == 0x000050, "Member 'FTestCharacter::SkeletalAnim' has a wrong offset!");

// ScriptStruct Game.AIDirectorTargetConfig
// 0x0018 (0x0018 - 0x0000)
struct FAIDirectorTargetConfig
{
public:
	int32                                         MonsterId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDirectorTargetConfig) == 0x000008, "Wrong alignment on FAIDirectorTargetConfig");
static_assert(sizeof(FAIDirectorTargetConfig) == 0x000018, "Wrong size on FAIDirectorTargetConfig");
static_assert(offsetof(FAIDirectorTargetConfig, MonsterId) == 0x000000, "Member 'FAIDirectorTargetConfig::MonsterId' has a wrong offset!");
static_assert(offsetof(FAIDirectorTargetConfig, Num) == 0x000004, "Member 'FAIDirectorTargetConfig::Num' has a wrong offset!");
static_assert(offsetof(FAIDirectorTargetConfig, TargetName) == 0x000008, "Member 'FAIDirectorTargetConfig::TargetName' has a wrong offset!");

// ScriptStruct Game.HealthChangeValue
// 0x01B0 (0x01B0 - 0x0000)
struct FHealthChangeValue final
{
public:
	EModifyHPType                                 HealthChangeType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 OrgHealthChangeType;                               // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalDamage;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyBunkerValue;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagValue;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElemExplosionValue;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillIntensity;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedShowDamage;                                   // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialDamageFloat>            SpecialDamageFloats;                               // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          InjuryTransmission;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InjuryTransmissionOriginID;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScaler;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoneName;                                       // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormalDir;                                      // 0x0044(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartResult;                                        // 0x0050(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartitionResult;                                   // 0x0080(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLocation;                                     // 0x00B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         HitComponent;                                      // 0x00BC(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x00C4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageOriginType;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterDamageType                            OverrideDamageType;                                // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaknessDamage;                                   // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInefficientDamage;                                // 0x00D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShoot;                                            // 0x00D7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterActionStates;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginID;                                          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginRuntimeID;                                   // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsSummonSkill;                                    // 0x00E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApplyStrength;                                     // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnimScale;                                      // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCurveHitReaction;                           // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditiveHitReaction;                        // 0x00F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitReactPerformanceType;                           // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ModifierClassTag;                                  // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ABullet>                 Bullet;                                            // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEnergy;                                         // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalHitEnergy;                                 // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x1];                                      // 0x0110(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSkillApply;                                       // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageActualSourceType                       ActualSourceType;                                  // 0x0112(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActualSourceID;                                    // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DamageTag;                                         // 0x0118(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EAbnormalState>                        AllAbnormalState;                                  // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ShieldMulti;                                       // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bElemExplosionDamage;                              // 0x014C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShootDamageBonusType;                              // 0x014D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IgnoreDamageBonusType;                             // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageSpecialTagsType;                             // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageSubTagTypes;                                 // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSkillDamageType;                             // 0x015C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DamageEffectTriggerUniqueID;                       // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCritPercent;                                      // 0x0164(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCriteType                               CriteType;                                         // 0x0168(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CriticalDamageAddtion;                             // 0x016C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SingleFireModifier;                                // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DeadState;                                         // 0x0178(0x0020)(Transient, NativeAccessSpecifierPublic)
	int32                                         BulletFireTimeID;                                  // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageEffect;                                     // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnchantDamge;                                     // 0x019D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E[0x2];                                      // 0x019E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GMDamageValue;                                     // 0x01A0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthChangeValue) == 0x000008, "Wrong alignment on FHealthChangeValue");
static_assert(sizeof(FHealthChangeValue) == 0x0001B0, "Wrong size on FHealthChangeValue");
static_assert(offsetof(FHealthChangeValue, HealthChangeType) == 0x000000, "Member 'FHealthChangeValue::HealthChangeType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, OrgHealthChangeType) == 0x000001, "Member 'FHealthChangeValue::OrgHealthChangeType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, Value) == 0x000004, "Member 'FHealthChangeValue::Value' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, AdditionalDamage) == 0x000008, "Member 'FHealthChangeValue::AdditionalDamage' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DestroyBunkerValue) == 0x00000C, "Member 'FHealthChangeValue::DestroyBunkerValue' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitLagValue) == 0x000010, "Member 'FHealthChangeValue::HitLagValue' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ElemExplosionValue) == 0x000014, "Member 'FHealthChangeValue::ElemExplosionValue' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, SkillIntensity) == 0x000018, "Member 'FHealthChangeValue::SkillIntensity' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bNeedShowDamage) == 0x00001C, "Member 'FHealthChangeValue::bNeedShowDamage' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, SpecialDamageFloats) == 0x000020, "Member 'FHealthChangeValue::SpecialDamageFloats' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, InjuryTransmission) == 0x000030, "Member 'FHealthChangeValue::InjuryTransmission' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, InjuryTransmissionOriginID) == 0x000034, "Member 'FHealthChangeValue::InjuryTransmissionOriginID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageScaler) == 0x000038, "Member 'FHealthChangeValue::DamageScaler' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitBoneName) == 0x00003C, "Member 'FHealthChangeValue::HitBoneName' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitNormalDir) == 0x000044, "Member 'FHealthChangeValue::HitNormalDir' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, PartResult) == 0x000050, "Member 'FHealthChangeValue::PartResult' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, PartitionResult) == 0x000080, "Member 'FHealthChangeValue::PartitionResult' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ApplyLocation) == 0x0000B0, "Member 'FHealthChangeValue::ApplyLocation' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitComponent) == 0x0000BC, "Member 'FHealthChangeValue::HitComponent' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, OriginLocation) == 0x0000C4, "Member 'FHealthChangeValue::OriginLocation' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageOriginType) == 0x0000D0, "Member 'FHealthChangeValue::DamageOriginType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, OverrideDamageType) == 0x0000D4, "Member 'FHealthChangeValue::OverrideDamageType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bWeaknessDamage) == 0x0000D5, "Member 'FHealthChangeValue::bWeaknessDamage' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bInefficientDamage) == 0x0000D6, "Member 'FHealthChangeValue::bInefficientDamage' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bShoot) == 0x0000D7, "Member 'FHealthChangeValue::bShoot' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, CharacterActionStates) == 0x0000D8, "Member 'FHealthChangeValue::CharacterActionStates' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, OriginID) == 0x0000DC, "Member 'FHealthChangeValue::OriginID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, OriginRuntimeID) == 0x0000E0, "Member 'FHealthChangeValue::OriginRuntimeID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bAsSummonSkill) == 0x0000E4, "Member 'FHealthChangeValue::bAsSummonSkill' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ApplyStrength) == 0x0000E8, "Member 'FHealthChangeValue::ApplyStrength' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitAnimScale) == 0x0000EC, "Member 'FHealthChangeValue::HitAnimScale' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bEnableCurveHitReaction) == 0x0000F0, "Member 'FHealthChangeValue::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bEnableAdditiveHitReaction) == 0x0000F1, "Member 'FHealthChangeValue::bEnableAdditiveHitReaction' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitReactPerformanceType) == 0x0000F4, "Member 'FHealthChangeValue::HitReactPerformanceType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ModifierClassTag) == 0x0000F8, "Member 'FHealthChangeValue::ModifierClassTag' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, Bullet) == 0x000100, "Member 'FHealthChangeValue::Bullet' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, HitEnergy) == 0x000108, "Member 'FHealthChangeValue::HitEnergy' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, CriticalHitEnergy) == 0x00010C, "Member 'FHealthChangeValue::CriticalHitEnergy' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bSkillApply) == 0x000111, "Member 'FHealthChangeValue::bSkillApply' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ActualSourceType) == 0x000112, "Member 'FHealthChangeValue::ActualSourceType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ActualSourceID) == 0x000114, "Member 'FHealthChangeValue::ActualSourceID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageTag) == 0x000118, "Member 'FHealthChangeValue::DamageTag' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, AllAbnormalState) == 0x000138, "Member 'FHealthChangeValue::AllAbnormalState' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ShieldMulti) == 0x000148, "Member 'FHealthChangeValue::ShieldMulti' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bElemExplosionDamage) == 0x00014C, "Member 'FHealthChangeValue::bElemExplosionDamage' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, ShootDamageBonusType) == 0x00014D, "Member 'FHealthChangeValue::ShootDamageBonusType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, IgnoreDamageBonusType) == 0x000150, "Member 'FHealthChangeValue::IgnoreDamageBonusType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageSpecialTagsType) == 0x000154, "Member 'FHealthChangeValue::DamageSpecialTagsType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageSubTagTypes) == 0x000158, "Member 'FHealthChangeValue::DamageSubTagTypes' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, IgnoreSkillDamageType) == 0x00015C, "Member 'FHealthChangeValue::IgnoreSkillDamageType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DamageEffectTriggerUniqueID) == 0x000160, "Member 'FHealthChangeValue::DamageEffectTriggerUniqueID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, FCritPercent) == 0x000164, "Member 'FHealthChangeValue::FCritPercent' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, CriteType) == 0x000168, "Member 'FHealthChangeValue::CriteType' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, CriticalDamageAddtion) == 0x00016C, "Member 'FHealthChangeValue::CriticalDamageAddtion' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, SingleFireModifier) == 0x000170, "Member 'FHealthChangeValue::SingleFireModifier' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, DeadState) == 0x000178, "Member 'FHealthChangeValue::DeadState' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, BulletFireTimeID) == 0x000198, "Member 'FHealthChangeValue::BulletFireTimeID' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bDamageEffect) == 0x00019C, "Member 'FHealthChangeValue::bDamageEffect' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, bEnchantDamge) == 0x00019D, "Member 'FHealthChangeValue::bEnchantDamge' has a wrong offset!");
static_assert(offsetof(FHealthChangeValue, GMDamageValue) == 0x0001A0, "Member 'FHealthChangeValue::GMDamageValue' has a wrong offset!");

// ScriptStruct Game.FogConfig2st
// 0x0024 (0x0024 - 0x0000)
struct FFogConfig2st final
{
public:
	struct FLinearColor                           FogColor2st;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity2st;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightMax2st;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightMin2st;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFade2st;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightOffset2st;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFogConfig2st) == 0x000004, "Wrong alignment on FFogConfig2st");
static_assert(sizeof(FFogConfig2st) == 0x000024, "Wrong size on FFogConfig2st");
static_assert(offsetof(FFogConfig2st, FogColor2st) == 0x000000, "Member 'FFogConfig2st::FogColor2st' has a wrong offset!");
static_assert(offsetof(FFogConfig2st, FogDensity2st) == 0x000010, "Member 'FFogConfig2st::FogDensity2st' has a wrong offset!");
static_assert(offsetof(FFogConfig2st, FogHeightMax2st) == 0x000014, "Member 'FFogConfig2st::FogHeightMax2st' has a wrong offset!");
static_assert(offsetof(FFogConfig2st, FogHeightMin2st) == 0x000018, "Member 'FFogConfig2st::FogHeightMin2st' has a wrong offset!");
static_assert(offsetof(FFogConfig2st, FogHeightFade2st) == 0x00001C, "Member 'FFogConfig2st::FogHeightFade2st' has a wrong offset!");
static_assert(offsetof(FFogConfig2st, FogHeightOffset2st) == 0x000020, "Member 'FFogConfig2st::FogHeightOffset2st' has a wrong offset!");

// ScriptStruct Game.TaskActionInfo
// 0x0028 (0x0028 - 0x0000)
struct FTaskActionInfo final
{
public:
	ELevelTaskAction                              Action;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Param1;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param2;                                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumParam;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumParam2;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMulticast;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0xB];                                       // 0x001D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTaskActionInfo) == 0x000004, "Wrong alignment on FTaskActionInfo");
static_assert(sizeof(FTaskActionInfo) == 0x000028, "Wrong size on FTaskActionInfo");
static_assert(offsetof(FTaskActionInfo, Action) == 0x000000, "Member 'FTaskActionInfo::Action' has a wrong offset!");
static_assert(offsetof(FTaskActionInfo, Param1) == 0x000004, "Member 'FTaskActionInfo::Param1' has a wrong offset!");
static_assert(offsetof(FTaskActionInfo, Param2) == 0x00000C, "Member 'FTaskActionInfo::Param2' has a wrong offset!");
static_assert(offsetof(FTaskActionInfo, NumParam) == 0x000014, "Member 'FTaskActionInfo::NumParam' has a wrong offset!");
static_assert(offsetof(FTaskActionInfo, NumParam2) == 0x000018, "Member 'FTaskActionInfo::NumParam2' has a wrong offset!");
static_assert(offsetof(FTaskActionInfo, bUseMulticast) == 0x00001C, "Member 'FTaskActionInfo::bUseMulticast' has a wrong offset!");

// ScriptStruct Game.TaskActionHandle
// 0x0030 (0x0030 - 0x0000)
struct FTaskActionHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ELevelTaskEvent                               TargetEvent;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTaskActionInfo                        ActionInfo;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskActionHandle) == 0x000004, "Wrong alignment on FTaskActionHandle");
static_assert(sizeof(FTaskActionHandle) == 0x000030, "Wrong size on FTaskActionHandle");
static_assert(offsetof(FTaskActionHandle, TargetEvent) == 0x000004, "Member 'FTaskActionHandle::TargetEvent' has a wrong offset!");
static_assert(offsetof(FTaskActionHandle, ActionInfo) == 0x000008, "Member 'FTaskActionHandle::ActionInfo' has a wrong offset!");

// ScriptStruct Game.PreDamageResultData
// 0x01E0 (0x01E0 - 0x0000)
struct FPreDamageResultData final
{
public:
	struct FHealthChangeValue                     ChangeValue;                                       // 0x0000(0x01B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ModifyResult;                                      // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  Luancher;                                          // 0x01B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Target;                                            // 0x01C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  DamageEffectLuancher;                              // 0x01C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreHealthValue;                                    // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostHealthValue;                                   // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreDamageResultData) == 0x000008, "Wrong alignment on FPreDamageResultData");
static_assert(sizeof(FPreDamageResultData) == 0x0001E0, "Wrong size on FPreDamageResultData");
static_assert(offsetof(FPreDamageResultData, ChangeValue) == 0x000000, "Member 'FPreDamageResultData::ChangeValue' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, ModifyResult) == 0x0001B0, "Member 'FPreDamageResultData::ModifyResult' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, Luancher) == 0x0001B8, "Member 'FPreDamageResultData::Luancher' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, Target) == 0x0001C0, "Member 'FPreDamageResultData::Target' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, DamageEffectLuancher) == 0x0001C8, "Member 'FPreDamageResultData::DamageEffectLuancher' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, DamageValue) == 0x0001D0, "Member 'FPreDamageResultData::DamageValue' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, PreHealthValue) == 0x0001D4, "Member 'FPreDamageResultData::PreHealthValue' has a wrong offset!");
static_assert(offsetof(FPreDamageResultData, PostHealthValue) == 0x0001D8, "Member 'FPreDamageResultData::PostHealthValue' has a wrong offset!");

// ScriptStruct Game.VATCharacterRenderData
// 0x0018 (0x0018 - 0x0000)
struct FVATCharacterRenderData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVATCrowdMaterialManager*               CrowdMaterialManager;                              // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATCharacterRenderData) == 0x000008, "Wrong alignment on FVATCharacterRenderData");
static_assert(sizeof(FVATCharacterRenderData) == 0x000018, "Wrong size on FVATCharacterRenderData");
static_assert(offsetof(FVATCharacterRenderData, CrowdMaterialManager) == 0x000010, "Member 'FVATCharacterRenderData::CrowdMaterialManager' has a wrong offset!");

// ScriptStruct Game.ApplyDamageResultData
// 0x00C0 (0x00C0 - 0x0000)
struct FApplyDamageResultData final
{
public:
	float                                         OriginDamageValue;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RealDeductValue;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverdoseDamageValue;                               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamageValue;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverdoseHealthValue;                               // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthDamageValue;                                 // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RealHealthDamageValue;                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingHealth;                                   // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageCauseShieldBreak;                           // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageCauseDead;                                  // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  Causer;                                            // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Target;                                            // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifyResult;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 DamageType;                                        // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageOriginType;                                  // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginID;                                          // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginRuntimeID;                                   // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsSummonSkill;                                    // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDotDamage;                                        // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRangeDamage;                                      // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InjuryTransmission;                                // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InjuryTransmissionOriginID;                        // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLoc;                                         // 0x0054(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLoc;                                          // 0x0060(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageActualSourceType                       ActualSourceType;                                  // 0x006C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActualSourceID;                                    // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DamageTag;                                         // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EAbnormalState>                        AllAbnormalState;                                  // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ElemExplosionCount;                                // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSkillDamageType;                             // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterActionStates;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageSpecialTagsType;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FApplyDamageResultData) == 0x000008, "Wrong alignment on FApplyDamageResultData");
static_assert(sizeof(FApplyDamageResultData) == 0x0000C0, "Wrong size on FApplyDamageResultData");
static_assert(offsetof(FApplyDamageResultData, OriginDamageValue) == 0x000000, "Member 'FApplyDamageResultData::OriginDamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, DamageValue) == 0x000004, "Member 'FApplyDamageResultData::DamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, RealDeductValue) == 0x000008, "Member 'FApplyDamageResultData::RealDeductValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, OverdoseDamageValue) == 0x00000C, "Member 'FApplyDamageResultData::OverdoseDamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ShieldDamageValue) == 0x000010, "Member 'FApplyDamageResultData::ShieldDamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, OverdoseHealthValue) == 0x000014, "Member 'FApplyDamageResultData::OverdoseHealthValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, HealthDamageValue) == 0x000018, "Member 'FApplyDamageResultData::HealthDamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, RealHealthDamageValue) == 0x00001C, "Member 'FApplyDamageResultData::RealHealthDamageValue' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, RemainingHealth) == 0x000020, "Member 'FApplyDamageResultData::RemainingHealth' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, bDamageCauseShieldBreak) == 0x000024, "Member 'FApplyDamageResultData::bDamageCauseShieldBreak' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, bDamageCauseDead) == 0x000025, "Member 'FApplyDamageResultData::bDamageCauseDead' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, Causer) == 0x000028, "Member 'FApplyDamageResultData::Causer' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, Target) == 0x000030, "Member 'FApplyDamageResultData::Target' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ModifyResult) == 0x000038, "Member 'FApplyDamageResultData::ModifyResult' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, DamageType) == 0x00003C, "Member 'FApplyDamageResultData::DamageType' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, DamageOriginType) == 0x000040, "Member 'FApplyDamageResultData::DamageOriginType' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, OriginID) == 0x000044, "Member 'FApplyDamageResultData::OriginID' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, OriginRuntimeID) == 0x000048, "Member 'FApplyDamageResultData::OriginRuntimeID' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, bAsSummonSkill) == 0x00004C, "Member 'FApplyDamageResultData::bAsSummonSkill' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, bDotDamage) == 0x00004D, "Member 'FApplyDamageResultData::bDotDamage' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, bRangeDamage) == 0x00004E, "Member 'FApplyDamageResultData::bRangeDamage' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, InjuryTransmission) == 0x00004F, "Member 'FApplyDamageResultData::InjuryTransmission' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, InjuryTransmissionOriginID) == 0x000050, "Member 'FApplyDamageResultData::InjuryTransmissionOriginID' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, OriginLoc) == 0x000054, "Member 'FApplyDamageResultData::OriginLoc' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ApplyLoc) == 0x000060, "Member 'FApplyDamageResultData::ApplyLoc' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ActualSourceType) == 0x00006C, "Member 'FApplyDamageResultData::ActualSourceType' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ActualSourceID) == 0x000070, "Member 'FApplyDamageResultData::ActualSourceID' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, DamageTag) == 0x000078, "Member 'FApplyDamageResultData::DamageTag' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, AllAbnormalState) == 0x000098, "Member 'FApplyDamageResultData::AllAbnormalState' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, ElemExplosionCount) == 0x0000A8, "Member 'FApplyDamageResultData::ElemExplosionCount' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, IgnoreSkillDamageType) == 0x0000AC, "Member 'FApplyDamageResultData::IgnoreSkillDamageType' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, CharacterActionStates) == 0x0000B0, "Member 'FApplyDamageResultData::CharacterActionStates' has a wrong offset!");
static_assert(offsetof(FApplyDamageResultData, DamageSpecialTagsType) == 0x0000B4, "Member 'FApplyDamageResultData::DamageSpecialTagsType' has a wrong offset!");

// ScriptStruct Game.PreviewMeshReplace_MainBody
// 0x0068 (0x0068 - 0x0000)
struct FPreviewMeshReplace_MainBody final
{
public:
	struct FSoftObjectPath                        SkeletalMeshPath;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SkeletalMesh_AllAgesPath;                          // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SequencePath;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutLineLevel;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewMeshReplace_MainBody) == 0x000008, "Wrong alignment on FPreviewMeshReplace_MainBody");
static_assert(sizeof(FPreviewMeshReplace_MainBody) == 0x000068, "Wrong size on FPreviewMeshReplace_MainBody");
static_assert(offsetof(FPreviewMeshReplace_MainBody, SkeletalMeshPath) == 0x000000, "Member 'FPreviewMeshReplace_MainBody::SkeletalMeshPath' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_MainBody, SkeletalMesh_AllAgesPath) == 0x000018, "Member 'FPreviewMeshReplace_MainBody::SkeletalMesh_AllAgesPath' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_MainBody, SequencePath) == 0x000030, "Member 'FPreviewMeshReplace_MainBody::SequencePath' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_MainBody, bAttach) == 0x000048, "Member 'FPreviewMeshReplace_MainBody::bAttach' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_MainBody, OutLineLevel) == 0x000050, "Member 'FPreviewMeshReplace_MainBody::OutLineLevel' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_MainBody, Socket) == 0x000060, "Member 'FPreviewMeshReplace_MainBody::Socket' has a wrong offset!");

// ScriptStruct Game.AllAnimTrackData
// 0x0038 (0x0038 - 0x0000)
struct FAllAnimTrackData final
{
public:
	TArray<struct FAnimTrackData>                 AllTrack;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FFrameNumber                           LowerBound;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameNumber                           UpperBound;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAllAnimTrackData) == 0x000008, "Wrong alignment on FAllAnimTrackData");
static_assert(sizeof(FAllAnimTrackData) == 0x000038, "Wrong size on FAllAnimTrackData");
static_assert(offsetof(FAllAnimTrackData, AllTrack) == 0x000000, "Member 'FAllAnimTrackData::AllTrack' has a wrong offset!");
static_assert(offsetof(FAllAnimTrackData, LowerBound) == 0x000010, "Member 'FAllAnimTrackData::LowerBound' has a wrong offset!");
static_assert(offsetof(FAllAnimTrackData, UpperBound) == 0x000014, "Member 'FAllAnimTrackData::UpperBound' has a wrong offset!");

// ScriptStruct Game.WarningTipsInfo
// 0x0018 (0x0018 - 0x0000)
struct FWarningTipsInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWarningTipsInfo) == 0x000008, "Wrong alignment on FWarningTipsInfo");
static_assert(sizeof(FWarningTipsInfo) == 0x000018, "Wrong size on FWarningTipsInfo");
static_assert(offsetof(FWarningTipsInfo, Target) == 0x000008, "Member 'FWarningTipsInfo::Target' has a wrong offset!");

// ScriptStruct Game.FightModifierSpecialSignaData
// 0x0010 (0x0010 - 0x0000)
struct FFightModifierSpecialSignaData final
{
public:
	TArray<class UFightModifierSpecialSignaItem*> Items;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFightModifierSpecialSignaData) == 0x000008, "Wrong alignment on FFightModifierSpecialSignaData");
static_assert(sizeof(FFightModifierSpecialSignaData) == 0x000010, "Wrong size on FFightModifierSpecialSignaData");
static_assert(offsetof(FFightModifierSpecialSignaData, Items) == 0x000000, "Member 'FFightModifierSpecialSignaData::Items' has a wrong offset!");

// ScriptStruct Game.WeaponFireParam
// 0x01D0 (0x01D0 - 0x0000)
struct FWeaponFireParam final
{
public:
	float                                         MoveScatteringArea;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushScatteringArea;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandScatteringArea;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimScatteringArea;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMaxScatteringArea;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushMaxScatteringArea;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandMaxScatteringArea;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimMaxScatteringArea;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootAddScatter;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootAddScatter;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootAddScatter;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopFireRecoverScatterSpeed;                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShootScatterCurve;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShootScatterAddCurve;                              // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootScatterTime;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootScatterTime;                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootScatterTime;                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootScatterWaitRecoverTime;                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ShootScatterRecoverCurve;                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootScatterRecoverTime;                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootScatterRecoverTime;                      // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootScatterRecoverTime;                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShoulderShotRecoilForceYaw;                        // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InAimShotRecoilForceYaw;                           // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShoulderShotRecoilForcePitch;                      // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InAimShotRecoilForcePitch;                         // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilForceLimit;                                  // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilForceTime;                                   // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        RecoilPath;                                        // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RecoilRecoveryPath;                                // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RecoilForcePitchRateCurve;                         // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilForcePitchRateRecoverTime;                   // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PreheatScatterCurvePath;                           // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ShootCameraShake;                                  // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AimShootCameraShake;                               // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraShakeCurvePath;                              // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ERangeAttackState, struct FRecoilSetup>  RecoilSetup;                                       // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         PhysicalHitStrength;                               // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponHitAnimScale;                                // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCurveHitReaction;                           // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditiveHitReaction;                        // 0x01C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitReactPerformance                          HitReactPerformanceType;                           // 0x01CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB[0x5];                                      // 0x01CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponFireParam) == 0x000008, "Wrong alignment on FWeaponFireParam");
static_assert(sizeof(FWeaponFireParam) == 0x0001D0, "Wrong size on FWeaponFireParam");
static_assert(offsetof(FWeaponFireParam, MoveScatteringArea) == 0x000000, "Member 'FWeaponFireParam::MoveScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RushScatteringArea) == 0x000004, "Member 'FWeaponFireParam::RushScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StandScatteringArea) == 0x000008, "Member 'FWeaponFireParam::StandScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimScatteringArea) == 0x00000C, "Member 'FWeaponFireParam::AimScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, MoveMaxScatteringArea) == 0x000010, "Member 'FWeaponFireParam::MoveMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RushMaxScatteringArea) == 0x000014, "Member 'FWeaponFireParam::RushMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StandMaxScatteringArea) == 0x000018, "Member 'FWeaponFireParam::StandMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimMaxScatteringArea) == 0x00001C, "Member 'FWeaponFireParam::AimMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, MoveShootAddScatter) == 0x000020, "Member 'FWeaponFireParam::MoveShootAddScatter' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StandShootAddScatter) == 0x000024, "Member 'FWeaponFireParam::StandShootAddScatter' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimShootAddScatter) == 0x000028, "Member 'FWeaponFireParam::AimShootAddScatter' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StopFireRecoverScatterSpeed) == 0x00002C, "Member 'FWeaponFireParam::StopFireRecoverScatterSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, bUseShootScatterCurve) == 0x000030, "Member 'FWeaponFireParam::bUseShootScatterCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShootScatterAddCurve) == 0x000038, "Member 'FWeaponFireParam::ShootScatterAddCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, MoveShootScatterTime) == 0x000050, "Member 'FWeaponFireParam::MoveShootScatterTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StandShootScatterTime) == 0x000054, "Member 'FWeaponFireParam::StandShootScatterTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimShootScatterTime) == 0x000058, "Member 'FWeaponFireParam::AimShootScatterTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShootScatterWaitRecoverTime) == 0x00005C, "Member 'FWeaponFireParam::ShootScatterWaitRecoverTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShootScatterRecoverCurve) == 0x000060, "Member 'FWeaponFireParam::ShootScatterRecoverCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, MoveShootScatterRecoverTime) == 0x000078, "Member 'FWeaponFireParam::MoveShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, StandShootScatterRecoverTime) == 0x00007C, "Member 'FWeaponFireParam::StandShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimShootScatterRecoverTime) == 0x000080, "Member 'FWeaponFireParam::AimShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShoulderShotRecoilForceYaw) == 0x000084, "Member 'FWeaponFireParam::ShoulderShotRecoilForceYaw' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, InAimShotRecoilForceYaw) == 0x00008C, "Member 'FWeaponFireParam::InAimShotRecoilForceYaw' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShoulderShotRecoilForcePitch) == 0x000094, "Member 'FWeaponFireParam::ShoulderShotRecoilForcePitch' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, InAimShotRecoilForcePitch) == 0x00009C, "Member 'FWeaponFireParam::InAimShotRecoilForcePitch' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilForceLimit) == 0x0000A4, "Member 'FWeaponFireParam::RecoilForceLimit' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilForceTime) == 0x0000B0, "Member 'FWeaponFireParam::RecoilForceTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilPath) == 0x0000C0, "Member 'FWeaponFireParam::RecoilPath' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilRecoveryPath) == 0x0000D8, "Member 'FWeaponFireParam::RecoilRecoveryPath' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilForcePitchRateCurve) == 0x0000F0, "Member 'FWeaponFireParam::RecoilForcePitchRateCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilForcePitchRateRecoverTime) == 0x000108, "Member 'FWeaponFireParam::RecoilForcePitchRateRecoverTime' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, PreheatScatterCurvePath) == 0x000110, "Member 'FWeaponFireParam::PreheatScatterCurvePath' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, ShootCameraShake) == 0x000128, "Member 'FWeaponFireParam::ShootCameraShake' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, AimShootCameraShake) == 0x000140, "Member 'FWeaponFireParam::AimShootCameraShake' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, CameraShakeCurvePath) == 0x000158, "Member 'FWeaponFireParam::CameraShakeCurvePath' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, RecoilSetup) == 0x000170, "Member 'FWeaponFireParam::RecoilSetup' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, PhysicalHitStrength) == 0x0001C0, "Member 'FWeaponFireParam::PhysicalHitStrength' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, WeaponHitAnimScale) == 0x0001C4, "Member 'FWeaponFireParam::WeaponHitAnimScale' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, bEnableCurveHitReaction) == 0x0001C8, "Member 'FWeaponFireParam::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, bEnableAdditiveHitReaction) == 0x0001C9, "Member 'FWeaponFireParam::bEnableAdditiveHitReaction' has a wrong offset!");
static_assert(offsetof(FWeaponFireParam, HitReactPerformanceType) == 0x0001CA, "Member 'FWeaponFireParam::HitReactPerformanceType' has a wrong offset!");

// ScriptStruct Game.GameVehicleAngularDampEff
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FGameVehicleAngularDampEff final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameVehicleAngularDampEff) == 0x000004, "Wrong alignment on FGameVehicleAngularDampEff");
static_assert(sizeof(FGameVehicleAngularDampEff) == 0x000008, "Wrong size on FGameVehicleAngularDampEff");

// ScriptStruct Game.StateBlockTypeNames
// 0x0010 (0x0010 - 0x0000)
struct FStateBlockTypeNames final
{
public:
	TArray<class FString>                         TypeNames;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateBlockTypeNames) == 0x000008, "Wrong alignment on FStateBlockTypeNames");
static_assert(sizeof(FStateBlockTypeNames) == 0x000010, "Wrong size on FStateBlockTypeNames");
static_assert(offsetof(FStateBlockTypeNames, TypeNames) == 0x000000, "Member 'FStateBlockTypeNames::TypeNames' has a wrong offset!");

// ScriptStruct Game.BulletHitSearchSetting
// 0x00D0 (0x00D0 - 0x0000)
struct FBulletHitSearchSetting final
{
public:
	TArray<ECampRelation>                         TargetCampRelations;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESearchTargetPartType                         TargetPartType;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESearchTargetType>                     ActorType;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         EmitterRolePickTypes;                              // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RequireModifierIDs;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockModifierIDs;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RequireModifierTags;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlockModifierTags;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHitOriginType                                ActorDistanceCheckOriginType;                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorDistanceCheckOriginSocket;                    // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ActorRangeLimit;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerifyClosestDistance;                            // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginType                                ActorTraceCheckOriginType;                         // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorTraceCheckOriginSocket;                       // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ActorTraceChannel;                                 // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorFilterByAirBlock;                            // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStateBlockTypeNames>           StateBlockTypeNames;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 SearcherFilter;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletHitSearchSetting) == 0x000008, "Wrong alignment on FBulletHitSearchSetting");
static_assert(sizeof(FBulletHitSearchSetting) == 0x0000D0, "Wrong size on FBulletHitSearchSetting");
static_assert(offsetof(FBulletHitSearchSetting, TargetCampRelations) == 0x000000, "Member 'FBulletHitSearchSetting::TargetCampRelations' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, TargetPartType) == 0x000010, "Member 'FBulletHitSearchSetting::TargetPartType' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorType) == 0x000018, "Member 'FBulletHitSearchSetting::ActorType' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, EmitterRolePickTypes) == 0x000028, "Member 'FBulletHitSearchSetting::EmitterRolePickTypes' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, RequireModifierIDs) == 0x000030, "Member 'FBulletHitSearchSetting::RequireModifierIDs' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, BlockModifierIDs) == 0x000040, "Member 'FBulletHitSearchSetting::BlockModifierIDs' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, RequireModifierTags) == 0x000050, "Member 'FBulletHitSearchSetting::RequireModifierTags' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, BlockModifierTags) == 0x000060, "Member 'FBulletHitSearchSetting::BlockModifierTags' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorDistanceCheckOriginType) == 0x000070, "Member 'FBulletHitSearchSetting::ActorDistanceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorDistanceCheckOriginSocket) == 0x000078, "Member 'FBulletHitSearchSetting::ActorDistanceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorRangeLimit) == 0x000088, "Member 'FBulletHitSearchSetting::ActorRangeLimit' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, bVerifyClosestDistance) == 0x000090, "Member 'FBulletHitSearchSetting::bVerifyClosestDistance' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorTraceCheckOriginType) == 0x000091, "Member 'FBulletHitSearchSetting::ActorTraceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorTraceCheckOriginSocket) == 0x000098, "Member 'FBulletHitSearchSetting::ActorTraceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, ActorTraceChannel) == 0x0000A8, "Member 'FBulletHitSearchSetting::ActorTraceChannel' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, bActorFilterByAirBlock) == 0x0000A9, "Member 'FBulletHitSearchSetting::bActorFilterByAirBlock' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, StateBlockTypeNames) == 0x0000B0, "Member 'FBulletHitSearchSetting::StateBlockTypeNames' has a wrong offset!");
static_assert(offsetof(FBulletHitSearchSetting, SearcherFilter) == 0x0000C0, "Member 'FBulletHitSearchSetting::SearcherFilter' has a wrong offset!");

// ScriptStruct Game.BulletExhibition
// 0x0118 (0x0118 - 0x0000)
struct FBulletExhibition final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereCollisionRadius;                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombCollisionRadius;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityCollisionRadius;                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionPurposeTag;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  CollisionPresets;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bParticlePathComposite;                            // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ParticlePath;                                      // 0x0028(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleScale;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TailBeamParticlePath;                              // 0x0048(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TailBeamParticleParamName;                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TailBeamParticleParam;                             // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TailParticlePath;                                  // 0x0070(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TailParticlePlayPre;                               // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BulletFireEffect;                                  // 0x0090(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireEffectAttachWeapon;                           // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LaunchSoundEvent;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlyingSoundEvent;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlyingSoundFadeOutTime;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletDistance;                                    // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DopplerDistance;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        WarningParticlePath;                               // 0x00E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         WarningTipsActorPath;                              // 0x00F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WPDisableOnRecycle;                                // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletExhibition) == 0x000008, "Wrong alignment on FBulletExhibition");
static_assert(sizeof(FBulletExhibition) == 0x000118, "Wrong size on FBulletExhibition");
static_assert(offsetof(FBulletExhibition, Scale) == 0x000000, "Member 'FBulletExhibition::Scale' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, SphereCollisionRadius) == 0x000004, "Member 'FBulletExhibition::SphereCollisionRadius' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, BombCollisionRadius) == 0x000008, "Member 'FBulletExhibition::BombCollisionRadius' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, AbilityCollisionRadius) == 0x00000C, "Member 'FBulletExhibition::AbilityCollisionRadius' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, CollisionPurposeTag) == 0x000010, "Member 'FBulletExhibition::CollisionPurposeTag' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, CollisionPresets) == 0x000018, "Member 'FBulletExhibition::CollisionPresets' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, bParticlePathComposite) == 0x000020, "Member 'FBulletExhibition::bParticlePathComposite' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, ParticlePath) == 0x000028, "Member 'FBulletExhibition::ParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, ParticleScale) == 0x000040, "Member 'FBulletExhibition::ParticleScale' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, TailBeamParticlePath) == 0x000048, "Member 'FBulletExhibition::TailBeamParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, TailBeamParticleParamName) == 0x000060, "Member 'FBulletExhibition::TailBeamParticleParamName' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, TailBeamParticleParam) == 0x000068, "Member 'FBulletExhibition::TailBeamParticleParam' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, TailParticlePath) == 0x000070, "Member 'FBulletExhibition::TailParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, TailParticlePlayPre) == 0x000088, "Member 'FBulletExhibition::TailParticlePlayPre' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, BulletFireEffect) == 0x000090, "Member 'FBulletExhibition::BulletFireEffect' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, bFireEffectAttachWeapon) == 0x0000A8, "Member 'FBulletExhibition::bFireEffectAttachWeapon' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, LaunchSoundEvent) == 0x0000B0, "Member 'FBulletExhibition::LaunchSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, FlyingSoundEvent) == 0x0000C0, "Member 'FBulletExhibition::FlyingSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, FlyingSoundFadeOutTime) == 0x0000D0, "Member 'FBulletExhibition::FlyingSoundFadeOutTime' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, BulletDistance) == 0x0000D4, "Member 'FBulletExhibition::BulletDistance' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, DopplerDistance) == 0x0000D8, "Member 'FBulletExhibition::DopplerDistance' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, WarningParticlePath) == 0x0000E0, "Member 'FBulletExhibition::WarningParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, WarningTipsActorPath) == 0x0000F8, "Member 'FBulletExhibition::WarningTipsActorPath' has a wrong offset!");
static_assert(offsetof(FBulletExhibition, WPDisableOnRecycle) == 0x000110, "Member 'FBulletExhibition::WPDisableOnRecycle' has a wrong offset!");

// ScriptStruct Game.BulletThrough
// 0x000C (0x000C - 0x0000)
struct FBulletThrough final
{
public:
	bool                                          Through;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ThroughCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletThrouthType                            ThroughType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ThroughIgnoreType;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ThroughIgnoreOnlyAOEAcc;                           // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletThrough) == 0x000004, "Wrong alignment on FBulletThrough");
static_assert(sizeof(FBulletThrough) == 0x00000C, "Wrong size on FBulletThrough");
static_assert(offsetof(FBulletThrough, Through) == 0x000000, "Member 'FBulletThrough::Through' has a wrong offset!");
static_assert(offsetof(FBulletThrough, ThroughCount) == 0x000004, "Member 'FBulletThrough::ThroughCount' has a wrong offset!");
static_assert(offsetof(FBulletThrough, ThroughType) == 0x000008, "Member 'FBulletThrough::ThroughType' has a wrong offset!");
static_assert(offsetof(FBulletThrough, ThroughIgnoreType) == 0x000009, "Member 'FBulletThrough::ThroughIgnoreType' has a wrong offset!");
static_assert(offsetof(FBulletThrough, ThroughIgnoreOnlyAOEAcc) == 0x00000A, "Member 'FBulletThrough::ThroughIgnoreOnlyAOEAcc' has a wrong offset!");

// ScriptStruct Game.BulletInfo
// 0x0498 (0x04A0 - 0x0008)
struct FBulletInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsActiveSearchSettings;                           // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletHitSearchSetting                SearchSettings;                                    // 0x0028(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ThroughMaxPartInTarget;                            // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThroughMaxTargetNum;                               // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BulletClass;                                       // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BulletClassTag;                                    // 0x011C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletCountLimit;                                  // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWeaponDamage;                               // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletHitType                                HitEffectType;                                     // 0x0129(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletWorkType                               SpawnType;                                         // 0x012A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B[0x5];                                      // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletExhibition                      BulletExhibition;                                  // 0x0130(0x0118)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ECampRelation>                         IgnoreCampRelations;                               // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBulletThrough                         DefaultBulletThrough;                              // 0x0258(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponDamageTag;                                   // 0x0264(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterp;                                    // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GravityScaleCurve;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletMovementType                           MovementType;                                      // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Frequency;                                         // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyRange;                                    // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletExtremeRange;                                // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletCollitionFlags;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletCollitionApplyFlags;                         // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitDie;                                            // 0x02AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LifeEndApply;                                      // 0x02AD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE[0x2];                                      // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LifeEndEffectParticlePath;                         // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LifeEndEffectSoundEvent;                           // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SameTargetMaxNum;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetNum;                                      // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             BulletChannel;                                     // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BulletRayPath;                                     // 0x02E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletRayParamName;                                // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BulletRayParam;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BulletRayPlayPre;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletRayDestroyImmediately;                      // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StopFireParticlePath;                              // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiTrace;                                       // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TraceShape;                                        // 0x033C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidthTraceNum;                                     // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidthHeightNum;                                    // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStrength;                                       // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCurveHitReaction;                           // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitShakeEffectSelfOnly;                           // 0x0351(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         CameraShakeClassPath;                              // 0x0358(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeMaxValidDistance;                             // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttenuation;                                      // 0x0374(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         HitAbilityTargetShake_NoAimPath;                   // 0x0378(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         HitAbilityTargetShake_InAimPath;                   // 0x0390(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectNotPlayInTime;                            // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HitEffectPlayPre;                                  // 0x03AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitWeaknessEffectNotPlayInTime;                    // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HitWeaknessEffectPlayPre;                          // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitEffectTable;                                // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitEffectID;                                       // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectComposite;                               // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitEffectParticlePath;                             // 0x03D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectAttach;                                  // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectFollowBulletRotation;                    // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreHitEffectRotation;                          // 0x03EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EB[0x1];                                      // 0x03EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleCount;                                  // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeTime;                                          // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0xC];                                      // 0x03F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitEffectRelativeTransform;                        // 0x0400(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 HitEffectSoundEvent;                               // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SubSkillIDs;                                       // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESkillCriteType                               WeaknessCriteType;                                 // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCriteType                               NormalCriteType;                                   // 0x0451(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 OverrideModifyHPType;                              // 0x0452(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_453[0x1];                                      // 0x0453(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CastRange;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ActorTraceChannel;                                 // 0x0458(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BombDamageType;                                    // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BombEmitterID;                                     // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletDirectHitAsBomb;                            // 0x0464(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbnormalStateApplyInfo>        AbnormalInfos;                                     // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 BowArrowTag;                                       // 0x0478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HomingStopTime;                                    // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingRandomRange;                                 // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceGround;                                      // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChainInfectionApply;                              // 0x0495(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffect;                                    // 0x0496(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_497[0x9];                                      // 0x0497(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletInfo) == 0x000010, "Wrong alignment on FBulletInfo");
static_assert(sizeof(FBulletInfo) == 0x0004A0, "Wrong size on FBulletInfo");
static_assert(offsetof(FBulletInfo, ID) == 0x000008, "Member 'FBulletInfo::ID' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bRepaceData) == 0x00000C, "Member 'FBulletInfo::bRepaceData' has a wrong offset!");
static_assert(offsetof(FBulletInfo, ReplaceParamArray) == 0x000010, "Member 'FBulletInfo::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bIsActiveSearchSettings) == 0x000020, "Member 'FBulletInfo::bIsActiveSearchSettings' has a wrong offset!");
static_assert(offsetof(FBulletInfo, SearchSettings) == 0x000028, "Member 'FBulletInfo::SearchSettings' has a wrong offset!");
static_assert(offsetof(FBulletInfo, ThroughMaxPartInTarget) == 0x0000F8, "Member 'FBulletInfo::ThroughMaxPartInTarget' has a wrong offset!");
static_assert(offsetof(FBulletInfo, ThroughMaxTargetNum) == 0x0000FC, "Member 'FBulletInfo::ThroughMaxTargetNum' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletClass) == 0x000100, "Member 'FBulletInfo::BulletClass' has a wrong offset!");
static_assert(offsetof(FBulletInfo, EmitterID) == 0x000118, "Member 'FBulletInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletClassTag) == 0x00011C, "Member 'FBulletInfo::BulletClassTag' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletCountLimit) == 0x000124, "Member 'FBulletInfo::BulletCountLimit' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bIgnoreWeaponDamage) == 0x000128, "Member 'FBulletInfo::bIgnoreWeaponDamage' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectType) == 0x000129, "Member 'FBulletInfo::HitEffectType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, SpawnType) == 0x00012A, "Member 'FBulletInfo::SpawnType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletExhibition) == 0x000130, "Member 'FBulletInfo::BulletExhibition' has a wrong offset!");
static_assert(offsetof(FBulletInfo, IgnoreCampRelations) == 0x000248, "Member 'FBulletInfo::IgnoreCampRelations' has a wrong offset!");
static_assert(offsetof(FBulletInfo, DefaultBulletThrough) == 0x000258, "Member 'FBulletInfo::DefaultBulletThrough' has a wrong offset!");
static_assert(offsetof(FBulletInfo, WeaponDamageTag) == 0x000264, "Member 'FBulletInfo::WeaponDamageTag' has a wrong offset!");
static_assert(offsetof(FBulletInfo, InitialSpeed) == 0x00026C, "Member 'FBulletInfo::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FBulletInfo, Acceleration) == 0x000270, "Member 'FBulletInfo::Acceleration' has a wrong offset!");
static_assert(offsetof(FBulletInfo, AccelerationCurve) == 0x000278, "Member 'FBulletInfo::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(FBulletInfo, RotationInterp) == 0x000280, "Member 'FBulletInfo::RotationInterp' has a wrong offset!");
static_assert(offsetof(FBulletInfo, GravityScale) == 0x000284, "Member 'FBulletInfo::GravityScale' has a wrong offset!");
static_assert(offsetof(FBulletInfo, GravityScaleCurve) == 0x000288, "Member 'FBulletInfo::GravityScaleCurve' has a wrong offset!");
static_assert(offsetof(FBulletInfo, MovementType) == 0x000290, "Member 'FBulletInfo::MovementType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, Frequency) == 0x000294, "Member 'FBulletInfo::Frequency' has a wrong offset!");
static_assert(offsetof(FBulletInfo, FrequencyRange) == 0x000298, "Member 'FBulletInfo::FrequencyRange' has a wrong offset!");
static_assert(offsetof(FBulletInfo, LifeTime) == 0x00029C, "Member 'FBulletInfo::LifeTime' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletExtremeRange) == 0x0002A0, "Member 'FBulletInfo::BulletExtremeRange' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletCollitionFlags) == 0x0002A4, "Member 'FBulletInfo::BulletCollitionFlags' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletCollitionApplyFlags) == 0x0002A8, "Member 'FBulletInfo::BulletCollitionApplyFlags' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitDie) == 0x0002AC, "Member 'FBulletInfo::HitDie' has a wrong offset!");
static_assert(offsetof(FBulletInfo, LifeEndApply) == 0x0002AD, "Member 'FBulletInfo::LifeEndApply' has a wrong offset!");
static_assert(offsetof(FBulletInfo, LifeEndEffectParticlePath) == 0x0002B0, "Member 'FBulletInfo::LifeEndEffectParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, LifeEndEffectSoundEvent) == 0x0002C8, "Member 'FBulletInfo::LifeEndEffectSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletInfo, SameTargetMaxNum) == 0x0002D8, "Member 'FBulletInfo::SameTargetMaxNum' has a wrong offset!");
static_assert(offsetof(FBulletInfo, MaxTargetNum) == 0x0002DC, "Member 'FBulletInfo::MaxTargetNum' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletChannel) == 0x0002E0, "Member 'FBulletInfo::BulletChannel' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletRayPath) == 0x0002E8, "Member 'FBulletInfo::BulletRayPath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletRayParamName) == 0x000300, "Member 'FBulletInfo::BulletRayParamName' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletRayParam) == 0x000308, "Member 'FBulletInfo::BulletRayParam' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BulletRayPlayPre) == 0x000310, "Member 'FBulletInfo::BulletRayPlayPre' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bBulletRayDestroyImmediately) == 0x000318, "Member 'FBulletInfo::bBulletRayDestroyImmediately' has a wrong offset!");
static_assert(offsetof(FBulletInfo, StopFireParticlePath) == 0x000320, "Member 'FBulletInfo::StopFireParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bMultiTrace) == 0x000338, "Member 'FBulletInfo::bMultiTrace' has a wrong offset!");
static_assert(offsetof(FBulletInfo, TraceShape) == 0x00033C, "Member 'FBulletInfo::TraceShape' has a wrong offset!");
static_assert(offsetof(FBulletInfo, WidthTraceNum) == 0x000344, "Member 'FBulletInfo::WidthTraceNum' has a wrong offset!");
static_assert(offsetof(FBulletInfo, WidthHeightNum) == 0x000348, "Member 'FBulletInfo::WidthHeightNum' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitStrength) == 0x00034C, "Member 'FBulletInfo::HitStrength' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bEnableCurveHitReaction) == 0x000350, "Member 'FBulletInfo::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bHitShakeEffectSelfOnly) == 0x000351, "Member 'FBulletInfo::bHitShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FBulletInfo, CameraShakeClassPath) == 0x000358, "Member 'FBulletInfo::CameraShakeClassPath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, ShakeMaxValidDistance) == 0x000370, "Member 'FBulletInfo::ShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bAttenuation) == 0x000374, "Member 'FBulletInfo::bAttenuation' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitAbilityTargetShake_NoAimPath) == 0x000378, "Member 'FBulletInfo::HitAbilityTargetShake_NoAimPath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitAbilityTargetShake_InAimPath) == 0x000390, "Member 'FBulletInfo::HitAbilityTargetShake_InAimPath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectNotPlayInTime) == 0x0003A8, "Member 'FBulletInfo::HitEffectNotPlayInTime' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectPlayPre) == 0x0003AC, "Member 'FBulletInfo::HitEffectPlayPre' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitWeaknessEffectNotPlayInTime) == 0x0003B4, "Member 'FBulletInfo::HitWeaknessEffectNotPlayInTime' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitWeaknessEffectPlayPre) == 0x0003B8, "Member 'FBulletInfo::HitWeaknessEffectPlayPre' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bUseHitEffectTable) == 0x0003C0, "Member 'FBulletInfo::bUseHitEffectTable' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectID) == 0x0003C4, "Member 'FBulletInfo::HitEffectID' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bHitEffectComposite) == 0x0003C8, "Member 'FBulletInfo::bHitEffectComposite' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectParticlePath) == 0x0003D0, "Member 'FBulletInfo::HitEffectParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bHitEffectAttach) == 0x0003E8, "Member 'FBulletInfo::bHitEffectAttach' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bHitEffectFollowBulletRotation) == 0x0003E9, "Member 'FBulletInfo::bHitEffectFollowBulletRotation' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bIgnoreHitEffectRotation) == 0x0003EA, "Member 'FBulletInfo::bIgnoreHitEffectRotation' has a wrong offset!");
static_assert(offsetof(FBulletInfo, MaxParticleCount) == 0x0003EC, "Member 'FBulletInfo::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FBulletInfo, FreeTime) == 0x0003F0, "Member 'FBulletInfo::FreeTime' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectRelativeTransform) == 0x000400, "Member 'FBulletInfo::HitEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HitEffectSoundEvent) == 0x000430, "Member 'FBulletInfo::HitEffectSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletInfo, SubSkillIDs) == 0x000440, "Member 'FBulletInfo::SubSkillIDs' has a wrong offset!");
static_assert(offsetof(FBulletInfo, WeaknessCriteType) == 0x000450, "Member 'FBulletInfo::WeaknessCriteType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, NormalCriteType) == 0x000451, "Member 'FBulletInfo::NormalCriteType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, OverrideModifyHPType) == 0x000452, "Member 'FBulletInfo::OverrideModifyHPType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, CastRange) == 0x000454, "Member 'FBulletInfo::CastRange' has a wrong offset!");
static_assert(offsetof(FBulletInfo, ActorTraceChannel) == 0x000458, "Member 'FBulletInfo::ActorTraceChannel' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BombDamageType) == 0x00045C, "Member 'FBulletInfo::BombDamageType' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BombEmitterID) == 0x000460, "Member 'FBulletInfo::BombEmitterID' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bBulletDirectHitAsBomb) == 0x000464, "Member 'FBulletInfo::bBulletDirectHitAsBomb' has a wrong offset!");
static_assert(offsetof(FBulletInfo, AbnormalInfos) == 0x000468, "Member 'FBulletInfo::AbnormalInfos' has a wrong offset!");
static_assert(offsetof(FBulletInfo, BowArrowTag) == 0x000478, "Member 'FBulletInfo::BowArrowTag' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HomingStopTime) == 0x000488, "Member 'FBulletInfo::HomingStopTime' has a wrong offset!");
static_assert(offsetof(FBulletInfo, HomingRandomRange) == 0x000490, "Member 'FBulletInfo::HomingRandomRange' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bTraceGround) == 0x000494, "Member 'FBulletInfo::bTraceGround' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bChainInfectionApply) == 0x000495, "Member 'FBulletInfo::bChainInfectionApply' has a wrong offset!");
static_assert(offsetof(FBulletInfo, bReplaceEffect) == 0x000496, "Member 'FBulletInfo::bReplaceEffect' has a wrong offset!");

// ScriptStruct Game.NiagaraData
// 0x0030 (0x0030 - 0x0000)
struct FNiagaraData final
{
public:
	struct FSoftObjectPath                        InAssetPath;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAssetDelay;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     TransInfos;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNiagaraData) == 0x000008, "Wrong alignment on FNiagaraData");
static_assert(sizeof(FNiagaraData) == 0x000030, "Wrong size on FNiagaraData");
static_assert(offsetof(FNiagaraData, InAssetPath) == 0x000000, "Member 'FNiagaraData::InAssetPath' has a wrong offset!");
static_assert(offsetof(FNiagaraData, InAssetDelay) == 0x000018, "Member 'FNiagaraData::InAssetDelay' has a wrong offset!");
static_assert(offsetof(FNiagaraData, TransInfos) == 0x000020, "Member 'FNiagaraData::TransInfos' has a wrong offset!");

// ScriptStruct Game.AIDirectorConfig
// 0x0048 (0x0050 - 0x0008)
struct FAIDirectorConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAIDirectorConfigAsset>  Config;                                            // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetMonsterLevel;                                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDirectorConfig) == 0x000008, "Wrong alignment on FAIDirectorConfig");
static_assert(sizeof(FAIDirectorConfig) == 0x000050, "Wrong size on FAIDirectorConfig");
static_assert(offsetof(FAIDirectorConfig, ID) == 0x000008, "Member 'FAIDirectorConfig::ID' has a wrong offset!");
static_assert(offsetof(FAIDirectorConfig, Remark) == 0x000010, "Member 'FAIDirectorConfig::Remark' has a wrong offset!");
static_assert(offsetof(FAIDirectorConfig, Config) == 0x000020, "Member 'FAIDirectorConfig::Config' has a wrong offset!");
static_assert(offsetof(FAIDirectorConfig, PresetMonsterLevel) == 0x000048, "Member 'FAIDirectorConfig::PresetMonsterLevel' has a wrong offset!");

// ScriptStruct Game.WeaponFriction
// 0x0068 (0x0068 - 0x0000)
struct FWeaponFriction final
{
public:
	float                                         FrictionInvalidPer;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionCoefficient;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FrictionInCurve;                                   // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionInTime;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FrictionOutCurve;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionOutTime;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InCurve;                                           // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OutCurve;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTime;                                           // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponFriction) == 0x000008, "Wrong alignment on FWeaponFriction");
static_assert(sizeof(FWeaponFriction) == 0x000068, "Wrong size on FWeaponFriction");
static_assert(offsetof(FWeaponFriction, FrictionInvalidPer) == 0x000000, "Member 'FWeaponFriction::FrictionInvalidPer' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, FrictionCoefficient) == 0x000004, "Member 'FWeaponFriction::FrictionCoefficient' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, FrictionInCurve) == 0x000008, "Member 'FWeaponFriction::FrictionInCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, FrictionInTime) == 0x000020, "Member 'FWeaponFriction::FrictionInTime' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, FrictionOutCurve) == 0x000028, "Member 'FWeaponFriction::FrictionOutCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, FrictionOutTime) == 0x000040, "Member 'FWeaponFriction::FrictionOutTime' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, InCurve) == 0x000048, "Member 'FWeaponFriction::InCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, OutCurve) == 0x000050, "Member 'FWeaponFriction::OutCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, InTime) == 0x000058, "Member 'FWeaponFriction::InTime' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, OutTime) == 0x00005C, "Member 'FWeaponFriction::OutTime' has a wrong offset!");
static_assert(offsetof(FWeaponFriction, OutValue) == 0x000060, "Member 'FWeaponFriction::OutValue' has a wrong offset!");

// ScriptStruct Game.KidRideNiagaraParam
// 0x0018 (0x0018 - 0x0000)
struct FKidRideNiagaraParam final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKidRideNiagaraParam) == 0x000008, "Wrong alignment on FKidRideNiagaraParam");
static_assert(sizeof(FKidRideNiagaraParam) == 0x000018, "Wrong size on FKidRideNiagaraParam");
static_assert(offsetof(FKidRideNiagaraParam, Key) == 0x000000, "Member 'FKidRideNiagaraParam::Key' has a wrong offset!");
static_assert(offsetof(FKidRideNiagaraParam, Value) == 0x000010, "Member 'FKidRideNiagaraParam::Value' has a wrong offset!");

// ScriptStruct Game.KidRideEffectParam
// 0x0048 (0x0048 - 0x0000)
struct FKidRideEffectParam final
{
public:
	struct FSoftObjectPath                        NiagaraPath;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SocketName;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoopEffect;                                     // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideParam;                                    // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKidRideNiagaraParam>           NiagaraParams;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideEffectParam) == 0x000008, "Wrong alignment on FKidRideEffectParam");
static_assert(sizeof(FKidRideEffectParam) == 0x000048, "Wrong size on FKidRideEffectParam");
static_assert(offsetof(FKidRideEffectParam, NiagaraPath) == 0x000000, "Member 'FKidRideEffectParam::NiagaraPath' has a wrong offset!");
static_assert(offsetof(FKidRideEffectParam, SocketName) == 0x000018, "Member 'FKidRideEffectParam::SocketName' has a wrong offset!");
static_assert(offsetof(FKidRideEffectParam, SocketOffset) == 0x000028, "Member 'FKidRideEffectParam::SocketOffset' has a wrong offset!");
static_assert(offsetof(FKidRideEffectParam, bIsLoopEffect) == 0x000034, "Member 'FKidRideEffectParam::bIsLoopEffect' has a wrong offset!");
static_assert(offsetof(FKidRideEffectParam, bOverrideParam) == 0x000035, "Member 'FKidRideEffectParam::bOverrideParam' has a wrong offset!");
static_assert(offsetof(FKidRideEffectParam, NiagaraParams) == 0x000038, "Member 'FKidRideEffectParam::NiagaraParams' has a wrong offset!");

// ScriptStruct Game.EnvMaterialTemplate
// 0x0050 (0x0058 - 0x0008)
struct FEnvMaterialTemplate final : public FTableRowBase
{
public:
	TMap<EEnvMaterialLayerType, class FString>    MaterialTemplates;                                 // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvMaterialTemplate) == 0x000008, "Wrong alignment on FEnvMaterialTemplate");
static_assert(sizeof(FEnvMaterialTemplate) == 0x000058, "Wrong size on FEnvMaterialTemplate");
static_assert(offsetof(FEnvMaterialTemplate, MaterialTemplates) == 0x000008, "Member 'FEnvMaterialTemplate::MaterialTemplates' has a wrong offset!");

// ScriptStruct Game.SpecializedSkillsConfig
// 0x0020 (0x0020 - 0x0000)
struct FSpecializedSkillsConfig final
{
public:
	int32                                         MinNum;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNum;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SpecializedSkillIDs;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SpecializedPropertyID;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecializedSkillsConfig) == 0x000008, "Wrong alignment on FSpecializedSkillsConfig");
static_assert(sizeof(FSpecializedSkillsConfig) == 0x000020, "Wrong size on FSpecializedSkillsConfig");
static_assert(offsetof(FSpecializedSkillsConfig, MinNum) == 0x000000, "Member 'FSpecializedSkillsConfig::MinNum' has a wrong offset!");
static_assert(offsetof(FSpecializedSkillsConfig, MaxNum) == 0x000004, "Member 'FSpecializedSkillsConfig::MaxNum' has a wrong offset!");
static_assert(offsetof(FSpecializedSkillsConfig, SpecializedSkillIDs) == 0x000008, "Member 'FSpecializedSkillsConfig::SpecializedSkillIDs' has a wrong offset!");
static_assert(offsetof(FSpecializedSkillsConfig, SpecializedPropertyID) == 0x000018, "Member 'FSpecializedSkillsConfig::SpecializedPropertyID' has a wrong offset!");

// ScriptStruct Game.SpawnNpcSpCfg
// 0x0010 (0x0010 - 0x0000)
struct FSpawnNpcSpCfg final
{
public:
	float                                         AdditionalHealthScale;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddTimeByKill;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnNpcSpCfg) == 0x000004, "Wrong alignment on FSpawnNpcSpCfg");
static_assert(sizeof(FSpawnNpcSpCfg) == 0x000010, "Wrong size on FSpawnNpcSpCfg");
static_assert(offsetof(FSpawnNpcSpCfg, AdditionalHealthScale) == 0x000000, "Member 'FSpawnNpcSpCfg::AdditionalHealthScale' has a wrong offset!");
static_assert(offsetof(FSpawnNpcSpCfg, SkillID) == 0x000004, "Member 'FSpawnNpcSpCfg::SkillID' has a wrong offset!");
static_assert(offsetof(FSpawnNpcSpCfg, SkillLevel) == 0x000008, "Member 'FSpawnNpcSpCfg::SkillLevel' has a wrong offset!");
static_assert(offsetof(FSpawnNpcSpCfg, AddTimeByKill) == 0x00000C, "Member 'FSpawnNpcSpCfg::AddTimeByKill' has a wrong offset!");

// ScriptStruct Game.FlexibleEnumValue
// 0x0004 (0x0004 - 0x0000)
struct FFlexibleEnumValue final
{
public:
	int32                                         CurrentValue;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlexibleEnumValue) == 0x000004, "Wrong alignment on FFlexibleEnumValue");
static_assert(sizeof(FFlexibleEnumValue) == 0x000004, "Wrong size on FFlexibleEnumValue");
static_assert(offsetof(FFlexibleEnumValue, CurrentValue) == 0x000000, "Member 'FFlexibleEnumValue::CurrentValue' has a wrong offset!");

// ScriptStruct Game.SpawnNpcBornParams
// 0x0028 (0x0028 - 0x0000)
struct FSpawnNpcBornParams final
{
public:
	int32                                         SpawnEffectId;                                     // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingCustomParam;                               // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewBornEffectStartPointName;                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornEffectMaxHeight;                               // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareDuration;                                   // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareUpDuration;                                 // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnNpcBornParams) == 0x000008, "Wrong alignment on FSpawnNpcBornParams");
static_assert(sizeof(FSpawnNpcBornParams) == 0x000028, "Wrong size on FSpawnNpcBornParams");
static_assert(offsetof(FSpawnNpcBornParams, SpawnEffectId) == 0x000000, "Member 'FSpawnNpcBornParams::SpawnEffectId' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBornParams, bIsUsingCustomParam) == 0x000004, "Member 'FSpawnNpcBornParams::bIsUsingCustomParam' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBornParams, NewBornEffectStartPointName) == 0x000008, "Member 'FSpawnNpcBornParams::NewBornEffectStartPointName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBornParams, BornEffectMaxHeight) == 0x000018, "Member 'FSpawnNpcBornParams::BornEffectMaxHeight' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBornParams, PrePareDuration) == 0x00001C, "Member 'FSpawnNpcBornParams::PrePareDuration' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBornParams, PrePareUpDuration) == 0x000020, "Member 'FSpawnNpcBornParams::PrePareUpDuration' has a wrong offset!");

// ScriptStruct Game.SpawnNpcBaseParams
// 0x00E8 (0x00E8 - 0x0000)
struct FSpawnNpcBaseParams
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AI;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomParam1;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                Type;                                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                DamageFloatType;                                   // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESummonType                                   SummonType;                                        // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIEvent*>                       AIEvents;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         AIEventID;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTeamCaptain;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PatrolPoint;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpecializedSkillsConfig               SpecializedSkillsConfig;                           // 0x0050(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         IdleAnimIndex;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnNpcSpCfg                         SpawnNpcSpCfg;                                     // 0x0074(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpawnNpcSpCfg                         ActiveSpawnerExCfg;                                // 0x0084(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AICtrlID;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             CampPriority;                                      // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PatrolIndex;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PatrolSpLevelStrength;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPal;                                             // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnNodeId;                                       // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableNavWalking;                                 // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawnNpcBornParams                    BornParams;                                        // 0x00C0(0x0028)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnNpcBaseParams) == 0x000008, "Wrong alignment on FSpawnNpcBaseParams");
static_assert(sizeof(FSpawnNpcBaseParams) == 0x0000E8, "Wrong size on FSpawnNpcBaseParams");
static_assert(offsetof(FSpawnNpcBaseParams, ID) == 0x000000, "Member 'FSpawnNpcBaseParams::ID' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, Level) == 0x000004, "Member 'FSpawnNpcBaseParams::Level' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, Team) == 0x000008, "Member 'FSpawnNpcBaseParams::Team' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, AI) == 0x000018, "Member 'FSpawnNpcBaseParams::AI' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, CustomParam1) == 0x00001C, "Member 'FSpawnNpcBaseParams::CustomParam1' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, Type) == 0x000020, "Member 'FSpawnNpcBaseParams::Type' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, DamageFloatType) == 0x000021, "Member 'FSpawnNpcBaseParams::DamageFloatType' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, SummonType) == 0x000022, "Member 'FSpawnNpcBaseParams::SummonType' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, AIEvents) == 0x000028, "Member 'FSpawnNpcBaseParams::AIEvents' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, AIEventID) == 0x000038, "Member 'FSpawnNpcBaseParams::AIEventID' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, bIsTeamCaptain) == 0x00003C, "Member 'FSpawnNpcBaseParams::bIsTeamCaptain' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, PatrolPoint) == 0x000040, "Member 'FSpawnNpcBaseParams::PatrolPoint' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, SpecializedSkillsConfig) == 0x000050, "Member 'FSpawnNpcBaseParams::SpecializedSkillsConfig' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, IdleAnimIndex) == 0x000070, "Member 'FSpawnNpcBaseParams::IdleAnimIndex' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, SpawnNpcSpCfg) == 0x000074, "Member 'FSpawnNpcBaseParams::SpawnNpcSpCfg' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, ActiveSpawnerExCfg) == 0x000084, "Member 'FSpawnNpcBaseParams::ActiveSpawnerExCfg' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, AICtrlID) == 0x000094, "Member 'FSpawnNpcBaseParams::AICtrlID' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, CampPriority) == 0x000098, "Member 'FSpawnNpcBaseParams::CampPriority' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, PatrolIndex) == 0x0000A8, "Member 'FSpawnNpcBaseParams::PatrolIndex' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, AreaId) == 0x0000AC, "Member 'FSpawnNpcBaseParams::AreaId' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, PatrolSpLevelStrength) == 0x0000B0, "Member 'FSpawnNpcBaseParams::PatrolSpLevelStrength' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, IsPal) == 0x0000B4, "Member 'FSpawnNpcBaseParams::IsPal' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, SpawnNodeId) == 0x0000B8, "Member 'FSpawnNpcBaseParams::SpawnNodeId' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, DisableNavWalking) == 0x0000BC, "Member 'FSpawnNpcBaseParams::DisableNavWalking' has a wrong offset!");
static_assert(offsetof(FSpawnNpcBaseParams, BornParams) == 0x0000C0, "Member 'FSpawnNpcBaseParams::BornParams' has a wrong offset!");

// ScriptStruct Game.SpawnNpcPointParams
// 0x0038 (0x0120 - 0x00E8)
struct FSpawnNpcPointParams final : public FSpawnNpcBaseParams
{
public:
	class FString                                 PointName;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewBornEffectStartPointName;                       // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornEffectMaxHeight;                               // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareDuration;                                   // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareUpDuration;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnEffectId;                                     // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingCustomParam;                               // 0x0118(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnNpcPointParams) == 0x000008, "Wrong alignment on FSpawnNpcPointParams");
static_assert(sizeof(FSpawnNpcPointParams) == 0x000120, "Wrong size on FSpawnNpcPointParams");
static_assert(offsetof(FSpawnNpcPointParams, PointName) == 0x0000E8, "Member 'FSpawnNpcPointParams::PointName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, NewBornEffectStartPointName) == 0x0000F8, "Member 'FSpawnNpcPointParams::NewBornEffectStartPointName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, BornEffectMaxHeight) == 0x000108, "Member 'FSpawnNpcPointParams::BornEffectMaxHeight' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, PrePareDuration) == 0x00010C, "Member 'FSpawnNpcPointParams::PrePareDuration' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, PrePareUpDuration) == 0x000110, "Member 'FSpawnNpcPointParams::PrePareUpDuration' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, SpawnEffectId) == 0x000114, "Member 'FSpawnNpcPointParams::SpawnEffectId' has a wrong offset!");
static_assert(offsetof(FSpawnNpcPointParams, bIsUsingCustomParam) == 0x000118, "Member 'FSpawnNpcPointParams::bIsUsingCustomParam' has a wrong offset!");

// ScriptStruct Game.QueryResultString
// 0x0020 (0x0020 - 0x0000)
struct FQueryResultString final
{
public:
	class FString                                 ResultPoint;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResultTarget;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueryResultString) == 0x000008, "Wrong alignment on FQueryResultString");
static_assert(sizeof(FQueryResultString) == 0x000020, "Wrong size on FQueryResultString");
static_assert(offsetof(FQueryResultString, ResultPoint) == 0x000000, "Member 'FQueryResultString::ResultPoint' has a wrong offset!");
static_assert(offsetof(FQueryResultString, ResultTarget) == 0x000010, "Member 'FQueryResultString::ResultTarget' has a wrong offset!");

// ScriptStruct Game.HighestDpsInfo
// 0x000C (0x000C - 0x0000)
struct FHighestDpsInfo final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  HighestDps2Other;                                  // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighestDpsInfo) == 0x000004, "Wrong alignment on FHighestDpsInfo");
static_assert(sizeof(FHighestDpsInfo) == 0x00000C, "Wrong size on FHighestDpsInfo");
static_assert(offsetof(FHighestDpsInfo, Value) == 0x000000, "Member 'FHighestDpsInfo::Value' has a wrong offset!");
static_assert(offsetof(FHighestDpsInfo, HighestDps2Other) == 0x000004, "Member 'FHighestDpsInfo::HighestDps2Other' has a wrong offset!");

// ScriptStruct Game.QueryResult
// 0x0090 (0x0090 - 0x0000)
struct FQueryResult final
{
public:
	bool                                          bValid;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  QueryTarget;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryPoint;                                        // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomPoint;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAimPoint;                                     // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeOffsetScale;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EApplyLocationType                            LocationType;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneResult                            PartitionResult;                                   // 0x0028(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartResult;                                        // 0x0058(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x4];                                       // 0x0088(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ESearchTargetPartType                         SearchTargetPart;                                  // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueryResult) == 0x000008, "Wrong alignment on FQueryResult");
static_assert(sizeof(FQueryResult) == 0x000090, "Wrong size on FQueryResult");
static_assert(offsetof(FQueryResult, bValid) == 0x000000, "Member 'FQueryResult::bValid' has a wrong offset!");
static_assert(offsetof(FQueryResult, QueryTarget) == 0x000004, "Member 'FQueryResult::QueryTarget' has a wrong offset!");
static_assert(offsetof(FQueryResult, QueryPoint) == 0x00000C, "Member 'FQueryResult::QueryPoint' has a wrong offset!");
static_assert(offsetof(FQueryResult, bRandomPoint) == 0x000018, "Member 'FQueryResult::bRandomPoint' has a wrong offset!");
static_assert(offsetof(FQueryResult, bAutoAimPoint) == 0x000019, "Member 'FQueryResult::bAutoAimPoint' has a wrong offset!");
static_assert(offsetof(FQueryResult, RangeOffsetScale) == 0x00001C, "Member 'FQueryResult::RangeOffsetScale' has a wrong offset!");
static_assert(offsetof(FQueryResult, LocationType) == 0x000020, "Member 'FQueryResult::LocationType' has a wrong offset!");
static_assert(offsetof(FQueryResult, PartitionResult) == 0x000028, "Member 'FQueryResult::PartitionResult' has a wrong offset!");
static_assert(offsetof(FQueryResult, PartResult) == 0x000058, "Member 'FQueryResult::PartResult' has a wrong offset!");
static_assert(offsetof(FQueryResult, SearchTargetPart) == 0x00008C, "Member 'FQueryResult::SearchTargetPart' has a wrong offset!");

// ScriptStruct Game.ApplyHitResultData
// 0x00B0 (0x00B0 - 0x0000)
struct FApplyHitResultData final
{
public:
	class UAbilityComponentBase*                  Launcher;                                          // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Target;                                            // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginSkillID;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ObjTrigger;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrit;                                             // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitType;                                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAbnormal;                                      // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneResult                            PartResult;                                        // 0x0038(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartitionResult;                                   // 0x0068(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0098(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     HitComponent;                                      // 0x00A4(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FApplyHitResultData) == 0x000008, "Wrong alignment on FApplyHitResultData");
static_assert(sizeof(FApplyHitResultData) == 0x0000B0, "Wrong size on FApplyHitResultData");
static_assert(offsetof(FApplyHitResultData, Launcher) == 0x000000, "Member 'FApplyHitResultData::Launcher' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, Target) == 0x000008, "Member 'FApplyHitResultData::Target' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, HitActor) == 0x000010, "Member 'FApplyHitResultData::HitActor' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, OriginSkillID) == 0x000018, "Member 'FApplyHitResultData::OriginSkillID' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, ObjTrigger) == 0x000020, "Member 'FApplyHitResultData::ObjTrigger' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, bCrit) == 0x000028, "Member 'FApplyHitResultData::bCrit' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, HitType) == 0x00002C, "Member 'FApplyHitResultData::HitType' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, bHasAbnormal) == 0x000030, "Member 'FApplyHitResultData::bHasAbnormal' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, PartResult) == 0x000038, "Member 'FApplyHitResultData::PartResult' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, PartitionResult) == 0x000068, "Member 'FApplyHitResultData::PartitionResult' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, HitLocation) == 0x000098, "Member 'FApplyHitResultData::HitLocation' has a wrong offset!");
static_assert(offsetof(FApplyHitResultData, HitComponent) == 0x0000A4, "Member 'FApplyHitResultData::HitComponent' has a wrong offset!");

// ScriptStruct Game.EnvSnowLayerRow
// 0x0008 (0x0010 - 0x0008)
struct FEnvSnowLayerRow final : public FTableRowBase
{
public:
	class FName                                   LayerName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvSnowLayerRow) == 0x000008, "Wrong alignment on FEnvSnowLayerRow");
static_assert(sizeof(FEnvSnowLayerRow) == 0x000010, "Wrong size on FEnvSnowLayerRow");
static_assert(offsetof(FEnvSnowLayerRow, LayerName) == 0x000008, "Member 'FEnvSnowLayerRow::LayerName' has a wrong offset!");

// ScriptStruct Game.ModifierUIEffect
// 0x0028 (0x0028 - 0x0000)
struct FModifierUIEffect final
{
public:
	EModifierUIEffect                             ModifierUIEffect;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ModifierUIEffectParams;                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     Params;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierUIEffect) == 0x000008, "Wrong alignment on FModifierUIEffect");
static_assert(sizeof(FModifierUIEffect) == 0x000028, "Wrong size on FModifierUIEffect");
static_assert(offsetof(FModifierUIEffect, ModifierUIEffect) == 0x000000, "Member 'FModifierUIEffect::ModifierUIEffect' has a wrong offset!");
static_assert(offsetof(FModifierUIEffect, ModifierUIEffectParams) == 0x000008, "Member 'FModifierUIEffect::ModifierUIEffectParams' has a wrong offset!");
static_assert(offsetof(FModifierUIEffect, Params) == 0x000018, "Member 'FModifierUIEffect::Params' has a wrong offset!");

// ScriptStruct Game.ModifierPostStartEffectInfo
// 0x0008 (0x0180 - 0x0178)
struct FModifierPostStartEffectInfo final : public FModifierEffectInfo
{
public:
	EModifierPostStartEffectType                  ApplyType;                                         // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierPostStartEffectInfo) == 0x000008, "Wrong alignment on FModifierPostStartEffectInfo");
static_assert(sizeof(FModifierPostStartEffectInfo) == 0x000180, "Wrong size on FModifierPostStartEffectInfo");
static_assert(offsetof(FModifierPostStartEffectInfo, ApplyType) == 0x000178, "Member 'FModifierPostStartEffectInfo::ApplyType' has a wrong offset!");

// ScriptStruct Game.ModifierKeepEffectInfo
// 0x0308 (0x0480 - 0x0178)
struct FModifierKeepEffectInfo final : public FModifierEffectInfo
{
public:
	struct FAttributeChangeValueGrowupBase        InitShield;                                        // 0x0178(0x01F8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bParticleUseReliableRP;                            // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         SpecialSignaWidgetPath;                            // 0x0378(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpecialSignaWidgetSocket;                          // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AbornmalEffect;                                    // 0x0398(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ModifierStateTags;                                 // 0x03B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 EffectPostProcessPaths;                            // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDeactiveOnSwitch;                                 // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySelfVisible;                                  // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ActiveModifierIDs;                                 // 0x03E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActiveModifierTags;                                // 0x03F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockModifierIDs;                                  // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockModifierTags;                                 // 0x0428(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 DeActiveModifierIDs;                               // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DeActiveModifierTags;                              // 0x0458(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bScaleSlomo;                                       // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlomPriority                                 SlomPriority;                                      // 0x0479(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierKeepEffectInfo) == 0x000008, "Wrong alignment on FModifierKeepEffectInfo");
static_assert(sizeof(FModifierKeepEffectInfo) == 0x000480, "Wrong size on FModifierKeepEffectInfo");
static_assert(offsetof(FModifierKeepEffectInfo, InitShield) == 0x000178, "Member 'FModifierKeepEffectInfo::InitShield' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, bParticleUseReliableRP) == 0x000370, "Member 'FModifierKeepEffectInfo::bParticleUseReliableRP' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, SpecialSignaWidgetPath) == 0x000378, "Member 'FModifierKeepEffectInfo::SpecialSignaWidgetPath' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, SpecialSignaWidgetSocket) == 0x000390, "Member 'FModifierKeepEffectInfo::SpecialSignaWidgetSocket' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, AbornmalEffect) == 0x000398, "Member 'FModifierKeepEffectInfo::AbornmalEffect' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, ModifierStateTags) == 0x0003B0, "Member 'FModifierKeepEffectInfo::ModifierStateTags' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, EffectPostProcessPaths) == 0x0003D0, "Member 'FModifierKeepEffectInfo::EffectPostProcessPaths' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, bDeactiveOnSwitch) == 0x0003E0, "Member 'FModifierKeepEffectInfo::bDeactiveOnSwitch' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, bOnlySelfVisible) == 0x0003E1, "Member 'FModifierKeepEffectInfo::bOnlySelfVisible' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, ActiveModifierIDs) == 0x0003E8, "Member 'FModifierKeepEffectInfo::ActiveModifierIDs' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, ActiveModifierTags) == 0x0003F8, "Member 'FModifierKeepEffectInfo::ActiveModifierTags' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, BlockModifierIDs) == 0x000418, "Member 'FModifierKeepEffectInfo::BlockModifierIDs' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, BlockModifierTags) == 0x000428, "Member 'FModifierKeepEffectInfo::BlockModifierTags' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, DeActiveModifierIDs) == 0x000448, "Member 'FModifierKeepEffectInfo::DeActiveModifierIDs' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, DeActiveModifierTags) == 0x000458, "Member 'FModifierKeepEffectInfo::DeActiveModifierTags' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, bScaleSlomo) == 0x000478, "Member 'FModifierKeepEffectInfo::bScaleSlomo' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectInfo, SlomPriority) == 0x000479, "Member 'FModifierKeepEffectInfo::SlomPriority' has a wrong offset!");

// ScriptStruct Game.WeaponFireModifierInfo
// 0x0028 (0x0028 - 0x0000)
struct FWeaponFireModifierInfo final
{
public:
	struct FSoftClassPath                         WeaponFireEffects;                                 // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     WeaponFireEffectsParams;                           // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponFireModifierInfo) == 0x000008, "Wrong alignment on FWeaponFireModifierInfo");
static_assert(sizeof(FWeaponFireModifierInfo) == 0x000028, "Wrong size on FWeaponFireModifierInfo");
static_assert(offsetof(FWeaponFireModifierInfo, WeaponFireEffects) == 0x000000, "Member 'FWeaponFireModifierInfo::WeaponFireEffects' has a wrong offset!");
static_assert(offsetof(FWeaponFireModifierInfo, WeaponFireEffectsParams) == 0x000018, "Member 'FWeaponFireModifierInfo::WeaponFireEffectsParams' has a wrong offset!");

// ScriptStruct Game.ModifierDataInfo
// 0x12F8 (0x1300 - 0x0008)
struct FModifierDataInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          ShowType;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SpritePath;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInOnlineOnlyShowSelf;                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnCDTime;                                       // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FModifierUIEffect>              ModifierUIEffects;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         HideFightWidgetParts;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BlockDisplayWidgetNames;                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ModifierClassTag;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierIncomeType                           IncomeType;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsMark;                                           // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarkLevel                                    MarkLevel;                                         // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkToActor;                                      // 0x007B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            KeepTime;                                          // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, struct FVector2D>                 RandomKeepTime;                                    // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNotEffectBySlomo;                                 // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlomoPauseModifierTick;                           // 0x0121(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x6];                                      // 0x0122(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            MaxLiveTime;                                       // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ECampRelation>                         SearchCampRelations;                               // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ECharacterType>                        SearchCharacterTypes;                              // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FStateBlockTypeNames>           StateBlockTypeNames;                               // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EEffectTargetType                             EffectTargetType;                                  // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ModifierAddSpecialType;                            // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierAddType                              AddType;                                           // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AloneWorldCount;                                   // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AloneCount;                                        // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierAloneLimitType                       AloneLimitType;                                    // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            NewMaxOverlaid;                                    // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EModifierOverlaidLimitType                    OverlaidLimitType;                                 // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              EndConditions;                                     // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEndCondtionRemoveOne;                             // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AtuoRemoveOneTime;                                 // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndByAbnormalBlockType;                           // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStateBlockTypeNames>           EndStateBlockTypeNames;                            // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDeadNotRemove;                                    // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierEffectInfo                    ApplyEffect;                                       // 0x0250(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FModifierEffectInfo                    EndEffect;                                         // 0x03C8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<int32, float>                            IntervalTimeMap;                                   // 0x0540(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIntervalApplyExec;                                // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierIntervalEffectInfo            IntervalEffect;                                    // 0x0598(0x0370)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FModifierKeepEffectInfo                KeepEffect;                                        // 0x0908(0x0480)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FModifierPostStartEffectInfo           PostApplyEffect;                                   // 0x0D88(0x0180)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bConditionApplyOnce;                               // 0x0F08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F09[0x7];                                      // 0x0F09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              ConditionApplys;                                   // 0x0F10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FModifierEffectInfo                    ConditionApplyEffect;                              // 0x0F20(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FConditionSetting>              ConditionKeeps;                                    // 0x1098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FModifierEffectInfo                    ConditionKeepEffect;                               // 0x10A8(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FModifierDamageEffect>          ModifierDamageEffects;                             // 0x1220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         WeaponFireObject;                                  // 0x1230(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     WeaponFireObjectParams;                            // 0x1248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, float>                            WeaponFireRandomActive;                            // 0x1258(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FWeaponFireModifierInfo>        WeaponFireEffects;                                 // 0x12A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FModifierDamageEffect>          BulletDamageEffects;                               // 0x12B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                OnPreDeadExecEffect;                               // 0x12C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                OnDeadCheckEffect;                                 // 0x12D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FConditionSetting>              BufferCondition;                                   // 0x12E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffect;                                    // 0x12F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePlayerModifier;                             // 0x12F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAddModifierFailedNeedContinue;                 // 0x12FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReInitSaveModifier : 1;                           // 0x12FB(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDeadSaveModifier : 1;                             // 0x12FB(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12FC[0x4];                                     // 0x12FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierDataInfo) == 0x000008, "Wrong alignment on FModifierDataInfo");
static_assert(sizeof(FModifierDataInfo) == 0x001300, "Wrong size on FModifierDataInfo");
static_assert(offsetof(FModifierDataInfo, ID) == 0x000008, "Member 'FModifierDataInfo::ID' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bRepaceData) == 0x00000C, "Member 'FModifierDataInfo::bRepaceData' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ReplaceParamArray) == 0x000010, "Member 'FModifierDataInfo::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ShowType) == 0x000020, "Member 'FModifierDataInfo::ShowType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, SpritePath) == 0x000028, "Member 'FModifierDataInfo::SpritePath' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bInOnlineOnlyShowSelf) == 0x000040, "Member 'FModifierDataInfo::bInOnlineOnlyShowSelf' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bWarnCDTime) == 0x000041, "Member 'FModifierDataInfo::bWarnCDTime' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ModifierUIEffects) == 0x000048, "Member 'FModifierDataInfo::ModifierUIEffects' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, HideFightWidgetParts) == 0x000058, "Member 'FModifierDataInfo::HideFightWidgetParts' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, BlockDisplayWidgetNames) == 0x000060, "Member 'FModifierDataInfo::BlockDisplayWidgetNames' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ModifierClassTag) == 0x000070, "Member 'FModifierDataInfo::ModifierClassTag' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, IncomeType) == 0x000078, "Member 'FModifierDataInfo::IncomeType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bAsMark) == 0x000079, "Member 'FModifierDataInfo::bAsMark' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, MarkLevel) == 0x00007A, "Member 'FModifierDataInfo::MarkLevel' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bMarkToActor) == 0x00007B, "Member 'FModifierDataInfo::bMarkToActor' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, KeepTime) == 0x000080, "Member 'FModifierDataInfo::KeepTime' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, RandomKeepTime) == 0x0000D0, "Member 'FModifierDataInfo::RandomKeepTime' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bNotEffectBySlomo) == 0x000120, "Member 'FModifierDataInfo::bNotEffectBySlomo' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bSlomoPauseModifierTick) == 0x000121, "Member 'FModifierDataInfo::bSlomoPauseModifierTick' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, MaxLiveTime) == 0x000128, "Member 'FModifierDataInfo::MaxLiveTime' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, SearchCampRelations) == 0x000178, "Member 'FModifierDataInfo::SearchCampRelations' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, SearchCharacterTypes) == 0x000188, "Member 'FModifierDataInfo::SearchCharacterTypes' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, StateBlockTypeNames) == 0x000198, "Member 'FModifierDataInfo::StateBlockTypeNames' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, EffectTargetType) == 0x0001A8, "Member 'FModifierDataInfo::EffectTargetType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ModifierAddSpecialType) == 0x0001AC, "Member 'FModifierDataInfo::ModifierAddSpecialType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, AddType) == 0x0001B0, "Member 'FModifierDataInfo::AddType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, AloneWorldCount) == 0x0001B4, "Member 'FModifierDataInfo::AloneWorldCount' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, AloneCount) == 0x0001B8, "Member 'FModifierDataInfo::AloneCount' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, AloneLimitType) == 0x0001BC, "Member 'FModifierDataInfo::AloneLimitType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, NewMaxOverlaid) == 0x0001C0, "Member 'FModifierDataInfo::NewMaxOverlaid' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, OverlaidLimitType) == 0x000210, "Member 'FModifierDataInfo::OverlaidLimitType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, EndConditions) == 0x000218, "Member 'FModifierDataInfo::EndConditions' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bEndCondtionRemoveOne) == 0x000228, "Member 'FModifierDataInfo::bEndCondtionRemoveOne' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, AtuoRemoveOneTime) == 0x00022C, "Member 'FModifierDataInfo::AtuoRemoveOneTime' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bEndByAbnormalBlockType) == 0x000230, "Member 'FModifierDataInfo::bEndByAbnormalBlockType' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, EndStateBlockTypeNames) == 0x000238, "Member 'FModifierDataInfo::EndStateBlockTypeNames' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bDeadNotRemove) == 0x000248, "Member 'FModifierDataInfo::bDeadNotRemove' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ApplyEffect) == 0x000250, "Member 'FModifierDataInfo::ApplyEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, EndEffect) == 0x0003C8, "Member 'FModifierDataInfo::EndEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, IntervalTimeMap) == 0x000540, "Member 'FModifierDataInfo::IntervalTimeMap' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bIntervalApplyExec) == 0x000590, "Member 'FModifierDataInfo::bIntervalApplyExec' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, IntervalEffect) == 0x000598, "Member 'FModifierDataInfo::IntervalEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, KeepEffect) == 0x000908, "Member 'FModifierDataInfo::KeepEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, PostApplyEffect) == 0x000D88, "Member 'FModifierDataInfo::PostApplyEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bConditionApplyOnce) == 0x000F08, "Member 'FModifierDataInfo::bConditionApplyOnce' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ConditionApplys) == 0x000F10, "Member 'FModifierDataInfo::ConditionApplys' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ConditionApplyEffect) == 0x000F20, "Member 'FModifierDataInfo::ConditionApplyEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ConditionKeeps) == 0x001098, "Member 'FModifierDataInfo::ConditionKeeps' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ConditionKeepEffect) == 0x0010A8, "Member 'FModifierDataInfo::ConditionKeepEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, ModifierDamageEffects) == 0x001220, "Member 'FModifierDataInfo::ModifierDamageEffects' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, WeaponFireObject) == 0x001230, "Member 'FModifierDataInfo::WeaponFireObject' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, WeaponFireObjectParams) == 0x001248, "Member 'FModifierDataInfo::WeaponFireObjectParams' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, WeaponFireRandomActive) == 0x001258, "Member 'FModifierDataInfo::WeaponFireRandomActive' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, WeaponFireEffects) == 0x0012A8, "Member 'FModifierDataInfo::WeaponFireEffects' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, BulletDamageEffects) == 0x0012B8, "Member 'FModifierDataInfo::BulletDamageEffects' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, OnPreDeadExecEffect) == 0x0012C8, "Member 'FModifierDataInfo::OnPreDeadExecEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, OnDeadCheckEffect) == 0x0012D8, "Member 'FModifierDataInfo::OnDeadCheckEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, BufferCondition) == 0x0012E8, "Member 'FModifierDataInfo::BufferCondition' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bReplaceEffect) == 0x0012F8, "Member 'FModifierDataInfo::bReplaceEffect' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bIgnorePlayerModifier) == 0x0012F9, "Member 'FModifierDataInfo::bIgnorePlayerModifier' has a wrong offset!");
static_assert(offsetof(FModifierDataInfo, bCanAddModifierFailedNeedContinue) == 0x0012FA, "Member 'FModifierDataInfo::bCanAddModifierFailedNeedContinue' has a wrong offset!");

// ScriptStruct Game.FireButtonAttribute
// 0x0008 (0x0008 - 0x0000)
struct FFireButtonAttribute final
{
public:
	EExciteActionType                             Press_Excite;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimActionType                                Press_Aim;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExciteActionType                             LongPress_Excite;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimActionType                                LongPress_Aim;                                     // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExciteActionType                             Release_Excite;                                    // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimActionType                                Release_Aim;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExciteActionType                             LongRelease_Excite;                                // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimActionType                                LongRelease_Aim;                                   // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireButtonAttribute) == 0x000001, "Wrong alignment on FFireButtonAttribute");
static_assert(sizeof(FFireButtonAttribute) == 0x000008, "Wrong size on FFireButtonAttribute");
static_assert(offsetof(FFireButtonAttribute, Press_Excite) == 0x000000, "Member 'FFireButtonAttribute::Press_Excite' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, Press_Aim) == 0x000001, "Member 'FFireButtonAttribute::Press_Aim' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, LongPress_Excite) == 0x000002, "Member 'FFireButtonAttribute::LongPress_Excite' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, LongPress_Aim) == 0x000003, "Member 'FFireButtonAttribute::LongPress_Aim' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, Release_Excite) == 0x000004, "Member 'FFireButtonAttribute::Release_Excite' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, Release_Aim) == 0x000005, "Member 'FFireButtonAttribute::Release_Aim' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, LongRelease_Excite) == 0x000006, "Member 'FFireButtonAttribute::LongRelease_Excite' has a wrong offset!");
static_assert(offsetof(FFireButtonAttribute, LongRelease_Aim) == 0x000007, "Member 'FFireButtonAttribute::LongRelease_Aim' has a wrong offset!");

// ScriptStruct Game.AbilityCommonForceFeedback
// 0x0028 (0x0028 - 0x0000)
struct FAbilityCommonForceFeedback final
{
public:
	struct FSoftObjectPath                        ForceFeedbackCurve;                                // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColdDownTime;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityCommonForceFeedback) == 0x000008, "Wrong alignment on FAbilityCommonForceFeedback");
static_assert(sizeof(FAbilityCommonForceFeedback) == 0x000028, "Wrong size on FAbilityCommonForceFeedback");
static_assert(offsetof(FAbilityCommonForceFeedback, ForceFeedbackCurve) == 0x000000, "Member 'FAbilityCommonForceFeedback::ForceFeedbackCurve' has a wrong offset!");
static_assert(offsetof(FAbilityCommonForceFeedback, BlendInTime) == 0x000018, "Member 'FAbilityCommonForceFeedback::BlendInTime' has a wrong offset!");
static_assert(offsetof(FAbilityCommonForceFeedback, BlendOutTime) == 0x00001C, "Member 'FAbilityCommonForceFeedback::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FAbilityCommonForceFeedback, ColdDownTime) == 0x000020, "Member 'FAbilityCommonForceFeedback::ColdDownTime' has a wrong offset!");
static_assert(offsetof(FAbilityCommonForceFeedback, Priority) == 0x000024, "Member 'FAbilityCommonForceFeedback::Priority' has a wrong offset!");

// ScriptStruct Game.WeaponFollowInfo
// 0x0078 (0x0078 - 0x0000)
struct FWeaponFollowInfo final
{
public:
	bool                                          bEnableFollow;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdsorbentRangePer;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdsorbentTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AdsorbentCurve;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Distance2SpeedCurve;                               // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowSpeed;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuitFollow;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireFireFollowRangePer;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FireFollowSpeed;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireFollowReduceTime;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_FireFireFollowRangePer;                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Aim_FireFollowSpeed;                               // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_FireFollowReduceTime;                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FireFollowAngle;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponFollowInfo) == 0x000008, "Wrong alignment on FWeaponFollowInfo");
static_assert(sizeof(FWeaponFollowInfo) == 0x000078, "Wrong size on FWeaponFollowInfo");
static_assert(offsetof(FWeaponFollowInfo, bEnableFollow) == 0x000000, "Member 'FWeaponFollowInfo::bEnableFollow' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, AdsorbentRangePer) == 0x000004, "Member 'FWeaponFollowInfo::AdsorbentRangePer' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, AdsorbentTime) == 0x000008, "Member 'FWeaponFollowInfo::AdsorbentTime' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, AdsorbentCurve) == 0x000010, "Member 'FWeaponFollowInfo::AdsorbentCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, Distance2SpeedCurve) == 0x000028, "Member 'FWeaponFollowInfo::Distance2SpeedCurve' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, FollowSpeed) == 0x000040, "Member 'FWeaponFollowInfo::FollowSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, QuitFollow) == 0x000044, "Member 'FWeaponFollowInfo::QuitFollow' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, FireFireFollowRangePer) == 0x000048, "Member 'FWeaponFollowInfo::FireFireFollowRangePer' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, FireFollowSpeed) == 0x00004C, "Member 'FWeaponFollowInfo::FireFollowSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, FireFollowReduceTime) == 0x000054, "Member 'FWeaponFollowInfo::FireFollowReduceTime' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, Aim_FireFireFollowRangePer) == 0x000058, "Member 'FWeaponFollowInfo::Aim_FireFireFollowRangePer' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, Aim_FireFollowSpeed) == 0x00005C, "Member 'FWeaponFollowInfo::Aim_FireFollowSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, Aim_FireFollowReduceTime) == 0x000064, "Member 'FWeaponFollowInfo::Aim_FireFollowReduceTime' has a wrong offset!");
static_assert(offsetof(FWeaponFollowInfo, FireFollowAngle) == 0x000068, "Member 'FWeaponFollowInfo::FireFollowAngle' has a wrong offset!");

// ScriptStruct Game.WeaponTemplate
// 0x0958 (0x0960 - 0x0008)
struct FWeaponTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResNameDec;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResScaleType;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResMontageDec;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RecoilSuffixMontageDec;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Blueprint;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewModel;                                      // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UICameraID;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponDriveType                              WeaponDriveType;                                   // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bsemiAutomatic;                                    // 0x009A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputCacelRecoil;                                 // 0x009B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShootCancleAimUI;                                  // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShootNotInAim;                                     // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponFirePattern>             WeaponFirePatterns;                                // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WeaponBulletIcon;                                  // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReloadInterruptShoot;                          // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFireButtonAttribute                   FirstFireBtnCfg;                                   // 0x00C9(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FFireButtonAttribute                   SecondFireBtnCfg;                                  // 0x00D1(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShowAimCancel;                                     // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponName;                                        // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Describe;                                          // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAdditiveCount;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0104(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FireSocket;                                        // 0x010C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponFireSocket;                              // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationThreshold;                                 // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYawThreshold;                              // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnchantScale;                                      // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstBulletCount;                                  // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBurstBulletEndRecoil;                             // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSingleFireMode;                             // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponDiffusionType                          WeaponDiffusion;                                   // 0x0132(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizonScatterAngle;                               // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SingleShootCostBulletNum;                          // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireStorage;                                       // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletCost;                                        // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletLaunchCount;                                 // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadyPreheat;                                      // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFire;                                           // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepPreheat;                                       // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreheatInPlayerFire;                              // 0x0154(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BunkerReachRightPeakLeaveDis;                      // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerReachLeftPeakLeaveDis;                       // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerReachRightPeakLeaveDis_Aim;                  // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BunkerReachLeftPeakLeaveDis_Aim;                   // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseWeaponTime;                                   // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponReloadTime_MontageBlend;                     // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseWeaponTime_MontageBlend;                      // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRaiseWeaponTime_MontageBlend;                 // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingPoseSwitchOffTime;                         // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingPoseSwitchOffTime_Move;                    // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingPoseToSkillTime;                           // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRetainWeaponRaising;                           // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimRetainWeaponRaising;                            // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBunkerWeaponRaising_Retract;                 // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBunkerWeaponRaising_StopAim;                 // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBunkerWeaponRaising_RetractMoving;           // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBunkerWeaponRaising_StopAimMoving;           // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnHalfBunkerWeaponRaising_Retract;             // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnHalfBunkerWeaponRaising_StopAim;             // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnHalfBunkerWeaponRaising_RetractMoving;       // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnHalfBunkerWeaponRaising_StopAimMoving;       // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnBunkerWeaponRaising_Default;                 // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitBunkerWeaponRaising_Bolt;                      // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplayWeaponRaising_Bolt;                          // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShootMontageDurationForWeaponRaising;          // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShootMontageDurationOnlyOutSideBunker;         // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckHalfBunkerWeaponRaising;                     // 0x01BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB[0x1];                                      // 0x01BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponAngleThreshold;                              // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponBoltNum;                                     // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponFireParam                       FireParam;                                         // 0x01C8(0x01D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWeaponFriction                        WeaponFriction;                                    // 0x0398(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FirePointLight;                                    // 0x0400(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeFireEffect;                           // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FireEffectPath;                                    // 0x0420(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreFireEffectPath;                                 // 0x0438(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreheadEffect;                                     // 0x0450(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreFireSound;                                      // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrowBulletSocket;                                 // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BulletOnGroundSound;                               // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletOnGroundSoundDelayTime;                      // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeThrowBullet;                          // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_495[0x3];                                      // 0x0495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ThrowBulletEffectPath;                             // 0x0498(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeBulletSmoke;                          // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ThrowBulletSmoke;                                  // 0x04B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DuringFireSoundEvent;                              // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FireSoundEvent;                                    // 0x04E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExFireSoundEvents;                                 // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 FireSoundEndEvent;                                 // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SilencerFireSoundEvent;                            // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExSilencerFireSoundEvents;                         // 0x0520(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SilencerFireSoundEndEvent;                         // 0x0530(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FireSoundElementSwitch;                            // 0x0540(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FireSmokeEffectPath;                               // 0x0550(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSmokeMaxValue;                                 // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSmokeShowValue;                                // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSmokeAddValue;                                 // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSmokeAttenuationValue;                         // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CheckShootRange;                                   // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustWeakBulletDir;                               // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBodyBulletDir;                               // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustWeakBulletDir_PC;                            // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBodyBulletDir_PC;                            // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponBulletShootType                        NormalBulletShootType;                             // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponBulletShootType                        AimBulletShootType;                                // 0x0591(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_592[0x2];                                      // 0x0592(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBulletShootOffsete;                          // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CrossHairUIWidget;                                 // 0x0598(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AimCrossHairUIWidget;                              // 0x05B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AimAudioID;                                        // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         AmmunitionUIWidget;                                // 0x05D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AmmunitionOffset;                                  // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FightPowerOffset;                                  // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetRange;                                       // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimTargetRange;                                    // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampAimOffsetYaw;                                 // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BreathShakingYawCurvePath;                         // 0x0610(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BreathShakingPitchCurvePath;                       // 0x0628(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StableTime;                                        // 0x0640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilityCommonForceFeedback            ForceFeedbackCommon;                               // 0x0648(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAbilityCommonForceFeedback            ForceFeedbackCommonPS;                             // 0x0670(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWeaponFollowInfo                      FollowInfo_Mobile;                                 // 0x0698(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWeaponFollowInfo                      FollowInfo_PC;                                     // 0x0710(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWeaponFollowInfo                      FollowInfo_Gamepad;                                // 0x0788(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StorageAnimMontagePath;                            // 0x0800(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreheatAnimMontagePath;                            // 0x0818(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FireAnimMontagePath;                               // 0x0830(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AddPreheatCurve;                                   // 0x0848(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DecPreheatCurve;                                   // 0x0860(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitPreheatTime;                                   // 0x0878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootAddHeatValue;                                 // 0x087C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddOverloadCurveTime;                              // 0x0880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_884[0x4];                                      // 0x0884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AddOverloadCurve;                                  // 0x0888(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecOverloadCurveTime;                              // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DecOverloadCurve;                                  // 0x08A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecOverHeatCurveTime;                              // 0x08C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DecOverHeatCurve;                                  // 0x08C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitOverloadTime;                                  // 0x08E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitOverHeatTime;                                  // 0x08E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HeatToShootSpeed;                                  // 0x08E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HeatToDamage;                                      // 0x0900(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreheatAnimBlendOut;                               // 0x0918(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShootForced;                                      // 0x0930(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableScattering;                                // 0x0931(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoFire;                                   // 0x0932(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponFireMode                               FireMode;                                          // 0x0933(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponPartType;                                    // 0x0934(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultMuzzleID;                                   // 0x0938(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTopGuideID;                                 // 0x093C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultButtID;                                     // 0x0940(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAmmunitionID;                               // 0x0944(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultLowerGuideID;                               // 0x0948(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTriggerID;                                  // 0x094C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultGripID;                                     // 0x0950(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultSightID;                                    // 0x0954(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultStabilizerID;                               // 0x0958(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponHoldMode                               HoldType;                                          // 0x095C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95D[0x3];                                      // 0x095D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponTemplate) == 0x000008, "Wrong alignment on FWeaponTemplate");
static_assert(sizeof(FWeaponTemplate) == 0x000960, "Wrong size on FWeaponTemplate");
static_assert(offsetof(FWeaponTemplate, ID) == 0x000008, "Member 'FWeaponTemplate::ID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ResNameDec) == 0x000010, "Member 'FWeaponTemplate::ResNameDec' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ResScaleType) == 0x000020, "Member 'FWeaponTemplate::ResScaleType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ResMontageDec) == 0x000030, "Member 'FWeaponTemplate::ResMontageDec' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, RecoilSuffixMontageDec) == 0x000040, "Member 'FWeaponTemplate::RecoilSuffixMontageDec' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, Blueprint) == 0x000050, "Member 'FWeaponTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreviewModel) == 0x000068, "Member 'FWeaponTemplate::PreviewModel' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, UICameraID) == 0x000080, "Member 'FWeaponTemplate::UICameraID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bRepaceData) == 0x000084, "Member 'FWeaponTemplate::bRepaceData' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReplaceParamArray) == 0x000088, "Member 'FWeaponTemplate::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponType) == 0x000098, "Member 'FWeaponTemplate::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponDriveType) == 0x000099, "Member 'FWeaponTemplate::WeaponDriveType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bsemiAutomatic) == 0x00009A, "Member 'FWeaponTemplate::bsemiAutomatic' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bInputCacelRecoil) == 0x00009B, "Member 'FWeaponTemplate::bInputCacelRecoil' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootCancleAimUI) == 0x00009C, "Member 'FWeaponTemplate::ShootCancleAimUI' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootNotInAim) == 0x00009D, "Member 'FWeaponTemplate::ShootNotInAim' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponFirePatterns) == 0x0000A0, "Member 'FWeaponTemplate::WeaponFirePatterns' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponBulletIcon) == 0x0000B0, "Member 'FWeaponTemplate::WeaponBulletIcon' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bCanReloadInterruptShoot) == 0x0000C8, "Member 'FWeaponTemplate::bCanReloadInterruptShoot' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FirstFireBtnCfg) == 0x0000C9, "Member 'FWeaponTemplate::FirstFireBtnCfg' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, SecondFireBtnCfg) == 0x0000D1, "Member 'FWeaponTemplate::SecondFireBtnCfg' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShowAimCancel) == 0x0000D9, "Member 'FWeaponTemplate::ShowAimCancel' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponName) == 0x0000E0, "Member 'FWeaponTemplate::WeaponName' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, Describe) == 0x0000F0, "Member 'FWeaponTemplate::Describe' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, HitAdditiveCount) == 0x000100, "Member 'FWeaponTemplate::HitAdditiveCount' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AttachSocket) == 0x000104, "Member 'FWeaponTemplate::AttachSocket' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSocket) == 0x00010C, "Member 'FWeaponTemplate::FireSocket' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseWeaponFireSocket) == 0x000114, "Member 'FWeaponTemplate::bUseWeaponFireSocket' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, RotationThreshold) == 0x000118, "Member 'FWeaponTemplate::RotationThreshold' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, RotationYawThreshold) == 0x00011C, "Member 'FWeaponTemplate::RotationYawThreshold' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BulletID) == 0x000120, "Member 'FWeaponTemplate::BulletID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, Range) == 0x000124, "Member 'FWeaponTemplate::Range' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, EnchantScale) == 0x000128, "Member 'FWeaponTemplate::EnchantScale' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BurstBulletCount) == 0x00012C, "Member 'FWeaponTemplate::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bBurstBulletEndRecoil) == 0x000130, "Member 'FWeaponTemplate::bBurstBulletEndRecoil' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bEnableSingleFireMode) == 0x000131, "Member 'FWeaponTemplate::bEnableSingleFireMode' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponDiffusion) == 0x000132, "Member 'FWeaponTemplate::WeaponDiffusion' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, HorizonScatterAngle) == 0x000134, "Member 'FWeaponTemplate::HorizonScatterAngle' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, SingleShootCostBulletNum) == 0x000138, "Member 'FWeaponTemplate::SingleShootCostBulletNum' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireStorage) == 0x00013C, "Member 'FWeaponTemplate::FireStorage' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BulletCost) == 0x000140, "Member 'FWeaponTemplate::BulletCost' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BulletLaunchCount) == 0x000144, "Member 'FWeaponTemplate::BulletLaunchCount' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReadyPreheat) == 0x000148, "Member 'FWeaponTemplate::ReadyPreheat' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreFire) == 0x00014C, "Member 'FWeaponTemplate::PreFire' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, KeepPreheat) == 0x000150, "Member 'FWeaponTemplate::KeepPreheat' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bPreheatInPlayerFire) == 0x000154, "Member 'FWeaponTemplate::bPreheatInPlayerFire' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BunkerReachRightPeakLeaveDis) == 0x000158, "Member 'FWeaponTemplate::BunkerReachRightPeakLeaveDis' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BunkerReachLeftPeakLeaveDis) == 0x00015C, "Member 'FWeaponTemplate::BunkerReachLeftPeakLeaveDis' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BunkerReachRightPeakLeaveDis_Aim) == 0x000160, "Member 'FWeaponTemplate::BunkerReachRightPeakLeaveDis_Aim' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BunkerReachLeftPeakLeaveDis_Aim) == 0x000164, "Member 'FWeaponTemplate::BunkerReachLeftPeakLeaveDis_Aim' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, RaiseWeaponTime) == 0x000168, "Member 'FWeaponTemplate::RaiseWeaponTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponReloadTime_MontageBlend) == 0x00016C, "Member 'FWeaponTemplate::WeaponReloadTime_MontageBlend' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, RaiseWeaponTime_MontageBlend) == 0x000170, "Member 'FWeaponTemplate::RaiseWeaponTime_MontageBlend' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, SlideRaiseWeaponTime_MontageBlend) == 0x000174, "Member 'FWeaponTemplate::SlideRaiseWeaponTime_MontageBlend' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootingPoseSwitchOffTime) == 0x000178, "Member 'FWeaponTemplate::ShootingPoseSwitchOffTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootingPoseSwitchOffTime_Move) == 0x00017C, "Member 'FWeaponTemplate::ShootingPoseSwitchOffTime_Move' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootingPoseToSkillTime) == 0x000180, "Member 'FWeaponTemplate::ShootingPoseToSkillTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireRetainWeaponRaising) == 0x000184, "Member 'FWeaponTemplate::FireRetainWeaponRaising' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AimRetainWeaponRaising) == 0x000188, "Member 'FWeaponTemplate::AimRetainWeaponRaising' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnBunkerWeaponRaising_Retract) == 0x00018C, "Member 'FWeaponTemplate::ReturnBunkerWeaponRaising_Retract' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnBunkerWeaponRaising_StopAim) == 0x000190, "Member 'FWeaponTemplate::ReturnBunkerWeaponRaising_StopAim' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnBunkerWeaponRaising_RetractMoving) == 0x000194, "Member 'FWeaponTemplate::ReturnBunkerWeaponRaising_RetractMoving' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnBunkerWeaponRaising_StopAimMoving) == 0x000198, "Member 'FWeaponTemplate::ReturnBunkerWeaponRaising_StopAimMoving' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnHalfBunkerWeaponRaising_Retract) == 0x00019C, "Member 'FWeaponTemplate::ReturnHalfBunkerWeaponRaising_Retract' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnHalfBunkerWeaponRaising_StopAim) == 0x0001A0, "Member 'FWeaponTemplate::ReturnHalfBunkerWeaponRaising_StopAim' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnHalfBunkerWeaponRaising_RetractMoving) == 0x0001A4, "Member 'FWeaponTemplate::ReturnHalfBunkerWeaponRaising_RetractMoving' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnHalfBunkerWeaponRaising_StopAimMoving) == 0x0001A8, "Member 'FWeaponTemplate::ReturnHalfBunkerWeaponRaising_StopAimMoving' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReturnBunkerWeaponRaising_Default) == 0x0001AC, "Member 'FWeaponTemplate::ReturnBunkerWeaponRaising_Default' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ExitBunkerWeaponRaising_Bolt) == 0x0001B0, "Member 'FWeaponTemplate::ExitBunkerWeaponRaising_Bolt' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ReplayWeaponRaising_Bolt) == 0x0001B4, "Member 'FWeaponTemplate::ReplayWeaponRaising_Bolt' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseShootMontageDurationForWeaponRaising) == 0x0001B8, "Member 'FWeaponTemplate::bUseShootMontageDurationForWeaponRaising' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseShootMontageDurationOnlyOutSideBunker) == 0x0001B9, "Member 'FWeaponTemplate::bUseShootMontageDurationOnlyOutSideBunker' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bCheckHalfBunkerWeaponRaising) == 0x0001BA, "Member 'FWeaponTemplate::bCheckHalfBunkerWeaponRaising' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponAngleThreshold) == 0x0001BC, "Member 'FWeaponTemplate::WeaponAngleThreshold' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponBoltNum) == 0x0001C0, "Member 'FWeaponTemplate::WeaponBoltNum' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireParam) == 0x0001C8, "Member 'FWeaponTemplate::FireParam' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponFriction) == 0x000398, "Member 'FWeaponTemplate::WeaponFriction' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FirePointLight) == 0x000400, "Member 'FWeaponTemplate::FirePointLight' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseCompositeFireEffect) == 0x000418, "Member 'FWeaponTemplate::bUseCompositeFireEffect' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireEffectPath) == 0x000420, "Member 'FWeaponTemplate::FireEffectPath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreFireEffectPath) == 0x000438, "Member 'FWeaponTemplate::PreFireEffectPath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreheadEffect) == 0x000450, "Member 'FWeaponTemplate::PreheadEffect' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreFireSound) == 0x000468, "Member 'FWeaponTemplate::PreFireSound' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ThrowBulletSocket) == 0x000478, "Member 'FWeaponTemplate::ThrowBulletSocket' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BulletOnGroundSound) == 0x000480, "Member 'FWeaponTemplate::BulletOnGroundSound' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BulletOnGroundSoundDelayTime) == 0x000490, "Member 'FWeaponTemplate::BulletOnGroundSoundDelayTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseCompositeThrowBullet) == 0x000494, "Member 'FWeaponTemplate::bUseCompositeThrowBullet' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ThrowBulletEffectPath) == 0x000498, "Member 'FWeaponTemplate::ThrowBulletEffectPath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bUseCompositeBulletSmoke) == 0x0004B0, "Member 'FWeaponTemplate::bUseCompositeBulletSmoke' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ThrowBulletSmoke) == 0x0004B8, "Member 'FWeaponTemplate::ThrowBulletSmoke' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DuringFireSoundEvent) == 0x0004D0, "Member 'FWeaponTemplate::DuringFireSoundEvent' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSoundEvent) == 0x0004E0, "Member 'FWeaponTemplate::FireSoundEvent' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ExFireSoundEvents) == 0x0004F0, "Member 'FWeaponTemplate::ExFireSoundEvents' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSoundEndEvent) == 0x000500, "Member 'FWeaponTemplate::FireSoundEndEvent' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, SilencerFireSoundEvent) == 0x000510, "Member 'FWeaponTemplate::SilencerFireSoundEvent' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ExSilencerFireSoundEvents) == 0x000520, "Member 'FWeaponTemplate::ExSilencerFireSoundEvents' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, SilencerFireSoundEndEvent) == 0x000530, "Member 'FWeaponTemplate::SilencerFireSoundEndEvent' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSoundElementSwitch) == 0x000540, "Member 'FWeaponTemplate::FireSoundElementSwitch' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSmokeEffectPath) == 0x000550, "Member 'FWeaponTemplate::FireSmokeEffectPath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSmokeMaxValue) == 0x000568, "Member 'FWeaponTemplate::FireSmokeMaxValue' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSmokeShowValue) == 0x00056C, "Member 'FWeaponTemplate::FireSmokeShowValue' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSmokeAddValue) == 0x000570, "Member 'FWeaponTemplate::FireSmokeAddValue' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireSmokeAttenuationValue) == 0x000574, "Member 'FWeaponTemplate::FireSmokeAttenuationValue' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, CheckShootRange) == 0x000578, "Member 'FWeaponTemplate::CheckShootRange' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AdjustWeakBulletDir) == 0x000580, "Member 'FWeaponTemplate::AdjustWeakBulletDir' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AdjustBodyBulletDir) == 0x000584, "Member 'FWeaponTemplate::AdjustBodyBulletDir' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AdjustWeakBulletDir_PC) == 0x000588, "Member 'FWeaponTemplate::AdjustWeakBulletDir_PC' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AdjustBodyBulletDir_PC) == 0x00058C, "Member 'FWeaponTemplate::AdjustBodyBulletDir_PC' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, NormalBulletShootType) == 0x000590, "Member 'FWeaponTemplate::NormalBulletShootType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AimBulletShootType) == 0x000591, "Member 'FWeaponTemplate::AimBulletShootType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, CameraBulletShootOffsete) == 0x000594, "Member 'FWeaponTemplate::CameraBulletShootOffsete' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, CrossHairUIWidget) == 0x000598, "Member 'FWeaponTemplate::CrossHairUIWidget' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AimCrossHairUIWidget) == 0x0005B0, "Member 'FWeaponTemplate::AimCrossHairUIWidget' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AimAudioID) == 0x0005C8, "Member 'FWeaponTemplate::AimAudioID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AmmunitionUIWidget) == 0x0005D0, "Member 'FWeaponTemplate::AmmunitionUIWidget' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AmmunitionOffset) == 0x0005E8, "Member 'FWeaponTemplate::AmmunitionOffset' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FightPowerOffset) == 0x0005F0, "Member 'FWeaponTemplate::FightPowerOffset' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, TargetRange) == 0x0005F8, "Member 'FWeaponTemplate::TargetRange' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AimTargetRange) == 0x000600, "Member 'FWeaponTemplate::AimTargetRange' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ClampAimOffsetYaw) == 0x000608, "Member 'FWeaponTemplate::ClampAimOffsetYaw' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BreathShakingYawCurvePath) == 0x000610, "Member 'FWeaponTemplate::BreathShakingYawCurvePath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, BreathShakingPitchCurvePath) == 0x000628, "Member 'FWeaponTemplate::BreathShakingPitchCurvePath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, StableTime) == 0x000640, "Member 'FWeaponTemplate::StableTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ForceFeedbackCommon) == 0x000648, "Member 'FWeaponTemplate::ForceFeedbackCommon' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ForceFeedbackCommonPS) == 0x000670, "Member 'FWeaponTemplate::ForceFeedbackCommonPS' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FollowInfo_Mobile) == 0x000698, "Member 'FWeaponTemplate::FollowInfo_Mobile' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FollowInfo_PC) == 0x000710, "Member 'FWeaponTemplate::FollowInfo_PC' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FollowInfo_Gamepad) == 0x000788, "Member 'FWeaponTemplate::FollowInfo_Gamepad' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, StorageAnimMontagePath) == 0x000800, "Member 'FWeaponTemplate::StorageAnimMontagePath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreheatAnimMontagePath) == 0x000818, "Member 'FWeaponTemplate::PreheatAnimMontagePath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireAnimMontagePath) == 0x000830, "Member 'FWeaponTemplate::FireAnimMontagePath' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AddPreheatCurve) == 0x000848, "Member 'FWeaponTemplate::AddPreheatCurve' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DecPreheatCurve) == 0x000860, "Member 'FWeaponTemplate::DecPreheatCurve' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WaitPreheatTime) == 0x000878, "Member 'FWeaponTemplate::WaitPreheatTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, ShootAddHeatValue) == 0x00087C, "Member 'FWeaponTemplate::ShootAddHeatValue' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AddOverloadCurveTime) == 0x000880, "Member 'FWeaponTemplate::AddOverloadCurveTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, AddOverloadCurve) == 0x000888, "Member 'FWeaponTemplate::AddOverloadCurve' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DecOverloadCurveTime) == 0x0008A0, "Member 'FWeaponTemplate::DecOverloadCurveTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DecOverloadCurve) == 0x0008A8, "Member 'FWeaponTemplate::DecOverloadCurve' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DecOverHeatCurveTime) == 0x0008C0, "Member 'FWeaponTemplate::DecOverHeatCurveTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DecOverHeatCurve) == 0x0008C8, "Member 'FWeaponTemplate::DecOverHeatCurve' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WaitOverloadTime) == 0x0008E0, "Member 'FWeaponTemplate::WaitOverloadTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WaitOverHeatTime) == 0x0008E4, "Member 'FWeaponTemplate::WaitOverHeatTime' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, HeatToShootSpeed) == 0x0008E8, "Member 'FWeaponTemplate::HeatToShootSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, HeatToDamage) == 0x000900, "Member 'FWeaponTemplate::HeatToDamage' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, PreheatAnimBlendOut) == 0x000918, "Member 'FWeaponTemplate::PreheatAnimBlendOut' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bShootForced) == 0x000930, "Member 'FWeaponTemplate::bShootForced' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bDisableScattering) == 0x000931, "Member 'FWeaponTemplate::bDisableScattering' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, bEnableAutoFire) == 0x000932, "Member 'FWeaponTemplate::bEnableAutoFire' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, FireMode) == 0x000933, "Member 'FWeaponTemplate::FireMode' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, WeaponPartType) == 0x000934, "Member 'FWeaponTemplate::WeaponPartType' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultMuzzleID) == 0x000938, "Member 'FWeaponTemplate::DefaultMuzzleID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultTopGuideID) == 0x00093C, "Member 'FWeaponTemplate::DefaultTopGuideID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultButtID) == 0x000940, "Member 'FWeaponTemplate::DefaultButtID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultAmmunitionID) == 0x000944, "Member 'FWeaponTemplate::DefaultAmmunitionID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultLowerGuideID) == 0x000948, "Member 'FWeaponTemplate::DefaultLowerGuideID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultTriggerID) == 0x00094C, "Member 'FWeaponTemplate::DefaultTriggerID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultGripID) == 0x000950, "Member 'FWeaponTemplate::DefaultGripID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultSightID) == 0x000954, "Member 'FWeaponTemplate::DefaultSightID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, DefaultStabilizerID) == 0x000958, "Member 'FWeaponTemplate::DefaultStabilizerID' has a wrong offset!");
static_assert(offsetof(FWeaponTemplate, HoldType) == 0x00095C, "Member 'FWeaponTemplate::HoldType' has a wrong offset!");

// ScriptStruct Game.OnlineTDBuildInfo
// 0x0014 (0x0014 - 0x0000)
struct FOnlineTDBuildInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDBaseSkillType                        Type;                                              // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Progress;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostMax;                                           // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDBuildInfo) == 0x000004, "Wrong alignment on FOnlineTDBuildInfo");
static_assert(sizeof(FOnlineTDBuildInfo) == 0x000014, "Wrong size on FOnlineTDBuildInfo");
static_assert(offsetof(FOnlineTDBuildInfo, Level) == 0x000000, "Member 'FOnlineTDBuildInfo::Level' has a wrong offset!");
static_assert(offsetof(FOnlineTDBuildInfo, MaxLevel) == 0x000004, "Member 'FOnlineTDBuildInfo::MaxLevel' has a wrong offset!");
static_assert(offsetof(FOnlineTDBuildInfo, Type) == 0x000008, "Member 'FOnlineTDBuildInfo::Type' has a wrong offset!");
static_assert(offsetof(FOnlineTDBuildInfo, Progress) == 0x00000C, "Member 'FOnlineTDBuildInfo::Progress' has a wrong offset!");
static_assert(offsetof(FOnlineTDBuildInfo, CostMax) == 0x000010, "Member 'FOnlineTDBuildInfo::CostMax' has a wrong offset!");

// ScriptStruct Game.ApplyHitPhysicalResultData
// 0x0038 (0x0038 - 0x0000)
struct FApplyHitPhysicalResultData final
{
public:
	bool                                          bEnableCurveHitReaction;                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditiveHitReaction;                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitStrength;                                       // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitBoneIndex;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitDir;                                            // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitNormalDir;                                      // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitOrigin;                                         // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponType;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnimScale;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitReactPerformanceType;                           // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FApplyHitPhysicalResultData) == 0x000004, "Wrong alignment on FApplyHitPhysicalResultData");
static_assert(sizeof(FApplyHitPhysicalResultData) == 0x000038, "Wrong size on FApplyHitPhysicalResultData");
static_assert(offsetof(FApplyHitPhysicalResultData, bEnableCurveHitReaction) == 0x000000, "Member 'FApplyHitPhysicalResultData::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, bEnableAdditiveHitReaction) == 0x000001, "Member 'FApplyHitPhysicalResultData::bEnableAdditiveHitReaction' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitStrength) == 0x000002, "Member 'FApplyHitPhysicalResultData::HitStrength' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitBoneIndex) == 0x000004, "Member 'FApplyHitPhysicalResultData::HitBoneIndex' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitDir) == 0x000008, "Member 'FApplyHitPhysicalResultData::HitDir' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitNormalDir) == 0x000014, "Member 'FApplyHitPhysicalResultData::HitNormalDir' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitOrigin) == 0x000020, "Member 'FApplyHitPhysicalResultData::HitOrigin' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, WeaponType) == 0x00002C, "Member 'FApplyHitPhysicalResultData::WeaponType' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitAnimScale) == 0x000030, "Member 'FApplyHitPhysicalResultData::HitAnimScale' has a wrong offset!");
static_assert(offsetof(FApplyHitPhysicalResultData, HitReactPerformanceType) == 0x000034, "Member 'FApplyHitPhysicalResultData::HitReactPerformanceType' has a wrong offset!");

// ScriptStruct Game.ApplyAttributeValueEvent
// 0x0010 (0x0010 - 0x0000)
struct FApplyAttributeValueEvent
{
public:
	class UAbilityAttribute*                      AttributeClass;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttributeValue;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FApplyAttributeValueEvent) == 0x000008, "Wrong alignment on FApplyAttributeValueEvent");
static_assert(sizeof(FApplyAttributeValueEvent) == 0x000010, "Wrong size on FApplyAttributeValueEvent");
static_assert(offsetof(FApplyAttributeValueEvent, AttributeClass) == 0x000000, "Member 'FApplyAttributeValueEvent::AttributeClass' has a wrong offset!");
static_assert(offsetof(FApplyAttributeValueEvent, AttributeValue) == 0x000008, "Member 'FApplyAttributeValueEvent::AttributeValue' has a wrong offset!");

// ScriptStruct Game.CameraAnimationSequenceResult
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCameraAnimationSequenceResult final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraAnimationSequenceResult) == 0x000004, "Wrong alignment on FCameraAnimationSequenceResult");
static_assert(sizeof(FCameraAnimationSequenceResult) == 0x00001C, "Wrong size on FCameraAnimationSequenceResult");

// ScriptStruct Game.ApplyAttributeChangeEvent
// 0x0028 (0x0038 - 0x0010)
struct FApplyAttributeChangeEvent final : public FApplyAttributeValueEvent
{
public:
	class UAbilityComponentBase*                  Launcher;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLocation;                                     // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBackPlayer;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FApplyAttributeChangeEvent) == 0x000008, "Wrong alignment on FApplyAttributeChangeEvent");
static_assert(sizeof(FApplyAttributeChangeEvent) == 0x000038, "Wrong size on FApplyAttributeChangeEvent");
static_assert(offsetof(FApplyAttributeChangeEvent, Launcher) == 0x000010, "Member 'FApplyAttributeChangeEvent::Launcher' has a wrong offset!");
static_assert(offsetof(FApplyAttributeChangeEvent, ApplyLocation) == 0x000018, "Member 'FApplyAttributeChangeEvent::ApplyLocation' has a wrong offset!");
static_assert(offsetof(FApplyAttributeChangeEvent, OriginLocation) == 0x000024, "Member 'FApplyAttributeChangeEvent::OriginLocation' has a wrong offset!");
static_assert(offsetof(FApplyAttributeChangeEvent, bApplyBackPlayer) == 0x000030, "Member 'FApplyAttributeChangeEvent::bApplyBackPlayer' has a wrong offset!");

// ScriptStruct Game.RuntimeEASInfo
// 0x0034 (0x0034 - 0x0000)
struct FRuntimeEASInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRunTimeID;                                    // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   Luncher;                                           // 0x000C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  GameSkillOwner;                                    // 0x0014(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGameCharacter>          GameSkillInstigator;                               // 0x001C(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  GameSkillCreator;                                  // 0x0024(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkillEmitter>           OwnerEmitter;                                      // 0x002C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeEASInfo) == 0x000004, "Wrong alignment on FRuntimeEASInfo");
static_assert(sizeof(FRuntimeEASInfo) == 0x000034, "Wrong size on FRuntimeEASInfo");
static_assert(offsetof(FRuntimeEASInfo, SkillID) == 0x000000, "Member 'FRuntimeEASInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, SkillRunTimeID) == 0x000004, "Member 'FRuntimeEASInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, SkillLevel) == 0x000008, "Member 'FRuntimeEASInfo::SkillLevel' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, Luncher) == 0x00000C, "Member 'FRuntimeEASInfo::Luncher' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, GameSkillOwner) == 0x000014, "Member 'FRuntimeEASInfo::GameSkillOwner' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, GameSkillInstigator) == 0x00001C, "Member 'FRuntimeEASInfo::GameSkillInstigator' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, GameSkillCreator) == 0x000024, "Member 'FRuntimeEASInfo::GameSkillCreator' has a wrong offset!");
static_assert(offsetof(FRuntimeEASInfo, OwnerEmitter) == 0x00002C, "Member 'FRuntimeEASInfo::OwnerEmitter' has a wrong offset!");

// ScriptStruct Game.ElemItemData
// 0x0010 (0x0010 - 0x0000)
struct FElemItemData final
{
public:
	EModifyHPType                                 InType;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurValue;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutTime;                                           // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemItemData) == 0x000004, "Wrong alignment on FElemItemData");
static_assert(sizeof(FElemItemData) == 0x000010, "Wrong size on FElemItemData");
static_assert(offsetof(FElemItemData, InType) == 0x000000, "Member 'FElemItemData::InType' has a wrong offset!");
static_assert(offsetof(FElemItemData, CurValue) == 0x000004, "Member 'FElemItemData::CurValue' has a wrong offset!");
static_assert(offsetof(FElemItemData, MaxValue) == 0x000008, "Member 'FElemItemData::MaxValue' has a wrong offset!");
static_assert(offsetof(FElemItemData, OutTime) == 0x00000C, "Member 'FElemItemData::OutTime' has a wrong offset!");

// ScriptStruct Game.EmitterTimePointEffect
// 0x0068 (0x0068 - 0x0000)
struct FEmitterTimePointEffect final
{
public:
	EHitEffectTimePoint                           TimePoint;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeChangeValueGrowup>    AttibuteChangeGrowup;                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCastModifierCondition>         AddModifierToTarget;                               // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveModifierToTarget;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCastModifierCondition>         AddModifierToLauncher;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveModifierToLauncher;                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 EmitterIDs;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterTimePointEffect) == 0x000008, "Wrong alignment on FEmitterTimePointEffect");
static_assert(sizeof(FEmitterTimePointEffect) == 0x000068, "Wrong size on FEmitterTimePointEffect");
static_assert(offsetof(FEmitterTimePointEffect, TimePoint) == 0x000000, "Member 'FEmitterTimePointEffect::TimePoint' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, AttibuteChangeGrowup) == 0x000008, "Member 'FEmitterTimePointEffect::AttibuteChangeGrowup' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, AddModifierToTarget) == 0x000018, "Member 'FEmitterTimePointEffect::AddModifierToTarget' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, RemoveModifierToTarget) == 0x000028, "Member 'FEmitterTimePointEffect::RemoveModifierToTarget' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, AddModifierToLauncher) == 0x000038, "Member 'FEmitterTimePointEffect::AddModifierToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, RemoveModifierToLauncher) == 0x000048, "Member 'FEmitterTimePointEffect::RemoveModifierToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterTimePointEffect, EmitterIDs) == 0x000058, "Member 'FEmitterTimePointEffect::EmitterIDs' has a wrong offset!");

// ScriptStruct Game.EmitterHitSetting
// 0x01A0 (0x01A0 - 0x0000)
struct FEmitterHitSetting final
{
public:
	bool                                          bAOE;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsShoot;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAvoid;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCriteType                               CriteType;                                         // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitExhibitionLocationType                    HitExhibitionLocationType;                         // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OriginSocketName;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveHitEffect;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectPathComposite;                           // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitEffectPath;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectNotAttach;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectFaceToLauncher;                          // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectInTargetFace;                            // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitEffectRelativeTransform;                        // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RandomRot;                                         // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EParticleEndPlayTriggerType                   HitEffectEndPlayTriggerType;                       // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HitSoundEvent;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitSoundSocket;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         HitCameraShakePath;                                // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitShakeEffectSelfOnly;                           // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitShakeMaxValidDistance;                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitShakeAttenuation;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitBlurCurve;                                      // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateHitBlurCenter;                              // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DamageAttenuationCurve;                            // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPropertyChangeValueGrowup>     PropertyChangeGrowup;                              // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FModifierDamageEffect>          DamageEffects;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PhysicalHitStrength;                               // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitAnimScale;                                      // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCurveHitReaction;                           // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditiveHitReaction;                        // 0x0121(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitReactPerformance                          HitReactPerformanceType;                           // 0x0122(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbnormalStateApplyInfo>        AbnormalInfos;                                     // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PauseFrameTime;                                    // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterPauseFrameType                        PauseFrameType;                                    // 0x013C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopSpecificSkill;                                // 0x013D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            StopSpecificSkillTimeMap;                          // 0x0140(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEmitterTimePointEffect>        TimePointEffects;                                  // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterHitSetting) == 0x000010, "Wrong alignment on FEmitterHitSetting");
static_assert(sizeof(FEmitterHitSetting) == 0x0001A0, "Wrong size on FEmitterHitSetting");
static_assert(offsetof(FEmitterHitSetting, bAOE) == 0x000000, "Member 'FEmitterHitSetting::bAOE' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bAsShoot) == 0x000001, "Member 'FEmitterHitSetting::bAsShoot' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bCanAvoid) == 0x000002, "Member 'FEmitterHitSetting::bCanAvoid' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, CriteType) == 0x000003, "Member 'FEmitterHitSetting::CriteType' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitExhibitionLocationType) == 0x000004, "Member 'FEmitterHitSetting::HitExhibitionLocationType' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, OriginSocketName) == 0x000008, "Member 'FEmitterHitSetting::OriginSocketName' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHaveHitEffect) == 0x000018, "Member 'FEmitterHitSetting::bHaveHitEffect' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHitEffectPathComposite) == 0x000019, "Member 'FEmitterHitSetting::bHitEffectPathComposite' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitEffectPath) == 0x000020, "Member 'FEmitterHitSetting::HitEffectPath' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHitEffectNotAttach) == 0x000038, "Member 'FEmitterHitSetting::bHitEffectNotAttach' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHitEffectFaceToLauncher) == 0x000039, "Member 'FEmitterHitSetting::bHitEffectFaceToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHitEffectInTargetFace) == 0x00003A, "Member 'FEmitterHitSetting::bHitEffectInTargetFace' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitEffectRelativeTransform) == 0x000040, "Member 'FEmitterHitSetting::HitEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, RandomRot) == 0x000070, "Member 'FEmitterHitSetting::RandomRot' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitEffectEndPlayTriggerType) == 0x00007C, "Member 'FEmitterHitSetting::HitEffectEndPlayTriggerType' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitSoundEvent) == 0x000080, "Member 'FEmitterHitSetting::HitSoundEvent' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitSoundSocket) == 0x000090, "Member 'FEmitterHitSetting::HitSoundSocket' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitCameraShakePath) == 0x000098, "Member 'FEmitterHitSetting::HitCameraShakePath' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bHitShakeEffectSelfOnly) == 0x0000B0, "Member 'FEmitterHitSetting::bHitShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitShakeMaxValidDistance) == 0x0000B4, "Member 'FEmitterHitSetting::HitShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitShakeAttenuation) == 0x0000B8, "Member 'FEmitterHitSetting::HitShakeAttenuation' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitBlurCurve) == 0x0000C0, "Member 'FEmitterHitSetting::HitBlurCurve' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bUpdateHitBlurCenter) == 0x0000D8, "Member 'FEmitterHitSetting::bUpdateHitBlurCenter' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, DamageAttenuationCurve) == 0x0000E0, "Member 'FEmitterHitSetting::DamageAttenuationCurve' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, PropertyChangeGrowup) == 0x0000F8, "Member 'FEmitterHitSetting::PropertyChangeGrowup' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, DamageEffects) == 0x000108, "Member 'FEmitterHitSetting::DamageEffects' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, PhysicalHitStrength) == 0x000118, "Member 'FEmitterHitSetting::PhysicalHitStrength' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitAnimScale) == 0x00011C, "Member 'FEmitterHitSetting::HitAnimScale' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bEnableCurveHitReaction) == 0x000120, "Member 'FEmitterHitSetting::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bEnableAdditiveHitReaction) == 0x000121, "Member 'FEmitterHitSetting::bEnableAdditiveHitReaction' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, HitReactPerformanceType) == 0x000122, "Member 'FEmitterHitSetting::HitReactPerformanceType' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, AbnormalInfos) == 0x000128, "Member 'FEmitterHitSetting::AbnormalInfos' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, PauseFrameTime) == 0x000138, "Member 'FEmitterHitSetting::PauseFrameTime' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, PauseFrameType) == 0x00013C, "Member 'FEmitterHitSetting::PauseFrameType' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, bStopSpecificSkill) == 0x00013D, "Member 'FEmitterHitSetting::bStopSpecificSkill' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, StopSpecificSkillTimeMap) == 0x000140, "Member 'FEmitterHitSetting::StopSpecificSkillTimeMap' has a wrong offset!");
static_assert(offsetof(FEmitterHitSetting, TimePointEffects) == 0x000190, "Member 'FEmitterHitSetting::TimePointEffects' has a wrong offset!");

// ScriptStruct Game.HPState
// 0x0058 (0x0058 - 0x0000)
struct FHPState final
{
public:
	bool                                          bForceHide;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepVisible;                                      // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastDamageTime;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastAimTime;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 bApplyModifierIDs;                                 // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x38];                                      // 0x0020(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHPState) == 0x000008, "Wrong alignment on FHPState");
static_assert(sizeof(FHPState) == 0x000058, "Wrong size on FHPState");
static_assert(offsetof(FHPState, bForceHide) == 0x000000, "Member 'FHPState::bForceHide' has a wrong offset!");
static_assert(offsetof(FHPState, bKeepVisible) == 0x000001, "Member 'FHPState::bKeepVisible' has a wrong offset!");
static_assert(offsetof(FHPState, LastDamageTime) == 0x000004, "Member 'FHPState::LastDamageTime' has a wrong offset!");
static_assert(offsetof(FHPState, LastAimTime) == 0x000008, "Member 'FHPState::LastAimTime' has a wrong offset!");
static_assert(offsetof(FHPState, bApplyModifierIDs) == 0x000010, "Member 'FHPState::bApplyModifierIDs' has a wrong offset!");

// ScriptStruct Game.SpawnerConfig
// 0x0038 (0x0038 - 0x0000)
struct FSpawnerConfig
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleAnimIndex;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpecializedSkillsConfig               SpecializedSkillsConfig;                           // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SpawnEffectId;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPal;                                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelayTime;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableNavWalking;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnerConfig) == 0x000008, "Wrong alignment on FSpawnerConfig");
static_assert(sizeof(FSpawnerConfig) == 0x000038, "Wrong size on FSpawnerConfig");
static_assert(offsetof(FSpawnerConfig, SpawnerID) == 0x000000, "Member 'FSpawnerConfig::SpawnerID' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, IdleAnimIndex) == 0x000004, "Member 'FSpawnerConfig::IdleAnimIndex' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, SpecializedSkillsConfig) == 0x000008, "Member 'FSpawnerConfig::SpecializedSkillsConfig' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, SpawnEffectId) == 0x000028, "Member 'FSpawnerConfig::SpawnEffectId' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, IsPal) == 0x00002C, "Member 'FSpawnerConfig::IsPal' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, SpawnDelayTime) == 0x000030, "Member 'FSpawnerConfig::SpawnDelayTime' has a wrong offset!");
static_assert(offsetof(FSpawnerConfig, DisableNavWalking) == 0x000034, "Member 'FSpawnerConfig::DisableNavWalking' has a wrong offset!");

// ScriptStruct Game.ActiveSpawnersTemplate
// 0x0080 (0x0088 - 0x0008)
struct FActiveSpawnersTemplate : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Points;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSpawnerConfig>                 SpawnerConfigs;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AIEvent;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnTimes;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitDelayTime;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnNpcSpCfg                         SpawnNpcSpCfg;                                     // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SpLevelStrength;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             CampPriority;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveSpawnersTemplate) == 0x000008, "Wrong alignment on FActiveSpawnersTemplate");
static_assert(sizeof(FActiveSpawnersTemplate) == 0x000088, "Wrong size on FActiveSpawnersTemplate");
static_assert(offsetof(FActiveSpawnersTemplate, ID) == 0x000008, "Member 'FActiveSpawnersTemplate::ID' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, Remark) == 0x000010, "Member 'FActiveSpawnersTemplate::Remark' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, Team) == 0x000020, "Member 'FActiveSpawnersTemplate::Team' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, Points) == 0x000030, "Member 'FActiveSpawnersTemplate::Points' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, SpawnerConfigs) == 0x000040, "Member 'FActiveSpawnersTemplate::SpawnerConfigs' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, AIEvent) == 0x000050, "Member 'FActiveSpawnersTemplate::AIEvent' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, Level) == 0x000054, "Member 'FActiveSpawnersTemplate::Level' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, SpawnTimes) == 0x000058, "Member 'FActiveSpawnersTemplate::SpawnTimes' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, IntervalTime) == 0x00005C, "Member 'FActiveSpawnersTemplate::IntervalTime' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, InitDelayTime) == 0x000060, "Member 'FActiveSpawnersTemplate::InitDelayTime' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, SpawnNpcSpCfg) == 0x000064, "Member 'FActiveSpawnersTemplate::SpawnNpcSpCfg' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, SpLevelStrength) == 0x000074, "Member 'FActiveSpawnersTemplate::SpLevelStrength' has a wrong offset!");
static_assert(offsetof(FActiveSpawnersTemplate, CampPriority) == 0x000078, "Member 'FActiveSpawnersTemplate::CampPriority' has a wrong offset!");

// ScriptStruct Game.SpawnNpcByStruct
// 0x0118 (0x0118 - 0x0000)
struct FSpawnNpcByStruct final
{
public:
	bool                                          ByGroup;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PointName;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExTags;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             CampPriority;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FActiveSpawnersTemplate                Config;                                            // 0x0058(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PointNameCache;                                    // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewBornEffectStartPointName;                       // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomWeight;                                      // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingCustomParam;                               // 0x0104(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BornEffectMaxHeight;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareDuration;                                   // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareUpDuration;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnNpcByStruct) == 0x000008, "Wrong alignment on FSpawnNpcByStruct");
static_assert(sizeof(FSpawnNpcByStruct) == 0x000118, "Wrong size on FSpawnNpcByStruct");
static_assert(offsetof(FSpawnNpcByStruct, ByGroup) == 0x000000, "Member 'FSpawnNpcByStruct::ByGroup' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, GroupName) == 0x000008, "Member 'FSpawnNpcByStruct::GroupName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, PointName) == 0x000018, "Member 'FSpawnNpcByStruct::PointName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, Tag) == 0x000028, "Member 'FSpawnNpcByStruct::Tag' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, ExTags) == 0x000038, "Member 'FSpawnNpcByStruct::ExTags' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, CampPriority) == 0x000048, "Member 'FSpawnNpcByStruct::CampPriority' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, Config) == 0x000058, "Member 'FSpawnNpcByStruct::Config' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, PointNameCache) == 0x0000E0, "Member 'FSpawnNpcByStruct::PointNameCache' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, NewBornEffectStartPointName) == 0x0000F0, "Member 'FSpawnNpcByStruct::NewBornEffectStartPointName' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, RandomWeight) == 0x000100, "Member 'FSpawnNpcByStruct::RandomWeight' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, bIsUsingCustomParam) == 0x000104, "Member 'FSpawnNpcByStruct::bIsUsingCustomParam' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, BornEffectMaxHeight) == 0x000108, "Member 'FSpawnNpcByStruct::BornEffectMaxHeight' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, PrePareDuration) == 0x00010C, "Member 'FSpawnNpcByStruct::PrePareDuration' has a wrong offset!");
static_assert(offsetof(FSpawnNpcByStruct, PrePareUpDuration) == 0x000110, "Member 'FSpawnNpcByStruct::PrePareUpDuration' has a wrong offset!");

// ScriptStruct Game.ContactModifyOutParam
// 0x0034 (0x0034 - 0x0000)
struct FContactModifyOutParam final
{
public:
	struct FVector                                Normal;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicFriction;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticFriction;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDealNormal;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExAngularDamp;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExAngularDampCD;                                   // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExForce;                                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExForceCD;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExAngularDampEffTime;                              // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCollisionEventId;                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContactModifyOutParam) == 0x000004, "Wrong alignment on FContactModifyOutParam");
static_assert(sizeof(FContactModifyOutParam) == 0x000034, "Wrong size on FContactModifyOutParam");
static_assert(offsetof(FContactModifyOutParam, Normal) == 0x000000, "Member 'FContactModifyOutParam::Normal' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, Restitution) == 0x00000C, "Member 'FContactModifyOutParam::Restitution' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, DynamicFriction) == 0x000010, "Member 'FContactModifyOutParam::DynamicFriction' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, StaticFriction) == 0x000014, "Member 'FContactModifyOutParam::StaticFriction' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, HasDealNormal) == 0x000018, "Member 'FContactModifyOutParam::HasDealNormal' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, ExAngularDamp) == 0x00001C, "Member 'FContactModifyOutParam::ExAngularDamp' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, ExAngularDampCD) == 0x000020, "Member 'FContactModifyOutParam::ExAngularDampCD' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, ExForce) == 0x000024, "Member 'FContactModifyOutParam::ExForce' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, ExForceCD) == 0x000028, "Member 'FContactModifyOutParam::ExForceCD' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, ExAngularDampEffTime) == 0x00002C, "Member 'FContactModifyOutParam::ExAngularDampEffTime' has a wrong offset!");
static_assert(offsetof(FContactModifyOutParam, TargetCollisionEventId) == 0x000030, "Member 'FContactModifyOutParam::TargetCollisionEventId' has a wrong offset!");

// ScriptStruct Game.FootPrintConfig
// 0x0068 (0x0070 - 0x0008)
struct FFootPrintConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Explain;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SnowMat;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SnowFootSize;                                      // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BeachMat;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BeachFootSize;                                     // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootPrintConfig) == 0x000008, "Wrong alignment on FFootPrintConfig");
static_assert(sizeof(FFootPrintConfig) == 0x000070, "Wrong size on FFootPrintConfig");
static_assert(offsetof(FFootPrintConfig, ID) == 0x000008, "Member 'FFootPrintConfig::ID' has a wrong offset!");
static_assert(offsetof(FFootPrintConfig, Explain) == 0x000010, "Member 'FFootPrintConfig::Explain' has a wrong offset!");
static_assert(offsetof(FFootPrintConfig, SnowMat) == 0x000020, "Member 'FFootPrintConfig::SnowMat' has a wrong offset!");
static_assert(offsetof(FFootPrintConfig, SnowFootSize) == 0x000038, "Member 'FFootPrintConfig::SnowFootSize' has a wrong offset!");
static_assert(offsetof(FFootPrintConfig, BeachMat) == 0x000048, "Member 'FFootPrintConfig::BeachMat' has a wrong offset!");
static_assert(offsetof(FFootPrintConfig, BeachFootSize) == 0x000060, "Member 'FFootPrintConfig::BeachFootSize' has a wrong offset!");

// ScriptStruct Game.WidgetData
// 0x0070 (0x0070 - 0x0000)
struct FWidgetData final
{
public:
	struct FVector                                WidgetPosition;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WidgetSocket;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHPBarTargetType, int32>                 WidgetID;                                          // 0x0018(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseSocketLocation;                                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRelativeLocation;                              // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetData) == 0x000008, "Wrong alignment on FWidgetData");
static_assert(sizeof(FWidgetData) == 0x000070, "Wrong size on FWidgetData");
static_assert(offsetof(FWidgetData, WidgetPosition) == 0x000000, "Member 'FWidgetData::WidgetPosition' has a wrong offset!");
static_assert(offsetof(FWidgetData, WidgetSocket) == 0x00000C, "Member 'FWidgetData::WidgetSocket' has a wrong offset!");
static_assert(offsetof(FWidgetData, WidgetID) == 0x000018, "Member 'FWidgetData::WidgetID' has a wrong offset!");
static_assert(offsetof(FWidgetData, bUseSocketLocation) == 0x000068, "Member 'FWidgetData::bUseSocketLocation' has a wrong offset!");
static_assert(offsetof(FWidgetData, bUseRelativeLocation) == 0x000069, "Member 'FWidgetData::bUseRelativeLocation' has a wrong offset!");

// ScriptStruct Game.ComponentWidgetData
// 0x0078 (0x0078 - 0x0000)
struct FComponentWidgetData final
{
public:
	struct FWidgetData                            WidgetData;                                        // 0x0000(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ComponentTag;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComponentWidgetData) == 0x000008, "Wrong alignment on FComponentWidgetData");
static_assert(sizeof(FComponentWidgetData) == 0x000078, "Wrong size on FComponentWidgetData");
static_assert(offsetof(FComponentWidgetData, WidgetData) == 0x000000, "Member 'FComponentWidgetData::WidgetData' has a wrong offset!");
static_assert(offsetof(FComponentWidgetData, ComponentTag) == 0x000070, "Member 'FComponentWidgetData::ComponentTag' has a wrong offset!");

// ScriptStruct Game.GyroLayer
// 0x003C (0x003C - 0x0000)
struct FGyroLayer final
{
public:
	struct FVector2D                              MoveFactorXY;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangeXY;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x2C];                                      // 0x0010(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGyroLayer) == 0x000004, "Wrong alignment on FGyroLayer");
static_assert(sizeof(FGyroLayer) == 0x00003C, "Wrong size on FGyroLayer");
static_assert(offsetof(FGyroLayer, MoveFactorXY) == 0x000000, "Member 'FGyroLayer::MoveFactorXY' has a wrong offset!");
static_assert(offsetof(FGyroLayer, RangeXY) == 0x000008, "Member 'FGyroLayer::RangeXY' has a wrong offset!");

// ScriptStruct Game.DamageInfo
// 0x0088 (0x0088 - 0x0000)
struct FDamageInfo final
{
public:
	class UAbilityComponentBase*                  Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameCharacter*                         Launcher;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifyResult;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurAttributeValue;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StrValue;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLocation;                                     // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDotDamage;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDamage;                                       // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitShield;                                        // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialDamageFloat                    SpecialDamageFloat;                                // 0x0050(0x0030)(Transient, NativeAccessSpecifierPublic)
	int32                                         DamageOriginType;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDead;                                             // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHandleFlyType                                HandleFlyType;                                     // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnchantDamage;                                    // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageInfo) == 0x000008, "Wrong alignment on FDamageInfo");
static_assert(sizeof(FDamageInfo) == 0x000088, "Wrong size on FDamageInfo");
static_assert(offsetof(FDamageInfo, Target) == 0x000000, "Member 'FDamageInfo::Target' has a wrong offset!");
static_assert(offsetof(FDamageInfo, Launcher) == 0x000008, "Member 'FDamageInfo::Launcher' has a wrong offset!");
static_assert(offsetof(FDamageInfo, ModifyResult) == 0x000010, "Member 'FDamageInfo::ModifyResult' has a wrong offset!");
static_assert(offsetof(FDamageInfo, Value) == 0x000014, "Member 'FDamageInfo::Value' has a wrong offset!");
static_assert(offsetof(FDamageInfo, CurAttributeValue) == 0x000018, "Member 'FDamageInfo::CurAttributeValue' has a wrong offset!");
static_assert(offsetof(FDamageInfo, StrValue) == 0x000020, "Member 'FDamageInfo::StrValue' has a wrong offset!");
static_assert(offsetof(FDamageInfo, ApplyLocation) == 0x000030, "Member 'FDamageInfo::ApplyLocation' has a wrong offset!");
static_assert(offsetof(FDamageInfo, Direction) == 0x00003C, "Member 'FDamageInfo::Direction' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bDotDamage) == 0x000048, "Member 'FDamageInfo::bDotDamage' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bShowDamage) == 0x000049, "Member 'FDamageInfo::bShowDamage' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bHitShield) == 0x00004A, "Member 'FDamageInfo::bHitShield' has a wrong offset!");
static_assert(offsetof(FDamageInfo, SpecialDamageFloat) == 0x000050, "Member 'FDamageInfo::SpecialDamageFloat' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageOriginType) == 0x000080, "Member 'FDamageInfo::DamageOriginType' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bDead) == 0x000084, "Member 'FDamageInfo::bDead' has a wrong offset!");
static_assert(offsetof(FDamageInfo, HandleFlyType) == 0x000085, "Member 'FDamageInfo::HandleFlyType' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bEnchantDamage) == 0x000086, "Member 'FDamageInfo::bEnchantDamage' has a wrong offset!");

// ScriptStruct Game.FireInfo
// 0x0040 (0x0040 - 0x0000)
struct FFireInfo final
{
public:
	struct FVector                                FireDirection;                                     // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireTimeId;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireCount;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFireInfo) == 0x000008, "Wrong alignment on FFireInfo");
static_assert(sizeof(FFireInfo) == 0x000040, "Wrong size on FFireInfo");
static_assert(offsetof(FFireInfo, FireDirection) == 0x000000, "Member 'FFireInfo::FireDirection' has a wrong offset!");
static_assert(offsetof(FFireInfo, HitLocation) == 0x00000C, "Member 'FFireInfo::HitLocation' has a wrong offset!");
static_assert(offsetof(FFireInfo, OriginLocation) == 0x000018, "Member 'FFireInfo::OriginLocation' has a wrong offset!");
static_assert(offsetof(FFireInfo, FireTimeId) == 0x000024, "Member 'FFireInfo::FireTimeId' has a wrong offset!");
static_assert(offsetof(FFireInfo, FireCount) == 0x000028, "Member 'FFireInfo::FireCount' has a wrong offset!");
static_assert(offsetof(FFireInfo, HitActor) == 0x000030, "Member 'FFireInfo::HitActor' has a wrong offset!");
static_assert(offsetof(FFireInfo, bHit) == 0x000038, "Member 'FFireInfo::bHit' has a wrong offset!");

// ScriptStruct Game.EffectIgnoreDestroy
// 0x0010 (0x0018 - 0x0008)
struct FEffectIgnoreDestroy final : public FTableRowBase
{
public:
	class FString                                 EffectName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectIgnoreDestroy) == 0x000008, "Wrong alignment on FEffectIgnoreDestroy");
static_assert(sizeof(FEffectIgnoreDestroy) == 0x000018, "Wrong size on FEffectIgnoreDestroy");
static_assert(offsetof(FEffectIgnoreDestroy, EffectName) == 0x000008, "Member 'FEffectIgnoreDestroy::EffectName' has a wrong offset!");

// ScriptStruct Game.AbilityBufferRatio
// 0x0008 (0x0008 - 0x0000)
struct FAbilityBufferRatio final
{
public:
	int32                                         BufferId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityBufferRatio) == 0x000004, "Wrong alignment on FAbilityBufferRatio");
static_assert(sizeof(FAbilityBufferRatio) == 0x000008, "Wrong size on FAbilityBufferRatio");
static_assert(offsetof(FAbilityBufferRatio, BufferId) == 0x000000, "Member 'FAbilityBufferRatio::BufferId' has a wrong offset!");
static_assert(offsetof(FAbilityBufferRatio, Ratio) == 0x000004, "Member 'FAbilityBufferRatio::Ratio' has a wrong offset!");

// ScriptStruct Game.QTESwitchParam
// 0x0020 (0x0020 - 0x0000)
struct FQTESwitchParam final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameCharacter*                         LeaveCharacter;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameCharacter*                         EnterCharacter;                                    // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaveCharacterWillBack;                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQTENotLeaveCharacter;                             // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQTESwitchParam) == 0x000008, "Wrong alignment on FQTESwitchParam");
static_assert(sizeof(FQTESwitchParam) == 0x000020, "Wrong size on FQTESwitchParam");
static_assert(offsetof(FQTESwitchParam, bStart) == 0x000000, "Member 'FQTESwitchParam::bStart' has a wrong offset!");
static_assert(offsetof(FQTESwitchParam, LeaveCharacter) == 0x000008, "Member 'FQTESwitchParam::LeaveCharacter' has a wrong offset!");
static_assert(offsetof(FQTESwitchParam, EnterCharacter) == 0x000010, "Member 'FQTESwitchParam::EnterCharacter' has a wrong offset!");
static_assert(offsetof(FQTESwitchParam, bLeaveCharacterWillBack) == 0x000018, "Member 'FQTESwitchParam::bLeaveCharacterWillBack' has a wrong offset!");
static_assert(offsetof(FQTESwitchParam, bQTENotLeaveCharacter) == 0x000019, "Member 'FQTESwitchParam::bQTENotLeaveCharacter' has a wrong offset!");

// ScriptStruct Game.IpRegionResult
// 0x0020 (0x0020 - 0x0000)
struct FIpRegionResult final
{
public:
	class FString                                 AreaCode;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Country;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIpRegionResult) == 0x000008, "Wrong alignment on FIpRegionResult");
static_assert(sizeof(FIpRegionResult) == 0x000020, "Wrong size on FIpRegionResult");
static_assert(offsetof(FIpRegionResult, AreaCode) == 0x000000, "Member 'FIpRegionResult::AreaCode' has a wrong offset!");
static_assert(offsetof(FIpRegionResult, Country) == 0x000010, "Member 'FIpRegionResult::Country' has a wrong offset!");

// ScriptStruct Game.BulletRecoverWeaponTemplate
// 0x0014 (0x0014 - 0x0000)
struct FBulletRecoverWeaponTemplate final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interval;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeChangeType                          CalcType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedValue;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentageValue;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletRecoverWeaponTemplate) == 0x000004, "Wrong alignment on FBulletRecoverWeaponTemplate");
static_assert(sizeof(FBulletRecoverWeaponTemplate) == 0x000014, "Wrong size on FBulletRecoverWeaponTemplate");
static_assert(offsetof(FBulletRecoverWeaponTemplate, WeaponType) == 0x000000, "Member 'FBulletRecoverWeaponTemplate::WeaponType' has a wrong offset!");
static_assert(offsetof(FBulletRecoverWeaponTemplate, Interval) == 0x000004, "Member 'FBulletRecoverWeaponTemplate::Interval' has a wrong offset!");
static_assert(offsetof(FBulletRecoverWeaponTemplate, CalcType) == 0x000008, "Member 'FBulletRecoverWeaponTemplate::CalcType' has a wrong offset!");
static_assert(offsetof(FBulletRecoverWeaponTemplate, FixedValue) == 0x00000C, "Member 'FBulletRecoverWeaponTemplate::FixedValue' has a wrong offset!");
static_assert(offsetof(FBulletRecoverWeaponTemplate, PercentageValue) == 0x000010, "Member 'FBulletRecoverWeaponTemplate::PercentageValue' has a wrong offset!");

// ScriptStruct Game.FloatRandomValue
// 0x000C (0x000C - 0x0000)
struct FFloatRandomValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Random;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatRandomValue) == 0x000004, "Wrong alignment on FFloatRandomValue");
static_assert(sizeof(FFloatRandomValue) == 0x00000C, "Wrong size on FFloatRandomValue");
static_assert(offsetof(FFloatRandomValue, Value) == 0x000000, "Member 'FFloatRandomValue::Value' has a wrong offset!");
static_assert(offsetof(FFloatRandomValue, Random) == 0x000004, "Member 'FFloatRandomValue::Random' has a wrong offset!");

// ScriptStruct Game.TeamSlotConfigInfo
// 0x0060 (0x0060 - 0x0000)
struct FTeamSlotConfigInfo final
{
public:
	TArray<class UAIWeightCondition*>             WeightConditions;                                  // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MembersMaxNum;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAITeamSlotConfig>          AITeamSlotConfigClass;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlotTowardType                               TeamSlotTowardType;                                // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamSlotRotationRate;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamSlotConfigSetDelay;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRandomValue                      SlotRotationRateRandom;                            // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatRandomValue                      SlotRotationAcceptanceAngle;                       // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatRandomValue                      SlotDelayRotateAngle;                              // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatRandomValue                      SlotDelayRotateTime;                               // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamSlotConfigInfo) == 0x000008, "Wrong alignment on FTeamSlotConfigInfo");
static_assert(sizeof(FTeamSlotConfigInfo) == 0x000060, "Wrong size on FTeamSlotConfigInfo");
static_assert(offsetof(FTeamSlotConfigInfo, WeightConditions) == 0x000000, "Member 'FTeamSlotConfigInfo::WeightConditions' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, MembersMaxNum) == 0x000010, "Member 'FTeamSlotConfigInfo::MembersMaxNum' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, AITeamSlotConfigClass) == 0x000018, "Member 'FTeamSlotConfigInfo::AITeamSlotConfigClass' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, TeamSlotTowardType) == 0x000020, "Member 'FTeamSlotConfigInfo::TeamSlotTowardType' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, TeamSlotRotationRate) == 0x000024, "Member 'FTeamSlotConfigInfo::TeamSlotRotationRate' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, TeamSlotConfigSetDelay) == 0x000028, "Member 'FTeamSlotConfigInfo::TeamSlotConfigSetDelay' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, SlotRotationRateRandom) == 0x00002C, "Member 'FTeamSlotConfigInfo::SlotRotationRateRandom' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, SlotRotationAcceptanceAngle) == 0x000038, "Member 'FTeamSlotConfigInfo::SlotRotationAcceptanceAngle' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, SlotDelayRotateAngle) == 0x000044, "Member 'FTeamSlotConfigInfo::SlotDelayRotateAngle' has a wrong offset!");
static_assert(offsetof(FTeamSlotConfigInfo, SlotDelayRotateTime) == 0x000050, "Member 'FTeamSlotConfigInfo::SlotDelayRotateTime' has a wrong offset!");

// ScriptStruct Game.TaskSyncData
// 0x0018 (0x0018 - 0x0000)
struct FTaskSyncData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTaskSyncData) == 0x000008, "Wrong alignment on FTaskSyncData");
static_assert(sizeof(FTaskSyncData) == 0x000018, "Wrong size on FTaskSyncData");
static_assert(offsetof(FTaskSyncData, Name) == 0x000000, "Member 'FTaskSyncData::Name' has a wrong offset!");
static_assert(offsetof(FTaskSyncData, Value) == 0x000010, "Member 'FTaskSyncData::Value' has a wrong offset!");

// ScriptStruct Game.Sync_SkillMoveByMagic
// 0x0050 (0x0050 - 0x0000)
struct FSync_SkillMoveByMagic final
{
public:
	class UBaseMovementComponent*                 Movement;                                          // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Goal;                                              // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMagicParameter                        Info;                                              // 0x0020(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 SkillMoveName;                                     // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InUniqueID;                                        // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSync_SkillMoveByMagic) == 0x000008, "Wrong alignment on FSync_SkillMoveByMagic");
static_assert(sizeof(FSync_SkillMoveByMagic) == 0x000050, "Wrong size on FSync_SkillMoveByMagic");
static_assert(offsetof(FSync_SkillMoveByMagic, Movement) == 0x000000, "Member 'FSync_SkillMoveByMagic::Movement' has a wrong offset!");
static_assert(offsetof(FSync_SkillMoveByMagic, TargetLocation) == 0x000008, "Member 'FSync_SkillMoveByMagic::TargetLocation' has a wrong offset!");
static_assert(offsetof(FSync_SkillMoveByMagic, Goal) == 0x000018, "Member 'FSync_SkillMoveByMagic::Goal' has a wrong offset!");
static_assert(offsetof(FSync_SkillMoveByMagic, Info) == 0x000020, "Member 'FSync_SkillMoveByMagic::Info' has a wrong offset!");
static_assert(offsetof(FSync_SkillMoveByMagic, SkillMoveName) == 0x000038, "Member 'FSync_SkillMoveByMagic::SkillMoveName' has a wrong offset!");
static_assert(offsetof(FSync_SkillMoveByMagic, InUniqueID) == 0x000048, "Member 'FSync_SkillMoveByMagic::InUniqueID' has a wrong offset!");

// ScriptStruct Game.ChangeCameraSetting
// 0x03C0 (0x03C0 - 0x0000)
struct FChangeCameraSetting final
{
public:
	struct FCameraInfo                            NormalCameraInfo;                                  // 0x0000(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraInfo                            FireCameraInfo;                                    // 0x00F0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraInfo                            AimCameraInfo;                                     // 0x01E0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraInfo                            RushCameraInfo;                                    // 0x02D0(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChangeCameraSetting) == 0x000008, "Wrong alignment on FChangeCameraSetting");
static_assert(sizeof(FChangeCameraSetting) == 0x0003C0, "Wrong size on FChangeCameraSetting");
static_assert(offsetof(FChangeCameraSetting, NormalCameraInfo) == 0x000000, "Member 'FChangeCameraSetting::NormalCameraInfo' has a wrong offset!");
static_assert(offsetof(FChangeCameraSetting, FireCameraInfo) == 0x0000F0, "Member 'FChangeCameraSetting::FireCameraInfo' has a wrong offset!");
static_assert(offsetof(FChangeCameraSetting, AimCameraInfo) == 0x0001E0, "Member 'FChangeCameraSetting::AimCameraInfo' has a wrong offset!");
static_assert(offsetof(FChangeCameraSetting, RushCameraInfo) == 0x0002D0, "Member 'FChangeCameraSetting::RushCameraInfo' has a wrong offset!");

// ScriptStruct Game.PreviewAnimNameMappingTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPreviewAnimNameMappingTemplate final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimResName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewAnimNameMappingTemplate) == 0x000008, "Wrong alignment on FPreviewAnimNameMappingTemplate");
static_assert(sizeof(FPreviewAnimNameMappingTemplate) == 0x000040, "Wrong size on FPreviewAnimNameMappingTemplate");
static_assert(offsetof(FPreviewAnimNameMappingTemplate, VariableName) == 0x000008, "Member 'FPreviewAnimNameMappingTemplate::VariableName' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingTemplate, AnimResName) == 0x000018, "Member 'FPreviewAnimNameMappingTemplate::AnimResName' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingTemplate, WidgetContainer) == 0x000028, "Member 'FPreviewAnimNameMappingTemplate::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingTemplate, bUseWeaponSubType) == 0x000038, "Member 'FPreviewAnimNameMappingTemplate::bUseWeaponSubType' has a wrong offset!");

// ScriptStruct Game.OnlineSeaSpawnShipAICharParams
// 0x0020 (0x0020 - 0x0000)
struct FOnlineSeaSpawnShipAICharParams final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AI;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                Type;                                              // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineSeaSpawnShipAICharParams) == 0x000008, "Wrong alignment on FOnlineSeaSpawnShipAICharParams");
static_assert(sizeof(FOnlineSeaSpawnShipAICharParams) == 0x000020, "Wrong size on FOnlineSeaSpawnShipAICharParams");
static_assert(offsetof(FOnlineSeaSpawnShipAICharParams, ID) == 0x000000, "Member 'FOnlineSeaSpawnShipAICharParams::ID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaSpawnShipAICharParams, Level) == 0x000004, "Member 'FOnlineSeaSpawnShipAICharParams::Level' has a wrong offset!");
static_assert(offsetof(FOnlineSeaSpawnShipAICharParams, Team) == 0x000008, "Member 'FOnlineSeaSpawnShipAICharParams::Team' has a wrong offset!");
static_assert(offsetof(FOnlineSeaSpawnShipAICharParams, AI) == 0x000018, "Member 'FOnlineSeaSpawnShipAICharParams::AI' has a wrong offset!");
static_assert(offsetof(FOnlineSeaSpawnShipAICharParams, Type) == 0x00001C, "Member 'FOnlineSeaSpawnShipAICharParams::Type' has a wrong offset!");

// ScriptStruct Game.DamageFloatWidget
// 0x0030 (0x0030 - 0x0000)
struct FDamageFloatWidget final
{
public:
	TArray<EModifyHPResult>                       HitTypes;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AnimWidget;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWorldPos;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageFloatWidget) == 0x000008, "Wrong alignment on FDamageFloatWidget");
static_assert(sizeof(FDamageFloatWidget) == 0x000030, "Wrong size on FDamageFloatWidget");
static_assert(offsetof(FDamageFloatWidget, HitTypes) == 0x000000, "Member 'FDamageFloatWidget::HitTypes' has a wrong offset!");
static_assert(offsetof(FDamageFloatWidget, AnimWidget) == 0x000010, "Member 'FDamageFloatWidget::AnimWidget' has a wrong offset!");
static_assert(offsetof(FDamageFloatWidget, bUseWorldPos) == 0x000028, "Member 'FDamageFloatWidget::bUseWorldPos' has a wrong offset!");

// ScriptStruct Game.DamageFloatWeapon
// 0x0028 (0x0028 - 0x0000)
struct FDamageFloatWeapon final
{
public:
	TArray<EWeaponType>                           WeaponTyps;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DamageType;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageFloatWidget>             WidgetInfos;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageFloatWeapon) == 0x000008, "Wrong alignment on FDamageFloatWeapon");
static_assert(sizeof(FDamageFloatWeapon) == 0x000028, "Wrong size on FDamageFloatWeapon");
static_assert(offsetof(FDamageFloatWeapon, WeaponTyps) == 0x000000, "Member 'FDamageFloatWeapon::WeaponTyps' has a wrong offset!");
static_assert(offsetof(FDamageFloatWeapon, DamageType) == 0x000010, "Member 'FDamageFloatWeapon::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageFloatWeapon, WidgetInfos) == 0x000018, "Member 'FDamageFloatWeapon::WidgetInfos' has a wrong offset!");

// ScriptStruct Game.DamageFloatInfo
// 0x0040 (0x0048 - 0x0008)
struct FDamageFloatInfo final : public FTableRowBase
{
public:
	ECharacterType                                AttackerType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterType>                        BeAttackerTypes;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDamageFloatWeapon>             Widgets;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         DefaultUMG;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageFloatInfo) == 0x000008, "Wrong alignment on FDamageFloatInfo");
static_assert(sizeof(FDamageFloatInfo) == 0x000048, "Wrong size on FDamageFloatInfo");
static_assert(offsetof(FDamageFloatInfo, AttackerType) == 0x000008, "Member 'FDamageFloatInfo::AttackerType' has a wrong offset!");
static_assert(offsetof(FDamageFloatInfo, BeAttackerTypes) == 0x000010, "Member 'FDamageFloatInfo::BeAttackerTypes' has a wrong offset!");
static_assert(offsetof(FDamageFloatInfo, Widgets) == 0x000020, "Member 'FDamageFloatInfo::Widgets' has a wrong offset!");
static_assert(offsetof(FDamageFloatInfo, DefaultUMG) == 0x000030, "Member 'FDamageFloatInfo::DefaultUMG' has a wrong offset!");

// ScriptStruct Game.AISkillTarget
// 0x0020 (0x0020 - 0x0000)
struct FAISkillTarget final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPos;                                         // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PerceptionOffset;                                  // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillTarget) == 0x000004, "Wrong alignment on FAISkillTarget");
static_assert(sizeof(FAISkillTarget) == 0x000020, "Wrong size on FAISkillTarget");
static_assert(offsetof(FAISkillTarget, TargetActor) == 0x000000, "Member 'FAISkillTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FAISkillTarget, TargetPos) == 0x000008, "Member 'FAISkillTarget::TargetPos' has a wrong offset!");
static_assert(offsetof(FAISkillTarget, PerceptionOffset) == 0x000014, "Member 'FAISkillTarget::PerceptionOffset' has a wrong offset!");

// ScriptStruct Game.AISkillTargets
// 0x0010 (0x0010 - 0x0000)
struct FAISkillTargets final
{
public:
	TArray<struct FAISkillTarget>                 AISkillTargets;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillTargets) == 0x000008, "Wrong alignment on FAISkillTargets");
static_assert(sizeof(FAISkillTargets) == 0x000010, "Wrong size on FAISkillTargets");
static_assert(offsetof(FAISkillTargets, AISkillTargets) == 0x000000, "Member 'FAISkillTargets::AISkillTargets' has a wrong offset!");

// ScriptStruct Game.MonSneakParam
// 0x0020 (0x0020 - 0x0000)
struct FMonSneakParam final
{
public:
	class FName                                   MonTag;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundAngle;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightMoveTime;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHoldTime;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHoldTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertnessTime;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleSpeed;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMonSneakParam) == 0x000004, "Wrong alignment on FMonSneakParam");
static_assert(sizeof(FMonSneakParam) == 0x000020, "Wrong size on FMonSneakParam");
static_assert(offsetof(FMonSneakParam, MonTag) == 0x000000, "Member 'FMonSneakParam::MonTag' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, AroundAngle) == 0x000008, "Member 'FMonSneakParam::AroundAngle' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, SightMoveTime) == 0x00000C, "Member 'FMonSneakParam::SightMoveTime' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, LeftHoldTime) == 0x000010, "Member 'FMonSneakParam::LeftHoldTime' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, RightHoldTime) == 0x000014, "Member 'FMonSneakParam::RightHoldTime' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, AlertnessTime) == 0x000018, "Member 'FMonSneakParam::AlertnessTime' has a wrong offset!");
static_assert(offsetof(FMonSneakParam, AngleSpeed) == 0x00001C, "Member 'FMonSneakParam::AngleSpeed' has a wrong offset!");

// ScriptStruct Game.SearchShape_Capsual
// 0x0010 (0x0010 - 0x0000)
struct FSearchShape_Capsual final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Height;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCollision;                                  // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSearchShape_Capsual) == 0x000004, "Wrong alignment on FSearchShape_Capsual");
static_assert(sizeof(FSearchShape_Capsual) == 0x000010, "Wrong size on FSearchShape_Capsual");
static_assert(offsetof(FSearchShape_Capsual, Radius) == 0x000000, "Member 'FSearchShape_Capsual::Radius' has a wrong offset!");
static_assert(offsetof(FSearchShape_Capsual, Height) == 0x000004, "Member 'FSearchShape_Capsual::Height' has a wrong offset!");
static_assert(offsetof(FSearchShape_Capsual, bCreateCollision) == 0x00000C, "Member 'FSearchShape_Capsual::bCreateCollision' has a wrong offset!");

// ScriptStruct Game.SearchShape_Circle
// 0x0010 (0x0010 - 0x0000)
struct FSearchShape_Circle final
{
public:
	struct FVector2D                              Scope;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleLimit;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCollision;                                  // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSearchShape_Circle) == 0x000004, "Wrong alignment on FSearchShape_Circle");
static_assert(sizeof(FSearchShape_Circle) == 0x000010, "Wrong size on FSearchShape_Circle");
static_assert(offsetof(FSearchShape_Circle, Scope) == 0x000000, "Member 'FSearchShape_Circle::Scope' has a wrong offset!");
static_assert(offsetof(FSearchShape_Circle, AngleLimit) == 0x000008, "Member 'FSearchShape_Circle::AngleLimit' has a wrong offset!");
static_assert(offsetof(FSearchShape_Circle, bCreateCollision) == 0x00000C, "Member 'FSearchShape_Circle::bCreateCollision' has a wrong offset!");

// ScriptStruct Game.SearchShape_Square
// 0x001C (0x001C - 0x0000)
struct FSearchShape_Square final
{
public:
	struct FVector2D                              XScope;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              YScope;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ZScope;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLineCenter;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCollision;                                  // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSearchShape_Square) == 0x000004, "Wrong alignment on FSearchShape_Square");
static_assert(sizeof(FSearchShape_Square) == 0x00001C, "Wrong size on FSearchShape_Square");
static_assert(offsetof(FSearchShape_Square, XScope) == 0x000000, "Member 'FSearchShape_Square::XScope' has a wrong offset!");
static_assert(offsetof(FSearchShape_Square, YScope) == 0x000008, "Member 'FSearchShape_Square::YScope' has a wrong offset!");
static_assert(offsetof(FSearchShape_Square, ZScope) == 0x000010, "Member 'FSearchShape_Square::ZScope' has a wrong offset!");
static_assert(offsetof(FSearchShape_Square, bUseLineCenter) == 0x000018, "Member 'FSearchShape_Square::bUseLineCenter' has a wrong offset!");
static_assert(offsetof(FSearchShape_Square, bCreateCollision) == 0x000019, "Member 'FSearchShape_Square::bCreateCollision' has a wrong offset!");

// ScriptStruct Game.SearchShape_Cylinder
// 0x000C (0x000C - 0x0000)
struct FSearchShape_Cylinder final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Height;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSearchShape_Cylinder) == 0x000004, "Wrong alignment on FSearchShape_Cylinder");
static_assert(sizeof(FSearchShape_Cylinder) == 0x00000C, "Wrong size on FSearchShape_Cylinder");
static_assert(offsetof(FSearchShape_Cylinder, Radius) == 0x000000, "Member 'FSearchShape_Cylinder::Radius' has a wrong offset!");
static_assert(offsetof(FSearchShape_Cylinder, Height) == 0x000004, "Member 'FSearchShape_Cylinder::Height' has a wrong offset!");

// ScriptStruct Game.AnchorSetting
// 0x00C0 (0x00C0 - 0x0000)
struct FAnchorSetting final
{
public:
	EAnchorPointType                              AnchorPointType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchTargetPartType                         AnchorPartType;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EmitterID;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SceneTargetsTag;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnchorPointFixType                           AnchorFixRule;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnchorFixSocketName;                               // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AnchorPointRulePath;                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnchorPointLimit;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnchorDirectionType                          AnchorDirection;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillStorageTransformID;                           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AppointWorldRotation;                              // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInverseDirection;                                 // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchShape                                  SearchShapeType;                                   // 0x0065(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSearchShape_Circle                    CircleInfo;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSearchShape_Square                    SquareInfo;                                        // 0x0078(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSearchShape_Capsual                   CapsuleInfo;                                       // 0x0094(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSearchShape_Cylinder                  CylinderInfo;                                      // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      CollisionObjectTypes;                              // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnchorSetting) == 0x000008, "Wrong alignment on FAnchorSetting");
static_assert(sizeof(FAnchorSetting) == 0x0000C0, "Wrong size on FAnchorSetting");
static_assert(offsetof(FAnchorSetting, AnchorPointType) == 0x000000, "Member 'FAnchorSetting::AnchorPointType' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorPartType) == 0x000001, "Member 'FAnchorSetting::AnchorPartType' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, EmitterID) == 0x000004, "Member 'FAnchorSetting::EmitterID' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, SceneTargetsTag) == 0x000008, "Member 'FAnchorSetting::SceneTargetsTag' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorFixRule) == 0x000018, "Member 'FAnchorSetting::AnchorFixRule' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorFixSocketName) == 0x000020, "Member 'FAnchorSetting::AnchorFixSocketName' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorPointRulePath) == 0x000030, "Member 'FAnchorSetting::AnchorPointRulePath' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorPointLimit) == 0x000048, "Member 'FAnchorSetting::AnchorPointLimit' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AnchorDirection) == 0x000050, "Member 'FAnchorSetting::AnchorDirection' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, SkillStorageTransformID) == 0x000054, "Member 'FAnchorSetting::SkillStorageTransformID' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, AppointWorldRotation) == 0x000058, "Member 'FAnchorSetting::AppointWorldRotation' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, bInverseDirection) == 0x000064, "Member 'FAnchorSetting::bInverseDirection' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, SearchShapeType) == 0x000065, "Member 'FAnchorSetting::SearchShapeType' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, CircleInfo) == 0x000068, "Member 'FAnchorSetting::CircleInfo' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, SquareInfo) == 0x000078, "Member 'FAnchorSetting::SquareInfo' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, CapsuleInfo) == 0x000094, "Member 'FAnchorSetting::CapsuleInfo' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, CylinderInfo) == 0x0000A4, "Member 'FAnchorSetting::CylinderInfo' has a wrong offset!");
static_assert(offsetof(FAnchorSetting, CollisionObjectTypes) == 0x0000B0, "Member 'FAnchorSetting::CollisionObjectTypes' has a wrong offset!");

// ScriptStruct Game.MapPiece
// 0x0030 (0x0030 - 0x0000)
struct FMapPiece final
{
public:
	struct FVector2D                              Pos;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PicPath;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDarkZonePointBase*>             PiecePoints;                                       // 0x0018(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapPiece) == 0x000008, "Wrong alignment on FMapPiece");
static_assert(sizeof(FMapPiece) == 0x000030, "Wrong size on FMapPiece");
static_assert(offsetof(FMapPiece, Pos) == 0x000000, "Member 'FMapPiece::Pos' has a wrong offset!");
static_assert(offsetof(FMapPiece, PicPath) == 0x000008, "Member 'FMapPiece::PicPath' has a wrong offset!");
static_assert(offsetof(FMapPiece, PiecePoints) == 0x000018, "Member 'FMapPiece::PiecePoints' has a wrong offset!");

// ScriptStruct Game.CharacterStateDepthOpacityParam
// 0x0008 (0x0008 - 0x0000)
struct FCharacterStateDepthOpacityParam final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDepthOpacity;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterStateDepthOpacityParam) == 0x000004, "Wrong alignment on FCharacterStateDepthOpacityParam");
static_assert(sizeof(FCharacterStateDepthOpacityParam) == 0x000008, "Wrong size on FCharacterStateDepthOpacityParam");
static_assert(offsetof(FCharacterStateDepthOpacityParam, Slot) == 0x000000, "Member 'FCharacterStateDepthOpacityParam::Slot' has a wrong offset!");
static_assert(offsetof(FCharacterStateDepthOpacityParam, bDepthOpacity) == 0x000004, "Member 'FCharacterStateDepthOpacityParam::bDepthOpacity' has a wrong offset!");

// ScriptStruct Game.CharacterStateSkmParam
// 0x0010 (0x0010 - 0x0000)
struct FCharacterStateSkmParam final
{
public:
	TArray<struct FCharacterStateDepthOpacityParam> Param;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterStateSkmParam) == 0x000008, "Wrong alignment on FCharacterStateSkmParam");
static_assert(sizeof(FCharacterStateSkmParam) == 0x000010, "Wrong size on FCharacterStateSkmParam");
static_assert(offsetof(FCharacterStateSkmParam, Param) == 0x000000, "Member 'FCharacterStateSkmParam::Param' has a wrong offset!");

// ScriptStruct Game.CharacterStateStartParam
// 0x0100 (0x0100 - 0x0000)
struct FCharacterStateStartParam final
{
public:
	TArray<class AActor*>                         Targets;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComponent;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatIndex;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDepth;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomDepth;                                      // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomStencil;                                 // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomStencil;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondarySlot;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecSlotName;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTranslucent2Mask;                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FCharacterStateSkmParam> SkmSettings;                                       // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SecondaryMaterial;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             SecondaryMaterials;                                // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UMaterialInterface*>  SecondaryMaterialsBySlot;                          // 0x00A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ECharacterMaterialType                        AbnormalBlendMode;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBody;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyFace;                                        // 0x00FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAccessory;                                   // 0x00FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterStateStartParam) == 0x000008, "Wrong alignment on FCharacterStateStartParam");
static_assert(sizeof(FCharacterStateStartParam) == 0x000100, "Wrong size on FCharacterStateStartParam");
static_assert(offsetof(FCharacterStateStartParam, Targets) == 0x000000, "Member 'FCharacterStateStartParam::Targets' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, MeshComponent) == 0x000010, "Member 'FCharacterStateStartParam::MeshComponent' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, MatIndex) == 0x000018, "Member 'FCharacterStateStartParam::MatIndex' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SlotName) == 0x00001C, "Member 'FCharacterStateStartParam::SlotName' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bUseCustomDepth) == 0x000024, "Member 'FCharacterStateStartParam::bUseCustomDepth' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bCustomDepth) == 0x000025, "Member 'FCharacterStateStartParam::bCustomDepth' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bUseCustomStencil) == 0x000026, "Member 'FCharacterStateStartParam::bUseCustomStencil' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, CustomStencil) == 0x000028, "Member 'FCharacterStateStartParam::CustomStencil' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SecondarySlot) == 0x00002C, "Member 'FCharacterStateStartParam::SecondarySlot' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SecSlotName) == 0x000030, "Member 'FCharacterStateStartParam::SecSlotName' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bIgnoreTranslucent2Mask) == 0x000038, "Member 'FCharacterStateStartParam::bIgnoreTranslucent2Mask' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SkmSettings) == 0x000040, "Member 'FCharacterStateStartParam::SkmSettings' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SecondaryMaterial) == 0x000090, "Member 'FCharacterStateStartParam::SecondaryMaterial' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SecondaryMaterials) == 0x000098, "Member 'FCharacterStateStartParam::SecondaryMaterials' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, SecondaryMaterialsBySlot) == 0x0000A8, "Member 'FCharacterStateStartParam::SecondaryMaterialsBySlot' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, AbnormalBlendMode) == 0x0000F8, "Member 'FCharacterStateStartParam::AbnormalBlendMode' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bApplyBody) == 0x0000F9, "Member 'FCharacterStateStartParam::bApplyBody' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bApplyFace) == 0x0000FA, "Member 'FCharacterStateStartParam::bApplyFace' has a wrong offset!");
static_assert(offsetof(FCharacterStateStartParam, bApplyAccessory) == 0x0000FB, "Member 'FCharacterStateStartParam::bApplyAccessory' has a wrong offset!");

// ScriptStruct Game.BunkerEdgeMoveData
// 0x0050 (0x0050 - 0x0000)
struct FBunkerEdgeMoveData final
{
public:
	class AGamePlayer*                            CurPlayer;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBunkerEdgeMoveData) == 0x000008, "Wrong alignment on FBunkerEdgeMoveData");
static_assert(sizeof(FBunkerEdgeMoveData) == 0x000050, "Wrong size on FBunkerEdgeMoveData");
static_assert(offsetof(FBunkerEdgeMoveData, CurPlayer) == 0x000000, "Member 'FBunkerEdgeMoveData::CurPlayer' has a wrong offset!");

// ScriptStruct Game.FloatingFontOutlineSettings
// 0x0030 (0x0030 - 0x0000)
struct FFloatingFontOutlineSettings final
{
public:
	int32                                         OutlineSize;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeparateFillAlpha;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyOutlineToDropShadows;                        // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        OutlineMaterialPath;                               // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColor;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatingFontOutlineSettings) == 0x000008, "Wrong alignment on FFloatingFontOutlineSettings");
static_assert(sizeof(FFloatingFontOutlineSettings) == 0x000030, "Wrong size on FFloatingFontOutlineSettings");
static_assert(offsetof(FFloatingFontOutlineSettings, OutlineSize) == 0x000000, "Member 'FFloatingFontOutlineSettings::OutlineSize' has a wrong offset!");
static_assert(offsetof(FFloatingFontOutlineSettings, bSeparateFillAlpha) == 0x000004, "Member 'FFloatingFontOutlineSettings::bSeparateFillAlpha' has a wrong offset!");
static_assert(offsetof(FFloatingFontOutlineSettings, bApplyOutlineToDropShadows) == 0x000005, "Member 'FFloatingFontOutlineSettings::bApplyOutlineToDropShadows' has a wrong offset!");
static_assert(offsetof(FFloatingFontOutlineSettings, OutlineMaterialPath) == 0x000008, "Member 'FFloatingFontOutlineSettings::OutlineMaterialPath' has a wrong offset!");
static_assert(offsetof(FFloatingFontOutlineSettings, OutlineColor) == 0x000020, "Member 'FFloatingFontOutlineSettings::OutlineColor' has a wrong offset!");

// ScriptStruct Game.FloatFontInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FFloatFontInfo final
{
public:
	struct FSoftObjectPath                        FontPath;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FontMaterialPath;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatingFontOutlineSettings           OutlineSettings;                                   // 0x0030(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   TypefaceFontName;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LetterSpacing;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x78];                                      // 0x0070(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatFontInfo) == 0x000008, "Wrong alignment on FFloatFontInfo");
static_assert(sizeof(FFloatFontInfo) == 0x0000E8, "Wrong size on FFloatFontInfo");
static_assert(offsetof(FFloatFontInfo, FontPath) == 0x000000, "Member 'FFloatFontInfo::FontPath' has a wrong offset!");
static_assert(offsetof(FFloatFontInfo, FontMaterialPath) == 0x000018, "Member 'FFloatFontInfo::FontMaterialPath' has a wrong offset!");
static_assert(offsetof(FFloatFontInfo, OutlineSettings) == 0x000030, "Member 'FFloatFontInfo::OutlineSettings' has a wrong offset!");
static_assert(offsetof(FFloatFontInfo, TypefaceFontName) == 0x000060, "Member 'FFloatFontInfo::TypefaceFontName' has a wrong offset!");
static_assert(offsetof(FFloatFontInfo, Size) == 0x000068, "Member 'FFloatFontInfo::Size' has a wrong offset!");
static_assert(offsetof(FFloatFontInfo, LetterSpacing) == 0x00006C, "Member 'FFloatFontInfo::LetterSpacing' has a wrong offset!");

// ScriptStruct Game.DamageFloatDetailInfo
// 0x0148 (0x0148 - 0x0000)
struct FDamageFloatDetailInfo final
{
public:
	int32                                         DamageType;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NodeName;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetDamage;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetFont;                                          // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatFontInfo                         NewFontInfo;                                       // 0x0010(0x00E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSetColor;                                         // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Color;                                             // 0x0100(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSetImage;                                         // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SpritePath;                                        // 0x0130(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageFloatDetailInfo) == 0x000008, "Wrong alignment on FDamageFloatDetailInfo");
static_assert(sizeof(FDamageFloatDetailInfo) == 0x000148, "Wrong size on FDamageFloatDetailInfo");
static_assert(offsetof(FDamageFloatDetailInfo, DamageType) == 0x000000, "Member 'FDamageFloatDetailInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, NodeName) == 0x000004, "Member 'FDamageFloatDetailInfo::NodeName' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, bSetDamage) == 0x00000C, "Member 'FDamageFloatDetailInfo::bSetDamage' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, bShow) == 0x00000D, "Member 'FDamageFloatDetailInfo::bShow' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, bSetFont) == 0x00000E, "Member 'FDamageFloatDetailInfo::bSetFont' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, NewFontInfo) == 0x000010, "Member 'FDamageFloatDetailInfo::NewFontInfo' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, bSetColor) == 0x0000F8, "Member 'FDamageFloatDetailInfo::bSetColor' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, Color) == 0x000100, "Member 'FDamageFloatDetailInfo::Color' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, bSetImage) == 0x000128, "Member 'FDamageFloatDetailInfo::bSetImage' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetailInfo, SpritePath) == 0x000130, "Member 'FDamageFloatDetailInfo::SpritePath' has a wrong offset!");

// ScriptStruct Game.ConditonFuncitonParam
// 0x0028 (0x0028 - 0x0000)
struct FConditonFuncitonParam final
{
public:
	class AActor*                                 Launcher;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Creator;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelegateCastIndex;                                 // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckConditonGroup;                                // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InSkillId;                                         // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseLauncher;                                  // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditonFuncitonParam) == 0x000008, "Wrong alignment on FConditonFuncitonParam");
static_assert(sizeof(FConditonFuncitonParam) == 0x000028, "Wrong size on FConditonFuncitonParam");
static_assert(offsetof(FConditonFuncitonParam, Launcher) == 0x000000, "Member 'FConditonFuncitonParam::Launcher' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, Creator) == 0x000008, "Member 'FConditonFuncitonParam::Creator' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, Target) == 0x000010, "Member 'FConditonFuncitonParam::Target' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, DelegateCastIndex) == 0x000018, "Member 'FConditonFuncitonParam::DelegateCastIndex' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, CheckConditonGroup) == 0x00001C, "Member 'FConditonFuncitonParam::CheckConditonGroup' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, InSkillId) == 0x000020, "Member 'FConditonFuncitonParam::InSkillId' has a wrong offset!");
static_assert(offsetof(FConditonFuncitonParam, bOnlyUseLauncher) == 0x000024, "Member 'FConditonFuncitonParam::bOnlyUseLauncher' has a wrong offset!");

// ScriptStruct Game.CharacterMCSlotMaterialInfo
// 0x03F8 (0x03F8 - 0x0000)
struct alignas(0x08) FCharacterMCSlotMaterialInfo final
{
public:
	uint8                                         Pad_0[0x3F8];                                      // 0x0000(0x03F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMCSlotMaterialInfo) == 0x000008, "Wrong alignment on FCharacterMCSlotMaterialInfo");
static_assert(sizeof(FCharacterMCSlotMaterialInfo) == 0x0003F8, "Wrong size on FCharacterMCSlotMaterialInfo");

// ScriptStruct Game.VehicleCameraShake
// 0x0018 (0x0018 - 0x0000)
struct FVehicleCameraShake final
{
public:
	struct FVector                                CameraShakeAnchor;                                 // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraShakeBase*                       CameraShake;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleCameraShake) == 0x000008, "Wrong alignment on FVehicleCameraShake");
static_assert(sizeof(FVehicleCameraShake) == 0x000018, "Wrong size on FVehicleCameraShake");
static_assert(offsetof(FVehicleCameraShake, CameraShakeAnchor) == 0x000000, "Member 'FVehicleCameraShake::CameraShakeAnchor' has a wrong offset!");
static_assert(offsetof(FVehicleCameraShake, CameraShake) == 0x000010, "Member 'FVehicleCameraShake::CameraShake' has a wrong offset!");

// ScriptStruct Game.AbilityForceFeedbackInfo
// 0x0068 (0x0070 - 0x0008)
struct FAbilityForceFeedbackInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityForceFeedbackType                     Type;                                              // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityCommonForceFeedback            ForceFeedbackCommon;                               // 0x0010(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAbilityCommonForceFeedback            ForceFeedbackCommonPS;                             // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int64>                                 IgnoreCharacterIDs;                                // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityForceFeedbackInfo) == 0x000008, "Wrong alignment on FAbilityForceFeedbackInfo");
static_assert(sizeof(FAbilityForceFeedbackInfo) == 0x000070, "Wrong size on FAbilityForceFeedbackInfo");
static_assert(offsetof(FAbilityForceFeedbackInfo, ID) == 0x000008, "Member 'FAbilityForceFeedbackInfo::ID' has a wrong offset!");
static_assert(offsetof(FAbilityForceFeedbackInfo, Type) == 0x00000C, "Member 'FAbilityForceFeedbackInfo::Type' has a wrong offset!");
static_assert(offsetof(FAbilityForceFeedbackInfo, ForceFeedbackCommon) == 0x000010, "Member 'FAbilityForceFeedbackInfo::ForceFeedbackCommon' has a wrong offset!");
static_assert(offsetof(FAbilityForceFeedbackInfo, ForceFeedbackCommonPS) == 0x000038, "Member 'FAbilityForceFeedbackInfo::ForceFeedbackCommonPS' has a wrong offset!");
static_assert(offsetof(FAbilityForceFeedbackInfo, IgnoreCharacterIDs) == 0x000060, "Member 'FAbilityForceFeedbackInfo::IgnoreCharacterIDs' has a wrong offset!");

// ScriptStruct Game.CameraStateOverride
// 0x0004 (0x0004 - 0x0000)
struct FCameraStateOverride final
{
public:
	float                                         BlendOutTime;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraStateOverride) == 0x000004, "Wrong alignment on FCameraStateOverride");
static_assert(sizeof(FCameraStateOverride) == 0x000004, "Wrong size on FCameraStateOverride");
static_assert(offsetof(FCameraStateOverride, BlendOutTime) == 0x000000, "Member 'FCameraStateOverride::BlendOutTime' has a wrong offset!");

// ScriptStruct Game.FixDataInfo
// 0x0018 (0x0018 - 0x0000)
struct FFixDataInfo final
{
public:
	int32                                         MasterID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReplaceIDs;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFixDataInfo) == 0x000008, "Wrong alignment on FFixDataInfo");
static_assert(sizeof(FFixDataInfo) == 0x000018, "Wrong size on FFixDataInfo");
static_assert(offsetof(FFixDataInfo, MasterID) == 0x000000, "Member 'FFixDataInfo::MasterID' has a wrong offset!");
static_assert(offsetof(FFixDataInfo, ReplaceIDs) == 0x000008, "Member 'FFixDataInfo::ReplaceIDs' has a wrong offset!");

// ScriptStruct Game.SkillFixInfo
// 0x01C0 (0x01C8 - 0x0008)
struct FSkillFixInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SpritePath;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasterSkillID;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveSkillID;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 TeamPassiveSkillID;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveModifierID;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   ReplaceSkills;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   ReplaceEmitters;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   ReplaceModifiers;                                  // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   ReplaceTraps;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   ReplaceBullets;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ActiveSkills;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ActiveEmitters;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EWeaponType>                           WeaponTypes;                                       // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         WeaponDamageType;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 WeaponPassiveSkillIDs;                             // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 WeaponActiveSkills;                                // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 WeaponActiveEmitters;                              // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 WeaponPassiveModifierID;                           // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   WeaponReplaceSkills;                               // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   WeaponReplaceEmitters;                             // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   WeaponReplaceModifiers;                            // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   WeaponReplaceTraps;                                // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFixDataInfo>                   WeaponReplaceBullets;                              // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            SkillLevelFixMap;                                  // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillFixInfo) == 0x000008, "Wrong alignment on FSkillFixInfo");
static_assert(sizeof(FSkillFixInfo) == 0x0001C8, "Wrong size on FSkillFixInfo");
static_assert(offsetof(FSkillFixInfo, ID) == 0x000008, "Member 'FSkillFixInfo::ID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, SpritePath) == 0x000010, "Member 'FSkillFixInfo::SpritePath' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, Priority) == 0x000028, "Member 'FSkillFixInfo::Priority' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, MasterSkillID) == 0x00002C, "Member 'FSkillFixInfo::MasterSkillID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, PassiveSkillID) == 0x000030, "Member 'FSkillFixInfo::PassiveSkillID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, TeamPassiveSkillID) == 0x000040, "Member 'FSkillFixInfo::TeamPassiveSkillID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, PassiveModifierID) == 0x000050, "Member 'FSkillFixInfo::PassiveModifierID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ReplaceSkills) == 0x000060, "Member 'FSkillFixInfo::ReplaceSkills' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ReplaceEmitters) == 0x000070, "Member 'FSkillFixInfo::ReplaceEmitters' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ReplaceModifiers) == 0x000080, "Member 'FSkillFixInfo::ReplaceModifiers' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ReplaceTraps) == 0x000090, "Member 'FSkillFixInfo::ReplaceTraps' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ReplaceBullets) == 0x0000A0, "Member 'FSkillFixInfo::ReplaceBullets' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ActiveSkills) == 0x0000B0, "Member 'FSkillFixInfo::ActiveSkills' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, ActiveEmitters) == 0x0000C0, "Member 'FSkillFixInfo::ActiveEmitters' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponTypes) == 0x0000D0, "Member 'FSkillFixInfo::WeaponTypes' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponDamageType) == 0x0000E0, "Member 'FSkillFixInfo::WeaponDamageType' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponPassiveSkillIDs) == 0x0000E8, "Member 'FSkillFixInfo::WeaponPassiveSkillIDs' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponActiveSkills) == 0x0000F8, "Member 'FSkillFixInfo::WeaponActiveSkills' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponActiveEmitters) == 0x000108, "Member 'FSkillFixInfo::WeaponActiveEmitters' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponPassiveModifierID) == 0x000118, "Member 'FSkillFixInfo::WeaponPassiveModifierID' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponReplaceSkills) == 0x000128, "Member 'FSkillFixInfo::WeaponReplaceSkills' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponReplaceEmitters) == 0x000138, "Member 'FSkillFixInfo::WeaponReplaceEmitters' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponReplaceModifiers) == 0x000148, "Member 'FSkillFixInfo::WeaponReplaceModifiers' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponReplaceTraps) == 0x000158, "Member 'FSkillFixInfo::WeaponReplaceTraps' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, WeaponReplaceBullets) == 0x000168, "Member 'FSkillFixInfo::WeaponReplaceBullets' has a wrong offset!");
static_assert(offsetof(FSkillFixInfo, SkillLevelFixMap) == 0x000178, "Member 'FSkillFixInfo::SkillLevelFixMap' has a wrong offset!");

// ScriptStruct Game.FarmWarDropItemData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x04) FFarmWarDropItemData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFarmWarDropItemData) == 0x000004, "Wrong alignment on FFarmWarDropItemData");
static_assert(sizeof(FFarmWarDropItemData) == 0x000048, "Wrong size on FFarmWarDropItemData");

// ScriptStruct Game.Attribute
// 0x0010 (0x0010 - 0x0000)
struct Game::FAttribute final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Addition;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multi;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Game::FAttribute) == 0x000004, "Wrong alignment on Game::FAttribute");
static_assert(sizeof(Game::FAttribute) == 0x000010, "Wrong size on Game::FAttribute");
static_assert(offsetof(Game::FAttribute, BaseValue) == 0x000000, "Member 'Game::FAttribute::BaseValue' has a wrong offset!");
static_assert(offsetof(Game::FAttribute, CurrentValue) == 0x000004, "Member 'Game::FAttribute::CurrentValue' has a wrong offset!");
static_assert(offsetof(Game::FAttribute, Addition) == 0x000008, "Member 'Game::FAttribute::Addition' has a wrong offset!");
static_assert(offsetof(Game::FAttribute, Multi) == 0x00000C, "Member 'Game::FAttribute::Multi' has a wrong offset!");

// ScriptStruct Game.SpawnLocRot
// 0x0018 (0x0018 - 0x0000)
struct FSpawnLocRot final
{
public:
	struct FVector                                SpawnLoc;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRot;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnLocRot) == 0x000004, "Wrong alignment on FSpawnLocRot");
static_assert(sizeof(FSpawnLocRot) == 0x000018, "Wrong size on FSpawnLocRot");
static_assert(offsetof(FSpawnLocRot, SpawnLoc) == 0x000000, "Member 'FSpawnLocRot::SpawnLoc' has a wrong offset!");
static_assert(offsetof(FSpawnLocRot, SpawnRot) == 0x00000C, "Member 'FSpawnLocRot::SpawnRot' has a wrong offset!");

// ScriptStruct Game.FarmWarPlantInfo
// 0x000C (0x000C - 0x0000)
struct FFarmWarPlantInfo final
{
public:
	int32                                         TemplateId;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VegTag;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFarmWarPlantInfo) == 0x000004, "Wrong alignment on FFarmWarPlantInfo");
static_assert(sizeof(FFarmWarPlantInfo) == 0x00000C, "Wrong size on FFarmWarPlantInfo");
static_assert(offsetof(FFarmWarPlantInfo, TemplateId) == 0x000000, "Member 'FFarmWarPlantInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FFarmWarPlantInfo, VegTag) == 0x000004, "Member 'FFarmWarPlantInfo::VegTag' has a wrong offset!");

// ScriptStruct Game.GamepadShieldKeyRow
// 0x0018 (0x0020 - 0x0008)
struct FGamepadShieldKeyRow final : public FTableRowBase
{
public:
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadShieldKeyRow) == 0x000008, "Wrong alignment on FGamepadShieldKeyRow");
static_assert(sizeof(FGamepadShieldKeyRow) == 0x000020, "Wrong size on FGamepadShieldKeyRow");
static_assert(offsetof(FGamepadShieldKeyRow, Key) == 0x000008, "Member 'FGamepadShieldKeyRow::Key' has a wrong offset!");

// ScriptStruct Game.AnimInfoNet
// 0x0050 (0x0050 - 0x0000)
struct FAnimInfoNet final
{
public:
	EGamePlayerMoveState                          MoveAnimState;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MontageIndex_External;                             // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastMontageIndex_External;                         // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MontageIndex;                                      // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageSectionStart;                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcePlay;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    AimAtLocation;                                     // 0x000C(0x000C)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    BunkerMoveDirection;                               // 0x0018(0x000C)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    MoveDirection;                                     // 0x0024(0x000C)(Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeaponRaised;                                   // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdvanceAction;                                  // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBunkerLeaned;                                   // 0x0042(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetainBunkerLeaned;                               // 0x0043(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftSideBunker;                                 // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBunkerCrouching;                                // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBunkering;                                      // 0x0046(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBunkerShootingUnLeaned;                         // 0x0047(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimInfoNet) == 0x000008, "Wrong alignment on FAnimInfoNet");
static_assert(sizeof(FAnimInfoNet) == 0x000050, "Wrong size on FAnimInfoNet");
static_assert(offsetof(FAnimInfoNet, MoveAnimState) == 0x000000, "Member 'FAnimInfoNet::MoveAnimState' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, MontageIndex_External) == 0x000001, "Member 'FAnimInfoNet::MontageIndex_External' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, LastMontageIndex_External) == 0x000002, "Member 'FAnimInfoNet::LastMontageIndex_External' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, MontageIndex) == 0x000003, "Member 'FAnimInfoNet::MontageIndex' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, MontageSectionStart) == 0x000004, "Member 'FAnimInfoNet::MontageSectionStart' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bForcePlay) == 0x000008, "Member 'FAnimInfoNet::bForcePlay' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, AimAtLocation) == 0x00000C, "Member 'FAnimInfoNet::AimAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, BunkerMoveDirection) == 0x000018, "Member 'FAnimInfoNet::BunkerMoveDirection' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, MoveDirection) == 0x000024, "Member 'FAnimInfoNet::MoveDirection' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, Timestamp) == 0x000030, "Member 'FAnimInfoNet::Timestamp' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, MontageToPlay) == 0x000038, "Member 'FAnimInfoNet::MontageToPlay' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsWeaponRaised) == 0x000040, "Member 'FAnimInfoNet::bIsWeaponRaised' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsAdvanceAction) == 0x000041, "Member 'FAnimInfoNet::bIsAdvanceAction' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsBunkerLeaned) == 0x000042, "Member 'FAnimInfoNet::bIsBunkerLeaned' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bRetainBunkerLeaned) == 0x000043, "Member 'FAnimInfoNet::bRetainBunkerLeaned' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsLeftSideBunker) == 0x000044, "Member 'FAnimInfoNet::bIsLeftSideBunker' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsBunkerCrouching) == 0x000045, "Member 'FAnimInfoNet::bIsBunkerCrouching' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsBunkering) == 0x000046, "Member 'FAnimInfoNet::bIsBunkering' has a wrong offset!");
static_assert(offsetof(FAnimInfoNet, bIsBunkerShootingUnLeaned) == 0x000047, "Member 'FAnimInfoNet::bIsBunkerShootingUnLeaned' has a wrong offset!");

// ScriptStruct Game.ControlLockState
// 0x0012 (0x0012 - 0x0000)
struct FControlLockState final
{
public:
	bool                                          bLockMove;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCamera;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockSkill;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAim;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockFire;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockDodge;                                        // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockSwitch;                                       // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockQTE;                                          // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCross;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockBunkerInteract;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockJump;                                         // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockReload;                                       // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRush;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockUIAction;                                     // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExceptHalfSkill;                                  // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelSkill;                                      // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELockCtrlReason                               Reason;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1];                                       // 0x0011(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlLockState) == 0x000001, "Wrong alignment on FControlLockState");
static_assert(sizeof(FControlLockState) == 0x000012, "Wrong size on FControlLockState");
static_assert(offsetof(FControlLockState, bLockMove) == 0x000000, "Member 'FControlLockState::bLockMove' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockCamera) == 0x000001, "Member 'FControlLockState::bLockCamera' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockSkill) == 0x000002, "Member 'FControlLockState::bLockSkill' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockAim) == 0x000003, "Member 'FControlLockState::bLockAim' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockFire) == 0x000004, "Member 'FControlLockState::bLockFire' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockDodge) == 0x000005, "Member 'FControlLockState::bLockDodge' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockSwitch) == 0x000006, "Member 'FControlLockState::bLockSwitch' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockQTE) == 0x000007, "Member 'FControlLockState::bLockQTE' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockCross) == 0x000008, "Member 'FControlLockState::bLockCross' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockBunkerInteract) == 0x000009, "Member 'FControlLockState::bLockBunkerInteract' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockJump) == 0x00000A, "Member 'FControlLockState::bLockJump' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockReload) == 0x00000B, "Member 'FControlLockState::bLockReload' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockRush) == 0x00000C, "Member 'FControlLockState::bLockRush' has a wrong offset!");
static_assert(offsetof(FControlLockState, bLockUIAction) == 0x00000D, "Member 'FControlLockState::bLockUIAction' has a wrong offset!");
static_assert(offsetof(FControlLockState, bExceptHalfSkill) == 0x00000E, "Member 'FControlLockState::bExceptHalfSkill' has a wrong offset!");
static_assert(offsetof(FControlLockState, bCancelSkill) == 0x00000F, "Member 'FControlLockState::bCancelSkill' has a wrong offset!");
static_assert(offsetof(FControlLockState, Reason) == 0x000010, "Member 'FControlLockState::Reason' has a wrong offset!");

// ScriptStruct Game.EmitterParamInfo
// 0x0050 (0x0050 - 0x0000)
struct FEmitterParamInfo final
{
public:
	struct FVector                                ApplyLoc;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLoc;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScaler;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkillEmitter*                          LauncherEmitter;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABullet*                                BulletActor;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CastActor;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InjuryTransmission;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InjuryTransmissionOriginID;                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bElemExplosionDamage;                              // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreModifyHealth;                               // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterParamInfo) == 0x000008, "Wrong alignment on FEmitterParamInfo");
static_assert(sizeof(FEmitterParamInfo) == 0x000050, "Wrong size on FEmitterParamInfo");
static_assert(offsetof(FEmitterParamInfo, ApplyLoc) == 0x000000, "Member 'FEmitterParamInfo::ApplyLoc' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, OriginLoc) == 0x00000C, "Member 'FEmitterParamInfo::OriginLoc' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, Level) == 0x000018, "Member 'FEmitterParamInfo::Level' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, DamageScaler) == 0x00001C, "Member 'FEmitterParamInfo::DamageScaler' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, BoneName) == 0x000020, "Member 'FEmitterParamInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, LauncherEmitter) == 0x000028, "Member 'FEmitterParamInfo::LauncherEmitter' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, BulletActor) == 0x000030, "Member 'FEmitterParamInfo::BulletActor' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, CastActor) == 0x000038, "Member 'FEmitterParamInfo::CastActor' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, InjuryTransmission) == 0x000040, "Member 'FEmitterParamInfo::InjuryTransmission' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, InjuryTransmissionOriginID) == 0x000044, "Member 'FEmitterParamInfo::InjuryTransmissionOriginID' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, bElemExplosionDamage) == 0x000048, "Member 'FEmitterParamInfo::bElemExplosionDamage' has a wrong offset!");
static_assert(offsetof(FEmitterParamInfo, bIgnoreModifyHealth) == 0x000049, "Member 'FEmitterParamInfo::bIgnoreModifyHealth' has a wrong offset!");

// ScriptStruct Game.PartData
// 0x0078 (0x0078 - 0x0000)
struct FPartData final
{
public:
	class FString                                 PartName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainPart;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MainBone;                                          // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PartBoneNames;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PartType;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncePre;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceExtraPre;                                    // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagMulti;                                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsScareCrowPart;                                  // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScareCrowTargetPartTag;                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 PartTag;                                           // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0068(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDead;                                             // 0x0074(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartData) == 0x000008, "Wrong alignment on FPartData");
static_assert(sizeof(FPartData) == 0x000078, "Wrong size on FPartData");
static_assert(offsetof(FPartData, PartName) == 0x000000, "Member 'FPartData::PartName' has a wrong offset!");
static_assert(offsetof(FPartData, bMainPart) == 0x000010, "Member 'FPartData::bMainPart' has a wrong offset!");
static_assert(offsetof(FPartData, MainBone) == 0x000014, "Member 'FPartData::MainBone' has a wrong offset!");
static_assert(offsetof(FPartData, PartBoneNames) == 0x000020, "Member 'FPartData::PartBoneNames' has a wrong offset!");
static_assert(offsetof(FPartData, PartType) == 0x000030, "Member 'FPartData::PartType' has a wrong offset!");
static_assert(offsetof(FPartData, DamageScale) == 0x000034, "Member 'FPartData::DamageScale' has a wrong offset!");
static_assert(offsetof(FPartData, BouncePre) == 0x000038, "Member 'FPartData::BouncePre' has a wrong offset!");
static_assert(offsetof(FPartData, BounceExtraPre) == 0x00003C, "Member 'FPartData::BounceExtraPre' has a wrong offset!");
static_assert(offsetof(FPartData, HitLagMulti) == 0x000040, "Member 'FPartData::HitLagMulti' has a wrong offset!");
static_assert(offsetof(FPartData, bAsScareCrowPart) == 0x000044, "Member 'FPartData::bAsScareCrowPart' has a wrong offset!");
static_assert(offsetof(FPartData, ScareCrowTargetPartTag) == 0x000048, "Member 'FPartData::ScareCrowTargetPartTag' has a wrong offset!");
static_assert(offsetof(FPartData, PartTag) == 0x000058, "Member 'FPartData::PartTag' has a wrong offset!");
static_assert(offsetof(FPartData, LocationOffset) == 0x000068, "Member 'FPartData::LocationOffset' has a wrong offset!");
static_assert(offsetof(FPartData, bDead) == 0x000074, "Member 'FPartData::bDead' has a wrong offset!");

// ScriptStruct Game.ScaredCrowPartData
// 0x0088 (0x0088 - 0x0000)
struct FScaredCrowPartData final
{
public:
	struct FPartData                              ScaredCrowPartData;                                // 0x0000(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x0078(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScaredCrowPartData) == 0x000008, "Wrong alignment on FScaredCrowPartData");
static_assert(sizeof(FScaredCrowPartData) == 0x000088, "Wrong size on FScaredCrowPartData");
static_assert(offsetof(FScaredCrowPartData, ScaredCrowPartData) == 0x000000, "Member 'FScaredCrowPartData::ScaredCrowPartData' has a wrong offset!");
static_assert(offsetof(FScaredCrowPartData, SkeletalMeshComp) == 0x000078, "Member 'FScaredCrowPartData::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(FScaredCrowPartData, OwnerActor) == 0x000080, "Member 'FScaredCrowPartData::OwnerActor' has a wrong offset!");

// ScriptStruct Game.PartitionData
// 0x0100 (0x0100 - 0x0000)
struct FPartitionData final
{
public:
	class FString                                 PartitionName;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PartitionBoneNames;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExtraBoneNames;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPartData                              MainPartData;                                      // 0x0030(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPartData>                      PartDatas;                                         // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EMonBodyType                                  BodyType;                                          // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElemExplosionUptakeEfficien;                       // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsScareCrowPartition;                             // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScareCrowTargetPartition;                          // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 PartitionTag;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScaredCrowPartData>            ScaredPartData;                                    // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDead;                                             // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartitionData) == 0x000008, "Wrong alignment on FPartitionData");
static_assert(sizeof(FPartitionData) == 0x000100, "Wrong size on FPartitionData");
static_assert(offsetof(FPartitionData, PartitionName) == 0x000000, "Member 'FPartitionData::PartitionName' has a wrong offset!");
static_assert(offsetof(FPartitionData, PartitionBoneNames) == 0x000010, "Member 'FPartitionData::PartitionBoneNames' has a wrong offset!");
static_assert(offsetof(FPartitionData, ExtraBoneNames) == 0x000020, "Member 'FPartitionData::ExtraBoneNames' has a wrong offset!");
static_assert(offsetof(FPartitionData, MainPartData) == 0x000030, "Member 'FPartitionData::MainPartData' has a wrong offset!");
static_assert(offsetof(FPartitionData, PartDatas) == 0x0000A8, "Member 'FPartitionData::PartDatas' has a wrong offset!");
static_assert(offsetof(FPartitionData, BodyType) == 0x0000B8, "Member 'FPartitionData::BodyType' has a wrong offset!");
static_assert(offsetof(FPartitionData, ElemExplosionUptakeEfficien) == 0x0000BC, "Member 'FPartitionData::ElemExplosionUptakeEfficien' has a wrong offset!");
static_assert(offsetof(FPartitionData, bAsScareCrowPartition) == 0x0000C0, "Member 'FPartitionData::bAsScareCrowPartition' has a wrong offset!");
static_assert(offsetof(FPartitionData, ScareCrowTargetPartition) == 0x0000C8, "Member 'FPartitionData::ScareCrowTargetPartition' has a wrong offset!");
static_assert(offsetof(FPartitionData, PartitionTag) == 0x0000D8, "Member 'FPartitionData::PartitionTag' has a wrong offset!");
static_assert(offsetof(FPartitionData, ScaredPartData) == 0x0000E8, "Member 'FPartitionData::ScaredPartData' has a wrong offset!");
static_assert(offsetof(FPartitionData, bDead) == 0x0000F8, "Member 'FPartitionData::bDead' has a wrong offset!");

// ScriptStruct Game.AnimDistanceMappingCurveInfo
// 0x0110 (0x0110 - 0x0000)
struct FAnimDistanceMappingCurveInfo final
{
public:
	struct FRuntimeFloatCurve                     DistanceData;                                      // 0x0000(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RotationData;                                      // 0x0088(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimDistanceMappingCurveInfo) == 0x000008, "Wrong alignment on FAnimDistanceMappingCurveInfo");
static_assert(sizeof(FAnimDistanceMappingCurveInfo) == 0x000110, "Wrong size on FAnimDistanceMappingCurveInfo");
static_assert(offsetof(FAnimDistanceMappingCurveInfo, DistanceData) == 0x000000, "Member 'FAnimDistanceMappingCurveInfo::DistanceData' has a wrong offset!");
static_assert(offsetof(FAnimDistanceMappingCurveInfo, RotationData) == 0x000088, "Member 'FAnimDistanceMappingCurveInfo::RotationData' has a wrong offset!");

// ScriptStruct Game.RepListSizeLevel
// 0x0008 (0x0008 - 0x0000)
struct FRepListSizeLevel final
{
public:
	int32                                         ListSize;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLists;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepListSizeLevel) == 0x000004, "Wrong alignment on FRepListSizeLevel");
static_assert(sizeof(FRepListSizeLevel) == 0x000008, "Wrong size on FRepListSizeLevel");
static_assert(offsetof(FRepListSizeLevel, ListSize) == 0x000000, "Member 'FRepListSizeLevel::ListSize' has a wrong offset!");
static_assert(offsetof(FRepListSizeLevel, NumLists) == 0x000004, "Member 'FRepListSizeLevel::NumLists' has a wrong offset!");

// ScriptStruct Game.OnlineSeaGameEventParam
// 0x0020 (0x0020 - 0x0000)
struct FOnlineSeaGameEventParam final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineSeaGameEventType                       Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Diff;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaGameEventParam) == 0x000008, "Wrong alignment on FOnlineSeaGameEventParam");
static_assert(sizeof(FOnlineSeaGameEventParam) == 0x000020, "Wrong size on FOnlineSeaGameEventParam");
static_assert(offsetof(FOnlineSeaGameEventParam, ID) == 0x000000, "Member 'FOnlineSeaGameEventParam::ID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventParam, Type) == 0x000004, "Member 'FOnlineSeaGameEventParam::Type' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventParam, Tag) == 0x000008, "Member 'FOnlineSeaGameEventParam::Tag' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventParam, Diff) == 0x000018, "Member 'FOnlineSeaGameEventParam::Diff' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventParam, MaxCount) == 0x00001C, "Member 'FOnlineSeaGameEventParam::MaxCount' has a wrong offset!");

// ScriptStruct Game.ModifyHPTypeBlockParam
// 0x0002 (0x0002 - 0x0000)
struct FModifyHPTypeBlockParam final
{
public:
	EModifyHPTypeBlockSource                      BlockSource;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 BlockType;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifyHPTypeBlockParam) == 0x000001, "Wrong alignment on FModifyHPTypeBlockParam");
static_assert(sizeof(FModifyHPTypeBlockParam) == 0x000002, "Wrong size on FModifyHPTypeBlockParam");
static_assert(offsetof(FModifyHPTypeBlockParam, BlockSource) == 0x000000, "Member 'FModifyHPTypeBlockParam::BlockSource' has a wrong offset!");
static_assert(offsetof(FModifyHPTypeBlockParam, BlockType) == 0x000001, "Member 'FModifyHPTypeBlockParam::BlockType' has a wrong offset!");

// ScriptStruct Game.KideRideCameraParams
// 0x0034 (0x0034 - 0x0000)
struct FKideRideCameraParams final
{
public:
	float                                         ArmLength;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ArmRotation;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKideRideCameraParams) == 0x000004, "Wrong alignment on FKideRideCameraParams");
static_assert(sizeof(FKideRideCameraParams) == 0x000034, "Wrong size on FKideRideCameraParams");
static_assert(offsetof(FKideRideCameraParams, ArmLength) == 0x000000, "Member 'FKideRideCameraParams::ArmLength' has a wrong offset!");
static_assert(offsetof(FKideRideCameraParams, ArmRotation) == 0x000004, "Member 'FKideRideCameraParams::ArmRotation' has a wrong offset!");
static_assert(offsetof(FKideRideCameraParams, Location) == 0x000010, "Member 'FKideRideCameraParams::Location' has a wrong offset!");
static_assert(offsetof(FKideRideCameraParams, TargetOffset) == 0x00001C, "Member 'FKideRideCameraParams::TargetOffset' has a wrong offset!");
static_assert(offsetof(FKideRideCameraParams, CameraRotation) == 0x000028, "Member 'FKideRideCameraParams::CameraRotation' has a wrong offset!");

// ScriptStruct Game.DarkZonePreLoadInfo
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FDarkZonePreLoadInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkZonePreLoadInfo) == 0x000008, "Wrong alignment on FDarkZonePreLoadInfo");
static_assert(sizeof(FDarkZonePreLoadInfo) == 0x000040, "Wrong size on FDarkZonePreLoadInfo");

// ScriptStruct Game.PalSecretCollect
// 0x0060 (0x0060 - 0x0000)
struct FPalSecretCollect final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            Delta;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Fixed;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwitchActive;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPalSecretCollect) == 0x000008, "Wrong alignment on FPalSecretCollect");
static_assert(sizeof(FPalSecretCollect) == 0x000060, "Wrong size on FPalSecretCollect");
static_assert(offsetof(FPalSecretCollect, Tag) == 0x000000, "Member 'FPalSecretCollect::Tag' has a wrong offset!");
static_assert(offsetof(FPalSecretCollect, Delta) == 0x000008, "Member 'FPalSecretCollect::Delta' has a wrong offset!");
static_assert(offsetof(FPalSecretCollect, Fixed) == 0x000058, "Member 'FPalSecretCollect::Fixed' has a wrong offset!");
static_assert(offsetof(FPalSecretCollect, SwitchActive) == 0x00005C, "Member 'FPalSecretCollect::SwitchActive' has a wrong offset!");

// ScriptStruct Game.EnergyStorageEffect
// 0x0060 (0x0060 - 0x0000)
struct FEnergyStorageEffect final
{
public:
	float                                         StorageTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StorageParticlePath;                               // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundPlay;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0038(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0044(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0050(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnergyStorageEffect) == 0x000008, "Wrong alignment on FEnergyStorageEffect");
static_assert(sizeof(FEnergyStorageEffect) == 0x000060, "Wrong size on FEnergyStorageEffect");
static_assert(offsetof(FEnergyStorageEffect, StorageTime) == 0x000000, "Member 'FEnergyStorageEffect::StorageTime' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, StorageParticlePath) == 0x000008, "Member 'FEnergyStorageEffect::StorageParticlePath' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, SoundPlay) == 0x000020, "Member 'FEnergyStorageEffect::SoundPlay' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, Socket) == 0x000030, "Member 'FEnergyStorageEffect::Socket' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, LocationOffset) == 0x000038, "Member 'FEnergyStorageEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, RotationOffset) == 0x000044, "Member 'FEnergyStorageEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(FEnergyStorageEffect, Scale) == 0x000050, "Member 'FEnergyStorageEffect::Scale' has a wrong offset!");

// ScriptStruct Game.SelectorInfo
// 0x00F8 (0x0100 - 0x0008)
struct FSelectorInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         SelectorClassType;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectorFinishType                           SelectorFinishType;                                // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectorKeepSkillID;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOffset;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffset;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSelectTime;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedOnNavMesh;                                    // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCameraYawInWorld;                             // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCameraPitchInWorld;                           // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlType;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectToLand;                                    // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyFront;                                        // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOffsetY;                                      // 0x0056(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOffsetX;                                      // 0x0057(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAimInput;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFireInput;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalCullSphereRadius;                             // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalCullSphereZ;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalCullBoxSize;                                  // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSectorRadius;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSectorDegrees;                                // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSectorZ;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotShowUITips;                                    // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenAutoAim;                                      // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AutoAimRange;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockTarget;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockValidAngle;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterAim;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MappingAngle;                                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMappingAttachToCloest;                            // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MappingAttachRange;                                // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeMoveAngle;                                     // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockTargetAtBegin;                                // 0x00B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToCloest;                                   // 0x00B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttachRange;                                       // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RelativeVector;                                    // 0x00BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowParabola;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParabolaType;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadiius;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ValidDistanceRange;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GravityScaleRange;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CostTimeRange;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimTime;                                           // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectorInfo) == 0x000008, "Wrong alignment on FSelectorInfo");
static_assert(sizeof(FSelectorInfo) == 0x000100, "Wrong size on FSelectorInfo");
static_assert(offsetof(FSelectorInfo, ID) == 0x000008, "Member 'FSelectorInfo::ID' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SelectorClassType) == 0x000010, "Member 'FSelectorInfo::SelectorClassType' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SelectorFinishType) == 0x000028, "Member 'FSelectorInfo::SelectorFinishType' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SelectorKeepSkillID) == 0x00002C, "Member 'FSelectorInfo::SelectorKeepSkillID' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, Scale) == 0x000030, "Member 'FSelectorInfo::Scale' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MinOffset) == 0x00003C, "Member 'FSelectorInfo::MinOffset' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MaxOffset) == 0x000040, "Member 'FSelectorInfo::MaxOffset' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MaxSelectTime) == 0x000044, "Member 'FSelectorInfo::MaxSelectTime' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, YawOffset) == 0x000048, "Member 'FSelectorInfo::YawOffset' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bNeedOnNavMesh) == 0x00004C, "Member 'FSelectorInfo::bNeedOnNavMesh' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockCameraYawInWorld) == 0x00004D, "Member 'FSelectorInfo::bLockCameraYawInWorld' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockCameraPitchInWorld) == 0x00004E, "Member 'FSelectorInfo::bLockCameraPitchInWorld' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, ControlType) == 0x000050, "Member 'FSelectorInfo::ControlType' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bProjectToLand) == 0x000054, "Member 'FSelectorInfo::bProjectToLand' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bOnlyFront) == 0x000055, "Member 'FSelectorInfo::bOnlyFront' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockOffsetY) == 0x000056, "Member 'FSelectorInfo::bLockOffsetY' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockOffsetX) == 0x000057, "Member 'FSelectorInfo::bLockOffsetX' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bClearAimInput) == 0x000058, "Member 'FSelectorInfo::bClearAimInput' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bClearFireInput) == 0x000059, "Member 'FSelectorInfo::bClearFireInput' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalCullSphereRadius) == 0x00005C, "Member 'FSelectorInfo::DecalCullSphereRadius' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalCullSphereZ) == 0x000060, "Member 'FSelectorInfo::DecalCullSphereZ' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalCullBoxSize) == 0x000064, "Member 'FSelectorInfo::DecalCullBoxSize' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalSectorRadius) == 0x000070, "Member 'FSelectorInfo::DecalSectorRadius' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalSectorDegrees) == 0x000074, "Member 'FSelectorInfo::DecalSectorDegrees' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, DecalSectorZ) == 0x000078, "Member 'FSelectorInfo::DecalSectorZ' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bNotShowUITips) == 0x00007C, "Member 'FSelectorInfo::bNotShowUITips' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bOpenAutoAim) == 0x00007D, "Member 'FSelectorInfo::bOpenAutoAim' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, AutoAimRange) == 0x000080, "Member 'FSelectorInfo::AutoAimRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockTarget) == 0x000088, "Member 'FSelectorInfo::bLockTarget' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, LockValidAngle) == 0x00008C, "Member 'FSelectorInfo::LockValidAngle' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bEnterAim) == 0x000090, "Member 'FSelectorInfo::bEnterAim' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MappingAngle) == 0x000094, "Member 'FSelectorInfo::MappingAngle' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bMappingAttachToCloest) == 0x000098, "Member 'FSelectorInfo::bMappingAttachToCloest' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MappingAttachRange) == 0x00009C, "Member 'FSelectorInfo::MappingAttachRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, MoveSpeed) == 0x0000A0, "Member 'FSelectorInfo::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SpeedCurve) == 0x0000A8, "Member 'FSelectorInfo::SpeedCurve' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, FreeMoveAngle) == 0x0000B0, "Member 'FSelectorInfo::FreeMoveAngle' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bLockTargetAtBegin) == 0x0000B4, "Member 'FSelectorInfo::bLockTargetAtBegin' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bAttachToCloest) == 0x0000B5, "Member 'FSelectorInfo::bAttachToCloest' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, AttachRange) == 0x0000B8, "Member 'FSelectorInfo::AttachRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, RelativeVector) == 0x0000BC, "Member 'FSelectorInfo::RelativeVector' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, bShowParabola) == 0x0000C4, "Member 'FSelectorInfo::bShowParabola' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, ParabolaType) == 0x0000C8, "Member 'FSelectorInfo::ParabolaType' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, ProjectileRadiius) == 0x0000CC, "Member 'FSelectorInfo::ProjectileRadiius' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, ValidDistanceRange) == 0x0000D0, "Member 'FSelectorInfo::ValidDistanceRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, GravityScaleRange) == 0x0000D8, "Member 'FSelectorInfo::GravityScaleRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, CostTimeRange) == 0x0000E0, "Member 'FSelectorInfo::CostTimeRange' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, Velocity) == 0x0000E8, "Member 'FSelectorInfo::Velocity' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SocketName) == 0x0000EC, "Member 'FSelectorInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, GravityScale) == 0x0000F4, "Member 'FSelectorInfo::GravityScale' has a wrong offset!");
static_assert(offsetof(FSelectorInfo, SimTime) == 0x0000F8, "Member 'FSelectorInfo::SimTime' has a wrong offset!");

// ScriptStruct Game.DecalManagerInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDecalManagerInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGameDecalActor>         Actor;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecalManagerInfo) == 0x000008, "Wrong alignment on FDecalManagerInfo");
static_assert(sizeof(FDecalManagerInfo) == 0x000010, "Wrong size on FDecalManagerInfo");
static_assert(offsetof(FDecalManagerInfo, Actor) == 0x000008, "Member 'FDecalManagerInfo::Actor' has a wrong offset!");

// ScriptStruct Game.ClampAttribute
// 0x0020 (0x0020 - 0x0000)
struct FClampAttribute final
{
public:
	struct Game::FAttribute                       CurrentAttribute;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct Game::FAttribute                       MaxAttribute;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClampAttribute) == 0x000004, "Wrong alignment on FClampAttribute");
static_assert(sizeof(FClampAttribute) == 0x000020, "Wrong size on FClampAttribute");
static_assert(offsetof(FClampAttribute, CurrentAttribute) == 0x000000, "Member 'FClampAttribute::CurrentAttribute' has a wrong offset!");
static_assert(offsetof(FClampAttribute, MaxAttribute) == 0x000010, "Member 'FClampAttribute::MaxAttribute' has a wrong offset!");

// ScriptStruct Game.TargetWarpingTarget
// 0x0034 (0x0034 - 0x0000)
struct FTargetWarpingTarget final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         Component;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollowComponent;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetWarpingTarget) == 0x000004, "Wrong alignment on FTargetWarpingTarget");
static_assert(sizeof(FTargetWarpingTarget) == 0x000034, "Wrong size on FTargetWarpingTarget");
static_assert(offsetof(FTargetWarpingTarget, Name) == 0x000000, "Member 'FTargetWarpingTarget::Name' has a wrong offset!");
static_assert(offsetof(FTargetWarpingTarget, Location) == 0x000008, "Member 'FTargetWarpingTarget::Location' has a wrong offset!");
static_assert(offsetof(FTargetWarpingTarget, Rotation) == 0x000014, "Member 'FTargetWarpingTarget::Rotation' has a wrong offset!");
static_assert(offsetof(FTargetWarpingTarget, Component) == 0x000020, "Member 'FTargetWarpingTarget::Component' has a wrong offset!");
static_assert(offsetof(FTargetWarpingTarget, BoneName) == 0x000028, "Member 'FTargetWarpingTarget::BoneName' has a wrong offset!");
static_assert(offsetof(FTargetWarpingTarget, bFollowComponent) == 0x000030, "Member 'FTargetWarpingTarget::bFollowComponent' has a wrong offset!");

// ScriptStruct Game.Graph
// 0x0088 (0x0088 - 0x0000)
struct FGraph final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APathPoint*>                     Nodes;                                             // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APathPoint*>                     LastPath;                                          // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class APathPoint*                             LastStart;                                         // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APathPoint*                             LastEnd;                                           // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraph) == 0x000008, "Wrong alignment on FGraph");
static_assert(sizeof(FGraph) == 0x000088, "Wrong size on FGraph");
static_assert(offsetof(FGraph, Nodes) == 0x000028, "Member 'FGraph::Nodes' has a wrong offset!");
static_assert(offsetof(FGraph, LastPath) == 0x000068, "Member 'FGraph::LastPath' has a wrong offset!");
static_assert(offsetof(FGraph, LastStart) == 0x000078, "Member 'FGraph::LastStart' has a wrong offset!");
static_assert(offsetof(FGraph, LastEnd) == 0x000080, "Member 'FGraph::LastEnd' has a wrong offset!");

// ScriptStruct Game.SpawnNpcParams
// 0x0048 (0x0130 - 0x00E8)
struct FSpawnNpcParams : public FSpawnNpcBaseParams
{
public:
	struct FVector                                Location;                                          // 0x00E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PlayEnterAnimIndex;                                // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HPPercent;                                         // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateToAIDirector;                               // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHalfCapsuleHeight;                             // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AddTags;                                           // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsFromDarkAsync;                                   // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            SpawnCollisionRule;                                // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ANPCSpawnPoint>          SpawnPoint;                                        // 0x0124(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldFollowParamLevel;                            // 0x012C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnNpcParams) == 0x000008, "Wrong alignment on FSpawnNpcParams");
static_assert(sizeof(FSpawnNpcParams) == 0x000130, "Wrong size on FSpawnNpcParams");
static_assert(offsetof(FSpawnNpcParams, Location) == 0x0000E8, "Member 'FSpawnNpcParams::Location' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, Rotation) == 0x0000F4, "Member 'FSpawnNpcParams::Rotation' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, PlayEnterAnimIndex) == 0x000100, "Member 'FSpawnNpcParams::PlayEnterAnimIndex' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, HPPercent) == 0x000104, "Member 'FSpawnNpcParams::HPPercent' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, bUpdateToAIDirector) == 0x000108, "Member 'FSpawnNpcParams::bUpdateToAIDirector' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, bUseHalfCapsuleHeight) == 0x000109, "Member 'FSpawnNpcParams::bUseHalfCapsuleHeight' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, AddTags) == 0x000110, "Member 'FSpawnNpcParams::AddTags' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, IsFromDarkAsync) == 0x000120, "Member 'FSpawnNpcParams::IsFromDarkAsync' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, SpawnCollisionRule) == 0x000121, "Member 'FSpawnNpcParams::SpawnCollisionRule' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, SpawnPoint) == 0x000124, "Member 'FSpawnNpcParams::SpawnPoint' has a wrong offset!");
static_assert(offsetof(FSpawnNpcParams, ShouldFollowParamLevel) == 0x00012C, "Member 'FSpawnNpcParams::ShouldFollowParamLevel' has a wrong offset!");

// ScriptStruct Game.ARSeqConfig
// 0x0008 (0x0010 - 0x0008)
struct FARSeqConfig final : public FTableRowBase
{
public:
	int32                                         ActionID;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptByClick;                                 // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntry;                                           // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FARSeqConfig) == 0x000008, "Wrong alignment on FARSeqConfig");
static_assert(sizeof(FARSeqConfig) == 0x000010, "Wrong size on FARSeqConfig");
static_assert(offsetof(FARSeqConfig, ActionID) == 0x000008, "Member 'FARSeqConfig::ActionID' has a wrong offset!");
static_assert(offsetof(FARSeqConfig, bLoop) == 0x00000C, "Member 'FARSeqConfig::bLoop' has a wrong offset!");
static_assert(offsetof(FARSeqConfig, bInterruptByClick) == 0x00000D, "Member 'FARSeqConfig::bInterruptByClick' has a wrong offset!");
static_assert(offsetof(FARSeqConfig, IsEntry) == 0x00000E, "Member 'FARSeqConfig::IsEntry' has a wrong offset!");

// ScriptStruct Game.AIDirectorConditionGlobalEvent
// 0x0020 (0x0020 - 0x0000)
struct FAIDirectorConditionGlobalEvent final
{
public:
	TArray<class UAIDirectorCondition*>           TriggerConditions;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAIDirectorGlobalEvent*                 Event;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerCD;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDirectorConditionGlobalEvent) == 0x000008, "Wrong alignment on FAIDirectorConditionGlobalEvent");
static_assert(sizeof(FAIDirectorConditionGlobalEvent) == 0x000020, "Wrong size on FAIDirectorConditionGlobalEvent");
static_assert(offsetof(FAIDirectorConditionGlobalEvent, TriggerConditions) == 0x000000, "Member 'FAIDirectorConditionGlobalEvent::TriggerConditions' has a wrong offset!");
static_assert(offsetof(FAIDirectorConditionGlobalEvent, Event) == 0x000010, "Member 'FAIDirectorConditionGlobalEvent::Event' has a wrong offset!");
static_assert(offsetof(FAIDirectorConditionGlobalEvent, TriggerCD) == 0x000018, "Member 'FAIDirectorConditionGlobalEvent::TriggerCD' has a wrong offset!");

// ScriptStruct Game.BuildBufferRatio
// 0x0018 (0x0018 - 0x0000)
struct FBuildBufferRatio final
{
public:
	int32                                         BufferId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Ratios;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildBufferRatio) == 0x000008, "Wrong alignment on FBuildBufferRatio");
static_assert(sizeof(FBuildBufferRatio) == 0x000018, "Wrong size on FBuildBufferRatio");
static_assert(offsetof(FBuildBufferRatio, BufferId) == 0x000000, "Member 'FBuildBufferRatio::BufferId' has a wrong offset!");
static_assert(offsetof(FBuildBufferRatio, Ratios) == 0x000008, "Member 'FBuildBufferRatio::Ratios' has a wrong offset!");

// ScriptStruct Game.TargetShootItem
// 0x000C (0x000C - 0x0000)
struct FTargetShootItem final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetShootItemType                          Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetShootItem) == 0x000004, "Wrong alignment on FTargetShootItem");
static_assert(sizeof(FTargetShootItem) == 0x00000C, "Wrong size on FTargetShootItem");
static_assert(offsetof(FTargetShootItem, ID) == 0x000000, "Member 'FTargetShootItem::ID' has a wrong offset!");
static_assert(offsetof(FTargetShootItem, Score) == 0x000004, "Member 'FTargetShootItem::Score' has a wrong offset!");
static_assert(offsetof(FTargetShootItem, Type) == 0x000008, "Member 'FTargetShootItem::Type' has a wrong offset!");

// ScriptStruct Game.HouseFaceAnimNameMapping
// 0x0020 (0x0028 - 0x0008)
struct FHouseFaceAnimNameMapping final : public FTableRowBase
{
public:
	class FString                                 ActionName;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FaceActionName;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseFaceAnimNameMapping) == 0x000008, "Wrong alignment on FHouseFaceAnimNameMapping");
static_assert(sizeof(FHouseFaceAnimNameMapping) == 0x000028, "Wrong size on FHouseFaceAnimNameMapping");
static_assert(offsetof(FHouseFaceAnimNameMapping, ActionName) == 0x000008, "Member 'FHouseFaceAnimNameMapping::ActionName' has a wrong offset!");
static_assert(offsetof(FHouseFaceAnimNameMapping, FaceActionName) == 0x000018, "Member 'FHouseFaceAnimNameMapping::FaceActionName' has a wrong offset!");

// ScriptStruct Game.MagicSpecialFightUIs
// 0x0028 (0x0028 - 0x0000)
struct FMagicSpecialFightUIs final
{
public:
	int32                                         ModifierID;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  ModifierLauncher;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  ModifierTarget;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     Params;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagicSpecialFightUIs) == 0x000008, "Wrong alignment on FMagicSpecialFightUIs");
static_assert(sizeof(FMagicSpecialFightUIs) == 0x000028, "Wrong size on FMagicSpecialFightUIs");
static_assert(offsetof(FMagicSpecialFightUIs, ModifierID) == 0x000000, "Member 'FMagicSpecialFightUIs::ModifierID' has a wrong offset!");
static_assert(offsetof(FMagicSpecialFightUIs, ModifierLauncher) == 0x000008, "Member 'FMagicSpecialFightUIs::ModifierLauncher' has a wrong offset!");
static_assert(offsetof(FMagicSpecialFightUIs, ModifierTarget) == 0x000010, "Member 'FMagicSpecialFightUIs::ModifierTarget' has a wrong offset!");
static_assert(offsetof(FMagicSpecialFightUIs, Params) == 0x000018, "Member 'FMagicSpecialFightUIs::Params' has a wrong offset!");

// ScriptStruct Game.HouseBedRoomTemplate
// 0x0070 (0x0078 - 0x0008)
struct FHouseBedRoomTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  ArtLevel;                                          // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LogicLevel;                                        // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseBedRoomTemplate) == 0x000008, "Wrong alignment on FHouseBedRoomTemplate");
static_assert(sizeof(FHouseBedRoomTemplate) == 0x000078, "Wrong size on FHouseBedRoomTemplate");
static_assert(offsetof(FHouseBedRoomTemplate, ID) == 0x000008, "Member 'FHouseBedRoomTemplate::ID' has a wrong offset!");
static_assert(offsetof(FHouseBedRoomTemplate, Pos) == 0x00000C, "Member 'FHouseBedRoomTemplate::Pos' has a wrong offset!");
static_assert(offsetof(FHouseBedRoomTemplate, Rotator) == 0x000018, "Member 'FHouseBedRoomTemplate::Rotator' has a wrong offset!");
static_assert(offsetof(FHouseBedRoomTemplate, ArtLevel) == 0x000028, "Member 'FHouseBedRoomTemplate::ArtLevel' has a wrong offset!");
static_assert(offsetof(FHouseBedRoomTemplate, LogicLevel) == 0x000050, "Member 'FHouseBedRoomTemplate::LogicLevel' has a wrong offset!");

// ScriptStruct Game.BuildBuffInfo
// 0x000C (0x000C - 0x0000)
struct FBuildBuffInfo final
{
public:
	int32                                         Wave;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildType;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildBuffInfo) == 0x000004, "Wrong alignment on FBuildBuffInfo");
static_assert(sizeof(FBuildBuffInfo) == 0x00000C, "Wrong size on FBuildBuffInfo");
static_assert(offsetof(FBuildBuffInfo, Wave) == 0x000000, "Member 'FBuildBuffInfo::Wave' has a wrong offset!");
static_assert(offsetof(FBuildBuffInfo, BuffId) == 0x000004, "Member 'FBuildBuffInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FBuildBuffInfo, BuildType) == 0x000008, "Member 'FBuildBuffInfo::BuildType' has a wrong offset!");

// ScriptStruct Game.AIGlobalConfig
// 0x0038 (0x0040 - 0x0008)
struct FAIGlobalConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Remark;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGlobalConfig) == 0x000008, "Wrong alignment on FAIGlobalConfig");
static_assert(sizeof(FAIGlobalConfig) == 0x000040, "Wrong size on FAIGlobalConfig");
static_assert(offsetof(FAIGlobalConfig, ID) == 0x000008, "Member 'FAIGlobalConfig::ID' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, PropertyName) == 0x000010, "Member 'FAIGlobalConfig::PropertyName' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, Remark) == 0x000020, "Member 'FAIGlobalConfig::Remark' has a wrong offset!");
static_assert(offsetof(FAIGlobalConfig, Value) == 0x000030, "Member 'FAIGlobalConfig::Value' has a wrong offset!");

// ScriptStruct Game.PostProcessRule
// 0x0020 (0x0020 - 0x0000)
struct FPostProcessRule final
{
public:
	EPostProcessType                              PostProcessType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlockPostProcessTypeMask;                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPostProcessParams*                     PostProcessParam;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityAttribute*                      AbilityAttribute;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAttribute;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttribute;                                      // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessRule) == 0x000008, "Wrong alignment on FPostProcessRule");
static_assert(sizeof(FPostProcessRule) == 0x000020, "Wrong size on FPostProcessRule");
static_assert(offsetof(FPostProcessRule, PostProcessType) == 0x000000, "Member 'FPostProcessRule::PostProcessType' has a wrong offset!");
static_assert(offsetof(FPostProcessRule, BlockPostProcessTypeMask) == 0x000004, "Member 'FPostProcessRule::BlockPostProcessTypeMask' has a wrong offset!");
static_assert(offsetof(FPostProcessRule, PostProcessParam) == 0x000008, "Member 'FPostProcessRule::PostProcessParam' has a wrong offset!");
static_assert(offsetof(FPostProcessRule, AbilityAttribute) == 0x000010, "Member 'FPostProcessRule::AbilityAttribute' has a wrong offset!");
static_assert(offsetof(FPostProcessRule, CurrentAttribute) == 0x000018, "Member 'FPostProcessRule::CurrentAttribute' has a wrong offset!");
static_assert(offsetof(FPostProcessRule, MaxAttribute) == 0x00001C, "Member 'FPostProcessRule::MaxAttribute' has a wrong offset!");

// ScriptStruct Game.BraveBuffBuyInfo
// 0x0008 (0x0008 - 0x0000)
struct FBraveBuffBuyInfo final
{
public:
	int32                                         BuffId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyCount;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBraveBuffBuyInfo) == 0x000004, "Wrong alignment on FBraveBuffBuyInfo");
static_assert(sizeof(FBraveBuffBuyInfo) == 0x000008, "Wrong size on FBraveBuffBuyInfo");
static_assert(offsetof(FBraveBuffBuyInfo, BuffId) == 0x000000, "Member 'FBraveBuffBuyInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FBraveBuffBuyInfo, BuyCount) == 0x000004, "Member 'FBraveBuffBuyInfo::BuyCount' has a wrong offset!");

// ScriptStruct Game.HouseCameraConfig
// 0x00A8 (0x00B0 - 0x0008)
struct FHouseCameraConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionAnimID;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionAnimName;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ActionAnim;                                        // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PoseAnimName;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           PoseAnim;                                          // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          CameraAnimRes;                                     // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseCameraConfig) == 0x000008, "Wrong alignment on FHouseCameraConfig");
static_assert(sizeof(FHouseCameraConfig) == 0x0000B0, "Wrong size on FHouseCameraConfig");
static_assert(offsetof(FHouseCameraConfig, ID) == 0x000008, "Member 'FHouseCameraConfig::ID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, SkinID) == 0x00000C, "Member 'FHouseCameraConfig::SkinID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, ActionAnimID) == 0x000010, "Member 'FHouseCameraConfig::ActionAnimID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, ActionAnimName) == 0x000018, "Member 'FHouseCameraConfig::ActionAnimName' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, ActionAnim) == 0x000028, "Member 'FHouseCameraConfig::ActionAnim' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, PoseAnimName) == 0x000050, "Member 'FHouseCameraConfig::PoseAnimName' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, PoseAnim) == 0x000060, "Member 'FHouseCameraConfig::PoseAnim' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig, CameraAnimRes) == 0x000088, "Member 'FHouseCameraConfig::CameraAnimRes' has a wrong offset!");

// ScriptStruct Game.TempRelaceSkillData
// 0x0018 (0x0018 - 0x0000)
struct FTempRelaceSkillData final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymbiosisModifierID;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetainSkillWhenDeactive;                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTempRelaceSkillData) == 0x000004, "Wrong alignment on FTempRelaceSkillData");
static_assert(sizeof(FTempRelaceSkillData) == 0x000018, "Wrong size on FTempRelaceSkillData");
static_assert(offsetof(FTempRelaceSkillData, ActiveTime) == 0x000000, "Member 'FTempRelaceSkillData::ActiveTime' has a wrong offset!");
static_assert(offsetof(FTempRelaceSkillData, RemainingTime) == 0x000004, "Member 'FTempRelaceSkillData::RemainingTime' has a wrong offset!");
static_assert(offsetof(FTempRelaceSkillData, SkillID) == 0x000008, "Member 'FTempRelaceSkillData::SkillID' has a wrong offset!");
static_assert(offsetof(FTempRelaceSkillData, Index) == 0x00000C, "Member 'FTempRelaceSkillData::Index' has a wrong offset!");
static_assert(offsetof(FTempRelaceSkillData, SymbiosisModifierID) == 0x000010, "Member 'FTempRelaceSkillData::SymbiosisModifierID' has a wrong offset!");
static_assert(offsetof(FTempRelaceSkillData, bRetainSkillWhenDeactive) == 0x000014, "Member 'FTempRelaceSkillData::bRetainSkillWhenDeactive' has a wrong offset!");

// ScriptStruct Game.BossStateDamage
// 0x00C8 (0x00C8 - 0x0000)
struct FBossStateDamage final
{
public:
	TMap<int32, float>                            MonsterRealDamage;                                 // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RecivedRealDamage;                                 // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainHealth;                                      // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 StateTime;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<float>                                 StateDamage;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	class FString                                 CurStateName;                                      // 0x0080(0x0010)(ZeroConstructor, Transient, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateStartTime;                                    // 0x0090(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DestName;                                          // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<int32>                                 DestDeadTime;                                      // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<class FString>                         DestStateName;                                     // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBossStateDamage) == 0x000008, "Wrong alignment on FBossStateDamage");
static_assert(sizeof(FBossStateDamage) == 0x0000C8, "Wrong size on FBossStateDamage");
static_assert(offsetof(FBossStateDamage, MonsterRealDamage) == 0x000000, "Member 'FBossStateDamage::MonsterRealDamage' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, RecivedRealDamage) == 0x000050, "Member 'FBossStateDamage::RecivedRealDamage' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, RemainHealth) == 0x000054, "Member 'FBossStateDamage::RemainHealth' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, MaxHealth) == 0x000058, "Member 'FBossStateDamage::MaxHealth' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, StateTime) == 0x000060, "Member 'FBossStateDamage::StateTime' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, StateDamage) == 0x000070, "Member 'FBossStateDamage::StateDamage' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, CurStateName) == 0x000080, "Member 'FBossStateDamage::CurStateName' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, StateStartTime) == 0x000090, "Member 'FBossStateDamage::StateStartTime' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, DestName) == 0x000098, "Member 'FBossStateDamage::DestName' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, DestDeadTime) == 0x0000A8, "Member 'FBossStateDamage::DestDeadTime' has a wrong offset!");
static_assert(offsetof(FBossStateDamage, DestStateName) == 0x0000B8, "Member 'FBossStateDamage::DestStateName' has a wrong offset!");

// ScriptStruct Game.BoughtBufferInfo
// 0x0014 (0x0014 - 0x0000)
struct FBoughtBufferInfo final
{
public:
	int32                                         ShopId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractiveMode;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferId;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferCount;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoughtBufferInfo) == 0x000004, "Wrong alignment on FBoughtBufferInfo");
static_assert(sizeof(FBoughtBufferInfo) == 0x000014, "Wrong size on FBoughtBufferInfo");
static_assert(offsetof(FBoughtBufferInfo, ShopId) == 0x000000, "Member 'FBoughtBufferInfo::ShopId' has a wrong offset!");
static_assert(offsetof(FBoughtBufferInfo, InteractiveMode) == 0x000004, "Member 'FBoughtBufferInfo::InteractiveMode' has a wrong offset!");
static_assert(offsetof(FBoughtBufferInfo, BufferId) == 0x000008, "Member 'FBoughtBufferInfo::BufferId' has a wrong offset!");
static_assert(offsetof(FBoughtBufferInfo, Rarity) == 0x00000C, "Member 'FBoughtBufferInfo::Rarity' has a wrong offset!");
static_assert(offsetof(FBoughtBufferInfo, BufferCount) == 0x000010, "Member 'FBoughtBufferInfo::BufferCount' has a wrong offset!");

// ScriptStruct Game.RandomBufferInfo
// 0x000C (0x000C - 0x0000)
struct FRandomBufferInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowToBuy;                                     // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShopId;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomBufferInfo) == 0x000004, "Wrong alignment on FRandomBufferInfo");
static_assert(sizeof(FRandomBufferInfo) == 0x00000C, "Wrong size on FRandomBufferInfo");
static_assert(offsetof(FRandomBufferInfo, ID) == 0x000000, "Member 'FRandomBufferInfo::ID' has a wrong offset!");
static_assert(offsetof(FRandomBufferInfo, bIsAllowToBuy) == 0x000004, "Member 'FRandomBufferInfo::bIsAllowToBuy' has a wrong offset!");
static_assert(offsetof(FRandomBufferInfo, ShopId) == 0x000008, "Member 'FRandomBufferInfo::ShopId' has a wrong offset!");

// ScriptStruct Game.QueryResultBlendOut
// 0x001C (0x001C - 0x0000)
struct FQueryResultBlendOut final
{
public:
	float                                         CurrentAlphaValue;                                 // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElpasedTime;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CachedTargetLoc;                                   // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueryResultBlendOut) == 0x000004, "Wrong alignment on FQueryResultBlendOut");
static_assert(sizeof(FQueryResultBlendOut) == 0x00001C, "Wrong size on FQueryResultBlendOut");
static_assert(offsetof(FQueryResultBlendOut, CurrentAlphaValue) == 0x000000, "Member 'FQueryResultBlendOut::CurrentAlphaValue' has a wrong offset!");
static_assert(offsetof(FQueryResultBlendOut, ElpasedTime) == 0x000004, "Member 'FQueryResultBlendOut::ElpasedTime' has a wrong offset!");
static_assert(offsetof(FQueryResultBlendOut, BlendOutTime) == 0x000008, "Member 'FQueryResultBlendOut::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FQueryResultBlendOut, bIsValid) == 0x00000C, "Member 'FQueryResultBlendOut::bIsValid' has a wrong offset!");
static_assert(offsetof(FQueryResultBlendOut, CachedTargetLoc) == 0x000010, "Member 'FQueryResultBlendOut::CachedTargetLoc' has a wrong offset!");

// ScriptStruct Game.HouseCharacterSuitInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FHouseCharacterSuitInfo final
{
public:
	struct FSoftClassPath                         Blueprint;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResName;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories2;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories3;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories4;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories5;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SafeMesh;                                          // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResNameDec;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemGDPL;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseCharacterSuitInfo) == 0x000008, "Wrong alignment on FHouseCharacterSuitInfo");
static_assert(sizeof(FHouseCharacterSuitInfo) == 0x0000C0, "Wrong size on FHouseCharacterSuitInfo");
static_assert(offsetof(FHouseCharacterSuitInfo, Blueprint) == 0x000000, "Member 'FHouseCharacterSuitInfo::Blueprint' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, ResName) == 0x000018, "Member 'FHouseCharacterSuitInfo::ResName' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, Accessories) == 0x000028, "Member 'FHouseCharacterSuitInfo::Accessories' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, Accessories2) == 0x000038, "Member 'FHouseCharacterSuitInfo::Accessories2' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, Accessories3) == 0x000048, "Member 'FHouseCharacterSuitInfo::Accessories3' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, Accessories4) == 0x000058, "Member 'FHouseCharacterSuitInfo::Accessories4' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, Accessories5) == 0x000068, "Member 'FHouseCharacterSuitInfo::Accessories5' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, SafeMesh) == 0x000078, "Member 'FHouseCharacterSuitInfo::SafeMesh' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, ResNameDec) == 0x0000A0, "Member 'FHouseCharacterSuitInfo::ResNameDec' has a wrong offset!");
static_assert(offsetof(FHouseCharacterSuitInfo, ItemGDPL) == 0x0000B0, "Member 'FHouseCharacterSuitInfo::ItemGDPL' has a wrong offset!");

// ScriptStruct Game.ActiveStateSetting
// 0x0002 (0x0002 - 0x0000)
struct FActiveStateSetting final
{
public:
	ESkillCastType                                SkillCastType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionStateCommand                           ActionStateCommand;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveStateSetting) == 0x000001, "Wrong alignment on FActiveStateSetting");
static_assert(sizeof(FActiveStateSetting) == 0x000002, "Wrong size on FActiveStateSetting");
static_assert(offsetof(FActiveStateSetting, SkillCastType) == 0x000000, "Member 'FActiveStateSetting::SkillCastType' has a wrong offset!");
static_assert(offsetof(FActiveStateSetting, ActionStateCommand) == 0x000001, "Member 'FActiveStateSetting::ActionStateCommand' has a wrong offset!");

// ScriptStruct Game.TeamSafeAreaStoreInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTeamSafeAreaStoreInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamSafeAreaStoreInfo) == 0x000008, "Wrong alignment on FTeamSafeAreaStoreInfo");
static_assert(sizeof(FTeamSafeAreaStoreInfo) == 0x000018, "Wrong size on FTeamSafeAreaStoreInfo");

// ScriptStruct Game.ShootOrSkillMasteryCollation
// 0x0010 (0x0018 - 0x0008)
struct FShootOrSkillMasteryCollation final : public FTableRowBase
{
public:
	int32                                         Type;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootDamage;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDamage;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonDamage;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShootOrSkillMasteryCollation) == 0x000008, "Wrong alignment on FShootOrSkillMasteryCollation");
static_assert(sizeof(FShootOrSkillMasteryCollation) == 0x000018, "Wrong size on FShootOrSkillMasteryCollation");
static_assert(offsetof(FShootOrSkillMasteryCollation, Type) == 0x000008, "Member 'FShootOrSkillMasteryCollation::Type' has a wrong offset!");
static_assert(offsetof(FShootOrSkillMasteryCollation, ShootDamage) == 0x00000C, "Member 'FShootOrSkillMasteryCollation::ShootDamage' has a wrong offset!");
static_assert(offsetof(FShootOrSkillMasteryCollation, SkillDamage) == 0x000010, "Member 'FShootOrSkillMasteryCollation::SkillDamage' has a wrong offset!");
static_assert(offsetof(FShootOrSkillMasteryCollation, SummonDamage) == 0x000014, "Member 'FShootOrSkillMasteryCollation::SummonDamage' has a wrong offset!");

// ScriptStruct Game.PlayerDeathEffectSettings
// 0x0048 (0x0048 - 0x0000)
struct FPlayerDeathEffectSettings final
{
public:
	class FName                                   SpawnBone;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         DeathParticle;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDelayTime;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessType                              ProcessType;                                       // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessParams*                     Params;                                            // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessDelayTime;                              // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessAliveTime;                              // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialSlot;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialParameter*>             MaterialParameters;                                // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaterialDelayTime;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDeathEffectSettings) == 0x000008, "Wrong alignment on FPlayerDeathEffectSettings");
static_assert(sizeof(FPlayerDeathEffectSettings) == 0x000048, "Wrong size on FPlayerDeathEffectSettings");
static_assert(offsetof(FPlayerDeathEffectSettings, SpawnBone) == 0x000000, "Member 'FPlayerDeathEffectSettings::SpawnBone' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, DeathParticle) == 0x000008, "Member 'FPlayerDeathEffectSettings::DeathParticle' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, EffectDelayTime) == 0x000010, "Member 'FPlayerDeathEffectSettings::EffectDelayTime' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, ProcessType) == 0x000014, "Member 'FPlayerDeathEffectSettings::ProcessType' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, Params) == 0x000018, "Member 'FPlayerDeathEffectSettings::Params' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, PostProcessDelayTime) == 0x000020, "Member 'FPlayerDeathEffectSettings::PostProcessDelayTime' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, PostProcessAliveTime) == 0x000024, "Member 'FPlayerDeathEffectSettings::PostProcessAliveTime' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, MaterialSlot) == 0x000028, "Member 'FPlayerDeathEffectSettings::MaterialSlot' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, MaterialParameters) == 0x000030, "Member 'FPlayerDeathEffectSettings::MaterialParameters' has a wrong offset!");
static_assert(offsetof(FPlayerDeathEffectSettings, MaterialDelayTime) == 0x000040, "Member 'FPlayerDeathEffectSettings::MaterialDelayTime' has a wrong offset!");

// ScriptStruct Game.HouseFootLineTemplate
// 0x0048 (0x0048 - 0x0000)
struct FHouseFootLineTemplate final
{
public:
	TSoftObjectPtr<class UPhysicalMaterial>       TarGetMaterial;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootCfg;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioEventName;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHouseFootLineTemplate) == 0x000008, "Wrong alignment on FHouseFootLineTemplate");
static_assert(sizeof(FHouseFootLineTemplate) == 0x000048, "Wrong size on FHouseFootLineTemplate");
static_assert(offsetof(FHouseFootLineTemplate, TarGetMaterial) == 0x000000, "Member 'FHouseFootLineTemplate::TarGetMaterial' has a wrong offset!");
static_assert(offsetof(FHouseFootLineTemplate, FootCfg) == 0x000028, "Member 'FHouseFootLineTemplate::FootCfg' has a wrong offset!");
static_assert(offsetof(FHouseFootLineTemplate, AudioEventName) == 0x000030, "Member 'FHouseFootLineTemplate::AudioEventName' has a wrong offset!");
static_assert(offsetof(FHouseFootLineTemplate, Level) == 0x000040, "Member 'FHouseFootLineTemplate::Level' has a wrong offset!");

// ScriptStruct Game.HouseFloorToFootAndAudioTemplate
// 0x0018 (0x0020 - 0x0008)
struct FHouseFloorToFootAndAudioTemplate final : public FTableRowBase
{
public:
	EAreaType                                     Area;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHouseFootLineTemplate>         FootConfigList;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseFloorToFootAndAudioTemplate) == 0x000008, "Wrong alignment on FHouseFloorToFootAndAudioTemplate");
static_assert(sizeof(FHouseFloorToFootAndAudioTemplate) == 0x000020, "Wrong size on FHouseFloorToFootAndAudioTemplate");
static_assert(offsetof(FHouseFloorToFootAndAudioTemplate, Area) == 0x000008, "Member 'FHouseFloorToFootAndAudioTemplate::Area' has a wrong offset!");
static_assert(offsetof(FHouseFloorToFootAndAudioTemplate, FootConfigList) == 0x000010, "Member 'FHouseFloorToFootAndAudioTemplate::FootConfigList' has a wrong offset!");

// ScriptStruct Game.FarmWarDropItemConfig
// 0x0048 (0x0048 - 0x0000)
struct FFarmWarDropItemConfig final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNum;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        NiagaraAssetPathFirst;                             // 0x0010(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        NiagaraAssetPathSecond;                            // 0x0028(0x0018)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFarmWarDropItemConfig) == 0x000008, "Wrong alignment on FFarmWarDropItemConfig");
static_assert(sizeof(FFarmWarDropItemConfig) == 0x000048, "Wrong size on FFarmWarDropItemConfig");
static_assert(offsetof(FFarmWarDropItemConfig, ID) == 0x000000, "Member 'FFarmWarDropItemConfig::ID' has a wrong offset!");
static_assert(offsetof(FFarmWarDropItemConfig, Radius) == 0x000004, "Member 'FFarmWarDropItemConfig::Radius' has a wrong offset!");
static_assert(offsetof(FFarmWarDropItemConfig, MaxNum) == 0x000008, "Member 'FFarmWarDropItemConfig::MaxNum' has a wrong offset!");
static_assert(offsetof(FFarmWarDropItemConfig, NiagaraAssetPathFirst) == 0x000010, "Member 'FFarmWarDropItemConfig::NiagaraAssetPathFirst' has a wrong offset!");
static_assert(offsetof(FFarmWarDropItemConfig, NiagaraAssetPathSecond) == 0x000028, "Member 'FFarmWarDropItemConfig::NiagaraAssetPathSecond' has a wrong offset!");
static_assert(offsetof(FFarmWarDropItemConfig, Name) == 0x000040, "Member 'FFarmWarDropItemConfig::Name' has a wrong offset!");

// ScriptStruct Game.HouseFurPlayerInteractEffInfo
// 0x0040 (0x0040 - 0x0000)
struct FHouseFurPlayerInteractEffInfo final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          FurInteractEffect;                                 // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerInteractEffAutoDestroyed;                    // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerInteractEffChangeSpeed;                      // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerInteractEffChangeParamName;                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerInteractEffDisappearInstantly;               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHouseFurPlayerInteractEffInfo) == 0x000008, "Wrong alignment on FHouseFurPlayerInteractEffInfo");
static_assert(sizeof(FHouseFurPlayerInteractEffInfo) == 0x000040, "Wrong size on FHouseFurPlayerInteractEffInfo");
static_assert(offsetof(FHouseFurPlayerInteractEffInfo, FurInteractEffect) == 0x000000, "Member 'FHouseFurPlayerInteractEffInfo::FurInteractEffect' has a wrong offset!");
static_assert(offsetof(FHouseFurPlayerInteractEffInfo, PlayerInteractEffAutoDestroyed) == 0x000028, "Member 'FHouseFurPlayerInteractEffInfo::PlayerInteractEffAutoDestroyed' has a wrong offset!");
static_assert(offsetof(FHouseFurPlayerInteractEffInfo, PlayerInteractEffChangeSpeed) == 0x00002C, "Member 'FHouseFurPlayerInteractEffInfo::PlayerInteractEffChangeSpeed' has a wrong offset!");
static_assert(offsetof(FHouseFurPlayerInteractEffInfo, PlayerInteractEffChangeParamName) == 0x000030, "Member 'FHouseFurPlayerInteractEffInfo::PlayerInteractEffChangeParamName' has a wrong offset!");
static_assert(offsetof(FHouseFurPlayerInteractEffInfo, PlayerInteractEffDisappearInstantly) == 0x000038, "Member 'FHouseFurPlayerInteractEffInfo::PlayerInteractEffDisappearInstantly' has a wrong offset!");

// ScriptStruct Game.MaterialStateParameter
// 0x0040 (0x0040 - 0x0000)
struct FMaterialStateParameter
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialParameter*>             MaterialParameters;                                // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialParameter*>             SecondaryMaterialParameters;                       // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialStateParameter) == 0x000008, "Wrong alignment on FMaterialStateParameter");
static_assert(sizeof(FMaterialStateParameter) == 0x000040, "Wrong size on FMaterialStateParameter");
static_assert(offsetof(FMaterialStateParameter, MaterialParameters) == 0x000008, "Member 'FMaterialStateParameter::MaterialParameters' has a wrong offset!");
static_assert(offsetof(FMaterialStateParameter, SecondaryMaterialParameters) == 0x000018, "Member 'FMaterialStateParameter::SecondaryMaterialParameters' has a wrong offset!");

// ScriptStruct Game.InsertButton
// 0x0004 (0x0004 - 0x0000)
struct FInsertButton final
{
public:
	int32                                         OverrideButton;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInsertButton) == 0x000004, "Wrong alignment on FInsertButton");
static_assert(sizeof(FInsertButton) == 0x000004, "Wrong size on FInsertButton");
static_assert(offsetof(FInsertButton, OverrideButton) == 0x000000, "Member 'FInsertButton::OverrideButton' has a wrong offset!");

// ScriptStruct Game.PawnViewData
// 0x0018 (0x0018 - 0x0000)
struct FPawnViewData final
{
public:
	class FName                                   PawnViewSocket;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PawnViewOffset;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInsertButton                          FastInsertButton;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnViewData) == 0x000004, "Wrong alignment on FPawnViewData");
static_assert(sizeof(FPawnViewData) == 0x000018, "Wrong size on FPawnViewData");
static_assert(offsetof(FPawnViewData, PawnViewSocket) == 0x000000, "Member 'FPawnViewData::PawnViewSocket' has a wrong offset!");
static_assert(offsetof(FPawnViewData, PawnViewOffset) == 0x000008, "Member 'FPawnViewData::PawnViewOffset' has a wrong offset!");
static_assert(offsetof(FPawnViewData, FastInsertButton) == 0x000014, "Member 'FPawnViewData::FastInsertButton' has a wrong offset!");

// ScriptStruct Game.DamagePosition
// 0x0038 (0x0038 - 0x0000)
struct FDamagePosition final
{
public:
	class AActor*                                 M_lpActor;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_nPosition;                                       // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPawnViewData                          PawnViewData;                                      // 0x0014(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bIsPawnView;                                     // 0x002C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Component;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamagePosition) == 0x000008, "Wrong alignment on FDamagePosition");
static_assert(sizeof(FDamagePosition) == 0x000038, "Wrong size on FDamagePosition");
static_assert(offsetof(FDamagePosition, M_lpActor) == 0x000000, "Member 'FDamagePosition::M_lpActor' has a wrong offset!");
static_assert(offsetof(FDamagePosition, M_nPosition) == 0x000008, "Member 'FDamagePosition::M_nPosition' has a wrong offset!");
static_assert(offsetof(FDamagePosition, PawnViewData) == 0x000014, "Member 'FDamagePosition::PawnViewData' has a wrong offset!");
static_assert(offsetof(FDamagePosition, M_bIsPawnView) == 0x00002C, "Member 'FDamagePosition::M_bIsPawnView' has a wrong offset!");
static_assert(offsetof(FDamagePosition, Component) == 0x000030, "Member 'FDamagePosition::Component' has a wrong offset!");

// ScriptStruct Game.BabyMode
// 0x00F0 (0x00F0 - 0x0000)
struct FBabyMode final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamagePosition                        TargetDamageData;                                  // 0x0070(0x0038)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugMoveDelta;                                   // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBabyMode) == 0x000008, "Wrong alignment on FBabyMode");
static_assert(sizeof(FBabyMode) == 0x0000F0, "Wrong size on FBabyMode");
static_assert(offsetof(FBabyMode, TargetDamageData) == 0x000070, "Member 'FBabyMode::TargetDamageData' has a wrong offset!");
static_assert(offsetof(FBabyMode, bDebugMoveDelta) == 0x0000E0, "Member 'FBabyMode::bDebugMoveDelta' has a wrong offset!");

// ScriptStruct Game.CurveValue
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FCurveValue final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurveValue) == 0x000008, "Wrong alignment on FCurveValue");
static_assert(sizeof(FCurveValue) == 0x000090, "Wrong size on FCurveValue");

// ScriptStruct Game.SinEaseFunc
// 0x0004 (0x0004 - 0x0000)
struct FSinEaseFunc final
{
public:
	float                                         CurInterpAlpha;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSinEaseFunc) == 0x000004, "Wrong alignment on FSinEaseFunc");
static_assert(sizeof(FSinEaseFunc) == 0x000004, "Wrong size on FSinEaseFunc");
static_assert(offsetof(FSinEaseFunc, CurInterpAlpha) == 0x000000, "Member 'FSinEaseFunc::CurInterpAlpha' has a wrong offset!");

// ScriptStruct Game.SmoothVector
// 0x0024 (0x0024 - 0x0000)
struct FSmoothVector final
{
public:
	struct FVector                                TargetValue;                                       // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentValue;                                      // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSinEaseFunc                           SinEase;                                           // 0x001C(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseSinFunc : 1;                                   // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmoothVector) == 0x000004, "Wrong alignment on FSmoothVector");
static_assert(sizeof(FSmoothVector) == 0x000024, "Wrong size on FSmoothVector");
static_assert(offsetof(FSmoothVector, TargetValue) == 0x000000, "Member 'FSmoothVector::TargetValue' has a wrong offset!");
static_assert(offsetof(FSmoothVector, CurrentValue) == 0x00000C, "Member 'FSmoothVector::CurrentValue' has a wrong offset!");
static_assert(offsetof(FSmoothVector, Speed) == 0x000018, "Member 'FSmoothVector::Speed' has a wrong offset!");
static_assert(offsetof(FSmoothVector, SinEase) == 0x00001C, "Member 'FSmoothVector::SinEase' has a wrong offset!");

// ScriptStruct Game.EnchantCalcData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FEnchantCalcData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnchantCalcData) == 0x000008, "Wrong alignment on FEnchantCalcData");
static_assert(sizeof(FEnchantCalcData) == 0x000018, "Wrong size on FEnchantCalcData");

// ScriptStruct Game.SavedAnimSyncMarker
// 0x0010 (0x0010 - 0x0000)
struct FSavedAnimSyncMarker final
{
public:
	int32                                         TrackIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedAnimSyncMarker) == 0x000004, "Wrong alignment on FSavedAnimSyncMarker");
static_assert(sizeof(FSavedAnimSyncMarker) == 0x000010, "Wrong size on FSavedAnimSyncMarker");
static_assert(offsetof(FSavedAnimSyncMarker, TrackIndex) == 0x000000, "Member 'FSavedAnimSyncMarker::TrackIndex' has a wrong offset!");
static_assert(offsetof(FSavedAnimSyncMarker, MarkerName) == 0x000004, "Member 'FSavedAnimSyncMarker::MarkerName' has a wrong offset!");
static_assert(offsetof(FSavedAnimSyncMarker, Time) == 0x00000C, "Member 'FSavedAnimSyncMarker::Time' has a wrong offset!");

// ScriptStruct Game.FightCrossType
// 0x0010 (0x0018 - 0x0008)
struct FFightCrossType final : public FTableRowBase
{
public:
	EWeaponType                                   Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnitTime;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Anim1Count;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Anim2Count;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFightCrossType) == 0x000008, "Wrong alignment on FFightCrossType");
static_assert(sizeof(FFightCrossType) == 0x000018, "Wrong size on FFightCrossType");
static_assert(offsetof(FFightCrossType, Type) == 0x000008, "Member 'FFightCrossType::Type' has a wrong offset!");
static_assert(offsetof(FFightCrossType, UnitTime) == 0x00000C, "Member 'FFightCrossType::UnitTime' has a wrong offset!");
static_assert(offsetof(FFightCrossType, Anim1Count) == 0x000010, "Member 'FFightCrossType::Anim1Count' has a wrong offset!");
static_assert(offsetof(FFightCrossType, Anim2Count) == 0x000014, "Member 'FFightCrossType::Anim2Count' has a wrong offset!");

// ScriptStruct Game.HairTrace
// 0x0018 (0x0018 - 0x0000)
struct FHairTrace final
{
public:
	struct FVector                                CurPos;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TarPos;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHairTrace) == 0x000004, "Wrong alignment on FHairTrace");
static_assert(sizeof(FHairTrace) == 0x000018, "Wrong size on FHairTrace");
static_assert(offsetof(FHairTrace, CurPos) == 0x000000, "Member 'FHairTrace::CurPos' has a wrong offset!");
static_assert(offsetof(FHairTrace, TarPos) == 0x00000C, "Member 'FHairTrace::TarPos' has a wrong offset!");

// ScriptStruct Game.ElemExplosionEffect
// 0x00A0 (0x00A0 - 0x0000)
struct FElemExplosionEffect final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExTime;                                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Launcher;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLocation;                                     // 0x001C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 ModifyHPType;                                      // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAbilityComponentBase*>          ElemExplosionRecords;                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartResult;                                        // 0x0040(0x0030)(Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartitionResult;                                   // 0x0070(0x0030)(Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemExplosionEffect) == 0x000008, "Wrong alignment on FElemExplosionEffect");
static_assert(sizeof(FElemExplosionEffect) == 0x0000A0, "Wrong size on FElemExplosionEffect");
static_assert(offsetof(FElemExplosionEffect, EmitterID) == 0x000000, "Member 'FElemExplosionEffect::EmitterID' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, ExTime) == 0x000004, "Member 'FElemExplosionEffect::ExTime' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, Launcher) == 0x000008, "Member 'FElemExplosionEffect::Launcher' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, OriginLocation) == 0x000010, "Member 'FElemExplosionEffect::OriginLocation' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, ApplyLocation) == 0x00001C, "Member 'FElemExplosionEffect::ApplyLocation' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, ModifyHPType) == 0x000028, "Member 'FElemExplosionEffect::ModifyHPType' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, ElemExplosionRecords) == 0x000030, "Member 'FElemExplosionEffect::ElemExplosionRecords' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, PartResult) == 0x000040, "Member 'FElemExplosionEffect::PartResult' has a wrong offset!");
static_assert(offsetof(FElemExplosionEffect, PartitionResult) == 0x000070, "Member 'FElemExplosionEffect::PartitionResult' has a wrong offset!");

// ScriptStruct Game.AbilityLastForceFeedbackInfo
// 0x0020 (0x0020 - 0x0000)
struct FAbilityLastForceFeedbackInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityForceFeedbackType                     Type;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColdDownTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityLastForceFeedbackInfo) == 0x000004, "Wrong alignment on FAbilityLastForceFeedbackInfo");
static_assert(sizeof(FAbilityLastForceFeedbackInfo) == 0x000020, "Wrong size on FAbilityLastForceFeedbackInfo");
static_assert(offsetof(FAbilityLastForceFeedbackInfo, ID) == 0x000000, "Member 'FAbilityLastForceFeedbackInfo::ID' has a wrong offset!");
static_assert(offsetof(FAbilityLastForceFeedbackInfo, Type) == 0x000004, "Member 'FAbilityLastForceFeedbackInfo::Type' has a wrong offset!");
static_assert(offsetof(FAbilityLastForceFeedbackInfo, ColdDownTime) == 0x000008, "Member 'FAbilityLastForceFeedbackInfo::ColdDownTime' has a wrong offset!");
static_assert(offsetof(FAbilityLastForceFeedbackInfo, BlendOutTime) == 0x00000C, "Member 'FAbilityLastForceFeedbackInfo::BlendOutTime' has a wrong offset!");

// ScriptStruct Game.FightPopUIMgr
// 0x0260 (0x0260 - 0x0000)
struct alignas(0x08) FFightPopUIMgr final
{
public:
	uint8                                         Pad_0[0x260];                                      // 0x0000(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFightPopUIMgr) == 0x000008, "Wrong alignment on FFightPopUIMgr");
static_assert(sizeof(FFightPopUIMgr) == 0x000260, "Wrong size on FFightPopUIMgr");

// ScriptStruct Game.TimeValue
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FTimeValue final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimeValue) == 0x000004, "Wrong alignment on FTimeValue");
static_assert(sizeof(FTimeValue) == 0x000010, "Wrong size on FTimeValue");

// ScriptStruct Game.AutoLockTarget
// 0x0020 (0x0020 - 0x0000)
struct FAutoLockTarget final
{
public:
	class AActor*                                 LockActor;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameCharacter*                         LockChracter;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CacheViewTargetPosition;                           // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoLockTarget) == 0x000008, "Wrong alignment on FAutoLockTarget");
static_assert(sizeof(FAutoLockTarget) == 0x000020, "Wrong size on FAutoLockTarget");
static_assert(offsetof(FAutoLockTarget, LockActor) == 0x000000, "Member 'FAutoLockTarget::LockActor' has a wrong offset!");
static_assert(offsetof(FAutoLockTarget, LockChracter) == 0x000008, "Member 'FAutoLockTarget::LockChracter' has a wrong offset!");
static_assert(offsetof(FAutoLockTarget, CacheViewTargetPosition) == 0x000010, "Member 'FAutoLockTarget::CacheViewTargetPosition' has a wrong offset!");

// ScriptStruct Game.AssistRotationRate
// 0x000C (0x000C - 0x0000)
struct FAssistRotationRate final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AssistAimRotationRate;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistTargetRotationRate;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssistRotationRate) == 0x000004, "Wrong alignment on FAssistRotationRate");
static_assert(sizeof(FAssistRotationRate) == 0x00000C, "Wrong size on FAssistRotationRate");
static_assert(offsetof(FAssistRotationRate, WeaponType) == 0x000000, "Member 'FAssistRotationRate::WeaponType' has a wrong offset!");
static_assert(offsetof(FAssistRotationRate, AssistAimRotationRate) == 0x000004, "Member 'FAssistRotationRate::AssistAimRotationRate' has a wrong offset!");
static_assert(offsetof(FAssistRotationRate, AssistTargetRotationRate) == 0x000008, "Member 'FAssistRotationRate::AssistTargetRotationRate' has a wrong offset!");

// ScriptStruct Game.EmitterEffectSaveData
// 0x0008 (0x0008 - 0x0000)
struct FEmitterEffectSaveData final
{
public:
	float                                         TriggerTime;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectiveTimes;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterEffectSaveData) == 0x000004, "Wrong alignment on FEmitterEffectSaveData");
static_assert(sizeof(FEmitterEffectSaveData) == 0x000008, "Wrong size on FEmitterEffectSaveData");
static_assert(offsetof(FEmitterEffectSaveData, TriggerTime) == 0x000000, "Member 'FEmitterEffectSaveData::TriggerTime' has a wrong offset!");
static_assert(offsetof(FEmitterEffectSaveData, EffectiveTimes) == 0x000004, "Member 'FEmitterEffectSaveData::EffectiveTimes' has a wrong offset!");

// ScriptStruct Game.MassAIMoveDestinationDetailSettings
// 0x0010 (0x0010 - 0x0000)
struct FMassAIMoveDestinationDetailSettings final
{
public:
	bool                                          bChooseBoundary;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Offset;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomOffset;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InRadius;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMassAIMoveDestinationDetailSettings) == 0x000004, "Wrong alignment on FMassAIMoveDestinationDetailSettings");
static_assert(sizeof(FMassAIMoveDestinationDetailSettings) == 0x000010, "Wrong size on FMassAIMoveDestinationDetailSettings");
static_assert(offsetof(FMassAIMoveDestinationDetailSettings, bChooseBoundary) == 0x000000, "Member 'FMassAIMoveDestinationDetailSettings::bChooseBoundary' has a wrong offset!");
static_assert(offsetof(FMassAIMoveDestinationDetailSettings, Offset) == 0x000004, "Member 'FMassAIMoveDestinationDetailSettings::Offset' has a wrong offset!");
static_assert(offsetof(FMassAIMoveDestinationDetailSettings, bUseRandomOffset) == 0x000008, "Member 'FMassAIMoveDestinationDetailSettings::bUseRandomOffset' has a wrong offset!");
static_assert(offsetof(FMassAIMoveDestinationDetailSettings, InRadius) == 0x00000C, "Member 'FMassAIMoveDestinationDetailSettings::InRadius' has a wrong offset!");

// ScriptStruct Game.RayHitInfo
// 0x0020 (0x0020 - 0x0000)
struct FRayHitInfo final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockingHit;                                      // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierSingleFireDataFlag;                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRayHitInfo) == 0x000004, "Wrong alignment on FRayHitInfo");
static_assert(sizeof(FRayHitInfo) == 0x000020, "Wrong size on FRayHitInfo");
static_assert(offsetof(FRayHitInfo, Location) == 0x000000, "Member 'FRayHitInfo::Location' has a wrong offset!");
static_assert(offsetof(FRayHitInfo, bBlockingHit) == 0x00000C, "Member 'FRayHitInfo::bBlockingHit' has a wrong offset!");
static_assert(offsetof(FRayHitInfo, ImpactPoint) == 0x000010, "Member 'FRayHitInfo::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FRayHitInfo, ModifierSingleFireDataFlag) == 0x00001C, "Member 'FRayHitInfo::ModifierSingleFireDataFlag' has a wrong offset!");

// ScriptStruct Game.RayRpcHitInfo
// 0x0020 (0x0020 - 0x0000)
struct FRayRpcHitInfo final
{
public:
	struct FVector_NetQuantize                    StartLoc;                                          // 0x0000(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRayHitInfo>                    HitResults;                                        // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRayRpcHitInfo) == 0x000008, "Wrong alignment on FRayRpcHitInfo");
static_assert(sizeof(FRayRpcHitInfo) == 0x000020, "Wrong size on FRayRpcHitInfo");
static_assert(offsetof(FRayRpcHitInfo, StartLoc) == 0x000000, "Member 'FRayRpcHitInfo::StartLoc' has a wrong offset!");
static_assert(offsetof(FRayRpcHitInfo, HitResults) == 0x000010, "Member 'FRayRpcHitInfo::HitResults' has a wrong offset!");

// ScriptStruct Game.SharedCustomSlotConfig
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSharedCustomSlotConfig final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedCustomSlotConfig) == 0x000008, "Wrong alignment on FSharedCustomSlotConfig");
static_assert(sizeof(FSharedCustomSlotConfig) == 0x000020, "Wrong size on FSharedCustomSlotConfig");

// ScriptStruct Game.AnimReplaceData
// 0x0048 (0x0048 - 0x0000)
struct FAnimReplaceData final
{
public:
	bool                                          bLoadAnim_External;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewVariableName;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       AnimAssetReplace;                                  // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsManualPlay;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimReplaceData) == 0x000008, "Wrong alignment on FAnimReplaceData");
static_assert(sizeof(FAnimReplaceData) == 0x000048, "Wrong size on FAnimReplaceData");
static_assert(offsetof(FAnimReplaceData, bLoadAnim_External) == 0x000000, "Member 'FAnimReplaceData::bLoadAnim_External' has a wrong offset!");
static_assert(offsetof(FAnimReplaceData, NewVariableName) == 0x000008, "Member 'FAnimReplaceData::NewVariableName' has a wrong offset!");
static_assert(offsetof(FAnimReplaceData, AnimAssetReplace) == 0x000018, "Member 'FAnimReplaceData::AnimAssetReplace' has a wrong offset!");
static_assert(offsetof(FAnimReplaceData, bIsManualPlay) == 0x000040, "Member 'FAnimReplaceData::bIsManualPlay' has a wrong offset!");

// ScriptStruct Game.CachedSwitchPlayerInfo
// 0x0014 (0x0014 - 0x0000)
struct FCachedSwitchPlayerInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySuperSkill;                                   // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchCacheValidTime;                              // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x7];                                        // 0x000D(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedSwitchPlayerInfo) == 0x000004, "Wrong alignment on FCachedSwitchPlayerInfo");
static_assert(sizeof(FCachedSwitchPlayerInfo) == 0x000014, "Wrong size on FCachedSwitchPlayerInfo");
static_assert(offsetof(FCachedSwitchPlayerInfo, Index) == 0x000000, "Member 'FCachedSwitchPlayerInfo::Index' has a wrong offset!");
static_assert(offsetof(FCachedSwitchPlayerInfo, bPlaySuperSkill) == 0x000004, "Member 'FCachedSwitchPlayerInfo::bPlaySuperSkill' has a wrong offset!");
static_assert(offsetof(FCachedSwitchPlayerInfo, SwitchCacheValidTime) == 0x000008, "Member 'FCachedSwitchPlayerInfo::SwitchCacheValidTime' has a wrong offset!");
static_assert(offsetof(FCachedSwitchPlayerInfo, bValid) == 0x00000C, "Member 'FCachedSwitchPlayerInfo::bValid' has a wrong offset!");

// ScriptStruct Game.ParameterBase
// 0x0010 (0x0010 - 0x0000)
struct FParameterBase
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParameterBase) == 0x000004, "Wrong alignment on FParameterBase");
static_assert(sizeof(FParameterBase) == 0x000010, "Wrong size on FParameterBase");
static_assert(offsetof(FParameterBase, ID) == 0x000000, "Member 'FParameterBase::ID' has a wrong offset!");

// ScriptStruct Game.TempWeaponEnchant
// 0x0014 (0x0014 - 0x0000)
struct FTempWeaponEnchant final
{
public:
	int32                                         TempWeaponEnchantID;                               // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TempWeaponEnchantTimes;                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierRunTimeID;                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   EnchantLauncher;                                   // 0x000C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTempWeaponEnchant) == 0x000004, "Wrong alignment on FTempWeaponEnchant");
static_assert(sizeof(FTempWeaponEnchant) == 0x000014, "Wrong size on FTempWeaponEnchant");
static_assert(offsetof(FTempWeaponEnchant, TempWeaponEnchantID) == 0x000000, "Member 'FTempWeaponEnchant::TempWeaponEnchantID' has a wrong offset!");
static_assert(offsetof(FTempWeaponEnchant, TempWeaponEnchantTimes) == 0x000004, "Member 'FTempWeaponEnchant::TempWeaponEnchantTimes' has a wrong offset!");
static_assert(offsetof(FTempWeaponEnchant, ModifierRunTimeID) == 0x000008, "Member 'FTempWeaponEnchant::ModifierRunTimeID' has a wrong offset!");
static_assert(offsetof(FTempWeaponEnchant, EnchantLauncher) == 0x00000C, "Member 'FTempWeaponEnchant::EnchantLauncher' has a wrong offset!");

// ScriptStruct Game.WeaponSkinInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FWeaponSkinInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSkinInfo) == 0x000008, "Wrong alignment on FWeaponSkinInfo");
static_assert(sizeof(FWeaponSkinInfo) == 0x000020, "Wrong size on FWeaponSkinInfo");

// ScriptStruct Game.PreviewHeadAnimNameMappingTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPreviewHeadAnimNameMappingTemplate final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimResName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOriginalSkin;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewHeadAnimNameMappingTemplate) == 0x000008, "Wrong alignment on FPreviewHeadAnimNameMappingTemplate");
static_assert(sizeof(FPreviewHeadAnimNameMappingTemplate) == 0x000040, "Wrong size on FPreviewHeadAnimNameMappingTemplate");
static_assert(offsetof(FPreviewHeadAnimNameMappingTemplate, VariableName) == 0x000008, "Member 'FPreviewHeadAnimNameMappingTemplate::VariableName' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingTemplate, AnimResName) == 0x000018, "Member 'FPreviewHeadAnimNameMappingTemplate::AnimResName' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingTemplate, WidgetContainer) == 0x000028, "Member 'FPreviewHeadAnimNameMappingTemplate::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingTemplate, bUseWeaponSubType) == 0x000038, "Member 'FPreviewHeadAnimNameMappingTemplate::bUseWeaponSubType' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingTemplate, bUseOriginalSkin) == 0x000039, "Member 'FPreviewHeadAnimNameMappingTemplate::bUseOriginalSkin' has a wrong offset!");

// ScriptStruct Game.AttributeChangeValue
// 0x0020 (0x0020 - 0x0000)
struct FAttributeChangeValue final
{
public:
	class UAbilityAttribute*                      AttributeClass;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeChangeType                          ChangeType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAbilityComponentBase>   Target;                                            // 0x000C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTeam;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyMax;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyWeapon;                                      // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTemp;                                        // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveCache;                                      // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeChangeValue) == 0x000008, "Wrong alignment on FAttributeChangeValue");
static_assert(sizeof(FAttributeChangeValue) == 0x000020, "Wrong size on FAttributeChangeValue");
static_assert(offsetof(FAttributeChangeValue, AttributeClass) == 0x000000, "Member 'FAttributeChangeValue::AttributeClass' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, ChangeType) == 0x000008, "Member 'FAttributeChangeValue::ChangeType' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, Target) == 0x00000C, "Member 'FAttributeChangeValue::Target' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, Value) == 0x000014, "Member 'FAttributeChangeValue::Value' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, bApplyTeam) == 0x000018, "Member 'FAttributeChangeValue::bApplyTeam' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, bApplyMax) == 0x000019, "Member 'FAttributeChangeValue::bApplyMax' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, bApplyWeapon) == 0x00001A, "Member 'FAttributeChangeValue::bApplyWeapon' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, bApplyTemp) == 0x00001B, "Member 'FAttributeChangeValue::bApplyTemp' has a wrong offset!");
static_assert(offsetof(FAttributeChangeValue, bRemoveCache) == 0x00001C, "Member 'FAttributeChangeValue::bRemoveCache' has a wrong offset!");

// ScriptStruct Game.RecordSkillCostStruct
// 0x0038 (0x0038 - 0x0000)
struct FRecordSkillCostStruct final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRunTimeID;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecordSkillCostType                          SkillType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeValue                  Cost;                                              // 0x0010(0x0020)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CostTime;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecordSkillCostStruct) == 0x000008, "Wrong alignment on FRecordSkillCostStruct");
static_assert(sizeof(FRecordSkillCostStruct) == 0x000038, "Wrong size on FRecordSkillCostStruct");
static_assert(offsetof(FRecordSkillCostStruct, SkillID) == 0x000000, "Member 'FRecordSkillCostStruct::SkillID' has a wrong offset!");
static_assert(offsetof(FRecordSkillCostStruct, SkillRunTimeID) == 0x000004, "Member 'FRecordSkillCostStruct::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FRecordSkillCostStruct, SkillType) == 0x000008, "Member 'FRecordSkillCostStruct::SkillType' has a wrong offset!");
static_assert(offsetof(FRecordSkillCostStruct, Cost) == 0x000010, "Member 'FRecordSkillCostStruct::Cost' has a wrong offset!");
static_assert(offsetof(FRecordSkillCostStruct, CostTime) == 0x000030, "Member 'FRecordSkillCostStruct::CostTime' has a wrong offset!");

// ScriptStruct Game.SpecialThroughBulletInfo
// 0x0560 (0x0560 - 0x0000)
struct FSpecialThroughBulletInfo final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x008C)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletInfo                            BulletInfo;                                        // 0x0090(0x04A0)(BlueprintVisible, RepSkip, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x0530(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BulletOwner;                                       // 0x0538(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialThroughBulletType                     SpecialThroughBulletType;                          // 0x0540(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x3];                                      // 0x0541(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CacheTime;                                         // 0x0544(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     Targets;                                           // 0x0548(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ATrapReceiveBullet>      SelfTrap;                                          // 0x0558(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialThroughBulletInfo) == 0x000010, "Wrong alignment on FSpecialThroughBulletInfo");
static_assert(sizeof(FSpecialThroughBulletInfo) == 0x000560, "Wrong size on FSpecialThroughBulletInfo");
static_assert(offsetof(FSpecialThroughBulletInfo, HitResult) == 0x000000, "Member 'FSpecialThroughBulletInfo::HitResult' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, BulletInfo) == 0x000090, "Member 'FSpecialThroughBulletInfo::BulletInfo' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, BulletID) == 0x000530, "Member 'FSpecialThroughBulletInfo::BulletID' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, BulletOwner) == 0x000538, "Member 'FSpecialThroughBulletInfo::BulletOwner' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, SpecialThroughBulletType) == 0x000540, "Member 'FSpecialThroughBulletInfo::SpecialThroughBulletType' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, CacheTime) == 0x000544, "Member 'FSpecialThroughBulletInfo::CacheTime' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, Targets) == 0x000548, "Member 'FSpecialThroughBulletInfo::Targets' has a wrong offset!");
static_assert(offsetof(FSpecialThroughBulletInfo, SelfTrap) == 0x000558, "Member 'FSpecialThroughBulletInfo::SelfTrap' has a wrong offset!");

// ScriptStruct Game.CurveDataSpinePitchRuntimeData
// 0x0098 (0x0098 - 0x0000)
struct FCurveDataSpinePitchRuntimeData final
{
public:
	float                                         PitchOffset;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElpasedTime;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveLength;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopSectionPos;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDataValid;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContainLoopSection;                               // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRichCurve                             CurrentCurve;                                      // 0x0018(0x0080)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveDataSpinePitchRuntimeData) == 0x000008, "Wrong alignment on FCurveDataSpinePitchRuntimeData");
static_assert(sizeof(FCurveDataSpinePitchRuntimeData) == 0x000098, "Wrong size on FCurveDataSpinePitchRuntimeData");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, PitchOffset) == 0x000000, "Member 'FCurveDataSpinePitchRuntimeData::PitchOffset' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, ElpasedTime) == 0x000004, "Member 'FCurveDataSpinePitchRuntimeData::ElpasedTime' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, CurveLength) == 0x000008, "Member 'FCurveDataSpinePitchRuntimeData::CurveLength' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, LoopSectionPos) == 0x00000C, "Member 'FCurveDataSpinePitchRuntimeData::LoopSectionPos' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, bDataValid) == 0x000010, "Member 'FCurveDataSpinePitchRuntimeData::bDataValid' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, bContainLoopSection) == 0x000011, "Member 'FCurveDataSpinePitchRuntimeData::bContainLoopSection' has a wrong offset!");
static_assert(offsetof(FCurveDataSpinePitchRuntimeData, CurrentCurve) == 0x000018, "Member 'FCurveDataSpinePitchRuntimeData::CurrentCurve' has a wrong offset!");

// ScriptStruct Game.CharacterEffectType
// 0x0008 (0x0010 - 0x0008)
struct FCharacterEffectType final : public FTableRowBase
{
public:
	struct FFlexibleEnumValue                     Type;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Layer;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterEffectType) == 0x000008, "Wrong alignment on FCharacterEffectType");
static_assert(sizeof(FCharacterEffectType) == 0x000010, "Wrong size on FCharacterEffectType");
static_assert(offsetof(FCharacterEffectType, Type) == 0x000008, "Member 'FCharacterEffectType::Type' has a wrong offset!");
static_assert(offsetof(FCharacterEffectType, Layer) == 0x00000C, "Member 'FCharacterEffectType::Layer' has a wrong offset!");

// ScriptStruct Game.SkinReplaceMeshInfo
// 0x0078 (0x0078 - 0x0000)
struct FSkinReplaceMeshInfo final
{
public:
	int32                                         SkinTemplateID;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MeshTagName;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           MeshContainer;                                     // 0x0010(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshContainer_AllAges;                             // 0x0038(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AnimClassContainer;                                // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinReplaceMeshInfo) == 0x000008, "Wrong alignment on FSkinReplaceMeshInfo");
static_assert(sizeof(FSkinReplaceMeshInfo) == 0x000078, "Wrong size on FSkinReplaceMeshInfo");
static_assert(offsetof(FSkinReplaceMeshInfo, SkinTemplateID) == 0x000000, "Member 'FSkinReplaceMeshInfo::SkinTemplateID' has a wrong offset!");
static_assert(offsetof(FSkinReplaceMeshInfo, MeshTagName) == 0x000004, "Member 'FSkinReplaceMeshInfo::MeshTagName' has a wrong offset!");
static_assert(offsetof(FSkinReplaceMeshInfo, MeshContainer) == 0x000010, "Member 'FSkinReplaceMeshInfo::MeshContainer' has a wrong offset!");
static_assert(offsetof(FSkinReplaceMeshInfo, MeshContainer_AllAges) == 0x000038, "Member 'FSkinReplaceMeshInfo::MeshContainer_AllAges' has a wrong offset!");
static_assert(offsetof(FSkinReplaceMeshInfo, AnimClassContainer) == 0x000060, "Member 'FSkinReplaceMeshInfo::AnimClassContainer' has a wrong offset!");

// ScriptStruct Game.SkillWeightDebugInfo
// 0x0008 (0x0008 - 0x0000)
struct FSkillWeightDebugInfo final
{
public:
	int32                                         SkillGroupIndex;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillWeightDebugInfo) == 0x000004, "Wrong alignment on FSkillWeightDebugInfo");
static_assert(sizeof(FSkillWeightDebugInfo) == 0x000008, "Wrong size on FSkillWeightDebugInfo");
static_assert(offsetof(FSkillWeightDebugInfo, SkillGroupIndex) == 0x000000, "Member 'FSkillWeightDebugInfo::SkillGroupIndex' has a wrong offset!");
static_assert(offsetof(FSkillWeightDebugInfo, SkillID) == 0x000004, "Member 'FSkillWeightDebugInfo::SkillID' has a wrong offset!");

// ScriptStruct Game.SingleFireModifierDefine
// 0x0068 (0x0068 - 0x0000)
struct FSingleFireModifierDefine final
{
public:
	int32                                         BulletCostNum;                                     // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoBulletCanFire;                                   // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostBulletPower;                                   // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotCostBulletPower;                                // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillMasteryPower;                                 // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DamageTag;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSkillMasteryPower;                          // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FireSocket;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivate;                                         // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBulletNum;                                  // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentShootBulletCost;                            // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponEnchantID;                                   // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataFlag;                                          // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESingleFireModifierState>              FireModifierStates;                                // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleFireModifierDefine) == 0x000008, "Wrong alignment on FSingleFireModifierDefine");
static_assert(sizeof(FSingleFireModifierDefine) == 0x000068, "Wrong size on FSingleFireModifierDefine");
static_assert(offsetof(FSingleFireModifierDefine, BulletCostNum) == 0x000000, "Member 'FSingleFireModifierDefine::BulletCostNum' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, NoBulletCanFire) == 0x000004, "Member 'FSingleFireModifierDefine::NoBulletCanFire' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, CostBulletPower) == 0x000008, "Member 'FSingleFireModifierDefine::CostBulletPower' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, NotCostBulletPower) == 0x00000C, "Member 'FSingleFireModifierDefine::NotCostBulletPower' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, SkillMasteryPower) == 0x000010, "Member 'FSingleFireModifierDefine::SkillMasteryPower' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, DamageTag) == 0x000018, "Member 'FSingleFireModifierDefine::DamageTag' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, CurrentSkillMasteryPower) == 0x000028, "Member 'FSingleFireModifierDefine::CurrentSkillMasteryPower' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, FireSocket) == 0x000030, "Member 'FSingleFireModifierDefine::FireSocket' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, bActivate) == 0x000040, "Member 'FSingleFireModifierDefine::bActivate' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, CurrentBulletNum) == 0x000044, "Member 'FSingleFireModifierDefine::CurrentBulletNum' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, CurrentShootBulletCost) == 0x000048, "Member 'FSingleFireModifierDefine::CurrentShootBulletCost' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, WeaponEnchantID) == 0x00004C, "Member 'FSingleFireModifierDefine::WeaponEnchantID' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, DataFlag) == 0x000050, "Member 'FSingleFireModifierDefine::DataFlag' has a wrong offset!");
static_assert(offsetof(FSingleFireModifierDefine, FireModifierStates) == 0x000058, "Member 'FSingleFireModifierDefine::FireModifierStates' has a wrong offset!");

// ScriptStruct Game.PatrolPath
// 0x0018 (0x0018 - 0x0000)
struct FPatrolPath final
{
public:
	TArray<struct FPatrolPathPoint>               Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatrolPath) == 0x000008, "Wrong alignment on FPatrolPath");
static_assert(sizeof(FPatrolPath) == 0x000018, "Wrong size on FPatrolPath");
static_assert(offsetof(FPatrolPath, Points) == 0x000000, "Member 'FPatrolPath::Points' has a wrong offset!");
static_assert(offsetof(FPatrolPath, Weight) == 0x000010, "Member 'FPatrolPath::Weight' has a wrong offset!");

// ScriptStruct Game.PatrolSection
// 0x0010 (0x0010 - 0x0000)
struct FPatrolSection final
{
public:
	TArray<struct FPatrolPath>                    Paths;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolSection) == 0x000008, "Wrong alignment on FPatrolSection");
static_assert(sizeof(FPatrolSection) == 0x000010, "Wrong size on FPatrolSection");
static_assert(offsetof(FPatrolSection, Paths) == 0x000000, "Member 'FPatrolSection::Paths' has a wrong offset!");

// ScriptStruct Game.OnlineSeaGameEventGroupItem
// 0x0028 (0x0028 - 0x0000)
struct FOnlineSeaGameEventGroupItem final
{
public:
	TArray<int32>                                 ActiveEventIds;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EventsNum;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Difficulty;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SpecificTags;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaGameEventGroupItem) == 0x000008, "Wrong alignment on FOnlineSeaGameEventGroupItem");
static_assert(sizeof(FOnlineSeaGameEventGroupItem) == 0x000028, "Wrong size on FOnlineSeaGameEventGroupItem");
static_assert(offsetof(FOnlineSeaGameEventGroupItem, ActiveEventIds) == 0x000000, "Member 'FOnlineSeaGameEventGroupItem::ActiveEventIds' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventGroupItem, EventsNum) == 0x000010, "Member 'FOnlineSeaGameEventGroupItem::EventsNum' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventGroupItem, Difficulty) == 0x000014, "Member 'FOnlineSeaGameEventGroupItem::Difficulty' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEventGroupItem, SpecificTags) == 0x000018, "Member 'FOnlineSeaGameEventGroupItem::SpecificTags' has a wrong offset!");

// ScriptStruct Game.BulletEnchantInfo
// 0x0178 (0x0180 - 0x0008)
struct FBulletEnchantInfo final : public FTableRowBase
{
public:
	class FString                                 BlueprintName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 DamageType;                                        // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepRay;                                          // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParticlePathComposite;                            // 0x001F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ParticlePath;                                      // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitEffectTable;                                // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitEffectID;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HitEffectParticlePath;                             // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectAttach;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectFollowBulletRotation;                    // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectComposite;                               // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleCount;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeTime;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TailBeamParticlePath;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TailBeamParticleParamName;                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TailBeamParticleParam;                             // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TailParticlePath;                                  // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeBulletFireEffect;                     // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletFireEffectSpeed;                             // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BulletFireEffect;                                  // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletFireEffectAttachWeapon;                     // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FlyingSoundEvent;                                  // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LifeEndEffectParticlePath;                         // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeBulletRayPath;                        // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BulletRayPath;                                     // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletRayParamName;                                // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BulletRayParam;                                    // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StopFireParticlePath;                              // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffect;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FireSoundEvent;                                    // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSilencerFireSound;                                // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SilencerFireSoundEvent;                            // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceSound;                                     // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAbilityComponentBase>   EnchantLauncher;                                   // 0x0174(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletEnchantInfo) == 0x000008, "Wrong alignment on FBulletEnchantInfo");
static_assert(sizeof(FBulletEnchantInfo) == 0x000180, "Wrong size on FBulletEnchantInfo");
static_assert(offsetof(FBulletEnchantInfo, BlueprintName) == 0x000008, "Member 'FBulletEnchantInfo::BlueprintName' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, ID) == 0x000018, "Member 'FBulletEnchantInfo::ID' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, WeaponType) == 0x00001C, "Member 'FBulletEnchantInfo::WeaponType' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, DamageType) == 0x00001D, "Member 'FBulletEnchantInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bKeepRay) == 0x00001E, "Member 'FBulletEnchantInfo::bKeepRay' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bParticlePathComposite) == 0x00001F, "Member 'FBulletEnchantInfo::bParticlePathComposite' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, ParticlePath) == 0x000020, "Member 'FBulletEnchantInfo::ParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bUseHitEffectTable) == 0x000038, "Member 'FBulletEnchantInfo::bUseHitEffectTable' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, HitEffectID) == 0x00003C, "Member 'FBulletEnchantInfo::HitEffectID' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, HitEffectParticlePath) == 0x000040, "Member 'FBulletEnchantInfo::HitEffectParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bHitEffectAttach) == 0x000058, "Member 'FBulletEnchantInfo::bHitEffectAttach' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bHitEffectFollowBulletRotation) == 0x000059, "Member 'FBulletEnchantInfo::bHitEffectFollowBulletRotation' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bHitEffectComposite) == 0x00005A, "Member 'FBulletEnchantInfo::bHitEffectComposite' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, MaxParticleCount) == 0x00005C, "Member 'FBulletEnchantInfo::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, FreeTime) == 0x000060, "Member 'FBulletEnchantInfo::FreeTime' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, TailBeamParticlePath) == 0x000068, "Member 'FBulletEnchantInfo::TailBeamParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, TailBeamParticleParamName) == 0x000080, "Member 'FBulletEnchantInfo::TailBeamParticleParamName' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, TailBeamParticleParam) == 0x000088, "Member 'FBulletEnchantInfo::TailBeamParticleParam' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, TailParticlePath) == 0x000090, "Member 'FBulletEnchantInfo::TailParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bUseCompositeBulletFireEffect) == 0x0000A8, "Member 'FBulletEnchantInfo::bUseCompositeBulletFireEffect' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, BulletFireEffectSpeed) == 0x0000AC, "Member 'FBulletEnchantInfo::BulletFireEffectSpeed' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, BulletFireEffect) == 0x0000B0, "Member 'FBulletEnchantInfo::BulletFireEffect' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bBulletFireEffectAttachWeapon) == 0x0000C8, "Member 'FBulletEnchantInfo::bBulletFireEffectAttachWeapon' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, FlyingSoundEvent) == 0x0000D0, "Member 'FBulletEnchantInfo::FlyingSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, LifeEndEffectParticlePath) == 0x0000E0, "Member 'FBulletEnchantInfo::LifeEndEffectParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bUseCompositeBulletRayPath) == 0x0000F8, "Member 'FBulletEnchantInfo::bUseCompositeBulletRayPath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, BulletRayPath) == 0x000100, "Member 'FBulletEnchantInfo::BulletRayPath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, BulletRayParamName) == 0x000118, "Member 'FBulletEnchantInfo::BulletRayParamName' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, BulletRayParam) == 0x000120, "Member 'FBulletEnchantInfo::BulletRayParam' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, StopFireParticlePath) == 0x000128, "Member 'FBulletEnchantInfo::StopFireParticlePath' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bReplaceEffect) == 0x000140, "Member 'FBulletEnchantInfo::bReplaceEffect' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, FireSoundEvent) == 0x000148, "Member 'FBulletEnchantInfo::FireSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bSilencerFireSound) == 0x000158, "Member 'FBulletEnchantInfo::bSilencerFireSound' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, SilencerFireSoundEvent) == 0x000160, "Member 'FBulletEnchantInfo::SilencerFireSoundEvent' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, bReplaceSound) == 0x000170, "Member 'FBulletEnchantInfo::bReplaceSound' has a wrong offset!");
static_assert(offsetof(FBulletEnchantInfo, EnchantLauncher) == 0x000174, "Member 'FBulletEnchantInfo::EnchantLauncher' has a wrong offset!");

// ScriptStruct Game.CustomHipPhyDataSection
// 0x0002 (0x0002 - 0x0000)
struct FCustomHipPhyDataSection final
{
public:
	EUIWidgetAnimType                             WidgetAnimType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomPhysicsType                            CustomHipType;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomHipPhyDataSection) == 0x000001, "Wrong alignment on FCustomHipPhyDataSection");
static_assert(sizeof(FCustomHipPhyDataSection) == 0x000002, "Wrong size on FCustomHipPhyDataSection");
static_assert(offsetof(FCustomHipPhyDataSection, WidgetAnimType) == 0x000000, "Member 'FCustomHipPhyDataSection::WidgetAnimType' has a wrong offset!");
static_assert(offsetof(FCustomHipPhyDataSection, CustomHipType) == 0x000001, "Member 'FCustomHipPhyDataSection::CustomHipType' has a wrong offset!");

// ScriptStruct Game.WeaponPartsTemplate
// 0x0120 (0x0128 - 0x0008)
struct FWeaponPartsTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewModel;                                      // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsChildren : 1;                                   // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponPartsName;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketStart;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketEnd;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketOffsetPer;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            SpecialSocketOffsetPer;                            // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CrossHairUIWidget;                                 // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AimCrossHairUIWidget;                              // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 SubBlueprint;                                      // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 SubPreviewModel;                                   // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SubAttachSocketStart;                              // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsSilencer;                                       // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponPartsTemplate) == 0x000008, "Wrong alignment on FWeaponPartsTemplate");
static_assert(sizeof(FWeaponPartsTemplate) == 0x000128, "Wrong size on FWeaponPartsTemplate");
static_assert(offsetof(FWeaponPartsTemplate, ID) == 0x000008, "Member 'FWeaponPartsTemplate::ID' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, Blueprint) == 0x000010, "Member 'FWeaponPartsTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, PreviewModel) == 0x000028, "Member 'FWeaponPartsTemplate::PreviewModel' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, WeaponPartsName) == 0x000048, "Member 'FWeaponPartsTemplate::WeaponPartsName' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, AttachSocketStart) == 0x000058, "Member 'FWeaponPartsTemplate::AttachSocketStart' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, AttachSocketEnd) == 0x000060, "Member 'FWeaponPartsTemplate::AttachSocketEnd' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, SocketOffsetPer) == 0x000068, "Member 'FWeaponPartsTemplate::SocketOffsetPer' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, SpecialSocketOffsetPer) == 0x000070, "Member 'FWeaponPartsTemplate::SpecialSocketOffsetPer' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, CrossHairUIWidget) == 0x0000C0, "Member 'FWeaponPartsTemplate::CrossHairUIWidget' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, AimCrossHairUIWidget) == 0x0000D8, "Member 'FWeaponPartsTemplate::AimCrossHairUIWidget' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, SubBlueprint) == 0x0000F0, "Member 'FWeaponPartsTemplate::SubBlueprint' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, SubPreviewModel) == 0x000100, "Member 'FWeaponPartsTemplate::SubPreviewModel' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, SubAttachSocketStart) == 0x000110, "Member 'FWeaponPartsTemplate::SubAttachSocketStart' has a wrong offset!");
static_assert(offsetof(FWeaponPartsTemplate, bIsSilencer) == 0x000120, "Member 'FWeaponPartsTemplate::bIsSilencer' has a wrong offset!");

// ScriptStruct Game.SpawnNpcContextData
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FSpawnNpcContextData final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnNpcContextData) == 0x000004, "Wrong alignment on FSpawnNpcContextData");
static_assert(sizeof(FSpawnNpcContextData) == 0x00006C, "Wrong size on FSpawnNpcContextData");

// ScriptStruct Game.RayMultiHitInfo
// 0x0010 (0x0010 - 0x0000)
struct FRayMultiHitInfo final
{
public:
	TArray<struct FHitResult>                     MultiHitResult;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRayMultiHitInfo) == 0x000008, "Wrong alignment on FRayMultiHitInfo");
static_assert(sizeof(FRayMultiHitInfo) == 0x000010, "Wrong size on FRayMultiHitInfo");
static_assert(offsetof(FRayMultiHitInfo, MultiHitResult) == 0x000000, "Member 'FRayMultiHitInfo::MultiHitResult' has a wrong offset!");

// ScriptStruct Game.DropClipRule
// 0x0003 (0x0003 - 0x0000)
struct FDropClipRule final
{
public:
	EFightType                                    FightType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropClipRule) == 0x000001, "Wrong alignment on FDropClipRule");
static_assert(sizeof(FDropClipRule) == 0x000003, "Wrong size on FDropClipRule");
static_assert(offsetof(FDropClipRule, FightType) == 0x000000, "Member 'FDropClipRule::FightType' has a wrong offset!");
static_assert(offsetof(FDropClipRule, WeaponType) == 0x000001, "Member 'FDropClipRule::WeaponType' has a wrong offset!");
static_assert(offsetof(FDropClipRule, bImmediately) == 0x000002, "Member 'FDropClipRule::bImmediately' has a wrong offset!");

// ScriptStruct Game.PatrolNpcSpawnerConfig
// 0x0008 (0x0040 - 0x0038)
struct FPatrolNpcSpawnerConfig final : public FSpawnerConfig
{
public:
	int32                                         Index;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AIEvent;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolNpcSpawnerConfig) == 0x000008, "Wrong alignment on FPatrolNpcSpawnerConfig");
static_assert(sizeof(FPatrolNpcSpawnerConfig) == 0x000040, "Wrong size on FPatrolNpcSpawnerConfig");
static_assert(offsetof(FPatrolNpcSpawnerConfig, Index) == 0x000038, "Member 'FPatrolNpcSpawnerConfig::Index' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnerConfig, AIEvent) == 0x00003C, "Member 'FPatrolNpcSpawnerConfig::AIEvent' has a wrong offset!");

// ScriptStruct Game.BulletModifierSpecialEffects
// 0x0018 (0x0018 - 0x0000)
struct FBulletModifierSpecialEffects final
{
public:
	int32                                         FireTimeId;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireBulletCount;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UModifierSpecialEffectObject*>   ModifierSpecialEffects;                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletModifierSpecialEffects) == 0x000008, "Wrong alignment on FBulletModifierSpecialEffects");
static_assert(sizeof(FBulletModifierSpecialEffects) == 0x000018, "Wrong size on FBulletModifierSpecialEffects");
static_assert(offsetof(FBulletModifierSpecialEffects, FireTimeId) == 0x000000, "Member 'FBulletModifierSpecialEffects::FireTimeId' has a wrong offset!");
static_assert(offsetof(FBulletModifierSpecialEffects, FireBulletCount) == 0x000004, "Member 'FBulletModifierSpecialEffects::FireBulletCount' has a wrong offset!");
static_assert(offsetof(FBulletModifierSpecialEffects, ModifierSpecialEffects) == 0x000008, "Member 'FBulletModifierSpecialEffects::ModifierSpecialEffects' has a wrong offset!");

// ScriptStruct Game.WeaponReloadDelayInfo
// 0x000C (0x000C - 0x0000)
struct FWeaponReloadDelayInfo final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoReloadDelayTime;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDelayTimeFactor;                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponReloadDelayInfo) == 0x000004, "Wrong alignment on FWeaponReloadDelayInfo");
static_assert(sizeof(FWeaponReloadDelayInfo) == 0x00000C, "Wrong size on FWeaponReloadDelayInfo");
static_assert(offsetof(FWeaponReloadDelayInfo, WeaponType) == 0x000000, "Member 'FWeaponReloadDelayInfo::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponReloadDelayInfo, AutoReloadDelayTime) == 0x000004, "Member 'FWeaponReloadDelayInfo::AutoReloadDelayTime' has a wrong offset!");
static_assert(offsetof(FWeaponReloadDelayInfo, ReloadDelayTimeFactor) == 0x000008, "Member 'FWeaponReloadDelayInfo::ReloadDelayTimeFactor' has a wrong offset!");

// ScriptStruct Game.ActiveSpawnersTowerTemplate
// 0x0000 (0x0088 - 0x0088)
struct FActiveSpawnersTowerTemplate final : public FActiveSpawnersTemplate
{
};
static_assert(alignof(FActiveSpawnersTowerTemplate) == 0x000008, "Wrong alignment on FActiveSpawnersTowerTemplate");
static_assert(sizeof(FActiveSpawnersTowerTemplate) == 0x000088, "Wrong size on FActiveSpawnersTowerTemplate");

// ScriptStruct Game.WeaponScatterSigma
// 0x000C (0x000C - 0x0000)
struct FWeaponScatterSigma final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScatterSigma;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatterRange;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponScatterSigma) == 0x000004, "Wrong alignment on FWeaponScatterSigma");
static_assert(sizeof(FWeaponScatterSigma) == 0x00000C, "Wrong size on FWeaponScatterSigma");
static_assert(offsetof(FWeaponScatterSigma, WeaponType) == 0x000000, "Member 'FWeaponScatterSigma::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponScatterSigma, ScatterSigma) == 0x000004, "Member 'FWeaponScatterSigma::ScatterSigma' has a wrong offset!");
static_assert(offsetof(FWeaponScatterSigma, ScatterRange) == 0x000008, "Member 'FWeaponScatterSigma::ScatterRange' has a wrong offset!");

// ScriptStruct Game.OnHitModifierEffect
// 0x0001 (0x0001 - 0x0000)
struct FOnHitModifierEffect final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnHitModifierEffect) == 0x000001, "Wrong alignment on FOnHitModifierEffect");
static_assert(sizeof(FOnHitModifierEffect) == 0x000001, "Wrong size on FOnHitModifierEffect");

// ScriptStruct Game.WeaponGrowTemplate
// 0x00B0 (0x00B8 - 0x0008)
struct FWeaponGrowTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletType;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyHPType                                 DamageType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Attack;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageCoefficient;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageCoefficient_Bomb;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireSpeed;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireBaseSpeed;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireInterval;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireBaseInterval;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstBulletCount;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireStorage;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletNum;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletCost;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletLaunchCount;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadSpeedRatio;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreFire;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingDamage;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMaxDistance;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRangeUltimateLimit;                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRangeStartAttenuation;                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalCritDamageInAimState;                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalCritPercentInAimState;                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagValue;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagValue_Bomb;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamageScaler;                                // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CriticalValue;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamage;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyValue;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyValue_Bomb;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElemExplosionValue;                                // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEnergy;                                         // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalHitEnergy;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEnergy_Bomb;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceCoefficient;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BounceModifierID;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMulti;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stability;                                         // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalStability;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accuracy;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalAccuracy;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPer;                                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreathShaking;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponGrowTemplate) == 0x000008, "Wrong alignment on FWeaponGrowTemplate");
static_assert(sizeof(FWeaponGrowTemplate) == 0x0000B8, "Wrong size on FWeaponGrowTemplate");
static_assert(offsetof(FWeaponGrowTemplate, ID) == 0x000008, "Member 'FWeaponGrowTemplate::ID' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BulletType) == 0x00000C, "Member 'FWeaponGrowTemplate::BulletType' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DamageType) == 0x000010, "Member 'FWeaponGrowTemplate::DamageType' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, Attack) == 0x000014, "Member 'FWeaponGrowTemplate::Attack' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DamageCoefficient) == 0x000018, "Member 'FWeaponGrowTemplate::DamageCoefficient' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DamageCoefficient_Bomb) == 0x00001C, "Member 'FWeaponGrowTemplate::DamageCoefficient_Bomb' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FireSpeed) == 0x000020, "Member 'FWeaponGrowTemplate::FireSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FireBaseSpeed) == 0x000024, "Member 'FWeaponGrowTemplate::FireBaseSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FireInterval) == 0x000028, "Member 'FWeaponGrowTemplate::FireInterval' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FireBaseInterval) == 0x00002C, "Member 'FWeaponGrowTemplate::FireBaseInterval' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BurstBulletCount) == 0x000030, "Member 'FWeaponGrowTemplate::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FireStorage) == 0x000034, "Member 'FWeaponGrowTemplate::FireStorage' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BulletNum) == 0x000038, "Member 'FWeaponGrowTemplate::BulletNum' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BulletCost) == 0x00003C, "Member 'FWeaponGrowTemplate::BulletCost' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BulletLaunchCount) == 0x000040, "Member 'FWeaponGrowTemplate::BulletLaunchCount' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, ReloadSpeedRatio) == 0x000044, "Member 'FWeaponGrowTemplate::ReloadSpeedRatio' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, PreFire) == 0x000048, "Member 'FWeaponGrowTemplate::PreFire' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, StartingDamage) == 0x00004C, "Member 'FWeaponGrowTemplate::StartingDamage' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DamageMaxDistance) == 0x000050, "Member 'FWeaponGrowTemplate::DamageMaxDistance' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FiringRangeUltimateLimit) == 0x000054, "Member 'FWeaponGrowTemplate::FiringRangeUltimateLimit' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, FiringRangeStartAttenuation) == 0x000058, "Member 'FWeaponGrowTemplate::FiringRangeStartAttenuation' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, AdditionalCritDamageInAimState) == 0x00005C, "Member 'FWeaponGrowTemplate::AdditionalCritDamageInAimState' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, AdditionalCritPercentInAimState) == 0x000060, "Member 'FWeaponGrowTemplate::AdditionalCritPercentInAimState' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, HitLagValue) == 0x000064, "Member 'FWeaponGrowTemplate::HitLagValue' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, HitLagValue_Bomb) == 0x000068, "Member 'FWeaponGrowTemplate::HitLagValue_Bomb' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, ShieldDamageScaler) == 0x00006C, "Member 'FWeaponGrowTemplate::ShieldDamageScaler' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, CriticalValue) == 0x000070, "Member 'FWeaponGrowTemplate::CriticalValue' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, CriticalDamage) == 0x000074, "Member 'FWeaponGrowTemplate::CriticalDamage' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DestroyValue) == 0x000078, "Member 'FWeaponGrowTemplate::DestroyValue' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, DestroyValue_Bomb) == 0x00007C, "Member 'FWeaponGrowTemplate::DestroyValue_Bomb' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, ElemExplosionValue) == 0x000080, "Member 'FWeaponGrowTemplate::ElemExplosionValue' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, HitEnergy) == 0x000084, "Member 'FWeaponGrowTemplate::HitEnergy' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, CriticalHitEnergy) == 0x000088, "Member 'FWeaponGrowTemplate::CriticalHitEnergy' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, HitEnergy_Bomb) == 0x00008C, "Member 'FWeaponGrowTemplate::HitEnergy_Bomb' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BounceCoefficient) == 0x000090, "Member 'FWeaponGrowTemplate::BounceCoefficient' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BounceModifierID) == 0x000094, "Member 'FWeaponGrowTemplate::BounceModifierID' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, ShieldMulti) == 0x000098, "Member 'FWeaponGrowTemplate::ShieldMulti' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, Stability) == 0x00009C, "Member 'FWeaponGrowTemplate::Stability' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, AdditionalStability) == 0x0000A0, "Member 'FWeaponGrowTemplate::AdditionalStability' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, Accuracy) == 0x0000A4, "Member 'FWeaponGrowTemplate::Accuracy' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, AdditionalAccuracy) == 0x0000A8, "Member 'FWeaponGrowTemplate::AdditionalAccuracy' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, CameraPer) == 0x0000AC, "Member 'FWeaponGrowTemplate::CameraPer' has a wrong offset!");
static_assert(offsetof(FWeaponGrowTemplate, BreathShaking) == 0x0000B0, "Member 'FWeaponGrowTemplate::BreathShaking' has a wrong offset!");

// ScriptStruct Game.NiagaraCompositeEffectParentInfo
// 0x0040 (0x0040 - 0x0000)
struct FNiagaraCompositeEffectParentInfo final
{
public:
	class UPrimitiveComponent*                    ParentComp;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNiagaraCompositeEffectParentInfo) == 0x000010, "Wrong alignment on FNiagaraCompositeEffectParentInfo");
static_assert(sizeof(FNiagaraCompositeEffectParentInfo) == 0x000040, "Wrong size on FNiagaraCompositeEffectParentInfo");
static_assert(offsetof(FNiagaraCompositeEffectParentInfo, ParentComp) == 0x000000, "Member 'FNiagaraCompositeEffectParentInfo::ParentComp' has a wrong offset!");
static_assert(offsetof(FNiagaraCompositeEffectParentInfo, Socket) == 0x000008, "Member 'FNiagaraCompositeEffectParentInfo::Socket' has a wrong offset!");
static_assert(offsetof(FNiagaraCompositeEffectParentInfo, Offset) == 0x000010, "Member 'FNiagaraCompositeEffectParentInfo::Offset' has a wrong offset!");

// ScriptStruct Game.NiagaraCompositeEffectInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FNiagaraCompositeEffectInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FNiagaraCompositeEffectParentInfo> Parent;                                            // 0x0010(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x60];                                      // 0x0060(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNiagaraCompositeEffectInfo) == 0x000008, "Wrong alignment on FNiagaraCompositeEffectInfo");
static_assert(sizeof(FNiagaraCompositeEffectInfo) == 0x0000C0, "Wrong size on FNiagaraCompositeEffectInfo");
static_assert(offsetof(FNiagaraCompositeEffectInfo, Parent) == 0x000010, "Member 'FNiagaraCompositeEffectInfo::Parent' has a wrong offset!");

// ScriptStruct Game.TrapCompositeEffectInfo
// 0x0060 (0x0060 - 0x0000)
struct FTrapCompositeEffectInfo final
{
public:
	class FName                                   NiagaraName;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CasterName;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FNiagaraCompositeEffectInfo> CompositeEffectInfos;                              // 0x0010(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrapCompositeEffectInfo) == 0x000008, "Wrong alignment on FTrapCompositeEffectInfo");
static_assert(sizeof(FTrapCompositeEffectInfo) == 0x000060, "Wrong size on FTrapCompositeEffectInfo");
static_assert(offsetof(FTrapCompositeEffectInfo, NiagaraName) == 0x000000, "Member 'FTrapCompositeEffectInfo::NiagaraName' has a wrong offset!");
static_assert(offsetof(FTrapCompositeEffectInfo, CasterName) == 0x000008, "Member 'FTrapCompositeEffectInfo::CasterName' has a wrong offset!");
static_assert(offsetof(FTrapCompositeEffectInfo, CompositeEffectInfos) == 0x000010, "Member 'FTrapCompositeEffectInfo::CompositeEffectInfos' has a wrong offset!");

// ScriptStruct Game.Recoil
// 0x0030 (0x0030 - 0x0000)
struct FRecoil final
{
public:
	ERecoilState                                  RecoilState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Shake;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastBulletCount;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShootBulletCount;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilForcePitchRateRecoverTime;                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecoil) == 0x000010, "Wrong alignment on FRecoil");
static_assert(sizeof(FRecoil) == 0x000030, "Wrong size on FRecoil");
static_assert(offsetof(FRecoil, RecoilState) == 0x000000, "Member 'FRecoil::RecoilState' has a wrong offset!");
static_assert(offsetof(FRecoil, Shake) == 0x000010, "Member 'FRecoil::Shake' has a wrong offset!");
static_assert(offsetof(FRecoil, LastBulletCount) == 0x000020, "Member 'FRecoil::LastBulletCount' has a wrong offset!");
static_assert(offsetof(FRecoil, ShootBulletCount) == 0x000024, "Member 'FRecoil::ShootBulletCount' has a wrong offset!");
static_assert(offsetof(FRecoil, RecoilForcePitchRateRecoverTime) == 0x000028, "Member 'FRecoil::RecoilForcePitchRateRecoverTime' has a wrong offset!");

// ScriptStruct Game.ChannelBlockInfo
// 0x0050 (0x0050 - 0x0000)
struct FChannelBlockInfo final
{
public:
	class FString                                 BlockActorName;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlockComponentName;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlockChannelName;                                  // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQueryResultString                     BlockResult;                                       // 0x0030(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FChannelBlockInfo) == 0x000008, "Wrong alignment on FChannelBlockInfo");
static_assert(sizeof(FChannelBlockInfo) == 0x000050, "Wrong size on FChannelBlockInfo");
static_assert(offsetof(FChannelBlockInfo, BlockActorName) == 0x000000, "Member 'FChannelBlockInfo::BlockActorName' has a wrong offset!");
static_assert(offsetof(FChannelBlockInfo, BlockComponentName) == 0x000010, "Member 'FChannelBlockInfo::BlockComponentName' has a wrong offset!");
static_assert(offsetof(FChannelBlockInfo, BlockChannelName) == 0x000020, "Member 'FChannelBlockInfo::BlockChannelName' has a wrong offset!");
static_assert(offsetof(FChannelBlockInfo, BlockResult) == 0x000030, "Member 'FChannelBlockInfo::BlockResult' has a wrong offset!");

// ScriptStruct Game.SortTypeExcuInfo
// 0x0078 (0x0078 - 0x0000)
struct FSortTypeExcuInfo final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SortOwnerName;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EQueryTargetType>                      TargetTypes;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             RequireModifierError;                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             BlockModifierError;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             SearcherFilterError;                               // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FChannelBlockInfo>              BlockInfo;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             FinalResults;                                      // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSortTypeExcuInfo) == 0x000008, "Wrong alignment on FSortTypeExcuInfo");
static_assert(sizeof(FSortTypeExcuInfo) == 0x000078, "Wrong size on FSortTypeExcuInfo");
static_assert(offsetof(FSortTypeExcuInfo, ActiveTime) == 0x000000, "Member 'FSortTypeExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, EmitterID) == 0x000004, "Member 'FSortTypeExcuInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, SortOwnerName) == 0x000008, "Member 'FSortTypeExcuInfo::SortOwnerName' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, TargetTypes) == 0x000018, "Member 'FSortTypeExcuInfo::TargetTypes' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, RequireModifierError) == 0x000028, "Member 'FSortTypeExcuInfo::RequireModifierError' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, BlockModifierError) == 0x000038, "Member 'FSortTypeExcuInfo::BlockModifierError' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, SearcherFilterError) == 0x000048, "Member 'FSortTypeExcuInfo::SearcherFilterError' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, BlockInfo) == 0x000058, "Member 'FSortTypeExcuInfo::BlockInfo' has a wrong offset!");
static_assert(offsetof(FSortTypeExcuInfo, FinalResults) == 0x000068, "Member 'FSortTypeExcuInfo::FinalResults' has a wrong offset!");

// ScriptStruct Game.TargetScoreTextInfo
// 0x0018 (0x0020 - 0x0008)
struct FTargetScoreTextInfo final : public FTableRowBase
{
public:
	int32                                         MinScore;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScore;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetScoreTextInfo) == 0x000008, "Wrong alignment on FTargetScoreTextInfo");
static_assert(sizeof(FTargetScoreTextInfo) == 0x000020, "Wrong size on FTargetScoreTextInfo");
static_assert(offsetof(FTargetScoreTextInfo, MinScore) == 0x000008, "Member 'FTargetScoreTextInfo::MinScore' has a wrong offset!");
static_assert(offsetof(FTargetScoreTextInfo, MaxScore) == 0x00000C, "Member 'FTargetScoreTextInfo::MaxScore' has a wrong offset!");
static_assert(offsetof(FTargetScoreTextInfo, TextKey) == 0x000010, "Member 'FTargetScoreTextInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.ContactModifyInParam
// 0x0088 (0x0088 - 0x0000)
struct FContactModifyInParam final
{
public:
	class UPhysicalMaterial*                      SelfMaterial;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      OtherMaterial;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor0;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor1;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Restitution;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicFriction;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticFriction;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0038(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardDir;                                        // 0x0044(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LandingWheelNum;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasValidSplineInfo;                                // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredMoveDir;                                    // 0x0058(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosedSplinePos;                                   // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPosOnSpline;                                   // 0x0070(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableModifyNormal;                                // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CarSpeed;                                          // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCollisionEventId;                            // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContactModifyInParam) == 0x000008, "Wrong alignment on FContactModifyInParam");
static_assert(sizeof(FContactModifyInParam) == 0x000088, "Wrong size on FContactModifyInParam");
static_assert(offsetof(FContactModifyInParam, SelfMaterial) == 0x000000, "Member 'FContactModifyInParam::SelfMaterial' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, OtherMaterial) == 0x000008, "Member 'FContactModifyInParam::OtherMaterial' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, Actor0) == 0x000010, "Member 'FContactModifyInParam::Actor0' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, Actor1) == 0x000018, "Member 'FContactModifyInParam::Actor1' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, Normal) == 0x000020, "Member 'FContactModifyInParam::Normal' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, Restitution) == 0x00002C, "Member 'FContactModifyInParam::Restitution' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, DynamicFriction) == 0x000030, "Member 'FContactModifyInParam::DynamicFriction' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, StaticFriction) == 0x000034, "Member 'FContactModifyInParam::StaticFriction' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, Location) == 0x000038, "Member 'FContactModifyInParam::Location' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, ForwardDir) == 0x000044, "Member 'FContactModifyInParam::ForwardDir' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, LandingWheelNum) == 0x000050, "Member 'FContactModifyInParam::LandingWheelNum' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, HasValidSplineInfo) == 0x000054, "Member 'FContactModifyInParam::HasValidSplineInfo' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, DesiredMoveDir) == 0x000058, "Member 'FContactModifyInParam::DesiredMoveDir' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, ClosedSplinePos) == 0x000064, "Member 'FContactModifyInParam::ClosedSplinePos' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, NextPosOnSpline) == 0x000070, "Member 'FContactModifyInParam::NextPosOnSpline' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, EnableModifyNormal) == 0x00007C, "Member 'FContactModifyInParam::EnableModifyNormal' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, CarSpeed) == 0x000080, "Member 'FContactModifyInParam::CarSpeed' has a wrong offset!");
static_assert(offsetof(FContactModifyInParam, TargetCollisionEventId) == 0x000084, "Member 'FContactModifyInParam::TargetCollisionEventId' has a wrong offset!");

// ScriptStruct Game.PalSecretBlocks
// 0x0018 (0x0018 - 0x0000)
struct FPalSecretBlocks final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPalSecretBlocks) == 0x000008, "Wrong alignment on FPalSecretBlocks");
static_assert(sizeof(FPalSecretBlocks) == 0x000018, "Wrong size on FPalSecretBlocks");
static_assert(offsetof(FPalSecretBlocks, State) == 0x000000, "Member 'FPalSecretBlocks::State' has a wrong offset!");
static_assert(offsetof(FPalSecretBlocks, Tags) == 0x000008, "Member 'FPalSecretBlocks::Tags' has a wrong offset!");

// ScriptStruct Game.GamepadCustomWidgetDefine
// 0x0010 (0x0010 - 0x0000)
struct FGamepadCustomWidgetDefine final
{
public:
	TArray<class FName>                           CustomWidgets;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadCustomWidgetDefine) == 0x000008, "Wrong alignment on FGamepadCustomWidgetDefine");
static_assert(sizeof(FGamepadCustomWidgetDefine) == 0x000010, "Wrong size on FGamepadCustomWidgetDefine");
static_assert(offsetof(FGamepadCustomWidgetDefine, CustomWidgets) == 0x000000, "Member 'FGamepadCustomWidgetDefine::CustomWidgets' has a wrong offset!");

// ScriptStruct Game.BaseSkillInfo
// 0x0088 (0x0090 - 0x0008)
struct FBaseSkillInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDBaseSkillType                        Type;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillName;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EffectDesc;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDResourceType                         CostType;                                          // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CostNum;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierID;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ApplyTag;                                          // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreLevelId;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconResId;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBaseSkillOpCode                              OpCode;                                            // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param;                                             // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param2;                                            // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediate;                                         // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDDuty                                 DutyType;                                          // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuyCount;                                          // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPersonal;                                        // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRespawnTeam;                                     // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseSkillInfo) == 0x000008, "Wrong alignment on FBaseSkillInfo");
static_assert(sizeof(FBaseSkillInfo) == 0x000090, "Wrong size on FBaseSkillInfo");
static_assert(offsetof(FBaseSkillInfo, ID) == 0x000008, "Member 'FBaseSkillInfo::ID' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Type) == 0x00000C, "Member 'FBaseSkillInfo::Type' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Level) == 0x000010, "Member 'FBaseSkillInfo::Level' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, SkillName) == 0x000018, "Member 'FBaseSkillInfo::SkillName' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Desc) == 0x000028, "Member 'FBaseSkillInfo::Desc' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, EffectDesc) == 0x000038, "Member 'FBaseSkillInfo::EffectDesc' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Quality) == 0x000048, "Member 'FBaseSkillInfo::Quality' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Active) == 0x00004C, "Member 'FBaseSkillInfo::Active' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, CostType) == 0x00004D, "Member 'FBaseSkillInfo::CostType' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, CostNum) == 0x000050, "Member 'FBaseSkillInfo::CostNum' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, ModifierID) == 0x000054, "Member 'FBaseSkillInfo::ModifierID' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, SkillID) == 0x000058, "Member 'FBaseSkillInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, ApplyTag) == 0x000060, "Member 'FBaseSkillInfo::ApplyTag' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, PreLevelId) == 0x000070, "Member 'FBaseSkillInfo::PreLevelId' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, IconResId) == 0x000074, "Member 'FBaseSkillInfo::IconResId' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, OpCode) == 0x000078, "Member 'FBaseSkillInfo::OpCode' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Param) == 0x00007C, "Member 'FBaseSkillInfo::Param' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Param2) == 0x000080, "Member 'FBaseSkillInfo::Param2' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, Immediate) == 0x000084, "Member 'FBaseSkillInfo::Immediate' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, DutyType) == 0x000085, "Member 'FBaseSkillInfo::DutyType' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, BuyCount) == 0x000088, "Member 'FBaseSkillInfo::BuyCount' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, IsPersonal) == 0x00008C, "Member 'FBaseSkillInfo::IsPersonal' has a wrong offset!");
static_assert(offsetof(FBaseSkillInfo, IsRespawnTeam) == 0x00008D, "Member 'FBaseSkillInfo::IsRespawnTeam' has a wrong offset!");

// ScriptStruct Game.GamepadQuickKeyInfo
// 0x0048 (0x0048 - 0x0000)
struct FGamepadQuickKeyInfo
{
public:
	struct FKey                                   KeyboardKey;                                       // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   XBoxKey;                                           // 0x0018(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   PSKey;                                             // 0x0030(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadQuickKeyInfo) == 0x000008, "Wrong alignment on FGamepadQuickKeyInfo");
static_assert(sizeof(FGamepadQuickKeyInfo) == 0x000048, "Wrong size on FGamepadQuickKeyInfo");
static_assert(offsetof(FGamepadQuickKeyInfo, KeyboardKey) == 0x000000, "Member 'FGamepadQuickKeyInfo::KeyboardKey' has a wrong offset!");
static_assert(offsetof(FGamepadQuickKeyInfo, XBoxKey) == 0x000018, "Member 'FGamepadQuickKeyInfo::XBoxKey' has a wrong offset!");
static_assert(offsetof(FGamepadQuickKeyInfo, PSKey) == 0x000030, "Member 'FGamepadQuickKeyInfo::PSKey' has a wrong offset!");

// ScriptStruct Game.AnimMotionCustomData
// 0x0020 (0x0020 - 0x0000)
struct FAnimMotionCustomData final
{
public:
	class FString                                 Desc;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMotionCustomData) == 0x000008, "Wrong alignment on FAnimMotionCustomData");
static_assert(sizeof(FAnimMotionCustomData) == 0x000020, "Wrong size on FAnimMotionCustomData");
static_assert(offsetof(FAnimMotionCustomData, Desc) == 0x000000, "Member 'FAnimMotionCustomData::Desc' has a wrong offset!");
static_assert(offsetof(FAnimMotionCustomData, Velocity) == 0x000010, "Member 'FAnimMotionCustomData::Velocity' has a wrong offset!");
static_assert(offsetof(FAnimMotionCustomData, Acceleration) == 0x000014, "Member 'FAnimMotionCustomData::Acceleration' has a wrong offset!");
static_assert(offsetof(FAnimMotionCustomData, Yaw) == 0x000018, "Member 'FAnimMotionCustomData::Yaw' has a wrong offset!");

// ScriptStruct Game.VehicleNitrousSetup
// 0x0090 (0x0090 - 0x0000)
struct FVehicleNitrousSetup final
{
public:
	float                                         MaxEngineRPM;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxForwardSpeed;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AccelerationCurve;                                 // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleNitrousSetup) == 0x000008, "Wrong alignment on FVehicleNitrousSetup");
static_assert(sizeof(FVehicleNitrousSetup) == 0x000090, "Wrong size on FVehicleNitrousSetup");
static_assert(offsetof(FVehicleNitrousSetup, MaxEngineRPM) == 0x000000, "Member 'FVehicleNitrousSetup::MaxEngineRPM' has a wrong offset!");
static_assert(offsetof(FVehicleNitrousSetup, MaxForwardSpeed) == 0x000004, "Member 'FVehicleNitrousSetup::MaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(FVehicleNitrousSetup, AccelerationCurve) == 0x000008, "Member 'FVehicleNitrousSetup::AccelerationCurve' has a wrong offset!");

// ScriptStruct Game.KidRideDriftBoostInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FKidRideDriftBoostInfo final
{
public:
	struct FVector2D                              TimeRange;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKidRideEffectType                            EffectType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKidRideEffectType                            TriggerEffectType;                                 // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleNitrousSetup                   NirtrousSetup;                                     // 0x0010(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideDriftBoostInfo) == 0x000008, "Wrong alignment on FKidRideDriftBoostInfo");
static_assert(sizeof(FKidRideDriftBoostInfo) == 0x0000A0, "Wrong size on FKidRideDriftBoostInfo");
static_assert(offsetof(FKidRideDriftBoostInfo, TimeRange) == 0x000000, "Member 'FKidRideDriftBoostInfo::TimeRange' has a wrong offset!");
static_assert(offsetof(FKidRideDriftBoostInfo, EffectType) == 0x000008, "Member 'FKidRideDriftBoostInfo::EffectType' has a wrong offset!");
static_assert(offsetof(FKidRideDriftBoostInfo, TriggerEffectType) == 0x000009, "Member 'FKidRideDriftBoostInfo::TriggerEffectType' has a wrong offset!");
static_assert(offsetof(FKidRideDriftBoostInfo, NirtrousSetup) == 0x000010, "Member 'FKidRideDriftBoostInfo::NirtrousSetup' has a wrong offset!");

// ScriptStruct Game.KnapsackEnergyAttribute
// 0x0014 (0x0014 - 0x0000)
struct FKnapsackEnergyAttribute final
{
public:
	float                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicsValue;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddIntervalTime;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddValue;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKnapsackEnergyAttribute) == 0x000004, "Wrong alignment on FKnapsackEnergyAttribute");
static_assert(sizeof(FKnapsackEnergyAttribute) == 0x000014, "Wrong size on FKnapsackEnergyAttribute");
static_assert(offsetof(FKnapsackEnergyAttribute, MaxValue) == 0x000000, "Member 'FKnapsackEnergyAttribute::MaxValue' has a wrong offset!");
static_assert(offsetof(FKnapsackEnergyAttribute, BasicsValue) == 0x000004, "Member 'FKnapsackEnergyAttribute::BasicsValue' has a wrong offset!");
static_assert(offsetof(FKnapsackEnergyAttribute, InitValue) == 0x000008, "Member 'FKnapsackEnergyAttribute::InitValue' has a wrong offset!");
static_assert(offsetof(FKnapsackEnergyAttribute, AddIntervalTime) == 0x00000C, "Member 'FKnapsackEnergyAttribute::AddIntervalTime' has a wrong offset!");
static_assert(offsetof(FKnapsackEnergyAttribute, AddValue) == 0x000010, "Member 'FKnapsackEnergyAttribute::AddValue' has a wrong offset!");

// ScriptStruct Game.AccesoryInstanceInfo
// 0x0018 (0x0018 - 0x0000)
struct FAccesoryInstanceInfo final
{
public:
	class UAnimInstance*                          Instance;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterAccessory*                    Accessory;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DistanceMappingMontage;                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccesoryInstanceInfo) == 0x000008, "Wrong alignment on FAccesoryInstanceInfo");
static_assert(sizeof(FAccesoryInstanceInfo) == 0x000018, "Wrong size on FAccesoryInstanceInfo");
static_assert(offsetof(FAccesoryInstanceInfo, Instance) == 0x000000, "Member 'FAccesoryInstanceInfo::Instance' has a wrong offset!");
static_assert(offsetof(FAccesoryInstanceInfo, Accessory) == 0x000008, "Member 'FAccesoryInstanceInfo::Accessory' has a wrong offset!");
static_assert(offsetof(FAccesoryInstanceInfo, DistanceMappingMontage) == 0x000010, "Member 'FAccesoryInstanceInfo::DistanceMappingMontage' has a wrong offset!");

// ScriptStruct Game.GameLoadItem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameLoadItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameLoadItem) == 0x000008, "Wrong alignment on FGameLoadItem");
static_assert(sizeof(FGameLoadItem) == 0x000010, "Wrong size on FGameLoadItem");

// ScriptStruct Game.OwnerFireInfo
// 0x0028 (0x0028 - 0x0000)
struct FOwnerFireInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOwnerFireInfo) == 0x000008, "Wrong alignment on FOwnerFireInfo");
static_assert(sizeof(FOwnerFireInfo) == 0x000028, "Wrong size on FOwnerFireInfo");
static_assert(offsetof(FOwnerFireInfo, HitActor) == 0x000020, "Member 'FOwnerFireInfo::HitActor' has a wrong offset!");

// ScriptStruct Game.AbilityBufferAttributeRule
// 0x0010 (0x0010 - 0x0000)
struct FAbilityBufferAttributeRule
{
public:
	class UAbilityAttribute*                      AbilityAttribute;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityAttributeValue;                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityBufferAttributeRule) == 0x000008, "Wrong alignment on FAbilityBufferAttributeRule");
static_assert(sizeof(FAbilityBufferAttributeRule) == 0x000010, "Wrong size on FAbilityBufferAttributeRule");
static_assert(offsetof(FAbilityBufferAttributeRule, AbilityAttribute) == 0x000000, "Member 'FAbilityBufferAttributeRule::AbilityAttribute' has a wrong offset!");
static_assert(offsetof(FAbilityBufferAttributeRule, AbilityAttributeValue) == 0x000008, "Member 'FAbilityBufferAttributeRule::AbilityAttributeValue' has a wrong offset!");
static_assert(offsetof(FAbilityBufferAttributeRule, CurrentTime) == 0x00000C, "Member 'FAbilityBufferAttributeRule::CurrentTime' has a wrong offset!");

// ScriptStruct Game.AbilityBufferAttributeRuleLoop
// 0x0008 (0x0018 - 0x0010)
struct FAbilityBufferAttributeRuleLoop final : public FAbilityBufferAttributeRule
{
public:
	float                                         DelayTime;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityBufferAttributeRuleLoop) == 0x000008, "Wrong alignment on FAbilityBufferAttributeRuleLoop");
static_assert(sizeof(FAbilityBufferAttributeRuleLoop) == 0x000018, "Wrong size on FAbilityBufferAttributeRuleLoop");
static_assert(offsetof(FAbilityBufferAttributeRuleLoop, DelayTime) == 0x000010, "Member 'FAbilityBufferAttributeRuleLoop::DelayTime' has a wrong offset!");
static_assert(offsetof(FAbilityBufferAttributeRuleLoop, IntervalTime) == 0x000014, "Member 'FAbilityBufferAttributeRuleLoop::IntervalTime' has a wrong offset!");

// ScriptStruct Game.StepTriggerData
// 0x0160 (0x0160 - 0x0000)
struct FStepTriggerData final
{
public:
	class FName                                   FootBoneName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FootBoneName_Tip;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PhysicalGroupName;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoveStateGroupName;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterGroupName;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterFightGroupName;                           // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffGroundHeight;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnGroundHeight;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class FString>         PhysicalSetup;                                     // 0x0070(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, int32>                 HitEffectSetup;                                    // 0x00C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ESimpleMoveType, class FString>          MoveTypeSetup;                                     // 0x0110(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStepTriggerData) == 0x000008, "Wrong alignment on FStepTriggerData");
static_assert(sizeof(FStepTriggerData) == 0x000160, "Wrong size on FStepTriggerData");
static_assert(offsetof(FStepTriggerData, FootBoneName) == 0x000000, "Member 'FStepTriggerData::FootBoneName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, FootBoneName_Tip) == 0x000008, "Member 'FStepTriggerData::FootBoneName_Tip' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, EventName) == 0x000010, "Member 'FStepTriggerData::EventName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, PhysicalGroupName) == 0x000020, "Member 'FStepTriggerData::PhysicalGroupName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, MoveStateGroupName) == 0x000030, "Member 'FStepTriggerData::MoveStateGroupName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, CharacterGroupName) == 0x000040, "Member 'FStepTriggerData::CharacterGroupName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, CharacterFightGroupName) == 0x000050, "Member 'FStepTriggerData::CharacterFightGroupName' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, OffGroundHeight) == 0x000060, "Member 'FStepTriggerData::OffGroundHeight' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, OnGroundHeight) == 0x000064, "Member 'FStepTriggerData::OnGroundHeight' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, CapsuleRadius) == 0x000068, "Member 'FStepTriggerData::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, CapsuleHalfHeight) == 0x00006C, "Member 'FStepTriggerData::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, PhysicalSetup) == 0x000070, "Member 'FStepTriggerData::PhysicalSetup' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, HitEffectSetup) == 0x0000C0, "Member 'FStepTriggerData::HitEffectSetup' has a wrong offset!");
static_assert(offsetof(FStepTriggerData, MoveTypeSetup) == 0x000110, "Member 'FStepTriggerData::MoveTypeSetup' has a wrong offset!");

// ScriptStruct Game.AbnormalAnimStruct
// 0x0020 (0x0020 - 0x0000)
struct FAbnormalAnimStruct final
{
public:
	class UAnimSequenceBase*                      FrontRightMontage;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FrontLeftMontage;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      BackRightMontage;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      BackLeftMontage;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnormalAnimStruct) == 0x000008, "Wrong alignment on FAbnormalAnimStruct");
static_assert(sizeof(FAbnormalAnimStruct) == 0x000020, "Wrong size on FAbnormalAnimStruct");
static_assert(offsetof(FAbnormalAnimStruct, FrontRightMontage) == 0x000000, "Member 'FAbnormalAnimStruct::FrontRightMontage' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimStruct, FrontLeftMontage) == 0x000008, "Member 'FAbnormalAnimStruct::FrontLeftMontage' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimStruct, BackRightMontage) == 0x000010, "Member 'FAbnormalAnimStruct::BackRightMontage' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimStruct, BackLeftMontage) == 0x000018, "Member 'FAbnormalAnimStruct::BackLeftMontage' has a wrong offset!");

// ScriptStruct Game.AbnormalAnimList
// 0x0020 (0x0020 - 0x0000)
struct FAbnormalAnimList final
{
public:
	TArray<struct FAbnormalAnimStruct>            AbnormalAnimStruct;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbnormalAnimList) == 0x000008, "Wrong alignment on FAbnormalAnimList");
static_assert(sizeof(FAbnormalAnimList) == 0x000020, "Wrong size on FAbnormalAnimList");
static_assert(offsetof(FAbnormalAnimList, AbnormalAnimStruct) == 0x000000, "Member 'FAbnormalAnimList::AbnormalAnimStruct' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimList, BlendInTime) == 0x000010, "Member 'FAbnormalAnimList::BlendInTime' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimList, BlendOutTime) == 0x000014, "Member 'FAbnormalAnimList::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FAbnormalAnimList, Rate) == 0x000018, "Member 'FAbnormalAnimList::Rate' has a wrong offset!");

// ScriptStruct Game.DynamicRandomSetting
// 0x0018 (0x0018 - 0x0000)
struct FDynamicRandomSetting final
{
public:
	int32                                         BufferId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TemplateId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAbilityBufferRatio>            RandomSetting;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicRandomSetting) == 0x000008, "Wrong alignment on FDynamicRandomSetting");
static_assert(sizeof(FDynamicRandomSetting) == 0x000018, "Wrong size on FDynamicRandomSetting");
static_assert(offsetof(FDynamicRandomSetting, BufferId) == 0x000000, "Member 'FDynamicRandomSetting::BufferId' has a wrong offset!");
static_assert(offsetof(FDynamicRandomSetting, TemplateId) == 0x000004, "Member 'FDynamicRandomSetting::TemplateId' has a wrong offset!");
static_assert(offsetof(FDynamicRandomSetting, RandomSetting) == 0x000008, "Member 'FDynamicRandomSetting::RandomSetting' has a wrong offset!");

// ScriptStruct Game.AbilityBufferRandomSetting
// 0x00D8 (0x00D8 - 0x0000)
struct FAbilityBufferRandomSetting final
{
public:
	int32                                         FightId;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrategyId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAbilityBufferRatio>            StaticRandomSettinges;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDynamicRandomSetting>          DynamicRandomSettinges;                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityBufferRandomSetting) == 0x000008, "Wrong alignment on FAbilityBufferRandomSetting");
static_assert(sizeof(FAbilityBufferRandomSetting) == 0x0000D8, "Wrong size on FAbilityBufferRandomSetting");
static_assert(offsetof(FAbilityBufferRandomSetting, FightId) == 0x000000, "Member 'FAbilityBufferRandomSetting::FightId' has a wrong offset!");
static_assert(offsetof(FAbilityBufferRandomSetting, StrategyId) == 0x000004, "Member 'FAbilityBufferRandomSetting::StrategyId' has a wrong offset!");
static_assert(offsetof(FAbilityBufferRandomSetting, StaticRandomSettinges) == 0x000008, "Member 'FAbilityBufferRandomSetting::StaticRandomSettinges' has a wrong offset!");
static_assert(offsetof(FAbilityBufferRandomSetting, DynamicRandomSettinges) == 0x000018, "Member 'FAbilityBufferRandomSetting::DynamicRandomSettinges' has a wrong offset!");

// ScriptStruct Game.OnlineTDSkillData
// 0x0018 (0x0018 - 0x0000)
struct FOnlineTDSkillData final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDBaseSkillType                        Type;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxBuyCount;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurBuyCount;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyCost;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDSkillData) == 0x000004, "Wrong alignment on FOnlineTDSkillData");
static_assert(sizeof(FOnlineTDSkillData) == 0x000018, "Wrong size on FOnlineTDSkillData");
static_assert(offsetof(FOnlineTDSkillData, SkillID) == 0x000000, "Member 'FOnlineTDSkillData::SkillID' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillData, Type) == 0x000004, "Member 'FOnlineTDSkillData::Type' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillData, MaxBuyCount) == 0x000008, "Member 'FOnlineTDSkillData::MaxBuyCount' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillData, CurBuyCount) == 0x00000C, "Member 'FOnlineTDSkillData::CurBuyCount' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillData, BuyCost) == 0x000010, "Member 'FOnlineTDSkillData::BuyCost' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillData, TeamCount) == 0x000014, "Member 'FOnlineTDSkillData::TeamCount' has a wrong offset!");

// ScriptStruct Game.AIValueRange
// 0x0008 (0x0008 - 0x0000)
struct FAIValueRange final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIValueRange) == 0x000004, "Wrong alignment on FAIValueRange");
static_assert(sizeof(FAIValueRange) == 0x000008, "Wrong size on FAIValueRange");
static_assert(offsetof(FAIValueRange, Min) == 0x000000, "Member 'FAIValueRange::Min' has a wrong offset!");
static_assert(offsetof(FAIValueRange, Max) == 0x000004, "Member 'FAIValueRange::Max' has a wrong offset!");

// ScriptStruct Game.GameMeshRawData
// 0x0040 (0x0040 - 0x0000)
struct FGameMeshRawData final
{
public:
	TArray<struct FVector>                        Vertex;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                Index;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      UV;                                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         Color;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameMeshRawData) == 0x000008, "Wrong alignment on FGameMeshRawData");
static_assert(sizeof(FGameMeshRawData) == 0x000040, "Wrong size on FGameMeshRawData");
static_assert(offsetof(FGameMeshRawData, Vertex) == 0x000000, "Member 'FGameMeshRawData::Vertex' has a wrong offset!");
static_assert(offsetof(FGameMeshRawData, Index) == 0x000010, "Member 'FGameMeshRawData::Index' has a wrong offset!");
static_assert(offsetof(FGameMeshRawData, UV) == 0x000020, "Member 'FGameMeshRawData::UV' has a wrong offset!");
static_assert(offsetof(FGameMeshRawData, Color) == 0x000030, "Member 'FGameMeshRawData::Color' has a wrong offset!");

// ScriptStruct Game.AbilityBufferShop
// 0x0048 (0x0048 - 0x0000)
struct FAbilityBufferShop final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractiveMode;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferKind;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBrave;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RefreshTimes;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AbilityBufferes;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityBufferShop) == 0x000008, "Wrong alignment on FAbilityBufferShop");
static_assert(sizeof(FAbilityBufferShop) == 0x000048, "Wrong size on FAbilityBufferShop");
static_assert(offsetof(FAbilityBufferShop, ID) == 0x000000, "Member 'FAbilityBufferShop::ID' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, Name) == 0x000008, "Member 'FAbilityBufferShop::Name' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, Desc) == 0x000018, "Member 'FAbilityBufferShop::Desc' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, InteractiveMode) == 0x000028, "Member 'FAbilityBufferShop::InteractiveMode' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, BufferKind) == 0x00002C, "Member 'FAbilityBufferShop::BufferKind' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, IsBrave) == 0x000030, "Member 'FAbilityBufferShop::IsBrave' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, RefreshTimes) == 0x000034, "Member 'FAbilityBufferShop::RefreshTimes' has a wrong offset!");
static_assert(offsetof(FAbilityBufferShop, AbilityBufferes) == 0x000038, "Member 'FAbilityBufferShop::AbilityBufferes' has a wrong offset!");

// ScriptStruct Game.AICharacterInteractParam
// 0x0040 (0x0040 - 0x0000)
struct FAICharacterInteractParam final
{
public:
	class FName                                   MonTag;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcInteractType                              Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractParam;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InteractText;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Icon;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractAngle;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerInteractAngle;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxInteractDistance;                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICharacterInteractParam) == 0x000008, "Wrong alignment on FAICharacterInteractParam");
static_assert(sizeof(FAICharacterInteractParam) == 0x000040, "Wrong size on FAICharacterInteractParam");
static_assert(offsetof(FAICharacterInteractParam, MonTag) == 0x000000, "Member 'FAICharacterInteractParam::MonTag' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, Type) == 0x000008, "Member 'FAICharacterInteractParam::Type' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, InteractParam) == 0x000010, "Member 'FAICharacterInteractParam::InteractParam' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, InteractText) == 0x000020, "Member 'FAICharacterInteractParam::InteractText' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, Icon) == 0x000030, "Member 'FAICharacterInteractParam::Icon' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, InteractAngle) == 0x000034, "Member 'FAICharacterInteractParam::InteractAngle' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, PlayerInteractAngle) == 0x000038, "Member 'FAICharacterInteractParam::PlayerInteractAngle' has a wrong offset!");
static_assert(offsetof(FAICharacterInteractParam, MaxInteractDistance) == 0x00003C, "Member 'FAICharacterInteractParam::MaxInteractDistance' has a wrong offset!");

// ScriptStruct Game.AbilityBufferPrice
// 0x0080 (0x0080 - 0x0000)
struct FAbilityBufferPrice final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TemplateId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameAbilityBuffer>         AbilityBuffer;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferCount;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GDPL;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDynamic : 1;                                      // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuffParamPerCount;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraId;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Icon;                                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BuildTypeString;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityBufferPrice) == 0x000008, "Wrong alignment on FAbilityBufferPrice");
static_assert(sizeof(FAbilityBufferPrice) == 0x000080, "Wrong size on FAbilityBufferPrice");
static_assert(offsetof(FAbilityBufferPrice, ID) == 0x000000, "Member 'FAbilityBufferPrice::ID' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, TemplateId) == 0x000004, "Member 'FAbilityBufferPrice::TemplateId' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, AbilityBuffer) == 0x000008, "Member 'FAbilityBufferPrice::AbilityBuffer' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, BufferCount) == 0x000010, "Member 'FAbilityBufferPrice::BufferCount' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, GDPL) == 0x000018, "Member 'FAbilityBufferPrice::GDPL' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, Price) == 0x000028, "Member 'FAbilityBufferPrice::Price' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, Name) == 0x000030, "Member 'FAbilityBufferPrice::Name' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, Desc) == 0x000040, "Member 'FAbilityBufferPrice::Desc' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, BuffParamPerCount) == 0x000050, "Member 'FAbilityBufferPrice::BuffParamPerCount' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, ExtraId) == 0x000060, "Member 'FAbilityBufferPrice::ExtraId' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, Icon) == 0x000064, "Member 'FAbilityBufferPrice::Icon' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, Rarity) == 0x000068, "Member 'FAbilityBufferPrice::Rarity' has a wrong offset!");
static_assert(offsetof(FAbilityBufferPrice, BuildTypeString) == 0x000070, "Member 'FAbilityBufferPrice::BuildTypeString' has a wrong offset!");

// ScriptStruct Game.CustomSpawnParam
// 0x01E0 (0x01E0 - 0x0000)
struct FCustomSpawnParam final
{
public:
	TMap<class FString, int32>                    IntData;                                           // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FloatData;                                         // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     BoolData;                                          // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector>           VectorData;                                        // 0x00F0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StringData;                                        // 0x0140(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FTransform>        TransData;                                         // 0x0190(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSpawnParam) == 0x000008, "Wrong alignment on FCustomSpawnParam");
static_assert(sizeof(FCustomSpawnParam) == 0x0001E0, "Wrong size on FCustomSpawnParam");
static_assert(offsetof(FCustomSpawnParam, IntData) == 0x000000, "Member 'FCustomSpawnParam::IntData' has a wrong offset!");
static_assert(offsetof(FCustomSpawnParam, FloatData) == 0x000050, "Member 'FCustomSpawnParam::FloatData' has a wrong offset!");
static_assert(offsetof(FCustomSpawnParam, BoolData) == 0x0000A0, "Member 'FCustomSpawnParam::BoolData' has a wrong offset!");
static_assert(offsetof(FCustomSpawnParam, VectorData) == 0x0000F0, "Member 'FCustomSpawnParam::VectorData' has a wrong offset!");
static_assert(offsetof(FCustomSpawnParam, StringData) == 0x000140, "Member 'FCustomSpawnParam::StringData' has a wrong offset!");
static_assert(offsetof(FCustomSpawnParam, TransData) == 0x000190, "Member 'FCustomSpawnParam::TransData' has a wrong offset!");

// ScriptStruct Game.StackSummonSetting
// 0x0018 (0x0018 - 0x0000)
struct FStackSummonSetting final
{
public:
	class UClass*                                 SummonActorClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonAmount;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStack;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReplaced : 1;                                     // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActiveSummonCount;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStackSummonSetting) == 0x000008, "Wrong alignment on FStackSummonSetting");
static_assert(sizeof(FStackSummonSetting) == 0x000018, "Wrong size on FStackSummonSetting");
static_assert(offsetof(FStackSummonSetting, SummonActorClass) == 0x000000, "Member 'FStackSummonSetting::SummonActorClass' has a wrong offset!");
static_assert(offsetof(FStackSummonSetting, SummonAmount) == 0x000008, "Member 'FStackSummonSetting::SummonAmount' has a wrong offset!");
static_assert(offsetof(FStackSummonSetting, MaxStack) == 0x00000C, "Member 'FStackSummonSetting::MaxStack' has a wrong offset!");
static_assert(offsetof(FStackSummonSetting, ActiveSummonCount) == 0x000014, "Member 'FStackSummonSetting::ActiveSummonCount' has a wrong offset!");

// ScriptStruct Game.SummonSetting
// 0x0010 (0x0010 - 0x0000)
struct FSummonSetting final
{
public:
	class UClass*                                 SummonActorClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIndependent : 1;                                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSummonSetting) == 0x000008, "Wrong alignment on FSummonSetting");
static_assert(sizeof(FSummonSetting) == 0x000010, "Wrong size on FSummonSetting");
static_assert(offsetof(FSummonSetting, SummonActorClass) == 0x000000, "Member 'FSummonSetting::SummonActorClass' has a wrong offset!");

// ScriptStruct Game.AimActionSetting
// 0x0003 (0x0003 - 0x0000)
struct FAimActionSetting final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCastType                                SkillCastType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimActionType                                AimActionType;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimActionSetting) == 0x000001, "Wrong alignment on FAimActionSetting");
static_assert(sizeof(FAimActionSetting) == 0x000003, "Wrong size on FAimActionSetting");
static_assert(offsetof(FAimActionSetting, WeaponType) == 0x000000, "Member 'FAimActionSetting::WeaponType' has a wrong offset!");
static_assert(offsetof(FAimActionSetting, SkillCastType) == 0x000001, "Member 'FAimActionSetting::SkillCastType' has a wrong offset!");
static_assert(offsetof(FAimActionSetting, AimActionType) == 0x000002, "Member 'FAimActionSetting::AimActionType' has a wrong offset!");

// ScriptStruct Game.AIEnjoyArea
// 0x0010 (0x0010 - 0x0000)
struct FAIEnjoyArea final
{
public:
	struct FAIValueRange                          AngleRange;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIValueRange                          RadiusRange;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIEnjoyArea) == 0x000004, "Wrong alignment on FAIEnjoyArea");
static_assert(sizeof(FAIEnjoyArea) == 0x000010, "Wrong size on FAIEnjoyArea");
static_assert(offsetof(FAIEnjoyArea, AngleRange) == 0x000000, "Member 'FAIEnjoyArea::AngleRange' has a wrong offset!");
static_assert(offsetof(FAIEnjoyArea, RadiusRange) == 0x000008, "Member 'FAIEnjoyArea::RadiusRange' has a wrong offset!");

// ScriptStruct Game.AIControlParam
// 0x0088 (0x0090 - 0x0008)
struct FAIControlParam final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCharType                                 MemberType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalRationalR;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightRationalR;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComfortableR;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireAreaHalfAngle;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackAreaHalfAngle;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETeamCharType, struct FAIEnjoyArea>      MemberEnjoyArea;                                   // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SightRadius;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightHalfAngle;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRadius;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TP2CaptainDis;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollCD;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRecordTime;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIControlParam) == 0x000008, "Wrong alignment on FAIControlParam");
static_assert(sizeof(FAIControlParam) == 0x000090, "Wrong size on FAIControlParam");
static_assert(offsetof(FAIControlParam, ID) == 0x000008, "Member 'FAIControlParam::ID' has a wrong offset!");
static_assert(offsetof(FAIControlParam, MemberType) == 0x00000C, "Member 'FAIControlParam::MemberType' has a wrong offset!");
static_assert(offsetof(FAIControlParam, NormalRationalR) == 0x000010, "Member 'FAIControlParam::NormalRationalR' has a wrong offset!");
static_assert(offsetof(FAIControlParam, FightRationalR) == 0x000014, "Member 'FAIControlParam::FightRationalR' has a wrong offset!");
static_assert(offsetof(FAIControlParam, ComfortableR) == 0x000018, "Member 'FAIControlParam::ComfortableR' has a wrong offset!");
static_assert(offsetof(FAIControlParam, FireAreaHalfAngle) == 0x00001C, "Member 'FAIControlParam::FireAreaHalfAngle' has a wrong offset!");
static_assert(offsetof(FAIControlParam, BackAreaHalfAngle) == 0x000020, "Member 'FAIControlParam::BackAreaHalfAngle' has a wrong offset!");
static_assert(offsetof(FAIControlParam, MemberEnjoyArea) == 0x000028, "Member 'FAIControlParam::MemberEnjoyArea' has a wrong offset!");
static_assert(offsetof(FAIControlParam, SightRadius) == 0x000078, "Member 'FAIControlParam::SightRadius' has a wrong offset!");
static_assert(offsetof(FAIControlParam, SightHalfAngle) == 0x00007C, "Member 'FAIControlParam::SightHalfAngle' has a wrong offset!");
static_assert(offsetof(FAIControlParam, HearingRadius) == 0x000080, "Member 'FAIControlParam::HearingRadius' has a wrong offset!");
static_assert(offsetof(FAIControlParam, TP2CaptainDis) == 0x000084, "Member 'FAIControlParam::TP2CaptainDis' has a wrong offset!");
static_assert(offsetof(FAIControlParam, RollCD) == 0x000088, "Member 'FAIControlParam::RollCD' has a wrong offset!");
static_assert(offsetof(FAIControlParam, DamageRecordTime) == 0x00008C, "Member 'FAIControlParam::DamageRecordTime' has a wrong offset!");

// ScriptStruct Game.OnHitNotifyModifierEffect
// 0x0030 (0x0030 - 0x0000)
struct FOnHitNotifyModifierEffect final
{
public:
	TArray<struct FConditionSetting>              ApplyConditions;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                ReceiveHitEffect;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMagicParameter>                ApplyHitEffect;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnHitNotifyModifierEffect) == 0x000008, "Wrong alignment on FOnHitNotifyModifierEffect");
static_assert(sizeof(FOnHitNotifyModifierEffect) == 0x000030, "Wrong size on FOnHitNotifyModifierEffect");
static_assert(offsetof(FOnHitNotifyModifierEffect, ApplyConditions) == 0x000000, "Member 'FOnHitNotifyModifierEffect::ApplyConditions' has a wrong offset!");
static_assert(offsetof(FOnHitNotifyModifierEffect, ReceiveHitEffect) == 0x000010, "Member 'FOnHitNotifyModifierEffect::ReceiveHitEffect' has a wrong offset!");
static_assert(offsetof(FOnHitNotifyModifierEffect, ApplyHitEffect) == 0x000020, "Member 'FOnHitNotifyModifierEffect::ApplyHitEffect' has a wrong offset!");

// ScriptStruct Game.EmitterEffectApplyData
// 0x0048 (0x0048 - 0x0000)
struct FEmitterEffectApplyData final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EffectActor;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneResult                            PartitionOrPartResult;                             // 0x0010(0x0030)(Edit, BlueprintVisible, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckActor;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterEffectApplyData) == 0x000008, "Wrong alignment on FEmitterEffectApplyData");
static_assert(sizeof(FEmitterEffectApplyData) == 0x000048, "Wrong size on FEmitterEffectApplyData");
static_assert(offsetof(FEmitterEffectApplyData, EmitterID) == 0x000000, "Member 'FEmitterEffectApplyData::EmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterEffectApplyData, EffectActor) == 0x000008, "Member 'FEmitterEffectApplyData::EffectActor' has a wrong offset!");
static_assert(offsetof(FEmitterEffectApplyData, PartitionOrPartResult) == 0x000010, "Member 'FEmitterEffectApplyData::PartitionOrPartResult' has a wrong offset!");
static_assert(offsetof(FEmitterEffectApplyData, bCheckActor) == 0x000040, "Member 'FEmitterEffectApplyData::bCheckActor' has a wrong offset!");

// ScriptStruct Game.ViewGirlMain
// 0x00A0 (0x00A8 - 0x0008)
struct FViewGirlMain final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UViewCharacterData>      CharacterBodyConfig;                               // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewCharacterSecondaryData> CharacterBodySecondaryConfig;                      // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewCharacterData>      CharacterHeadConfig;                               // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewCharacterSecondaryData> CharacterHeadSecondaryConfig;                      // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewGirlMain) == 0x000008, "Wrong alignment on FViewGirlMain");
static_assert(sizeof(FViewGirlMain) == 0x0000A8, "Wrong size on FViewGirlMain");
static_assert(offsetof(FViewGirlMain, CharacterBodyConfig) == 0x000008, "Member 'FViewGirlMain::CharacterBodyConfig' has a wrong offset!");
static_assert(offsetof(FViewGirlMain, CharacterBodySecondaryConfig) == 0x000030, "Member 'FViewGirlMain::CharacterBodySecondaryConfig' has a wrong offset!");
static_assert(offsetof(FViewGirlMain, CharacterHeadConfig) == 0x000058, "Member 'FViewGirlMain::CharacterHeadConfig' has a wrong offset!");
static_assert(offsetof(FViewGirlMain, CharacterHeadSecondaryConfig) == 0x000080, "Member 'FViewGirlMain::CharacterHeadSecondaryConfig' has a wrong offset!");

// ScriptStruct Game.View_Character
// 0x01F0 (0x01F8 - 0x0008)
struct FView_Character final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UViewLightData>          CharacterLight;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewLightData>          CharacterLightAllAges;                             // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewOtherLightData>     CharacterOtherLight;                               // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewGirlMain                          FViewGirl;                                         // 0x0080(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FViewGirlMain                          FViewGirlAllAges;                                  // 0x0128(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewEnvironmentData>    CharacterEnv;                                      // 0x01D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Character) == 0x000008, "Wrong alignment on FView_Character");
static_assert(sizeof(FView_Character) == 0x0001F8, "Wrong size on FView_Character");
static_assert(offsetof(FView_Character, CharacterLight) == 0x000008, "Member 'FView_Character::CharacterLight' has a wrong offset!");
static_assert(offsetof(FView_Character, CharacterLightAllAges) == 0x000030, "Member 'FView_Character::CharacterLightAllAges' has a wrong offset!");
static_assert(offsetof(FView_Character, CharacterOtherLight) == 0x000058, "Member 'FView_Character::CharacterOtherLight' has a wrong offset!");
static_assert(offsetof(FView_Character, FViewGirl) == 0x000080, "Member 'FView_Character::FViewGirl' has a wrong offset!");
static_assert(offsetof(FView_Character, FViewGirlAllAges) == 0x000128, "Member 'FView_Character::FViewGirlAllAges' has a wrong offset!");
static_assert(offsetof(FView_Character, CharacterEnv) == 0x0001D0, "Member 'FView_Character::CharacterEnv' has a wrong offset!");

// ScriptStruct Game.ControlProtectionInfo
// 0x0018 (0x0018 - 0x0000)
struct FControlProtectionInfo final
{
public:
	bool                                          bNeedControlProtection;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlledCount;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAbnormalState                                LastAbnormalState;                                 // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAbnormalStateRunning;                           // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAbnormalStateTimeSecond;                      // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControlProtectionEndTimeSecond;                    // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControlProtectionEndTime;                          // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlProtectionInfo) == 0x000004, "Wrong alignment on FControlProtectionInfo");
static_assert(sizeof(FControlProtectionInfo) == 0x000018, "Wrong size on FControlProtectionInfo");
static_assert(offsetof(FControlProtectionInfo, bNeedControlProtection) == 0x000000, "Member 'FControlProtectionInfo::bNeedControlProtection' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, ControlledCount) == 0x000004, "Member 'FControlProtectionInfo::ControlledCount' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, LastAbnormalState) == 0x000008, "Member 'FControlProtectionInfo::LastAbnormalState' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, bIsAbnormalStateRunning) == 0x000009, "Member 'FControlProtectionInfo::bIsAbnormalStateRunning' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, StartAbnormalStateTimeSecond) == 0x00000C, "Member 'FControlProtectionInfo::StartAbnormalStateTimeSecond' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, ControlProtectionEndTimeSecond) == 0x000010, "Member 'FControlProtectionInfo::ControlProtectionEndTimeSecond' has a wrong offset!");
static_assert(offsetof(FControlProtectionInfo, ControlProtectionEndTime) == 0x000014, "Member 'FControlProtectionInfo::ControlProtectionEndTime' has a wrong offset!");

// ScriptStruct Game.AIMoveConf
// 0x0048 (0x0048 - 0x0000)
struct FAIMoveConf final
{
public:
	struct FVector2D                              SARange;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAIMove*>                        InsideSA;                                          // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIMove*>                        InSA;                                              // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIMove*>                        OutsideSA;                                         // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIMove*>                        MoveWhenError;                                     // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMoveConf) == 0x000008, "Wrong alignment on FAIMoveConf");
static_assert(sizeof(FAIMoveConf) == 0x000048, "Wrong size on FAIMoveConf");
static_assert(offsetof(FAIMoveConf, SARange) == 0x000000, "Member 'FAIMoveConf::SARange' has a wrong offset!");
static_assert(offsetof(FAIMoveConf, InsideSA) == 0x000008, "Member 'FAIMoveConf::InsideSA' has a wrong offset!");
static_assert(offsetof(FAIMoveConf, InSA) == 0x000018, "Member 'FAIMoveConf::InSA' has a wrong offset!");
static_assert(offsetof(FAIMoveConf, OutsideSA) == 0x000028, "Member 'FAIMoveConf::OutsideSA' has a wrong offset!");
static_assert(offsetof(FAIMoveConf, MoveWhenError) == 0x000038, "Member 'FAIMoveConf::MoveWhenError' has a wrong offset!");

// ScriptStruct Game.CacheDodgeInfo
// 0x0014 (0x0014 - 0x0000)
struct FCacheDodgeInfo final
{
public:
	int32                                         DodgeIndex;                                        // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeCacheValidTime;                               // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeDesiredYaw;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x7];                                        // 0x000D(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCacheDodgeInfo) == 0x000004, "Wrong alignment on FCacheDodgeInfo");
static_assert(sizeof(FCacheDodgeInfo) == 0x000014, "Wrong size on FCacheDodgeInfo");
static_assert(offsetof(FCacheDodgeInfo, DodgeIndex) == 0x000000, "Member 'FCacheDodgeInfo::DodgeIndex' has a wrong offset!");
static_assert(offsetof(FCacheDodgeInfo, DodgeCacheValidTime) == 0x000004, "Member 'FCacheDodgeInfo::DodgeCacheValidTime' has a wrong offset!");
static_assert(offsetof(FCacheDodgeInfo, DodgeDesiredYaw) == 0x000008, "Member 'FCacheDodgeInfo::DodgeDesiredYaw' has a wrong offset!");
static_assert(offsetof(FCacheDodgeInfo, bValid) == 0x00000C, "Member 'FCacheDodgeInfo::bValid' has a wrong offset!");

// ScriptStruct Game.CacheSkillInfo
// 0x001C (0x001C - 0x0000)
struct FCacheSkillInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCastType                                Type;                                              // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCast;                                         // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DelegateCastIndex;                                 // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoRelease;                                      // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillCacheValidTime;                               // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x7];                                       // 0x0015(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCacheSkillInfo) == 0x000004, "Wrong alignment on FCacheSkillInfo");
static_assert(sizeof(FCacheSkillInfo) == 0x00001C, "Wrong size on FCacheSkillInfo");
static_assert(offsetof(FCacheSkillInfo, ID) == 0x000000, "Member 'FCacheSkillInfo::ID' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, Type) == 0x000004, "Member 'FCacheSkillInfo::Type' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, bAutoCast) == 0x000005, "Member 'FCacheSkillInfo::bAutoCast' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, DelegateCastIndex) == 0x000008, "Member 'FCacheSkillInfo::DelegateCastIndex' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, bAutoRelease) == 0x00000C, "Member 'FCacheSkillInfo::bAutoRelease' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, SkillCacheValidTime) == 0x000010, "Member 'FCacheSkillInfo::SkillCacheValidTime' has a wrong offset!");
static_assert(offsetof(FCacheSkillInfo, bValid) == 0x000014, "Member 'FCacheSkillInfo::bValid' has a wrong offset!");

// ScriptStruct Game.BulletLoopEvent
// 0x0010 (0x0010 - 0x0000)
struct FBulletLoopEvent final
{
public:
	float                                         DelayTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapseTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireCount;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletLoopEvent) == 0x000004, "Wrong alignment on FBulletLoopEvent");
static_assert(sizeof(FBulletLoopEvent) == 0x000010, "Wrong size on FBulletLoopEvent");
static_assert(offsetof(FBulletLoopEvent, DelayTime) == 0x000000, "Member 'FBulletLoopEvent::DelayTime' has a wrong offset!");
static_assert(offsetof(FBulletLoopEvent, LoopCount) == 0x000004, "Member 'FBulletLoopEvent::LoopCount' has a wrong offset!");
static_assert(offsetof(FBulletLoopEvent, ElapseTime) == 0x000008, "Member 'FBulletLoopEvent::ElapseTime' has a wrong offset!");
static_assert(offsetof(FBulletLoopEvent, FireCount) == 0x00000C, "Member 'FBulletLoopEvent::FireCount' has a wrong offset!");

// ScriptStruct Game.CacheTrapBlueprintLogicVariable
// 0x0018 (0x0018 - 0x0000)
struct FCacheTrapBlueprintLogicVariable final
{
public:
	class FString                                 VariableName;                                      // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FValue;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCacheTrapBlueprintLogicVariable) == 0x000008, "Wrong alignment on FCacheTrapBlueprintLogicVariable");
static_assert(sizeof(FCacheTrapBlueprintLogicVariable) == 0x000018, "Wrong size on FCacheTrapBlueprintLogicVariable");
static_assert(offsetof(FCacheTrapBlueprintLogicVariable, VariableName) == 0x000000, "Member 'FCacheTrapBlueprintLogicVariable::VariableName' has a wrong offset!");
static_assert(offsetof(FCacheTrapBlueprintLogicVariable, FValue) == 0x000010, "Member 'FCacheTrapBlueprintLogicVariable::FValue' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapFenceParam
// 0x0008 (0x0008 - 0x0000)
struct FRocketGameTrapFenceParam final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleY;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapFenceParam) == 0x000004, "Wrong alignment on FRocketGameTrapFenceParam");
static_assert(sizeof(FRocketGameTrapFenceParam) == 0x000008, "Wrong size on FRocketGameTrapFenceParam");
static_assert(offsetof(FRocketGameTrapFenceParam, Length) == 0x000000, "Member 'FRocketGameTrapFenceParam::Length' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapFenceParam, AngleY) == 0x000004, "Member 'FRocketGameTrapFenceParam::AngleY' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapLaserParam
// 0x0008 (0x0008 - 0x0000)
struct FRocketGameTrapLaserParam final
{
public:
	float                                         CountDown;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapLaserParam) == 0x000004, "Wrong alignment on FRocketGameTrapLaserParam");
static_assert(sizeof(FRocketGameTrapLaserParam) == 0x000008, "Wrong size on FRocketGameTrapLaserParam");
static_assert(offsetof(FRocketGameTrapLaserParam, CountDown) == 0x000000, "Member 'FRocketGameTrapLaserParam::CountDown' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapLaserParam, LastTime) == 0x000004, "Member 'FRocketGameTrapLaserParam::LastTime' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapBallParam
// 0x0020 (0x0020 - 0x0000)
struct FRocketGameTrapBallParam final
{
public:
	struct FVector                                StartPos;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetTime;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapBallParam) == 0x000004, "Wrong alignment on FRocketGameTrapBallParam");
static_assert(sizeof(FRocketGameTrapBallParam) == 0x000020, "Wrong size on FRocketGameTrapBallParam");
static_assert(offsetof(FRocketGameTrapBallParam, StartPos) == 0x000000, "Member 'FRocketGameTrapBallParam::StartPos' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapBallParam, EndPos) == 0x00000C, "Member 'FRocketGameTrapBallParam::EndPos' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapBallParam, MoveTime) == 0x000018, "Member 'FRocketGameTrapBallParam::MoveTime' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapBallParam, OffsetTime) == 0x00001C, "Member 'FRocketGameTrapBallParam::OffsetTime' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapItemParam
// 0x0001 (0x0001 - 0x0000)
struct FRocketGameTrapItemParam final
{
public:
	ERocketGameItemType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapItemParam) == 0x000001, "Wrong alignment on FRocketGameTrapItemParam");
static_assert(sizeof(FRocketGameTrapItemParam) == 0x000001, "Wrong size on FRocketGameTrapItemParam");
static_assert(offsetof(FRocketGameTrapItemParam, Type) == 0x000000, "Member 'FRocketGameTrapItemParam::Type' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapInfo
// 0x0044 (0x0044 - 0x0000)
struct FRocketGameTrapInfo final
{
public:
	ERocketGameTrapType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERocketGamePosType                            Pos;                                               // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomPos;                                         // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRocketGameTrapFenceParam              FenceParam;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRocketGameTrapLaserParam              LaserParam;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRocketGameTrapBallParam               BallParam;                                         // 0x0020(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRocketGameTrapItemParam               ItemParam;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRocketGameTrapInfo) == 0x000004, "Wrong alignment on FRocketGameTrapInfo");
static_assert(sizeof(FRocketGameTrapInfo) == 0x000044, "Wrong size on FRocketGameTrapInfo");
static_assert(offsetof(FRocketGameTrapInfo, Type) == 0x000000, "Member 'FRocketGameTrapInfo::Type' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, Pos) == 0x000001, "Member 'FRocketGameTrapInfo::Pos' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, CustomPos) == 0x000004, "Member 'FRocketGameTrapInfo::CustomPos' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, FenceParam) == 0x000010, "Member 'FRocketGameTrapInfo::FenceParam' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, LaserParam) == 0x000018, "Member 'FRocketGameTrapInfo::LaserParam' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, BallParam) == 0x000020, "Member 'FRocketGameTrapInfo::BallParam' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapInfo, ItemParam) == 0x000040, "Member 'FRocketGameTrapInfo::ItemParam' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapUnit
// 0x0030 (0x0038 - 0x0008)
struct FRocketGameTrapUnit final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRocketGameTrapInfo>            Infos;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SafeDistance;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRocketGameTrapUnit) == 0x000008, "Wrong alignment on FRocketGameTrapUnit");
static_assert(sizeof(FRocketGameTrapUnit) == 0x000038, "Wrong size on FRocketGameTrapUnit");
static_assert(offsetof(FRocketGameTrapUnit, ID) == 0x000008, "Member 'FRocketGameTrapUnit::ID' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapUnit, Comment) == 0x000010, "Member 'FRocketGameTrapUnit::Comment' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapUnit, Infos) == 0x000020, "Member 'FRocketGameTrapUnit::Infos' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapUnit, SafeDistance) == 0x000030, "Member 'FRocketGameTrapUnit::SafeDistance' has a wrong offset!");

// ScriptStruct Game.BulletSpaceSpecialTrapThroughProcess
// 0x0008 (0x0008 - 0x0000)
struct FBulletSpaceSpecialTrapThroughProcess final
{
public:
	TWeakObjectPtr<class ABullet>                 BulletSpace;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSpaceSpecialTrapThroughProcess) == 0x000004, "Wrong alignment on FBulletSpaceSpecialTrapThroughProcess");
static_assert(sizeof(FBulletSpaceSpecialTrapThroughProcess) == 0x000008, "Wrong size on FBulletSpaceSpecialTrapThroughProcess");
static_assert(offsetof(FBulletSpaceSpecialTrapThroughProcess, BulletSpace) == 0x000000, "Member 'FBulletSpaceSpecialTrapThroughProcess::BulletSpace' has a wrong offset!");

// ScriptStruct Game.DealModifierDamageEffect
// 0x0090 (0x0090 - 0x0000)
struct FDealModifierDamageEffect final
{
public:
	TArray<struct FModifierDamageEffect>          DamageEffectInfo;                                  // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, class UCastConditionCheck*>      DamageEffectConditions;                            // 0x0010(0x0050)(Transient, NativeAccessSpecifierPublic)
	int32                                         CurOverlaid;                                       // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageOriginType;                                  // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnerID;                                           // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunTimeID;                                         // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UniqueId;                                          // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierID;                                        // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Luancher;                                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDealModifierDamageEffect) == 0x000008, "Wrong alignment on FDealModifierDamageEffect");
static_assert(sizeof(FDealModifierDamageEffect) == 0x000090, "Wrong size on FDealModifierDamageEffect");
static_assert(offsetof(FDealModifierDamageEffect, DamageEffectInfo) == 0x000000, "Member 'FDealModifierDamageEffect::DamageEffectInfo' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, DamageEffectConditions) == 0x000010, "Member 'FDealModifierDamageEffect::DamageEffectConditions' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, CurOverlaid) == 0x000060, "Member 'FDealModifierDamageEffect::CurOverlaid' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, Level) == 0x000064, "Member 'FDealModifierDamageEffect::Level' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, DamageOriginType) == 0x000068, "Member 'FDealModifierDamageEffect::DamageOriginType' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, OwnerID) == 0x00006C, "Member 'FDealModifierDamageEffect::OwnerID' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, RunTimeID) == 0x000070, "Member 'FDealModifierDamageEffect::RunTimeID' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, UniqueId) == 0x000074, "Member 'FDealModifierDamageEffect::UniqueId' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, ModifierID) == 0x000078, "Member 'FDealModifierDamageEffect::ModifierID' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, EmitterID) == 0x00007C, "Member 'FDealModifierDamageEffect::EmitterID' has a wrong offset!");
static_assert(offsetof(FDealModifierDamageEffect, Luancher) == 0x000080, "Member 'FDealModifierDamageEffect::Luancher' has a wrong offset!");

// ScriptStruct Game.DealArrayModifierDamageEffect
// 0x0018 (0x0018 - 0x0000)
struct FDealArrayModifierDamageEffect final
{
public:
	uint32                                        UniqueId;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDealModifierDamageEffect>      AllDamageEffectInfo;                               // 0x0008(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDealArrayModifierDamageEffect) == 0x000008, "Wrong alignment on FDealArrayModifierDamageEffect");
static_assert(sizeof(FDealArrayModifierDamageEffect) == 0x000018, "Wrong size on FDealArrayModifierDamageEffect");
static_assert(offsetof(FDealArrayModifierDamageEffect, UniqueId) == 0x000000, "Member 'FDealArrayModifierDamageEffect::UniqueId' has a wrong offset!");
static_assert(offsetof(FDealArrayModifierDamageEffect, AllDamageEffectInfo) == 0x000008, "Member 'FDealArrayModifierDamageEffect::AllDamageEffectInfo' has a wrong offset!");

// ScriptStruct Game.EmitterBurningData
// 0x00C8 (0x00C8 - 0x0000)
struct FEmitterBurningData final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQueryResult                           Result;                                            // 0x0010(0x0090)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BurningEffectPath;                                 // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   Launcher;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterBurningData) == 0x000008, "Wrong alignment on FEmitterBurningData");
static_assert(sizeof(FEmitterBurningData) == 0x0000C8, "Wrong size on FEmitterBurningData");
static_assert(offsetof(FEmitterBurningData, EmitterID) == 0x000000, "Member 'FEmitterBurningData::EmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, KeepTime) == 0x000004, "Member 'FEmitterBurningData::KeepTime' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, IntervalTime) == 0x000008, "Member 'FEmitterBurningData::IntervalTime' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, SkillLevel) == 0x00000C, "Member 'FEmitterBurningData::SkillLevel' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, Result) == 0x000010, "Member 'FEmitterBurningData::Result' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, BurningEffectPath) == 0x0000A0, "Member 'FEmitterBurningData::BurningEffectPath' has a wrong offset!");
static_assert(offsetof(FEmitterBurningData, Launcher) == 0x0000B8, "Member 'FEmitterBurningData::Launcher' has a wrong offset!");

// ScriptStruct Game.TraceRayEmitterInfoUpdateReplicated
// 0x00D0 (0x00D0 - 0x0000)
struct FTraceRayEmitterInfoUpdateReplicated final
{
public:
	uint32                                        EmitterHashIndex;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             CurrentStartTransform;                             // 0x0040(0x0030)(IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ClientUpdateCurrentStartTransform;                 // 0x0070(0x0030)(IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CurrentTraceTargetPosition;                        // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClientUpdateCurrentTraceTargetPosition;            // 0x00AC(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x00B8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraceRayEmitterInfoUpdateReplicated) == 0x000010, "Wrong alignment on FTraceRayEmitterInfoUpdateReplicated");
static_assert(sizeof(FTraceRayEmitterInfoUpdateReplicated) == 0x0000D0, "Wrong size on FTraceRayEmitterInfoUpdateReplicated");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, EmitterHashIndex) == 0x000000, "Member 'FTraceRayEmitterInfoUpdateReplicated::EmitterHashIndex' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, StartTransform) == 0x000010, "Member 'FTraceRayEmitterInfoUpdateReplicated::StartTransform' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, CurrentStartTransform) == 0x000040, "Member 'FTraceRayEmitterInfoUpdateReplicated::CurrentStartTransform' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, ClientUpdateCurrentStartTransform) == 0x000070, "Member 'FTraceRayEmitterInfoUpdateReplicated::ClientUpdateCurrentStartTransform' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, CurrentTraceTargetPosition) == 0x0000A0, "Member 'FTraceRayEmitterInfoUpdateReplicated::CurrentTraceTargetPosition' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, ClientUpdateCurrentTraceTargetPosition) == 0x0000AC, "Member 'FTraceRayEmitterInfoUpdateReplicated::ClientUpdateCurrentTraceTargetPosition' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoUpdateReplicated, TargetPosition) == 0x0000B8, "Member 'FTraceRayEmitterInfoUpdateReplicated::TargetPosition' has a wrong offset!");

// ScriptStruct Game.AISkill
// 0x0068 (0x0068 - 0x0000)
struct FAISkill final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseWeight;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakMove;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISkillCaster*                         Caster;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAISkillTargetTracker*                  TargetTracker;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAICharControl*                         ControlNoSkill;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAICharControl*                         Control;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAIWeightCondition*>             Conditions;                                        // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCastSkillAfterTrackerResult;                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillCastDelay;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillFinishDelay;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedInterruptBunkerState;                         // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCost;                                       // 0x0065(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCondition;                                  // 0x0066(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISkill) == 0x000008, "Wrong alignment on FAISkill");
static_assert(sizeof(FAISkill) == 0x000068, "Wrong size on FAISkill");
static_assert(offsetof(FAISkill, Remark) == 0x000008, "Member 'FAISkill::Remark' has a wrong offset!");
static_assert(offsetof(FAISkill, ID) == 0x000018, "Member 'FAISkill::ID' has a wrong offset!");
static_assert(offsetof(FAISkill, BaseWeight) == 0x00001C, "Member 'FAISkill::BaseWeight' has a wrong offset!");
static_assert(offsetof(FAISkill, bBreakMove) == 0x000020, "Member 'FAISkill::bBreakMove' has a wrong offset!");
static_assert(offsetof(FAISkill, Caster) == 0x000028, "Member 'FAISkill::Caster' has a wrong offset!");
static_assert(offsetof(FAISkill, TargetTracker) == 0x000030, "Member 'FAISkill::TargetTracker' has a wrong offset!");
static_assert(offsetof(FAISkill, ControlNoSkill) == 0x000038, "Member 'FAISkill::ControlNoSkill' has a wrong offset!");
static_assert(offsetof(FAISkill, Control) == 0x000040, "Member 'FAISkill::Control' has a wrong offset!");
static_assert(offsetof(FAISkill, Conditions) == 0x000048, "Member 'FAISkill::Conditions' has a wrong offset!");
static_assert(offsetof(FAISkill, bCastSkillAfterTrackerResult) == 0x000058, "Member 'FAISkill::bCastSkillAfterTrackerResult' has a wrong offset!");
static_assert(offsetof(FAISkill, SkillCastDelay) == 0x00005C, "Member 'FAISkill::SkillCastDelay' has a wrong offset!");
static_assert(offsetof(FAISkill, SkillFinishDelay) == 0x000060, "Member 'FAISkill::SkillFinishDelay' has a wrong offset!");
static_assert(offsetof(FAISkill, bNeedInterruptBunkerState) == 0x000064, "Member 'FAISkill::bNeedInterruptBunkerState' has a wrong offset!");
static_assert(offsetof(FAISkill, bIgnoreCost) == 0x000065, "Member 'FAISkill::bIgnoreCost' has a wrong offset!");
static_assert(offsetof(FAISkill, bIgnoreCondition) == 0x000066, "Member 'FAISkill::bIgnoreCondition' has a wrong offset!");

// ScriptStruct Game.AISkillGroup
// 0x0030 (0x0030 - 0x0000)
struct FAISkillGroup final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalCD;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAISkill>                       Skills;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillGroup) == 0x000008, "Wrong alignment on FAISkillGroup");
static_assert(sizeof(FAISkillGroup) == 0x000030, "Wrong size on FAISkillGroup");
static_assert(offsetof(FAISkillGroup, Remark) == 0x000008, "Member 'FAISkillGroup::Remark' has a wrong offset!");
static_assert(offsetof(FAISkillGroup, GlobalCD) == 0x000018, "Member 'FAISkillGroup::GlobalCD' has a wrong offset!");
static_assert(offsetof(FAISkillGroup, Weight) == 0x00001C, "Member 'FAISkillGroup::Weight' has a wrong offset!");
static_assert(offsetof(FAISkillGroup, Skills) == 0x000020, "Member 'FAISkillGroup::Skills' has a wrong offset!");

// ScriptStruct Game.TraceRayEmitterInfoInitReplicated
// 0x0070 (0x0070 - 0x0000)
struct FTraceRayEmitterInfoInitReplicated final
{
public:
	int32                                         RayBulletID;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayDistance;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EmitterHashIndex;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartTransformInterpSpeed;                         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentTraceTargetPosition;                        // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InterpSpeed;                                       // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInited;                                           // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraceRayEmitterInfoInitReplicated) == 0x000010, "Wrong alignment on FTraceRayEmitterInfoInitReplicated");
static_assert(sizeof(FTraceRayEmitterInfoInitReplicated) == 0x000070, "Wrong size on FTraceRayEmitterInfoInitReplicated");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, RayBulletID) == 0x000000, "Member 'FTraceRayEmitterInfoInitReplicated::RayBulletID' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, RayDistance) == 0x000004, "Member 'FTraceRayEmitterInfoInitReplicated::RayDistance' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, EmitterHashIndex) == 0x000008, "Member 'FTraceRayEmitterInfoInitReplicated::EmitterHashIndex' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, StartTransform) == 0x000010, "Member 'FTraceRayEmitterInfoInitReplicated::StartTransform' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, StartTransformInterpSpeed) == 0x000040, "Member 'FTraceRayEmitterInfoInitReplicated::StartTransformInterpSpeed' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, CurrentTraceTargetPosition) == 0x000044, "Member 'FTraceRayEmitterInfoInitReplicated::CurrentTraceTargetPosition' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, TargetPosition) == 0x000050, "Member 'FTraceRayEmitterInfoInitReplicated::TargetPosition' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, InterpSpeed) == 0x00005C, "Member 'FTraceRayEmitterInfoInitReplicated::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FTraceRayEmitterInfoInitReplicated, bInited) == 0x000068, "Member 'FTraceRayEmitterInfoInitReplicated::bInited' has a wrong offset!");

// ScriptStruct Game.VoiceItem
// 0x0018 (0x0018 - 0x0000)
struct FVoiceItem final
{
public:
	class FString                                 Event;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayState;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoiceItem) == 0x000008, "Wrong alignment on FVoiceItem");
static_assert(sizeof(FVoiceItem) == 0x000018, "Wrong size on FVoiceItem");
static_assert(offsetof(FVoiceItem, Event) == 0x000000, "Member 'FVoiceItem::Event' has a wrong offset!");
static_assert(offsetof(FVoiceItem, Weight) == 0x000010, "Member 'FVoiceItem::Weight' has a wrong offset!");
static_assert(offsetof(FVoiceItem, PlayState) == 0x000014, "Member 'FVoiceItem::PlayState' has a wrong offset!");

// ScriptStruct Game.Sync_OnPropertyChange
// 0x0020 (0x0020 - 0x0000)
struct FSync_OnPropertyChange final
{
public:
	class UAbilityComponentBase*                  Ability;                                           // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentVal;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVal;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeType                                AttributeType;                                     // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OldValue;                                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  InLauncher;                                        // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSync_OnPropertyChange) == 0x000008, "Wrong alignment on FSync_OnPropertyChange");
static_assert(sizeof(FSync_OnPropertyChange) == 0x000020, "Wrong size on FSync_OnPropertyChange");
static_assert(offsetof(FSync_OnPropertyChange, Ability) == 0x000000, "Member 'FSync_OnPropertyChange::Ability' has a wrong offset!");
static_assert(offsetof(FSync_OnPropertyChange, CurrentVal) == 0x000008, "Member 'FSync_OnPropertyChange::CurrentVal' has a wrong offset!");
static_assert(offsetof(FSync_OnPropertyChange, MaxVal) == 0x00000C, "Member 'FSync_OnPropertyChange::MaxVal' has a wrong offset!");
static_assert(offsetof(FSync_OnPropertyChange, AttributeType) == 0x000010, "Member 'FSync_OnPropertyChange::AttributeType' has a wrong offset!");
static_assert(offsetof(FSync_OnPropertyChange, OldValue) == 0x000014, "Member 'FSync_OnPropertyChange::OldValue' has a wrong offset!");
static_assert(offsetof(FSync_OnPropertyChange, InLauncher) == 0x000018, "Member 'FSync_OnPropertyChange::InLauncher' has a wrong offset!");

// ScriptStruct Game.SkillKeepIdentify
// 0x0020 (0x0020 - 0x0000)
struct FSkillKeepIdentify final
{
public:
	class FName                                   IdentifyName;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 KeepSkillIDs;                                      // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bKeeping;                                          // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillKeepIdentify) == 0x000008, "Wrong alignment on FSkillKeepIdentify");
static_assert(sizeof(FSkillKeepIdentify) == 0x000020, "Wrong size on FSkillKeepIdentify");
static_assert(offsetof(FSkillKeepIdentify, IdentifyName) == 0x000000, "Member 'FSkillKeepIdentify::IdentifyName' has a wrong offset!");
static_assert(offsetof(FSkillKeepIdentify, KeepSkillIDs) == 0x000008, "Member 'FSkillKeepIdentify::KeepSkillIDs' has a wrong offset!");
static_assert(offsetof(FSkillKeepIdentify, bKeeping) == 0x000018, "Member 'FSkillKeepIdentify::bKeeping' has a wrong offset!");

// ScriptStruct Game.CastSkillOnButtonTypeInfo
// 0x0010 (0x0010 - 0x0000)
struct FCastSkillOnButtonTypeInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCastType                                Type;                                              // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCastSkill;                                    // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentLongPressedTime;                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyStorge_GateTime;                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCastSkillOnButtonTypeInfo) == 0x000004, "Wrong alignment on FCastSkillOnButtonTypeInfo");
static_assert(sizeof(FCastSkillOnButtonTypeInfo) == 0x000010, "Wrong size on FCastSkillOnButtonTypeInfo");
static_assert(offsetof(FCastSkillOnButtonTypeInfo, Index) == 0x000000, "Member 'FCastSkillOnButtonTypeInfo::Index' has a wrong offset!");
static_assert(offsetof(FCastSkillOnButtonTypeInfo, Type) == 0x000004, "Member 'FCastSkillOnButtonTypeInfo::Type' has a wrong offset!");
static_assert(offsetof(FCastSkillOnButtonTypeInfo, bAutoCastSkill) == 0x000005, "Member 'FCastSkillOnButtonTypeInfo::bAutoCastSkill' has a wrong offset!");
static_assert(offsetof(FCastSkillOnButtonTypeInfo, CurrentLongPressedTime) == 0x000008, "Member 'FCastSkillOnButtonTypeInfo::CurrentLongPressedTime' has a wrong offset!");
static_assert(offsetof(FCastSkillOnButtonTypeInfo, EnergyStorge_GateTime) == 0x00000C, "Member 'FCastSkillOnButtonTypeInfo::EnergyStorge_GateTime' has a wrong offset!");

// ScriptStruct Game.RoleSkinBoxItem
// 0x0040 (0x0040 - 0x0000)
struct FRoleSkinBoxItem final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SocketName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoleSkinBoxItem) == 0x000008, "Wrong alignment on FRoleSkinBoxItem");
static_assert(sizeof(FRoleSkinBoxItem) == 0x000040, "Wrong size on FRoleSkinBoxItem");
static_assert(offsetof(FRoleSkinBoxItem, ID) == 0x000000, "Member 'FRoleSkinBoxItem::ID' has a wrong offset!");
static_assert(offsetof(FRoleSkinBoxItem, SocketName) == 0x000008, "Member 'FRoleSkinBoxItem::SocketName' has a wrong offset!");
static_assert(offsetof(FRoleSkinBoxItem, BoxSize) == 0x000018, "Member 'FRoleSkinBoxItem::BoxSize' has a wrong offset!");
static_assert(offsetof(FRoleSkinBoxItem, Offset) == 0x000024, "Member 'FRoleSkinBoxItem::Offset' has a wrong offset!");
static_assert(offsetof(FRoleSkinBoxItem, Rotator) == 0x000030, "Member 'FRoleSkinBoxItem::Rotator' has a wrong offset!");

// ScriptStruct Game.RoleSkinBoxData
// 0x0010 (0x0010 - 0x0000)
struct FRoleSkinBoxData final
{
public:
	TArray<struct FRoleSkinBoxItem>               Boxs;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleSkinBoxData) == 0x000008, "Wrong alignment on FRoleSkinBoxData");
static_assert(sizeof(FRoleSkinBoxData) == 0x000010, "Wrong size on FRoleSkinBoxData");
static_assert(offsetof(FRoleSkinBoxData, Boxs) == 0x000000, "Member 'FRoleSkinBoxData::Boxs' has a wrong offset!");

// ScriptStruct Game.TriggerOnPressedSkillCacheInfo
// 0x000C (0x000C - 0x0000)
struct FTriggerOnPressedSkillCacheInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCastType                                Type;                                              // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentLongPressedTime;                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerOnPressedSkillCacheInfo) == 0x000004, "Wrong alignment on FTriggerOnPressedSkillCacheInfo");
static_assert(sizeof(FTriggerOnPressedSkillCacheInfo) == 0x00000C, "Wrong size on FTriggerOnPressedSkillCacheInfo");
static_assert(offsetof(FTriggerOnPressedSkillCacheInfo, Index) == 0x000000, "Member 'FTriggerOnPressedSkillCacheInfo::Index' has a wrong offset!");
static_assert(offsetof(FTriggerOnPressedSkillCacheInfo, Type) == 0x000004, "Member 'FTriggerOnPressedSkillCacheInfo::Type' has a wrong offset!");
static_assert(offsetof(FTriggerOnPressedSkillCacheInfo, CurrentLongPressedTime) == 0x000008, "Member 'FTriggerOnPressedSkillCacheInfo::CurrentLongPressedTime' has a wrong offset!");

// ScriptStruct Game.FightAIEventConf
// 0x0010 (0x0010 - 0x0000)
struct FFightAIEventConf final
{
public:
	class UAICondition*                           AICondition;                                       // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIEvent*                               AIEvent;                                           // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFightAIEventConf) == 0x000008, "Wrong alignment on FFightAIEventConf");
static_assert(sizeof(FFightAIEventConf) == 0x000010, "Wrong size on FFightAIEventConf");
static_assert(offsetof(FFightAIEventConf, AICondition) == 0x000000, "Member 'FFightAIEventConf::AICondition' has a wrong offset!");
static_assert(offsetof(FFightAIEventConf, AIEvent) == 0x000008, "Member 'FFightAIEventConf::AIEvent' has a wrong offset!");

// ScriptStruct Game.GMDamageInfo
// 0x0020 (0x0020 - 0x0000)
struct FGMDamageInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGMDamageInfo) == 0x000008, "Wrong alignment on FGMDamageInfo");
static_assert(sizeof(FGMDamageInfo) == 0x000020, "Wrong size on FGMDamageInfo");
static_assert(offsetof(FGMDamageInfo, Name) == 0x000000, "Member 'FGMDamageInfo::Name' has a wrong offset!");
static_assert(offsetof(FGMDamageInfo, Value) == 0x000010, "Member 'FGMDamageInfo::Value' has a wrong offset!");

// ScriptStruct Game.GMRunDamageInfo
// 0x0048 (0x0048 - 0x0000)
struct FGMRunDamageInfo final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                AttackerType;                                      // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Attacker;                                          // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hiter;                                             // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillApply;                                       // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillID;                                           // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeal;                                             // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounce;                                           // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExecTime;                                          // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGMDamageInfo>                  Infos;                                             // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGMRunDamageInfo) == 0x000008, "Wrong alignment on FGMRunDamageInfo");
static_assert(sizeof(FGMRunDamageInfo) == 0x000048, "Wrong size on FGMRunDamageInfo");
static_assert(offsetof(FGMRunDamageInfo, Damage) == 0x000000, "Member 'FGMRunDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, AttackerType) == 0x000004, "Member 'FGMRunDamageInfo::AttackerType' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, Attacker) == 0x000008, "Member 'FGMRunDamageInfo::Attacker' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, Hiter) == 0x000018, "Member 'FGMRunDamageInfo::Hiter' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, bSkillApply) == 0x000028, "Member 'FGMRunDamageInfo::bSkillApply' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, SkillID) == 0x00002C, "Member 'FGMRunDamageInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, bHeal) == 0x000030, "Member 'FGMRunDamageInfo::bHeal' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, bBounce) == 0x000031, "Member 'FGMRunDamageInfo::bBounce' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, ExecTime) == 0x000034, "Member 'FGMRunDamageInfo::ExecTime' has a wrong offset!");
static_assert(offsetof(FGMRunDamageInfo, Infos) == 0x000038, "Member 'FGMRunDamageInfo::Infos' has a wrong offset!");

// ScriptStruct Game.ChasingGamePoint
// 0x0010 (0x0010 - 0x0000)
struct FChasingGamePoint final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChasingGamePoint) == 0x000008, "Wrong alignment on FChasingGamePoint");
static_assert(sizeof(FChasingGamePoint) == 0x000010, "Wrong size on FChasingGamePoint");
static_assert(offsetof(FChasingGamePoint, Points) == 0x000000, "Member 'FChasingGamePoint::Points' has a wrong offset!");

// ScriptStruct Game.ElemExplosionRuntime
// 0x0028 (0x0028 - 0x0000)
struct FElemExplosionRuntime final
{
public:
	float                                         CurValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddTime;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAbilityComponentBase*>          AbilityRecords;                                    // 0x0010(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         TriggerAddtionNum;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddElemTime;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemExplosionRuntime) == 0x000008, "Wrong alignment on FElemExplosionRuntime");
static_assert(sizeof(FElemExplosionRuntime) == 0x000028, "Wrong size on FElemExplosionRuntime");
static_assert(offsetof(FElemExplosionRuntime, CurValue) == 0x000000, "Member 'FElemExplosionRuntime::CurValue' has a wrong offset!");
static_assert(offsetof(FElemExplosionRuntime, TriggerValue) == 0x000004, "Member 'FElemExplosionRuntime::TriggerValue' has a wrong offset!");
static_assert(offsetof(FElemExplosionRuntime, AddTime) == 0x000008, "Member 'FElemExplosionRuntime::AddTime' has a wrong offset!");
static_assert(offsetof(FElemExplosionRuntime, AbilityRecords) == 0x000010, "Member 'FElemExplosionRuntime::AbilityRecords' has a wrong offset!");
static_assert(offsetof(FElemExplosionRuntime, TriggerAddtionNum) == 0x000020, "Member 'FElemExplosionRuntime::TriggerAddtionNum' has a wrong offset!");
static_assert(offsetof(FElemExplosionRuntime, AddElemTime) == 0x000024, "Member 'FElemExplosionRuntime::AddElemTime' has a wrong offset!");

// ScriptStruct Game.ElemExplosionItem
// 0x0050 (0x0050 - 0x0000)
struct FElemExplosionItem final
{
public:
	TMap<class AGamePlayerController*, struct FElemExplosionRuntime> RuntimeDatas;                                      // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemExplosionItem) == 0x000008, "Wrong alignment on FElemExplosionItem");
static_assert(sizeof(FElemExplosionItem) == 0x000050, "Wrong size on FElemExplosionItem");
static_assert(offsetof(FElemExplosionItem, RuntimeDatas) == 0x000000, "Member 'FElemExplosionItem::RuntimeDatas' has a wrong offset!");

// ScriptStruct Game.ElemExplosion
// 0x0050 (0x0050 - 0x0000)
struct FElemExplosion final
{
public:
	TMap<EModifyHPType, struct FElemExplosionItem> Data;                                              // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemExplosion) == 0x000008, "Wrong alignment on FElemExplosion");
static_assert(sizeof(FElemExplosion) == 0x000050, "Wrong size on FElemExplosion");
static_assert(offsetof(FElemExplosion, Data) == 0x000000, "Member 'FElemExplosion::Data' has a wrong offset!");

// ScriptStruct Game.OnCarBumpAnimData
// 0x0010 (0x0010 - 0x0000)
struct FOnCarBumpAnimData final
{
public:
	float                                         MinAngleRange;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleRange;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      BumpAnim;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnCarBumpAnimData) == 0x000008, "Wrong alignment on FOnCarBumpAnimData");
static_assert(sizeof(FOnCarBumpAnimData) == 0x000010, "Wrong size on FOnCarBumpAnimData");
static_assert(offsetof(FOnCarBumpAnimData, MinAngleRange) == 0x000000, "Member 'FOnCarBumpAnimData::MinAngleRange' has a wrong offset!");
static_assert(offsetof(FOnCarBumpAnimData, MaxAngleRange) == 0x000004, "Member 'FOnCarBumpAnimData::MaxAngleRange' has a wrong offset!");
static_assert(offsetof(FOnCarBumpAnimData, BumpAnim) == 0x000008, "Member 'FOnCarBumpAnimData::BumpAnim' has a wrong offset!");

// ScriptStruct Game.SimpleBlockServerInfo
// 0x0050 (0x0050 - 0x0000)
struct FSimpleBlockServerInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Trans;                                             // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroy;                                          // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleBlockServerInfo) == 0x000010, "Wrong alignment on FSimpleBlockServerInfo");
static_assert(sizeof(FSimpleBlockServerInfo) == 0x000050, "Wrong size on FSimpleBlockServerInfo");
static_assert(offsetof(FSimpleBlockServerInfo, Actor) == 0x000000, "Member 'FSimpleBlockServerInfo::Actor' has a wrong offset!");
static_assert(offsetof(FSimpleBlockServerInfo, Trans) == 0x000010, "Member 'FSimpleBlockServerInfo::Trans' has a wrong offset!");
static_assert(offsetof(FSimpleBlockServerInfo, Index) == 0x000040, "Member 'FSimpleBlockServerInfo::Index' has a wrong offset!");
static_assert(offsetof(FSimpleBlockServerInfo, bDestroy) == 0x000044, "Member 'FSimpleBlockServerInfo::bDestroy' has a wrong offset!");

// ScriptStruct Game.ElemExplosionBaseData
// 0x0008 (0x0008 - 0x0000)
struct FElemExplosionBaseData final
{
public:
	EMonBodyType                                  BodyType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElemExplosionUptakeEfficien;                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElemExplosionBaseData) == 0x000004, "Wrong alignment on FElemExplosionBaseData");
static_assert(sizeof(FElemExplosionBaseData) == 0x000008, "Wrong size on FElemExplosionBaseData");
static_assert(offsetof(FElemExplosionBaseData, BodyType) == 0x000000, "Member 'FElemExplosionBaseData::BodyType' has a wrong offset!");
static_assert(offsetof(FElemExplosionBaseData, ElemExplosionUptakeEfficien) == 0x000004, "Member 'FElemExplosionBaseData::ElemExplosionUptakeEfficien' has a wrong offset!");

// ScriptStruct Game.ElemExplosionData
// 0x0010 (0x0018 - 0x0008)
struct FElemExplosionData final : public FTableRowBase
{
public:
	EModifyHPType                                 Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonBodyType                                  BodyType;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rate;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElemExplosionData) == 0x000008, "Wrong alignment on FElemExplosionData");
static_assert(sizeof(FElemExplosionData) == 0x000018, "Wrong size on FElemExplosionData");
static_assert(offsetof(FElemExplosionData, Type) == 0x000008, "Member 'FElemExplosionData::Type' has a wrong offset!");
static_assert(offsetof(FElemExplosionData, BodyType) == 0x000009, "Member 'FElemExplosionData::BodyType' has a wrong offset!");
static_assert(offsetof(FElemExplosionData, Rate) == 0x00000C, "Member 'FElemExplosionData::Rate' has a wrong offset!");
static_assert(offsetof(FElemExplosionData, EmitterID) == 0x000010, "Member 'FElemExplosionData::EmitterID' has a wrong offset!");

// ScriptStruct Game.AutoPSOConfig
// 0x001C (0x001C - 0x0000)
struct FAutoPSOConfig final
{
public:
	int32                                         QualityLevel;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoNextQuality;                                   // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraversalAllAsset;                                 // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssetBeginIndex;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraversalAllSkill;                                 // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillBeginIndex;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraversalAllMap;                                   // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapBeginIndex;                                     // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoPSOConfig) == 0x000004, "Wrong alignment on FAutoPSOConfig");
static_assert(sizeof(FAutoPSOConfig) == 0x00001C, "Wrong size on FAutoPSOConfig");
static_assert(offsetof(FAutoPSOConfig, QualityLevel) == 0x000000, "Member 'FAutoPSOConfig::QualityLevel' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, AutoNextQuality) == 0x000004, "Member 'FAutoPSOConfig::AutoNextQuality' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, TraversalAllAsset) == 0x000005, "Member 'FAutoPSOConfig::TraversalAllAsset' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, AssetBeginIndex) == 0x000008, "Member 'FAutoPSOConfig::AssetBeginIndex' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, TraversalAllSkill) == 0x00000C, "Member 'FAutoPSOConfig::TraversalAllSkill' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, SkillBeginIndex) == 0x000010, "Member 'FAutoPSOConfig::SkillBeginIndex' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, TraversalAllMap) == 0x000014, "Member 'FAutoPSOConfig::TraversalAllMap' has a wrong offset!");
static_assert(offsetof(FAutoPSOConfig, MapBeginIndex) == 0x000018, "Member 'FAutoPSOConfig::MapBeginIndex' has a wrong offset!");

// ScriptStruct Game.EnchantBulletInfo
// 0x0018 (0x0018 - 0x0000)
struct FEnchantBulletInfo final
{
public:
	int32                                         EnchantBulletID;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginalBulletID;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletLevel;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   EnchantAbility;                                    // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnchantBulletInfo) == 0x000004, "Wrong alignment on FEnchantBulletInfo");
static_assert(sizeof(FEnchantBulletInfo) == 0x000018, "Wrong size on FEnchantBulletInfo");
static_assert(offsetof(FEnchantBulletInfo, EnchantBulletID) == 0x000000, "Member 'FEnchantBulletInfo::EnchantBulletID' has a wrong offset!");
static_assert(offsetof(FEnchantBulletInfo, Probability) == 0x000004, "Member 'FEnchantBulletInfo::Probability' has a wrong offset!");
static_assert(offsetof(FEnchantBulletInfo, OriginalBulletID) == 0x000008, "Member 'FEnchantBulletInfo::OriginalBulletID' has a wrong offset!");
static_assert(offsetof(FEnchantBulletInfo, BulletLevel) == 0x00000C, "Member 'FEnchantBulletInfo::BulletLevel' has a wrong offset!");
static_assert(offsetof(FEnchantBulletInfo, EnchantAbility) == 0x000010, "Member 'FEnchantBulletInfo::EnchantAbility' has a wrong offset!");

// ScriptStruct Game.TriangleAttributeRelative
// 0x0018 (0x0020 - 0x0008)
struct FTriangleAttributeRelative final : public FTableRowBase
{
public:
	int32                                         EnumIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LivingBody;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spirit;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Construct;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoneBody;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriangleAttributeRelative) == 0x000008, "Wrong alignment on FTriangleAttributeRelative");
static_assert(sizeof(FTriangleAttributeRelative) == 0x000020, "Wrong size on FTriangleAttributeRelative");
static_assert(offsetof(FTriangleAttributeRelative, EnumIndex) == 0x000008, "Member 'FTriangleAttributeRelative::EnumIndex' has a wrong offset!");
static_assert(offsetof(FTriangleAttributeRelative, LivingBody) == 0x00000C, "Member 'FTriangleAttributeRelative::LivingBody' has a wrong offset!");
static_assert(offsetof(FTriangleAttributeRelative, Spirit) == 0x000010, "Member 'FTriangleAttributeRelative::Spirit' has a wrong offset!");
static_assert(offsetof(FTriangleAttributeRelative, Construct) == 0x000014, "Member 'FTriangleAttributeRelative::Construct' has a wrong offset!");
static_assert(offsetof(FTriangleAttributeRelative, NoneBody) == 0x000018, "Member 'FTriangleAttributeRelative::NoneBody' has a wrong offset!");

// ScriptStruct Game.EffectStorage
// 0x0010 (0x0010 - 0x0000)
struct FEffectStorage final
{
public:
	class UFXSystemComponent*                     Particle;                                          // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseComponent*                        Wise;                                              // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectStorage) == 0x000008, "Wrong alignment on FEffectStorage");
static_assert(sizeof(FEffectStorage) == 0x000010, "Wrong size on FEffectStorage");
static_assert(offsetof(FEffectStorage, Particle) == 0x000000, "Member 'FEffectStorage::Particle' has a wrong offset!");
static_assert(offsetof(FEffectStorage, Wise) == 0x000008, "Member 'FEffectStorage::Wise' has a wrong offset!");

// ScriptStruct Game.AttackShildOrHealthEffect
// 0x0010 (0x0018 - 0x0008)
struct FAttackShildOrHealthEffect final : public FTableRowBase
{
public:
	int32                                         EnumIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntityBullet;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Element;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magic_4;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackShildOrHealthEffect) == 0x000008, "Wrong alignment on FAttackShildOrHealthEffect");
static_assert(sizeof(FAttackShildOrHealthEffect) == 0x000018, "Wrong size on FAttackShildOrHealthEffect");
static_assert(offsetof(FAttackShildOrHealthEffect, EnumIndex) == 0x000008, "Member 'FAttackShildOrHealthEffect::EnumIndex' has a wrong offset!");
static_assert(offsetof(FAttackShildOrHealthEffect, EntityBullet) == 0x00000C, "Member 'FAttackShildOrHealthEffect::EntityBullet' has a wrong offset!");
static_assert(offsetof(FAttackShildOrHealthEffect, Element) == 0x000010, "Member 'FAttackShildOrHealthEffect::Element' has a wrong offset!");
static_assert(offsetof(FAttackShildOrHealthEffect, Magic_4) == 0x000014, "Member 'FAttackShildOrHealthEffect::Magic_4' has a wrong offset!");

// ScriptStruct Game.EnchantInfoParam
// 0x0010 (0x0010 - 0x0000)
struct FEnchantInfoParam final
{
public:
	class FString                                 ChangeParam;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnchantInfoParam) == 0x000008, "Wrong alignment on FEnchantInfoParam");
static_assert(sizeof(FEnchantInfoParam) == 0x000010, "Wrong size on FEnchantInfoParam");
static_assert(offsetof(FEnchantInfoParam, ChangeParam) == 0x000000, "Member 'FEnchantInfoParam::ChangeParam' has a wrong offset!");

// ScriptStruct Game.EnchantInfoData
// 0x0060 (0x0060 - 0x0000)
struct FEnchantInfoData final
{
public:
	EEnchantTableName                             TableName;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnchantChangType                             ChangeType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnchantInfoParam                      ChangeParam;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnchantInfoData) == 0x000008, "Wrong alignment on FEnchantInfoData");
static_assert(sizeof(FEnchantInfoData) == 0x000060, "Wrong size on FEnchantInfoData");
static_assert(offsetof(FEnchantInfoData, TableName) == 0x000000, "Member 'FEnchantInfoData::TableName' has a wrong offset!");
static_assert(offsetof(FEnchantInfoData, ChangeID) == 0x000004, "Member 'FEnchantInfoData::ChangeID' has a wrong offset!");
static_assert(offsetof(FEnchantInfoData, ChangeType) == 0x000008, "Member 'FEnchantInfoData::ChangeType' has a wrong offset!");
static_assert(offsetof(FEnchantInfoData, ChangeParam) == 0x000010, "Member 'FEnchantInfoData::ChangeParam' has a wrong offset!");
static_assert(offsetof(FEnchantInfoData, Value) == 0x000020, "Member 'FEnchantInfoData::Value' has a wrong offset!");

// ScriptStruct Game.EnchantInfo
// 0x0018 (0x0020 - 0x0008)
struct FEnchantInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnchantInfoData>               EnchantInfoData;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnchantInfo) == 0x000008, "Wrong alignment on FEnchantInfo");
static_assert(sizeof(FEnchantInfo) == 0x000020, "Wrong size on FEnchantInfo");
static_assert(offsetof(FEnchantInfo, ID) == 0x000008, "Member 'FEnchantInfo::ID' has a wrong offset!");
static_assert(offsetof(FEnchantInfo, EnchantInfoData) == 0x000010, "Member 'FEnchantInfo::EnchantInfoData' has a wrong offset!");

// ScriptStruct Game.TextInfo
// 0x0028 (0x0028 - 0x0000)
struct FTextInfo final
{
public:
	float                                         WaitTimeBeforeShow;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BubbleText;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextShowTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SoundId;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextInfo) == 0x000008, "Wrong alignment on FTextInfo");
static_assert(sizeof(FTextInfo) == 0x000028, "Wrong size on FTextInfo");
static_assert(offsetof(FTextInfo, WaitTimeBeforeShow) == 0x000000, "Member 'FTextInfo::WaitTimeBeforeShow' has a wrong offset!");
static_assert(offsetof(FTextInfo, BubbleText) == 0x000008, "Member 'FTextInfo::BubbleText' has a wrong offset!");
static_assert(offsetof(FTextInfo, TextShowTime) == 0x000018, "Member 'FTextInfo::TextShowTime' has a wrong offset!");
static_assert(offsetof(FTextInfo, SoundId) == 0x000020, "Member 'FTextInfo::SoundId' has a wrong offset!");

// ScriptStruct Game.NpcTalkBubbleItemConfigInfo
// 0x0048 (0x0048 - 0x0000)
struct FNpcTalkBubbleItemConfigInfo final
{
public:
	TArray<struct FTextInfo>                      InTextInfoArray;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   InBindSocketName;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InZOffset;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBeginRange;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBubbleShowRange;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBubbleType                                   InBubbleType;                                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordAndRecover;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InAnimName;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutAnimName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcTalkBubbleItemConfigInfo) == 0x000008, "Wrong alignment on FNpcTalkBubbleItemConfigInfo");
static_assert(sizeof(FNpcTalkBubbleItemConfigInfo) == 0x000048, "Wrong size on FNpcTalkBubbleItemConfigInfo");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InTextInfoArray) == 0x000000, "Member 'FNpcTalkBubbleItemConfigInfo::InTextInfoArray' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InBindSocketName) == 0x000010, "Member 'FNpcTalkBubbleItemConfigInfo::InBindSocketName' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InZOffset) == 0x000018, "Member 'FNpcTalkBubbleItemConfigInfo::InZOffset' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InBeginRange) == 0x00001C, "Member 'FNpcTalkBubbleItemConfigInfo::InBeginRange' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InBubbleShowRange) == 0x000020, "Member 'FNpcTalkBubbleItemConfigInfo::InBubbleShowRange' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InBubbleType) == 0x000024, "Member 'FNpcTalkBubbleItemConfigInfo::InBubbleType' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, bRecordAndRecover) == 0x000025, "Member 'FNpcTalkBubbleItemConfigInfo::bRecordAndRecover' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, InAnimName) == 0x000028, "Member 'FNpcTalkBubbleItemConfigInfo::InAnimName' has a wrong offset!");
static_assert(offsetof(FNpcTalkBubbleItemConfigInfo, OutAnimName) == 0x000038, "Member 'FNpcTalkBubbleItemConfigInfo::OutAnimName' has a wrong offset!");

// ScriptStruct Game.ValueRangeInfo
// 0x000C (0x000C - 0x0000)
struct FValueRangeInfo final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeMin;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeMax;                                        // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FValueRangeInfo) == 0x000004, "Wrong alignment on FValueRangeInfo");
static_assert(sizeof(FValueRangeInfo) == 0x00000C, "Wrong size on FValueRangeInfo");
static_assert(offsetof(FValueRangeInfo, Min) == 0x000000, "Member 'FValueRangeInfo::Min' has a wrong offset!");
static_assert(offsetof(FValueRangeInfo, Max) == 0x000004, "Member 'FValueRangeInfo::Max' has a wrong offset!");
static_assert(offsetof(FValueRangeInfo, IncludeMin) == 0x000008, "Member 'FValueRangeInfo::IncludeMin' has a wrong offset!");
static_assert(offsetof(FValueRangeInfo, IncludeMax) == 0x000009, "Member 'FValueRangeInfo::IncludeMax' has a wrong offset!");

// ScriptStruct Game.TextureParameter
// 0x0018 (0x0028 - 0x0010)
struct FTextureParameter final : public FParameterBase
{
public:
	EMaterialType                                 MaterialType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyType                                   ModifyType;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               ValueInLight;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ValueInShadow;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureParameter) == 0x000008, "Wrong alignment on FTextureParameter");
static_assert(sizeof(FTextureParameter) == 0x000028, "Wrong size on FTextureParameter");
static_assert(offsetof(FTextureParameter, MaterialType) == 0x000010, "Member 'FTextureParameter::MaterialType' has a wrong offset!");
static_assert(offsetof(FTextureParameter, ModifyType) == 0x000011, "Member 'FTextureParameter::ModifyType' has a wrong offset!");
static_assert(offsetof(FTextureParameter, ValueInLight) == 0x000018, "Member 'FTextureParameter::ValueInLight' has a wrong offset!");
static_assert(offsetof(FTextureParameter, ValueInShadow) == 0x000020, "Member 'FTextureParameter::ValueInShadow' has a wrong offset!");

// ScriptStruct Game.InheritDataSetting
// 0x0010 (0x0010 - 0x0000)
struct FInheritDataSetting final
{
public:
	EInheritDataTargetType                        UseInheritFromTarget;                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InheritEmitterID;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InheritSceneTargetsTag;                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInheritDataSetting) == 0x000004, "Wrong alignment on FInheritDataSetting");
static_assert(sizeof(FInheritDataSetting) == 0x000010, "Wrong size on FInheritDataSetting");
static_assert(offsetof(FInheritDataSetting, UseInheritFromTarget) == 0x000000, "Member 'FInheritDataSetting::UseInheritFromTarget' has a wrong offset!");
static_assert(offsetof(FInheritDataSetting, InheritEmitterID) == 0x000004, "Member 'FInheritDataSetting::InheritEmitterID' has a wrong offset!");
static_assert(offsetof(FInheritDataSetting, InheritSceneTargetsTag) == 0x000008, "Member 'FInheritDataSetting::InheritSceneTargetsTag' has a wrong offset!");

// ScriptStruct Game.OnlineSeaMachineGunLevelRecord
// 0x0008 (0x0008 - 0x0000)
struct FOnlineSeaMachineGunLevelRecord final
{
public:
	int32                                         RoleId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaMachineGunLevelRecord) == 0x000004, "Wrong alignment on FOnlineSeaMachineGunLevelRecord");
static_assert(sizeof(FOnlineSeaMachineGunLevelRecord) == 0x000008, "Wrong size on FOnlineSeaMachineGunLevelRecord");
static_assert(offsetof(FOnlineSeaMachineGunLevelRecord, RoleId) == 0x000000, "Member 'FOnlineSeaMachineGunLevelRecord::RoleId' has a wrong offset!");
static_assert(offsetof(FOnlineSeaMachineGunLevelRecord, Count) == 0x000004, "Member 'FOnlineSeaMachineGunLevelRecord::Count' has a wrong offset!");

// ScriptStruct Game.ReinitCacheModifierInfo
// 0x0028 (0x0028 - 0x0000)
struct FReinitCacheModifierInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OuterObject;                                       // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  AbilityLauncher;                                   // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  AbilityTarget;                                     // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Overlaid;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReinitCacheModifierInfo) == 0x000008, "Wrong alignment on FReinitCacheModifierInfo");
static_assert(sizeof(FReinitCacheModifierInfo) == 0x000028, "Wrong size on FReinitCacheModifierInfo");
static_assert(offsetof(FReinitCacheModifierInfo, ID) == 0x000000, "Member 'FReinitCacheModifierInfo::ID' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, SkillID) == 0x000004, "Member 'FReinitCacheModifierInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, OuterObject) == 0x000008, "Member 'FReinitCacheModifierInfo::OuterObject' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, AbilityLauncher) == 0x000010, "Member 'FReinitCacheModifierInfo::AbilityLauncher' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, AbilityTarget) == 0x000018, "Member 'FReinitCacheModifierInfo::AbilityTarget' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, Overlaid) == 0x000020, "Member 'FReinitCacheModifierInfo::Overlaid' has a wrong offset!");
static_assert(offsetof(FReinitCacheModifierInfo, Level) == 0x000024, "Member 'FReinitCacheModifierInfo::Level' has a wrong offset!");

// ScriptStruct Game.PreviewMeshReplace_Accessory
// 0x0040 (0x0040 - 0x0000)
struct FPreviewMeshReplace_Accessory final
{
public:
	struct FSoftObjectPath                        SkeletalMeshPath;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SequencePath;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncOVRLipDataFromHead;                           // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewMeshReplace_Accessory) == 0x000008, "Wrong alignment on FPreviewMeshReplace_Accessory");
static_assert(sizeof(FPreviewMeshReplace_Accessory) == 0x000040, "Wrong size on FPreviewMeshReplace_Accessory");
static_assert(offsetof(FPreviewMeshReplace_Accessory, SkeletalMeshPath) == 0x000000, "Member 'FPreviewMeshReplace_Accessory::SkeletalMeshPath' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_Accessory, SequencePath) == 0x000018, "Member 'FPreviewMeshReplace_Accessory::SequencePath' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_Accessory, bAttach) == 0x000030, "Member 'FPreviewMeshReplace_Accessory::bAttach' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_Accessory, Socket) == 0x000034, "Member 'FPreviewMeshReplace_Accessory::Socket' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplace_Accessory, bSyncOVRLipDataFromHead) == 0x00003C, "Member 'FPreviewMeshReplace_Accessory::bSyncOVRLipDataFromHead' has a wrong offset!");

// ScriptStruct Game.PreviewMeshReplaceData
// 0x0078 (0x0078 - 0x0000)
struct FPreviewMeshReplaceData final
{
public:
	struct FPreviewMeshReplace_MainBody           MainBodyReplace;                                   // 0x0000(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FPreviewMeshReplace_Accessory>  AccessoryReplace;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewMeshReplaceData) == 0x000008, "Wrong alignment on FPreviewMeshReplaceData");
static_assert(sizeof(FPreviewMeshReplaceData) == 0x000078, "Wrong size on FPreviewMeshReplaceData");
static_assert(offsetof(FPreviewMeshReplaceData, MainBodyReplace) == 0x000000, "Member 'FPreviewMeshReplaceData::MainBodyReplace' has a wrong offset!");
static_assert(offsetof(FPreviewMeshReplaceData, AccessoryReplace) == 0x000068, "Member 'FPreviewMeshReplaceData::AccessoryReplace' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimSequenceConfigTemplate
// 0x0150 (0x0158 - 0x0008)
struct FPerformanceAnimSequenceConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceAnimMesh;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepReplaceAnimMesh;                              // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPreviewMeshReplaceData                PreviewMeshReplaceData;                            // 0x0018(0x0078)(Edit, NativeAccessSpecifierPublic)
	class FString                                 AnimName;                                          // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FacialAnimName;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClickInterupt;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimBlendInTime;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequenceBase>       AnimSeq;                                           // 0x00C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       AnimSeq_Facial;                                    // 0x00E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FacialAnimationDataID;                             // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FacialAnimationSectionRange;                       // 0x0114(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x0120(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceSectionStartTime;                             // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimFinishInteruptEffect;                         // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectId;                                          // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EffectSectionRange;                                // 0x013C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameCameraAnimMetaDataInfo*            CameraAnimationAsset;                              // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartCameraIndex;                                  // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndCameraIndex;                                    // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceAnimSequenceConfigTemplate) == 0x000008, "Wrong alignment on FPerformanceAnimSequenceConfigTemplate");
static_assert(sizeof(FPerformanceAnimSequenceConfigTemplate) == 0x000158, "Wrong size on FPerformanceAnimSequenceConfigTemplate");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, ID) == 0x000008, "Member 'FPerformanceAnimSequenceConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, CharacterID) == 0x00000C, "Member 'FPerformanceAnimSequenceConfigTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, bReplaceAnimMesh) == 0x000010, "Member 'FPerformanceAnimSequenceConfigTemplate::bReplaceAnimMesh' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, bKeepReplaceAnimMesh) == 0x000011, "Member 'FPerformanceAnimSequenceConfigTemplate::bKeepReplaceAnimMesh' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, PreviewMeshReplaceData) == 0x000018, "Member 'FPerformanceAnimSequenceConfigTemplate::PreviewMeshReplaceData' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, AnimName) == 0x000090, "Member 'FPerformanceAnimSequenceConfigTemplate::AnimName' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, FacialAnimName) == 0x0000A0, "Member 'FPerformanceAnimSequenceConfigTemplate::FacialAnimName' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, bClickInterupt) == 0x0000B0, "Member 'FPerformanceAnimSequenceConfigTemplate::bClickInterupt' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, AnimBlendInTime) == 0x0000B4, "Member 'FPerformanceAnimSequenceConfigTemplate::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, AnimBlendOutTime) == 0x0000B8, "Member 'FPerformanceAnimSequenceConfigTemplate::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, AnimSeq) == 0x0000C0, "Member 'FPerformanceAnimSequenceConfigTemplate::AnimSeq' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, AnimSeq_Facial) == 0x0000E8, "Member 'FPerformanceAnimSequenceConfigTemplate::AnimSeq_Facial' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, FacialAnimationDataID) == 0x000110, "Member 'FPerformanceAnimSequenceConfigTemplate::FacialAnimationDataID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, FacialAnimationSectionRange) == 0x000114, "Member 'FPerformanceAnimSequenceConfigTemplate::FacialAnimationSectionRange' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, VoiceID) == 0x000120, "Member 'FPerformanceAnimSequenceConfigTemplate::VoiceID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, VoiceSectionStartTime) == 0x000130, "Member 'FPerformanceAnimSequenceConfigTemplate::VoiceSectionStartTime' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, bAnimFinishInteruptEffect) == 0x000134, "Member 'FPerformanceAnimSequenceConfigTemplate::bAnimFinishInteruptEffect' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, EffectId) == 0x000138, "Member 'FPerformanceAnimSequenceConfigTemplate::EffectId' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, EffectSectionRange) == 0x00013C, "Member 'FPerformanceAnimSequenceConfigTemplate::EffectSectionRange' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, CameraAnimationAsset) == 0x000148, "Member 'FPerformanceAnimSequenceConfigTemplate::CameraAnimationAsset' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, StartCameraIndex) == 0x000150, "Member 'FPerformanceAnimSequenceConfigTemplate::StartCameraIndex' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceConfigTemplate, EndCameraIndex) == 0x000154, "Member 'FPerformanceAnimSequenceConfigTemplate::EndCameraIndex' has a wrong offset!");

// ScriptStruct Game.AIEvents
// 0x0028 (0x0030 - 0x0008)
struct FAIEvents final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventFuncList;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIEvents) == 0x000008, "Wrong alignment on FAIEvents");
static_assert(sizeof(FAIEvents) == 0x000030, "Wrong size on FAIEvents");
static_assert(offsetof(FAIEvents, ID) == 0x000008, "Member 'FAIEvents::ID' has a wrong offset!");
static_assert(offsetof(FAIEvents, Remark) == 0x000010, "Member 'FAIEvents::Remark' has a wrong offset!");
static_assert(offsetof(FAIEvents, EventFuncList) == 0x000020, "Member 'FAIEvents::EventFuncList' has a wrong offset!");

// ScriptStruct Game.FireBulletHit
// 0x0010 (0x0010 - 0x0000)
struct FFireBulletHit final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitTarget;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireBulletHit) == 0x000008, "Wrong alignment on FFireBulletHit");
static_assert(sizeof(FFireBulletHit) == 0x000010, "Wrong size on FFireBulletHit");
static_assert(offsetof(FFireBulletHit, HitTarget) == 0x000008, "Member 'FFireBulletHit::HitTarget' has a wrong offset!");

// ScriptStruct Game.TrapSpawnInfo
// 0x01B8 (0x01C0 - 0x0008)
struct FTrapSpawnInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         TrapType;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighLightBorder;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkillLevel;                                    // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePresetLevel;                                    // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapLimitLeaveChooseType                     TrapLimitLeaveChooseType;                          // 0x003F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFlexibleEnumValue                     CampType;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            LifeTime;                                          // 0x0048(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
	float                                         DeadKeepTime;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDestroyValue;                                  // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrowID;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMinion;                                           // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinionGrowID;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SummonerModifierIDs;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ECampRelation>                         Relations;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EAppointTargetType>                    AppointTarget;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPartOverlap;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnLeave;                                    // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BornSkill;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnterSubSkill;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 EnterModifierIDs;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         KeepingSubSkill;                                   // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplyModifierIntervalTime;                         // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntervalApplyModifierIDs;                          // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LeaveSubSkill;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeaveModifierID;                                   // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadSkill;                                         // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndSkill;                                          // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 EndRemoveModifiersID;                              // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseOwnerAttribute;                                // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttrackEnmity;                                    // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAoeSearch;                                        // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSearchAsCharacter;                                // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionSetting>              EndConditions;                                     // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseCharacterMovement;                             // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        SpawnParticlePath;                                 // 0x0158(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnSoundEvent;                                   // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EndParticlePath;                                   // 0x0180(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndSoundEvent;                                     // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkinReplaceMeshInfo>           SkinReplaceMesh;                                   // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrapSpawnInfo) == 0x000008, "Wrong alignment on FTrapSpawnInfo");
static_assert(sizeof(FTrapSpawnInfo) == 0x0001C0, "Wrong size on FTrapSpawnInfo");
static_assert(offsetof(FTrapSpawnInfo, ID) == 0x000008, "Member 'FTrapSpawnInfo::ID' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bRepaceData) == 0x00000C, "Member 'FTrapSpawnInfo::bRepaceData' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, ReplaceParamArray) == 0x000010, "Member 'FTrapSpawnInfo::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, TrapType) == 0x000020, "Member 'FTrapSpawnInfo::TrapType' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, Level) == 0x000038, "Member 'FTrapSpawnInfo::Level' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bHighLightBorder) == 0x00003C, "Member 'FTrapSpawnInfo::bHighLightBorder' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bUseSkillLevel) == 0x00003D, "Member 'FTrapSpawnInfo::bUseSkillLevel' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, UsePresetLevel) == 0x00003E, "Member 'FTrapSpawnInfo::UsePresetLevel' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, TrapLimitLeaveChooseType) == 0x00003F, "Member 'FTrapSpawnInfo::TrapLimitLeaveChooseType' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, CampType) == 0x000040, "Member 'FTrapSpawnInfo::CampType' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, LifeTime) == 0x000048, "Member 'FTrapSpawnInfo::LifeTime' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, DeadKeepTime) == 0x000098, "Member 'FTrapSpawnInfo::DeadKeepTime' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bUseDestroyValue) == 0x00009C, "Member 'FTrapSpawnInfo::bUseDestroyValue' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, GrowID) == 0x0000A0, "Member 'FTrapSpawnInfo::GrowID' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bMinion) == 0x0000A4, "Member 'FTrapSpawnInfo::bMinion' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, MinionGrowID) == 0x0000A8, "Member 'FTrapSpawnInfo::MinionGrowID' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, SummonerModifierIDs) == 0x0000B0, "Member 'FTrapSpawnInfo::SummonerModifierIDs' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, Relations) == 0x0000C0, "Member 'FTrapSpawnInfo::Relations' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, AppointTarget) == 0x0000D0, "Member 'FTrapSpawnInfo::AppointTarget' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bPartOverlap) == 0x0000E0, "Member 'FTrapSpawnInfo::bPartOverlap' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bRemoveOnLeave) == 0x0000E1, "Member 'FTrapSpawnInfo::bRemoveOnLeave' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, BornSkill) == 0x0000E4, "Member 'FTrapSpawnInfo::BornSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EnterSubSkill) == 0x0000E8, "Member 'FTrapSpawnInfo::EnterSubSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EnterModifierIDs) == 0x0000F0, "Member 'FTrapSpawnInfo::EnterModifierIDs' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, KeepingSubSkill) == 0x000100, "Member 'FTrapSpawnInfo::KeepingSubSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, ApplyModifierIntervalTime) == 0x000104, "Member 'FTrapSpawnInfo::ApplyModifierIntervalTime' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, IntervalApplyModifierIDs) == 0x000108, "Member 'FTrapSpawnInfo::IntervalApplyModifierIDs' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, LeaveSubSkill) == 0x000118, "Member 'FTrapSpawnInfo::LeaveSubSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, LeaveModifierID) == 0x00011C, "Member 'FTrapSpawnInfo::LeaveModifierID' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, DeadSkill) == 0x000120, "Member 'FTrapSpawnInfo::DeadSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EndSkill) == 0x000124, "Member 'FTrapSpawnInfo::EndSkill' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EndRemoveModifiersID) == 0x000128, "Member 'FTrapSpawnInfo::EndRemoveModifiersID' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bUseOwnerAttribute) == 0x000138, "Member 'FTrapSpawnInfo::bUseOwnerAttribute' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bAttrackEnmity) == 0x000139, "Member 'FTrapSpawnInfo::bAttrackEnmity' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bAoeSearch) == 0x00013A, "Member 'FTrapSpawnInfo::bAoeSearch' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bSearchAsCharacter) == 0x00013B, "Member 'FTrapSpawnInfo::bSearchAsCharacter' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EndConditions) == 0x000140, "Member 'FTrapSpawnInfo::EndConditions' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, bUseCharacterMovement) == 0x000150, "Member 'FTrapSpawnInfo::bUseCharacterMovement' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, SpawnParticlePath) == 0x000158, "Member 'FTrapSpawnInfo::SpawnParticlePath' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, SpawnSoundEvent) == 0x000170, "Member 'FTrapSpawnInfo::SpawnSoundEvent' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EndParticlePath) == 0x000180, "Member 'FTrapSpawnInfo::EndParticlePath' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, EndSoundEvent) == 0x000198, "Member 'FTrapSpawnInfo::EndSoundEvent' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, SurfaceType) == 0x0001A8, "Member 'FTrapSpawnInfo::SurfaceType' has a wrong offset!");
static_assert(offsetof(FTrapSpawnInfo, SkinReplaceMesh) == 0x0001B0, "Member 'FTrapSpawnInfo::SkinReplaceMesh' has a wrong offset!");

// ScriptStruct Game.UMG3DPrimitiveCacheInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FUMG3DPrimitiveCacheInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUMG3DPrimitiveCacheInfo) == 0x000004, "Wrong alignment on FUMG3DPrimitiveCacheInfo");
static_assert(sizeof(FUMG3DPrimitiveCacheInfo) == 0x00000C, "Wrong size on FUMG3DPrimitiveCacheInfo");

// ScriptStruct Game.UMG3DActorCacheInfo
// 0x0018 (0x0018 - 0x0000)
struct FUMG3DActorCacheInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUMG3DPrimitiveCacheInfo>       Primitives;                                        // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUMG3DActorCacheInfo) == 0x000008, "Wrong alignment on FUMG3DActorCacheInfo");
static_assert(sizeof(FUMG3DActorCacheInfo) == 0x000018, "Wrong size on FUMG3DActorCacheInfo");
static_assert(offsetof(FUMG3DActorCacheInfo, Actor) == 0x000000, "Member 'FUMG3DActorCacheInfo::Actor' has a wrong offset!");
static_assert(offsetof(FUMG3DActorCacheInfo, Primitives) == 0x000008, "Member 'FUMG3DActorCacheInfo::Primitives' has a wrong offset!");

// ScriptStruct Game.BulletRotator
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FBulletRotator final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletRotator) == 0x000010, "Wrong alignment on FBulletRotator");
static_assert(sizeof(FBulletRotator) == 0x000060, "Wrong size on FBulletRotator");

// ScriptStruct Game.BulletCustomTrack
// 0x0048 (0x0050 - 0x0008)
struct alignas(0x10) FBulletCustomTrack final : public FTableRowBase
{
public:
	class UCurveVector*                           Curve;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x33];                                      // 0x001D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletCustomTrack) == 0x000010, "Wrong alignment on FBulletCustomTrack");
static_assert(sizeof(FBulletCustomTrack) == 0x000050, "Wrong size on FBulletCustomTrack");
static_assert(offsetof(FBulletCustomTrack, Curve) == 0x000008, "Member 'FBulletCustomTrack::Curve' has a wrong offset!");
static_assert(offsetof(FBulletCustomTrack, Scale) == 0x000010, "Member 'FBulletCustomTrack::Scale' has a wrong offset!");
static_assert(offsetof(FBulletCustomTrack, IsLoop) == 0x00001C, "Member 'FBulletCustomTrack::IsLoop' has a wrong offset!");

// ScriptStruct Game.BulletCircle
// 0x00C0 (0x00C0 - 0x0000)
struct FBulletCircle final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center1;                                           // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotDir;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusSpeed;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusTime;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FollowParentBullet;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CenterMoveSpeed;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterMoveRealPos;                                // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixedRadius;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedRadius;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleSpeed;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContractionMinDegree;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContractionMaxDegree;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InRadiusSpeedCurve;                                // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center2;                                           // 0x0058(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RealCenter;                                        // 0x0064(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentAngle;                                      // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EllipseB;                                          // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetDistance;                                    // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  OffsetQuat;                                        // 0x0090(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AxisOffsetQuat;                                    // 0x00A0(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsStartContraction;                               // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RadiusSpeedCurve;                                  // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletCircle) == 0x000010, "Wrong alignment on FBulletCircle");
static_assert(sizeof(FBulletCircle) == 0x0000C0, "Wrong size on FBulletCircle");
static_assert(offsetof(FBulletCircle, Center) == 0x000000, "Member 'FBulletCircle::Center' has a wrong offset!");
static_assert(offsetof(FBulletCircle, Center1) == 0x00000C, "Member 'FBulletCircle::Center1' has a wrong offset!");
static_assert(offsetof(FBulletCircle, Axis) == 0x000018, "Member 'FBulletCircle::Axis' has a wrong offset!");
static_assert(offsetof(FBulletCircle, RotDir) == 0x000024, "Member 'FBulletCircle::RotDir' has a wrong offset!");
static_assert(offsetof(FBulletCircle, RadiusSpeed) == 0x000028, "Member 'FBulletCircle::RadiusSpeed' has a wrong offset!");
static_assert(offsetof(FBulletCircle, RadiusTime) == 0x00002C, "Member 'FBulletCircle::RadiusTime' has a wrong offset!");
static_assert(offsetof(FBulletCircle, FollowParentBullet) == 0x000030, "Member 'FBulletCircle::FollowParentBullet' has a wrong offset!");
static_assert(offsetof(FBulletCircle, CenterMoveSpeed) == 0x000034, "Member 'FBulletCircle::CenterMoveSpeed' has a wrong offset!");
static_assert(offsetof(FBulletCircle, bCenterMoveRealPos) == 0x000038, "Member 'FBulletCircle::bCenterMoveRealPos' has a wrong offset!");
static_assert(offsetof(FBulletCircle, bFixedRadius) == 0x000039, "Member 'FBulletCircle::bFixedRadius' has a wrong offset!");
static_assert(offsetof(FBulletCircle, FixedRadius) == 0x00003C, "Member 'FBulletCircle::FixedRadius' has a wrong offset!");
static_assert(offsetof(FBulletCircle, AngleSpeed) == 0x000040, "Member 'FBulletCircle::AngleSpeed' has a wrong offset!");
static_assert(offsetof(FBulletCircle, ContractionMinDegree) == 0x000044, "Member 'FBulletCircle::ContractionMinDegree' has a wrong offset!");
static_assert(offsetof(FBulletCircle, ContractionMaxDegree) == 0x000048, "Member 'FBulletCircle::ContractionMaxDegree' has a wrong offset!");
static_assert(offsetof(FBulletCircle, InRadiusSpeedCurve) == 0x000050, "Member 'FBulletCircle::InRadiusSpeedCurve' has a wrong offset!");
static_assert(offsetof(FBulletCircle, Center2) == 0x000058, "Member 'FBulletCircle::Center2' has a wrong offset!");
static_assert(offsetof(FBulletCircle, RealCenter) == 0x000064, "Member 'FBulletCircle::RealCenter' has a wrong offset!");
static_assert(offsetof(FBulletCircle, CurrentAngle) == 0x000070, "Member 'FBulletCircle::CurrentAngle' has a wrong offset!");
static_assert(offsetof(FBulletCircle, EllipseB) == 0x000074, "Member 'FBulletCircle::EllipseB' has a wrong offset!");
static_assert(offsetof(FBulletCircle, Radius) == 0x000078, "Member 'FBulletCircle::Radius' has a wrong offset!");
static_assert(offsetof(FBulletCircle, Speed) == 0x00007C, "Member 'FBulletCircle::Speed' has a wrong offset!");
static_assert(offsetof(FBulletCircle, OffsetDistance) == 0x000080, "Member 'FBulletCircle::OffsetDistance' has a wrong offset!");
static_assert(offsetof(FBulletCircle, OffsetQuat) == 0x000090, "Member 'FBulletCircle::OffsetQuat' has a wrong offset!");
static_assert(offsetof(FBulletCircle, AxisOffsetQuat) == 0x0000A0, "Member 'FBulletCircle::AxisOffsetQuat' has a wrong offset!");
static_assert(offsetof(FBulletCircle, bIsStartContraction) == 0x0000B0, "Member 'FBulletCircle::bIsStartContraction' has a wrong offset!");
static_assert(offsetof(FBulletCircle, RadiusSpeedCurve) == 0x0000B8, "Member 'FBulletCircle::RadiusSpeedCurve' has a wrong offset!");

// ScriptStruct Game.BulletThroughData
// 0x0018 (0x0018 - 0x0000)
struct FBulletThroughData final
{
public:
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQueryResult>                   AllThroughData;                                    // 0x0008(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletThroughData) == 0x000008, "Wrong alignment on FBulletThroughData");
static_assert(sizeof(FBulletThroughData) == 0x000018, "Wrong size on FBulletThroughData");
static_assert(offsetof(FBulletThroughData, Target) == 0x000000, "Member 'FBulletThroughData::Target' has a wrong offset!");
static_assert(offsetof(FBulletThroughData, AllThroughData) == 0x000008, "Member 'FBulletThroughData::AllThroughData' has a wrong offset!");

// ScriptStruct Game.BulletRebound
// 0x000C (0x000C - 0x0000)
struct FBulletRebound final
{
public:
	bool                                          Rebound;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReboundCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletReboundType                            ReboundType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletReboundDirection                       Direction;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletRebound) == 0x000004, "Wrong alignment on FBulletRebound");
static_assert(sizeof(FBulletRebound) == 0x00000C, "Wrong size on FBulletRebound");
static_assert(offsetof(FBulletRebound, Rebound) == 0x000000, "Member 'FBulletRebound::Rebound' has a wrong offset!");
static_assert(offsetof(FBulletRebound, ReboundCount) == 0x000004, "Member 'FBulletRebound::ReboundCount' has a wrong offset!");
static_assert(offsetof(FBulletRebound, ReboundType) == 0x000008, "Member 'FBulletRebound::ReboundType' has a wrong offset!");
static_assert(offsetof(FBulletRebound, Direction) == 0x000009, "Member 'FBulletRebound::Direction' has a wrong offset!");

// ScriptStruct Game.HitEffect
// 0x0088 (0x0088 - 0x0000)
struct FHitEffect final
{
public:
	EPhysicalSurface                              Surface;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCompositeParticlePath;                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ParticlePath;                                      // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          buseCompositeWeaknessParticlePath;                 // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        WeaknessParticlePath;                              // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParticleScale;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundEventName;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DecalMaterialPath;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalLifetime;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalFadeOutTime;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitEffect) == 0x000008, "Wrong alignment on FHitEffect");
static_assert(sizeof(FHitEffect) == 0x000088, "Wrong size on FHitEffect");
static_assert(offsetof(FHitEffect, Surface) == 0x000000, "Member 'FHitEffect::Surface' has a wrong offset!");
static_assert(offsetof(FHitEffect, bUseCompositeParticlePath) == 0x000001, "Member 'FHitEffect::bUseCompositeParticlePath' has a wrong offset!");
static_assert(offsetof(FHitEffect, ParticlePath) == 0x000008, "Member 'FHitEffect::ParticlePath' has a wrong offset!");
static_assert(offsetof(FHitEffect, buseCompositeWeaknessParticlePath) == 0x000020, "Member 'FHitEffect::buseCompositeWeaknessParticlePath' has a wrong offset!");
static_assert(offsetof(FHitEffect, WeaknessParticlePath) == 0x000028, "Member 'FHitEffect::WeaknessParticlePath' has a wrong offset!");
static_assert(offsetof(FHitEffect, ParticleScale) == 0x000040, "Member 'FHitEffect::ParticleScale' has a wrong offset!");
static_assert(offsetof(FHitEffect, SoundEventName) == 0x000048, "Member 'FHitEffect::SoundEventName' has a wrong offset!");
static_assert(offsetof(FHitEffect, SoundVolume) == 0x000058, "Member 'FHitEffect::SoundVolume' has a wrong offset!");
static_assert(offsetof(FHitEffect, DecalSize) == 0x00005C, "Member 'FHitEffect::DecalSize' has a wrong offset!");
static_assert(offsetof(FHitEffect, DecalMaterialPath) == 0x000068, "Member 'FHitEffect::DecalMaterialPath' has a wrong offset!");
static_assert(offsetof(FHitEffect, DecalLifetime) == 0x000080, "Member 'FHitEffect::DecalLifetime' has a wrong offset!");
static_assert(offsetof(FHitEffect, DecalFadeOutTime) == 0x000084, "Member 'FHitEffect::DecalFadeOutTime' has a wrong offset!");

// ScriptStruct Game.HitEffectGroup
// 0x00D8 (0x00E0 - 0x0008)
struct FHitEffectGroup final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitEffectEventName;                                // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitEffect                             Defaults;                                          // 0x0030(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHitEffect>                     Effects;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 SoundElementSwitch;                                // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffect;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitEffectGroup) == 0x000008, "Wrong alignment on FHitEffectGroup");
static_assert(sizeof(FHitEffectGroup) == 0x0000E0, "Wrong size on FHitEffectGroup");
static_assert(offsetof(FHitEffectGroup, ID) == 0x000008, "Member 'FHitEffectGroup::ID' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, Comment) == 0x000010, "Member 'FHitEffectGroup::Comment' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, HitEffectEventName) == 0x000020, "Member 'FHitEffectGroup::HitEffectEventName' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, Defaults) == 0x000030, "Member 'FHitEffectGroup::Defaults' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, Effects) == 0x0000B8, "Member 'FHitEffectGroup::Effects' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, SoundElementSwitch) == 0x0000C8, "Member 'FHitEffectGroup::SoundElementSwitch' has a wrong offset!");
static_assert(offsetof(FHitEffectGroup, bReplaceEffect) == 0x0000D8, "Member 'FHitEffectGroup::bReplaceEffect' has a wrong offset!");

// ScriptStruct Game.StateBlockCommitInfo
// 0x0018 (0x0020 - 0x0008)
struct FStateBlockCommitInfo final : public FTableRowBase
{
public:
	class FName                                   TypeName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StateNames;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateBlockCommitInfo) == 0x000008, "Wrong alignment on FStateBlockCommitInfo");
static_assert(sizeof(FStateBlockCommitInfo) == 0x000020, "Wrong size on FStateBlockCommitInfo");
static_assert(offsetof(FStateBlockCommitInfo, TypeName) == 0x000008, "Member 'FStateBlockCommitInfo::TypeName' has a wrong offset!");
static_assert(offsetof(FStateBlockCommitInfo, StateNames) == 0x000010, "Member 'FStateBlockCommitInfo::StateNames' has a wrong offset!");

// ScriptStruct Game.StateBlockInfo
// 0x0038 (0x0038 - 0x0000)
struct FStateBlockInfo final
{
public:
	int32                                         AbnormalState;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AbilityState;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DeActiveAbilityState;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0018(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateBlockInfo) == 0x000008, "Wrong alignment on FStateBlockInfo");
static_assert(sizeof(FStateBlockInfo) == 0x000038, "Wrong size on FStateBlockInfo");
static_assert(offsetof(FStateBlockInfo, AbnormalState) == 0x000000, "Member 'FStateBlockInfo::AbnormalState' has a wrong offset!");
static_assert(offsetof(FStateBlockInfo, AbilityState) == 0x000008, "Member 'FStateBlockInfo::AbilityState' has a wrong offset!");
static_assert(offsetof(FStateBlockInfo, DeActiveAbilityState) == 0x000010, "Member 'FStateBlockInfo::DeActiveAbilityState' has a wrong offset!");
static_assert(offsetof(FStateBlockInfo, TagContainer) == 0x000018, "Member 'FStateBlockInfo::TagContainer' has a wrong offset!");

// ScriptStruct Game.StateBlockSettingInfo
// 0x0030 (0x0038 - 0x0008)
struct FStateBlockSettingInfo final : public FTableRowBase
{
public:
	class FName                                   BlockTypeName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStateBlockInfo>                Infos;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateBlockSettingInfo) == 0x000008, "Wrong alignment on FStateBlockSettingInfo");
static_assert(sizeof(FStateBlockSettingInfo) == 0x000038, "Wrong size on FStateBlockSettingInfo");
static_assert(offsetof(FStateBlockSettingInfo, BlockTypeName) == 0x000008, "Member 'FStateBlockSettingInfo::BlockTypeName' has a wrong offset!");
static_assert(offsetof(FStateBlockSettingInfo, Infos) == 0x000010, "Member 'FStateBlockSettingInfo::Infos' has a wrong offset!");

// ScriptStruct Game.OnlineTDSkillPacket
// 0x0060 (0x0060 - 0x0000)
struct FOnlineTDSkillPacket final
{
public:
	EBaseSkillOpCode                              OpCode;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamValue;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamValue2;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediate;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreLevelId;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDDuty                                 DutyType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPersonal;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRespawnTeam;                                     // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGamePlayerState*>               ActivedPlayerStates;                               // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Dlc10SkillId;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EffectDesc;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDSkillPacket) == 0x000008, "Wrong alignment on FOnlineTDSkillPacket");
static_assert(sizeof(FOnlineTDSkillPacket) == 0x000060, "Wrong size on FOnlineTDSkillPacket");
static_assert(offsetof(FOnlineTDSkillPacket, OpCode) == 0x000000, "Member 'FOnlineTDSkillPacket::OpCode' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, Tag) == 0x000008, "Member 'FOnlineTDSkillPacket::Tag' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, BuffId) == 0x000018, "Member 'FOnlineTDSkillPacket::BuffId' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, SkillID) == 0x00001C, "Member 'FOnlineTDSkillPacket::SkillID' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, ParamValue) == 0x000020, "Member 'FOnlineTDSkillPacket::ParamValue' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, ParamValue2) == 0x000024, "Member 'FOnlineTDSkillPacket::ParamValue2' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, Immediate) == 0x000028, "Member 'FOnlineTDSkillPacket::Immediate' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, PreLevelId) == 0x00002C, "Member 'FOnlineTDSkillPacket::PreLevelId' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, DutyType) == 0x000030, "Member 'FOnlineTDSkillPacket::DutyType' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, IsPersonal) == 0x000031, "Member 'FOnlineTDSkillPacket::IsPersonal' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, IsRespawnTeam) == 0x000032, "Member 'FOnlineTDSkillPacket::IsRespawnTeam' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, ActivedPlayerStates) == 0x000038, "Member 'FOnlineTDSkillPacket::ActivedPlayerStates' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, Dlc10SkillId) == 0x000048, "Member 'FOnlineTDSkillPacket::Dlc10SkillId' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillPacket, EffectDesc) == 0x000050, "Member 'FOnlineTDSkillPacket::EffectDesc' has a wrong offset!");

// ScriptStruct Game.DamageValueData
// 0x0018 (0x0018 - 0x0000)
struct FDamageValueData final
{
public:
	float                                         DamageValue;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyBunkerValue;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElemExplosionValue;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEnergy;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalHitEnergy;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillIntensity;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageValueData) == 0x000004, "Wrong alignment on FDamageValueData");
static_assert(sizeof(FDamageValueData) == 0x000018, "Wrong size on FDamageValueData");
static_assert(offsetof(FDamageValueData, DamageValue) == 0x000000, "Member 'FDamageValueData::DamageValue' has a wrong offset!");
static_assert(offsetof(FDamageValueData, DestroyBunkerValue) == 0x000004, "Member 'FDamageValueData::DestroyBunkerValue' has a wrong offset!");
static_assert(offsetof(FDamageValueData, ElemExplosionValue) == 0x000008, "Member 'FDamageValueData::ElemExplosionValue' has a wrong offset!");
static_assert(offsetof(FDamageValueData, HitEnergy) == 0x00000C, "Member 'FDamageValueData::HitEnergy' has a wrong offset!");
static_assert(offsetof(FDamageValueData, CriticalHitEnergy) == 0x000010, "Member 'FDamageValueData::CriticalHitEnergy' has a wrong offset!");
static_assert(offsetof(FDamageValueData, SkillIntensity) == 0x000014, "Member 'FDamageValueData::SkillIntensity' has a wrong offset!");

// ScriptStruct Game.OutDamageValueInfo
// 0x0108 (0x0110 - 0x0008)
struct FOutDamageValueInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            FixValue;                                          // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributeFunc;                                 // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributeParams;                               // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAbilityAttribute*                      AttributeClass;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetAttribute;                               // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSummoner;                                      // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            AttributePercent;                                  // 0x0098(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CalcAttributePerFunc;                              // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     CalcAttributePerParams;                            // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutDamageValueInfo) == 0x000008, "Wrong alignment on FOutDamageValueInfo");
static_assert(sizeof(FOutDamageValueInfo) == 0x000110, "Wrong size on FOutDamageValueInfo");
static_assert(offsetof(FOutDamageValueInfo, ID) == 0x000008, "Member 'FOutDamageValueInfo::ID' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, FixValue) == 0x000010, "Member 'FOutDamageValueInfo::FixValue' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, CalcAttributeFunc) == 0x000060, "Member 'FOutDamageValueInfo::CalcAttributeFunc' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, CalcAttributeParams) == 0x000078, "Member 'FOutDamageValueInfo::CalcAttributeParams' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, AttributeClass) == 0x000088, "Member 'FOutDamageValueInfo::AttributeClass' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, bUseTargetAttribute) == 0x000090, "Member 'FOutDamageValueInfo::bUseTargetAttribute' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, bUseSummoner) == 0x000091, "Member 'FOutDamageValueInfo::bUseSummoner' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, AttributePercent) == 0x000098, "Member 'FOutDamageValueInfo::AttributePercent' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, CalcAttributePerFunc) == 0x0000E8, "Member 'FOutDamageValueInfo::CalcAttributePerFunc' has a wrong offset!");
static_assert(offsetof(FOutDamageValueInfo, CalcAttributePerParams) == 0x000100, "Member 'FOutDamageValueInfo::CalcAttributePerParams' has a wrong offset!");

// ScriptStruct Game.AttributeStructDescription
// 0x0020 (0x0028 - 0x0008)
struct FAttributeStructDescription final : public FTableRowBase
{
public:
	class FString                                 NameDesc;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityAttribute*                      AttributeClass;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValueIsPercent;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMax;                                           // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamAttribute;                                    // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponAttribute;                                  // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeStructDescription) == 0x000008, "Wrong alignment on FAttributeStructDescription");
static_assert(sizeof(FAttributeStructDescription) == 0x000028, "Wrong size on FAttributeStructDescription");
static_assert(offsetof(FAttributeStructDescription, NameDesc) == 0x000008, "Member 'FAttributeStructDescription::NameDesc' has a wrong offset!");
static_assert(offsetof(FAttributeStructDescription, AttributeClass) == 0x000018, "Member 'FAttributeStructDescription::AttributeClass' has a wrong offset!");
static_assert(offsetof(FAttributeStructDescription, bValueIsPercent) == 0x000020, "Member 'FAttributeStructDescription::bValueIsPercent' has a wrong offset!");
static_assert(offsetof(FAttributeStructDescription, bUseMax) == 0x000021, "Member 'FAttributeStructDescription::bUseMax' has a wrong offset!");
static_assert(offsetof(FAttributeStructDescription, bTeamAttribute) == 0x000022, "Member 'FAttributeStructDescription::bTeamAttribute' has a wrong offset!");
static_assert(offsetof(FAttributeStructDescription, bWeaponAttribute) == 0x000023, "Member 'FAttributeStructDescription::bWeaponAttribute' has a wrong offset!");

// ScriptStruct Game.BulletBombResult
// 0x0120 (0x0120 - 0x0000)
struct FBulletBombResult final
{
public:
	struct FQueryResult                           QueryResult;                                       // 0x0000(0x0090)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x008C)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletBombResult) == 0x000008, "Wrong alignment on FBulletBombResult");
static_assert(sizeof(FBulletBombResult) == 0x000120, "Wrong size on FBulletBombResult");
static_assert(offsetof(FBulletBombResult, QueryResult) == 0x000000, "Member 'FBulletBombResult::QueryResult' has a wrong offset!");
static_assert(offsetof(FBulletBombResult, HitResult) == 0x000090, "Member 'FBulletBombResult::HitResult' has a wrong offset!");

// ScriptStruct Game.ModifierExhibitionData
// 0x007C (0x0088 - 0x000C)
struct FModifierExhibitionData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  Luancher;                                          // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Target;                                            // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierID;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierRunTimeID;                                 // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LauncherCharacterHashIndex;                        // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ModifierClassTag;                                  // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeRemain;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoRemoveOneTimeRemain;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentOverlaid;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxOverlaid;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextXBulletCount;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUI;                                           // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneResult                            ApplyBoneInfo;                                     // 0x0050(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseTime;                                        // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoved;                                          // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierExhibitionData) == 0x000008, "Wrong alignment on FModifierExhibitionData");
static_assert(sizeof(FModifierExhibitionData) == 0x000088, "Wrong size on FModifierExhibitionData");
static_assert(offsetof(FModifierExhibitionData, Luancher) == 0x000010, "Member 'FModifierExhibitionData::Luancher' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, Target) == 0x000018, "Member 'FModifierExhibitionData::Target' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, ModifierID) == 0x000020, "Member 'FModifierExhibitionData::ModifierID' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, ModifierRunTimeID) == 0x000024, "Member 'FModifierExhibitionData::ModifierRunTimeID' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, LauncherCharacterHashIndex) == 0x000028, "Member 'FModifierExhibitionData::LauncherCharacterHashIndex' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, ModifierClassTag) == 0x00002C, "Member 'FModifierExhibitionData::ModifierClassTag' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, LifeTimeRemain) == 0x000034, "Member 'FModifierExhibitionData::LifeTimeRemain' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, LifeTime) == 0x000038, "Member 'FModifierExhibitionData::LifeTime' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, AutoRemoveOneTimeRemain) == 0x00003C, "Member 'FModifierExhibitionData::AutoRemoveOneTimeRemain' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, CurrentOverlaid) == 0x000040, "Member 'FModifierExhibitionData::CurrentOverlaid' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, MaxOverlaid) == 0x000044, "Member 'FModifierExhibitionData::MaxOverlaid' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, NextXBulletCount) == 0x000048, "Member 'FModifierExhibitionData::NextXBulletCount' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, bShowUI) == 0x00004C, "Member 'FModifierExhibitionData::bShowUI' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, ApplyBoneInfo) == 0x000050, "Member 'FModifierExhibitionData::ApplyBoneInfo' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, bPauseTime) == 0x000080, "Member 'FModifierExhibitionData::bPauseTime' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionData, bRemoved) == 0x000081, "Member 'FModifierExhibitionData::bRemoved' has a wrong offset!");

// ScriptStruct Game.ModifierExhibitionDataArray
// 0x0018 (0x0120 - 0x0108)
struct FModifierExhibitionDataArray final : public FFastArraySerializer
{
public:
	TArray<struct FModifierExhibitionData>        ModifierExhibitionDatas;                           // 0x0108(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  TargetAbility;                                     // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierExhibitionDataArray) == 0x000008, "Wrong alignment on FModifierExhibitionDataArray");
static_assert(sizeof(FModifierExhibitionDataArray) == 0x000120, "Wrong size on FModifierExhibitionDataArray");
static_assert(offsetof(FModifierExhibitionDataArray, ModifierExhibitionDatas) == 0x000108, "Member 'FModifierExhibitionDataArray::ModifierExhibitionDatas' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionDataArray, TargetAbility) == 0x000118, "Member 'FModifierExhibitionDataArray::TargetAbility' has a wrong offset!");

// ScriptStruct Game.PatrolExploreItemTemplate
// 0x0010 (0x0018 - 0x0008)
struct FPatrolExploreItemTemplate final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpenWorldExploreType                         Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ObjectId;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolExploreItemTemplate) == 0x000008, "Wrong alignment on FPatrolExploreItemTemplate");
static_assert(sizeof(FPatrolExploreItemTemplate) == 0x000018, "Wrong size on FPatrolExploreItemTemplate");
static_assert(offsetof(FPatrolExploreItemTemplate, Name) == 0x000008, "Member 'FPatrolExploreItemTemplate::Name' has a wrong offset!");
static_assert(offsetof(FPatrolExploreItemTemplate, Type) == 0x000010, "Member 'FPatrolExploreItemTemplate::Type' has a wrong offset!");
static_assert(offsetof(FPatrolExploreItemTemplate, ObjectId) == 0x000014, "Member 'FPatrolExploreItemTemplate::ObjectId' has a wrong offset!");

// ScriptStruct Game.ModifierExhibitionRemoveData
// 0x0008 (0x0008 - 0x0000)
struct FModifierExhibitionRemoveData final
{
public:
	int32                                         ModifierRunTimeID;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierRemoveSourceType                     RemoveSourceType;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierExhibitionRemoveData) == 0x000004, "Wrong alignment on FModifierExhibitionRemoveData");
static_assert(sizeof(FModifierExhibitionRemoveData) == 0x000008, "Wrong size on FModifierExhibitionRemoveData");
static_assert(offsetof(FModifierExhibitionRemoveData, ModifierRunTimeID) == 0x000000, "Member 'FModifierExhibitionRemoveData::ModifierRunTimeID' has a wrong offset!");
static_assert(offsetof(FModifierExhibitionRemoveData, RemoveSourceType) == 0x000004, "Member 'FModifierExhibitionRemoveData::RemoveSourceType' has a wrong offset!");

// ScriptStruct Game.QueryExcuInfo
// 0x0040 (0x0040 - 0x0000)
struct FQueryExcuInfo final
{
public:
	TArray<class AActor*>                         RelationError;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutRange;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CanNotApplyAOE;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         EmitterCannotApply;                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueryExcuInfo) == 0x000008, "Wrong alignment on FQueryExcuInfo");
static_assert(sizeof(FQueryExcuInfo) == 0x000040, "Wrong size on FQueryExcuInfo");
static_assert(offsetof(FQueryExcuInfo, RelationError) == 0x000000, "Member 'FQueryExcuInfo::RelationError' has a wrong offset!");
static_assert(offsetof(FQueryExcuInfo, OutRange) == 0x000010, "Member 'FQueryExcuInfo::OutRange' has a wrong offset!");
static_assert(offsetof(FQueryExcuInfo, CanNotApplyAOE) == 0x000020, "Member 'FQueryExcuInfo::CanNotApplyAOE' has a wrong offset!");
static_assert(offsetof(FQueryExcuInfo, EmitterCannotApply) == 0x000030, "Member 'FQueryExcuInfo::EmitterCannotApply' has a wrong offset!");

// ScriptStruct Game.TargetsQueryInfo
// 0x0088 (0x0088 - 0x0000)
struct FTargetsQueryInfo final
{
public:
	TArray<ESearchTargetType>                     InvalidSearchType;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EQueryTargetType>                      QueryTargetTypes;                                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseRelationCheck;                                 // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECampRelation>                         CampRelations;                                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EApplyLocationType                            LocationType;                                      // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandRadius;                                        // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 RequireModifierIDs;                                // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RequireModifiersTagClass;                          // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockModifiers;                                    // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlockModifiersTagClass;                            // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USkillEmitter*                          EmitterQuerier;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetsQueryInfo) == 0x000008, "Wrong alignment on FTargetsQueryInfo");
static_assert(sizeof(FTargetsQueryInfo) == 0x000088, "Wrong size on FTargetsQueryInfo");
static_assert(offsetof(FTargetsQueryInfo, InvalidSearchType) == 0x000000, "Member 'FTargetsQueryInfo::InvalidSearchType' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, QueryTargetTypes) == 0x000010, "Member 'FTargetsQueryInfo::QueryTargetTypes' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, bUseRelationCheck) == 0x000020, "Member 'FTargetsQueryInfo::bUseRelationCheck' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, CampRelations) == 0x000028, "Member 'FTargetsQueryInfo::CampRelations' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, LocationType) == 0x000038, "Member 'FTargetsQueryInfo::LocationType' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, RandRadius) == 0x00003C, "Member 'FTargetsQueryInfo::RandRadius' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, RequireModifierIDs) == 0x000040, "Member 'FTargetsQueryInfo::RequireModifierIDs' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, RequireModifiersTagClass) == 0x000050, "Member 'FTargetsQueryInfo::RequireModifiersTagClass' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, BlockModifiers) == 0x000060, "Member 'FTargetsQueryInfo::BlockModifiers' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, BlockModifiersTagClass) == 0x000070, "Member 'FTargetsQueryInfo::BlockModifiersTagClass' has a wrong offset!");
static_assert(offsetof(FTargetsQueryInfo, EmitterQuerier) == 0x000080, "Member 'FTargetsQueryInfo::EmitterQuerier' has a wrong offset!");

// ScriptStruct Game.SkillDescribeValue
// 0x0020 (0x0020 - 0x0000)
struct FSkillDescribeValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StrValue;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumber;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillDescribeValue) == 0x000008, "Wrong alignment on FSkillDescribeValue");
static_assert(sizeof(FSkillDescribeValue) == 0x000020, "Wrong size on FSkillDescribeValue");
static_assert(offsetof(FSkillDescribeValue, Value) == 0x000000, "Member 'FSkillDescribeValue::Value' has a wrong offset!");
static_assert(offsetof(FSkillDescribeValue, StrValue) == 0x000008, "Member 'FSkillDescribeValue::StrValue' has a wrong offset!");
static_assert(offsetof(FSkillDescribeValue, bNumber) == 0x000018, "Member 'FSkillDescribeValue::bNumber' has a wrong offset!");

// ScriptStruct Game.GameWidgetComponentInstanceData
// 0x0010 (0x00C8 - 0x00B8)
struct FGameWidgetComponentInstanceData final : public FSceneComponentInstanceData
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWidgetComponentInstanceData) == 0x000008, "Wrong alignment on FGameWidgetComponentInstanceData");
static_assert(sizeof(FGameWidgetComponentInstanceData) == 0x0000C8, "Wrong size on FGameWidgetComponentInstanceData");

// ScriptStruct Game.SkillCollisionExcuInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FSkillCollisionExcuInfo final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRunTimeID;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CasterName;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CollisionTriggerTag;                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 EffectEmitter;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             OverlapResults;                                    // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             ApplyResults;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSortTypeExcuInfo                      SortExcuInfo;                                      // 0x0060(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillCollisionExcuInfo) == 0x000008, "Wrong alignment on FSkillCollisionExcuInfo");
static_assert(sizeof(FSkillCollisionExcuInfo) == 0x0000D8, "Wrong size on FSkillCollisionExcuInfo");
static_assert(offsetof(FSkillCollisionExcuInfo, ActiveTime) == 0x000000, "Member 'FSkillCollisionExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, SkillID) == 0x000004, "Member 'FSkillCollisionExcuInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, SkillRunTimeID) == 0x000008, "Member 'FSkillCollisionExcuInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, CasterName) == 0x000010, "Member 'FSkillCollisionExcuInfo::CasterName' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, CollisionTriggerTag) == 0x000020, "Member 'FSkillCollisionExcuInfo::CollisionTriggerTag' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, EffectEmitter) == 0x000030, "Member 'FSkillCollisionExcuInfo::EffectEmitter' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, OverlapResults) == 0x000040, "Member 'FSkillCollisionExcuInfo::OverlapResults' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, ApplyResults) == 0x000050, "Member 'FSkillCollisionExcuInfo::ApplyResults' has a wrong offset!");
static_assert(offsetof(FSkillCollisionExcuInfo, SortExcuInfo) == 0x000060, "Member 'FSkillCollisionExcuInfo::SortExcuInfo' has a wrong offset!");

// ScriptStruct Game.SkillExcuInfo
// 0x0038 (0x0038 - 0x0000)
struct FSkillExcuInfo final
{
public:
	int32                                         InfoType;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveTime;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillID;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillRunTimeID;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CasterName;                                        // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillExcuInfo) == 0x000008, "Wrong alignment on FSkillExcuInfo");
static_assert(sizeof(FSkillExcuInfo) == 0x000038, "Wrong size on FSkillExcuInfo");
static_assert(offsetof(FSkillExcuInfo, InfoType) == 0x000000, "Member 'FSkillExcuInfo::InfoType' has a wrong offset!");
static_assert(offsetof(FSkillExcuInfo, ActiveTime) == 0x000004, "Member 'FSkillExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FSkillExcuInfo, SkillID) == 0x000008, "Member 'FSkillExcuInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FSkillExcuInfo, SkillRunTimeID) == 0x000018, "Member 'FSkillExcuInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FSkillExcuInfo, CasterName) == 0x000028, "Member 'FSkillExcuInfo::CasterName' has a wrong offset!");

// ScriptStruct Game.NotifyExcuInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FNotifyExcuInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotifyExcuInfo) == 0x000008, "Wrong alignment on FNotifyExcuInfo");
static_assert(sizeof(FNotifyExcuInfo) == 0x000018, "Wrong size on FNotifyExcuInfo");

// ScriptStruct Game.BubbleActionInfo
// 0x0030 (0x0030 - 0x0000)
struct FBubbleActionInfo final
{
public:
	TSoftObjectPtr<class UAnimSequence>           Action;                                            // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionInternalTime;                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBubbleActionInfo) == 0x000008, "Wrong alignment on FBubbleActionInfo");
static_assert(sizeof(FBubbleActionInfo) == 0x000030, "Wrong size on FBubbleActionInfo");
static_assert(offsetof(FBubbleActionInfo, Action) == 0x000000, "Member 'FBubbleActionInfo::Action' has a wrong offset!");
static_assert(offsetof(FBubbleActionInfo, ActionInternalTime) == 0x000028, "Member 'FBubbleActionInfo::ActionInternalTime' has a wrong offset!");

// ScriptStruct Game.SearcherExcuInfo
// 0x0108 (0x0108 - 0x0000)
struct FSearcherExcuInfo final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterInstanceID;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillRunTimeID;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuerierName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LauncherName;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetsQueryInfo                      TargetsQueryInfo;                                  // 0x0030(0x0088)(NativeAccessSpecifierPublic)
	TArray<class FString>                         RelationError;                                     // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         EmitterCannotApply;                                // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutRange;                                          // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         AbnormalCheckError;                                // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQueryResultString>             Targets;                                           // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSearcherExcuInfo) == 0x000008, "Wrong alignment on FSearcherExcuInfo");
static_assert(sizeof(FSearcherExcuInfo) == 0x000108, "Wrong size on FSearcherExcuInfo");
static_assert(offsetof(FSearcherExcuInfo, ActiveTime) == 0x000000, "Member 'FSearcherExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, EmitterID) == 0x000004, "Member 'FSearcherExcuInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, EmitterInstanceID) == 0x000008, "Member 'FSearcherExcuInfo::EmitterInstanceID' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, SkillRunTimeID) == 0x00000C, "Member 'FSearcherExcuInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, QuerierName) == 0x000010, "Member 'FSearcherExcuInfo::QuerierName' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, LauncherName) == 0x000020, "Member 'FSearcherExcuInfo::LauncherName' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, TargetsQueryInfo) == 0x000030, "Member 'FSearcherExcuInfo::TargetsQueryInfo' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, RelationError) == 0x0000B8, "Member 'FSearcherExcuInfo::RelationError' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, EmitterCannotApply) == 0x0000C8, "Member 'FSearcherExcuInfo::EmitterCannotApply' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, OutRange) == 0x0000D8, "Member 'FSearcherExcuInfo::OutRange' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, AbnormalCheckError) == 0x0000E8, "Member 'FSearcherExcuInfo::AbnormalCheckError' has a wrong offset!");
static_assert(offsetof(FSearcherExcuInfo, Targets) == 0x0000F8, "Member 'FSearcherExcuInfo::Targets' has a wrong offset!");

// ScriptStruct Game.SearchQueryExcuinfo
// 0x0180 (0x0180 - 0x0000)
struct FSearchQueryExcuinfo final
{
public:
	struct FSearcherExcuInfo                      SearchInfo;                                        // 0x0000(0x0108)(NativeAccessSpecifierPublic)
	struct FSortTypeExcuInfo                      SortInfo;                                          // 0x0108(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSearchQueryExcuinfo) == 0x000008, "Wrong alignment on FSearchQueryExcuinfo");
static_assert(sizeof(FSearchQueryExcuinfo) == 0x000180, "Wrong size on FSearchQueryExcuinfo");
static_assert(offsetof(FSearchQueryExcuinfo, SearchInfo) == 0x000000, "Member 'FSearchQueryExcuinfo::SearchInfo' has a wrong offset!");
static_assert(offsetof(FSearchQueryExcuinfo, SortInfo) == 0x000108, "Member 'FSearchQueryExcuinfo::SortInfo' has a wrong offset!");

// ScriptStruct Game.HellDiversMonsterSpawnGroup
// 0x0020 (0x0028 - 0x0008)
struct FHellDiversMonsterSpawnGroup final : public FTableRowBase
{
public:
	class FString                                 GroupName;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnNpcByStruct>              SpawnInfos;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHellDiversMonsterSpawnGroup) == 0x000008, "Wrong alignment on FHellDiversMonsterSpawnGroup");
static_assert(sizeof(FHellDiversMonsterSpawnGroup) == 0x000028, "Wrong size on FHellDiversMonsterSpawnGroup");
static_assert(offsetof(FHellDiversMonsterSpawnGroup, GroupName) == 0x000008, "Member 'FHellDiversMonsterSpawnGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FHellDiversMonsterSpawnGroup, SpawnInfos) == 0x000018, "Member 'FHellDiversMonsterSpawnGroup::SpawnInfos' has a wrong offset!");

// ScriptStruct Game.EmitterExcuInfo
// 0x0078 (0x0078 - 0x0000)
struct FEmitterExcuInfo final
{
public:
	int32                                         InfoType;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveTime;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmitterID;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmitterInstanceID;                                 // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillID;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillRunTimeID;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LauncherName;                                      // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterExcuInfo) == 0x000008, "Wrong alignment on FEmitterExcuInfo");
static_assert(sizeof(FEmitterExcuInfo) == 0x000078, "Wrong size on FEmitterExcuInfo");
static_assert(offsetof(FEmitterExcuInfo, InfoType) == 0x000000, "Member 'FEmitterExcuInfo::InfoType' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, ActiveTime) == 0x000004, "Member 'FEmitterExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, EmitterID) == 0x000008, "Member 'FEmitterExcuInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, EmitterInstanceID) == 0x000018, "Member 'FEmitterExcuInfo::EmitterInstanceID' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, SkillID) == 0x000028, "Member 'FEmitterExcuInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, SkillRunTimeID) == 0x000038, "Member 'FEmitterExcuInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FEmitterExcuInfo, LauncherName) == 0x000048, "Member 'FEmitterExcuInfo::LauncherName' has a wrong offset!");

// ScriptStruct Game.ModifierExcuInfo
// 0x0078 (0x0078 - 0x0000)
struct FModifierExcuInfo final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfoType;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillID;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillRunTimeID;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmitterOwnerID;                                    // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmitterInstanceID;                                 // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LauncherName;                                      // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModifierID;                                        // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModifierRunTimeID;                                 // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierExcuInfo) == 0x000008, "Wrong alignment on FModifierExcuInfo");
static_assert(sizeof(FModifierExcuInfo) == 0x000078, "Wrong size on FModifierExcuInfo");
static_assert(offsetof(FModifierExcuInfo, ActiveTime) == 0x000000, "Member 'FModifierExcuInfo::ActiveTime' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, InfoType) == 0x000004, "Member 'FModifierExcuInfo::InfoType' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, SkillID) == 0x000008, "Member 'FModifierExcuInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, SkillRunTimeID) == 0x000018, "Member 'FModifierExcuInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, EmitterOwnerID) == 0x000028, "Member 'FModifierExcuInfo::EmitterOwnerID' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, EmitterInstanceID) == 0x000038, "Member 'FModifierExcuInfo::EmitterInstanceID' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, LauncherName) == 0x000048, "Member 'FModifierExcuInfo::LauncherName' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, ModifierID) == 0x000058, "Member 'FModifierExcuInfo::ModifierID' has a wrong offset!");
static_assert(offsetof(FModifierExcuInfo, ModifierRunTimeID) == 0x000068, "Member 'FModifierExcuInfo::ModifierRunTimeID' has a wrong offset!");

// ScriptStruct Game.FontConfig
// 0x0060 (0x0068 - 0x0008)
struct FFontConfig final : public FTableRowBase
{
public:
	class FString                                 Language;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, struct FSoftObjectPath> FontMap;                                           // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontConfig) == 0x000008, "Wrong alignment on FFontConfig");
static_assert(sizeof(FFontConfig) == 0x000068, "Wrong size on FFontConfig");
static_assert(offsetof(FFontConfig, Language) == 0x000008, "Member 'FFontConfig::Language' has a wrong offset!");
static_assert(offsetof(FFontConfig, FontMap) == 0x000018, "Member 'FFontConfig::FontMap' has a wrong offset!");

// ScriptStruct Game.ConditionExcuInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FConditionExcuInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionExcuInfo) == 0x000008, "Wrong alignment on FConditionExcuInfo");
static_assert(sizeof(FConditionExcuInfo) == 0x000038, "Wrong size on FConditionExcuInfo");

// ScriptStruct Game.EffectPathReplace
// 0x0060 (0x0068 - 0x0008)
struct FEffectPathReplace final : public FTableRowBase
{
public:
	class FString                                 Path;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, class FString>                    Paths;                                             // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectPathReplace) == 0x000008, "Wrong alignment on FEffectPathReplace");
static_assert(sizeof(FEffectPathReplace) == 0x000068, "Wrong size on FEffectPathReplace");
static_assert(offsetof(FEffectPathReplace, Path) == 0x000008, "Member 'FEffectPathReplace::Path' has a wrong offset!");
static_assert(offsetof(FEffectPathReplace, Paths) == 0x000018, "Member 'FEffectPathReplace::Paths' has a wrong offset!");

// ScriptStruct Game.LogShieldInfo
// 0x000C (0x000C - 0x0000)
struct FLogShieldInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogShieldInfo) == 0x000004, "Wrong alignment on FLogShieldInfo");
static_assert(sizeof(FLogShieldInfo) == 0x00000C, "Wrong size on FLogShieldInfo");
static_assert(offsetof(FLogShieldInfo, ID) == 0x000000, "Member 'FLogShieldInfo::ID' has a wrong offset!");
static_assert(offsetof(FLogShieldInfo, Value) == 0x000004, "Member 'FLogShieldInfo::Value' has a wrong offset!");
static_assert(offsetof(FLogShieldInfo, Count) == 0x000008, "Member 'FLogShieldInfo::Count' has a wrong offset!");

// ScriptStruct Game.DestructibleRecordData
// 0x0014 (0x0014 - 0x0000)
struct FDestructibleRecordData final
{
public:
	int32                                         DeadCount;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HurtPlayerDamage;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HurtMonsterDamage;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillMonsterCount;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadByPlayerCount;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleRecordData) == 0x000004, "Wrong alignment on FDestructibleRecordData");
static_assert(sizeof(FDestructibleRecordData) == 0x000014, "Wrong size on FDestructibleRecordData");
static_assert(offsetof(FDestructibleRecordData, DeadCount) == 0x000000, "Member 'FDestructibleRecordData::DeadCount' has a wrong offset!");
static_assert(offsetof(FDestructibleRecordData, HurtPlayerDamage) == 0x000004, "Member 'FDestructibleRecordData::HurtPlayerDamage' has a wrong offset!");
static_assert(offsetof(FDestructibleRecordData, HurtMonsterDamage) == 0x000008, "Member 'FDestructibleRecordData::HurtMonsterDamage' has a wrong offset!");
static_assert(offsetof(FDestructibleRecordData, KillMonsterCount) == 0x00000C, "Member 'FDestructibleRecordData::KillMonsterCount' has a wrong offset!");
static_assert(offsetof(FDestructibleRecordData, DeadByPlayerCount) == 0x000010, "Member 'FDestructibleRecordData::DeadByPlayerCount' has a wrong offset!");

// ScriptStruct Game.GamePostProcessEffectType
// 0x0008 (0x0010 - 0x0008)
struct FGamePostProcessEffectType final : public FTableRowBase
{
public:
	struct FFlexibleEnumValue                     Type;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Layer;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamePostProcessEffectType) == 0x000008, "Wrong alignment on FGamePostProcessEffectType");
static_assert(sizeof(FGamePostProcessEffectType) == 0x000010, "Wrong size on FGamePostProcessEffectType");
static_assert(offsetof(FGamePostProcessEffectType, Type) == 0x000008, "Member 'FGamePostProcessEffectType::Type' has a wrong offset!");
static_assert(offsetof(FGamePostProcessEffectType, Layer) == 0x00000C, "Member 'FGamePostProcessEffectType::Layer' has a wrong offset!");

// ScriptStruct Game.PlayerRecordData
// 0x02A8 (0x02A8 - 0x0000)
struct FPlayerRecordData final
{
public:
	int32                                         G;                                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         D;                                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P;                                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         L;                                                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            TriggerCount;                                      // 0x0010(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            HitCount;                                          // 0x0060(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, float>                            Damage;                                            // 0x00B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            VehicleTriggerCount;                               // 0x0100(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            VehicleHitCount;                                   // 0x0150(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, float>                            VehicleDamage;                                     // 0x01A0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PlayerCharacterIndex;                              // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageReceived;                                    // 0x01F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectiveDamage;                                   // 0x01F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverflowDamage;                                    // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcessionDamageReceived;                          // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamage;                                      // 0x0204(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalShieldDamage;                                 // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDestoryValue;                                   // 0x020C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDestroy;                                     // 0x0210(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectiveTreatHealth;                              // 0x0214(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverflowTreatHealth;                               // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CauseEffectiveTreatHealth;                         // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CauseOverflowTreatHealth;                          // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightTime;                                         // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFightTime;                                    // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchEndHealth;                                    // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverBloodAmount;                                // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverBloodBox;                                   // 0x0234(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecoverBloodSkill;                                 // 0x0238(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadCount;                                         // 0x023C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElemExplosionCount;                                // 0x0240(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElemExplosionDamage;                               // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 DeadSkillId;                                       // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeadTime;                                          // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SkillKillCount;                                    // 0x0268(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossDamage;                                        // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShootDamage;                                    // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSingleSkillDamage;                              // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSingleSkillDamageID;                            // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSingleDamageRealID;                             // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverEnergy;                                     // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSkillQuick;                                     // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxReloadSpeedRatio;                               // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBulletNum;                                      // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShootSpeed;                                     // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCriticalValue;                                  // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCriticalDamageAddition;                         // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterField;                                       // 0x029C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletHurtTotalCount;                              // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerRecordData) == 0x000008, "Wrong alignment on FPlayerRecordData");
static_assert(sizeof(FPlayerRecordData) == 0x0002A8, "Wrong size on FPlayerRecordData");
static_assert(offsetof(FPlayerRecordData, G) == 0x000000, "Member 'FPlayerRecordData::G' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, D) == 0x000004, "Member 'FPlayerRecordData::D' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, P) == 0x000008, "Member 'FPlayerRecordData::P' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, L) == 0x00000C, "Member 'FPlayerRecordData::L' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, TriggerCount) == 0x000010, "Member 'FPlayerRecordData::TriggerCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, HitCount) == 0x000060, "Member 'FPlayerRecordData::HitCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, Damage) == 0x0000B0, "Member 'FPlayerRecordData::Damage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, VehicleTriggerCount) == 0x000100, "Member 'FPlayerRecordData::VehicleTriggerCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, VehicleHitCount) == 0x000150, "Member 'FPlayerRecordData::VehicleHitCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, VehicleDamage) == 0x0001A0, "Member 'FPlayerRecordData::VehicleDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, PlayerCharacterIndex) == 0x0001F0, "Member 'FPlayerRecordData::PlayerCharacterIndex' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, DamageReceived) == 0x0001F4, "Member 'FPlayerRecordData::DamageReceived' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, EffectiveDamage) == 0x0001F8, "Member 'FPlayerRecordData::EffectiveDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, OverflowDamage) == 0x0001FC, "Member 'FPlayerRecordData::OverflowDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, ConcessionDamageReceived) == 0x000200, "Member 'FPlayerRecordData::ConcessionDamageReceived' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, ShieldDamage) == 0x000204, "Member 'FPlayerRecordData::ShieldDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, TotalShieldDamage) == 0x000208, "Member 'FPlayerRecordData::TotalShieldDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxDestoryValue) == 0x00020C, "Member 'FPlayerRecordData::MaxDestoryValue' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, EffectDestroy) == 0x000210, "Member 'FPlayerRecordData::EffectDestroy' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, EffectiveTreatHealth) == 0x000214, "Member 'FPlayerRecordData::EffectiveTreatHealth' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, OverflowTreatHealth) == 0x000218, "Member 'FPlayerRecordData::OverflowTreatHealth' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, CauseEffectiveTreatHealth) == 0x00021C, "Member 'FPlayerRecordData::CauseEffectiveTreatHealth' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, CauseOverflowTreatHealth) == 0x000220, "Member 'FPlayerRecordData::CauseOverflowTreatHealth' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, FightTime) == 0x000224, "Member 'FPlayerRecordData::FightTime' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, StartFightTime) == 0x000228, "Member 'FPlayerRecordData::StartFightTime' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MatchEndHealth) == 0x00022C, "Member 'FPlayerRecordData::MatchEndHealth' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, RecoverBloodAmount) == 0x000230, "Member 'FPlayerRecordData::RecoverBloodAmount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, RecoverBloodBox) == 0x000234, "Member 'FPlayerRecordData::RecoverBloodBox' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, RecoverBloodSkill) == 0x000238, "Member 'FPlayerRecordData::RecoverBloodSkill' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, DeadCount) == 0x00023C, "Member 'FPlayerRecordData::DeadCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, ElemExplosionCount) == 0x000240, "Member 'FPlayerRecordData::ElemExplosionCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, ElemExplosionDamage) == 0x000244, "Member 'FPlayerRecordData::ElemExplosionDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, DeadSkillId) == 0x000248, "Member 'FPlayerRecordData::DeadSkillId' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, DeadTime) == 0x000258, "Member 'FPlayerRecordData::DeadTime' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, SkillKillCount) == 0x000268, "Member 'FPlayerRecordData::SkillKillCount' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, BossDamage) == 0x00026C, "Member 'FPlayerRecordData::BossDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxShootDamage) == 0x000270, "Member 'FPlayerRecordData::MaxShootDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxSingleSkillDamage) == 0x000274, "Member 'FPlayerRecordData::MaxSingleSkillDamage' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxSingleSkillDamageID) == 0x000278, "Member 'FPlayerRecordData::MaxSingleSkillDamageID' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxSingleDamageRealID) == 0x00027C, "Member 'FPlayerRecordData::MaxSingleDamageRealID' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, RecoverEnergy) == 0x000280, "Member 'FPlayerRecordData::RecoverEnergy' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxSkillQuick) == 0x000284, "Member 'FPlayerRecordData::MaxSkillQuick' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxReloadSpeedRatio) == 0x000288, "Member 'FPlayerRecordData::MaxReloadSpeedRatio' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxBulletNum) == 0x00028C, "Member 'FPlayerRecordData::MaxBulletNum' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxShootSpeed) == 0x000290, "Member 'FPlayerRecordData::MaxShootSpeed' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxCriticalValue) == 0x000294, "Member 'FPlayerRecordData::MaxCriticalValue' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, MaxCriticalDamageAddition) == 0x000298, "Member 'FPlayerRecordData::MaxCriticalDamageAddition' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, bEnterField) == 0x00029C, "Member 'FPlayerRecordData::bEnterField' has a wrong offset!");
static_assert(offsetof(FPlayerRecordData, BulletHurtTotalCount) == 0x0002A0, "Member 'FPlayerRecordData::BulletHurtTotalCount' has a wrong offset!");

// ScriptStruct Game.EmitterRunTimeInfo
// 0x0010 (0x0010 - 0x0000)
struct FEmitterRunTimeInfo final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterInstanceID;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterTimes;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterResult                                RunningResult;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterRunTimeInfo) == 0x000004, "Wrong alignment on FEmitterRunTimeInfo");
static_assert(sizeof(FEmitterRunTimeInfo) == 0x000010, "Wrong size on FEmitterRunTimeInfo");
static_assert(offsetof(FEmitterRunTimeInfo, EmitterID) == 0x000000, "Member 'FEmitterRunTimeInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterRunTimeInfo, EmitterInstanceID) == 0x000004, "Member 'FEmitterRunTimeInfo::EmitterInstanceID' has a wrong offset!");
static_assert(offsetof(FEmitterRunTimeInfo, EmitterTimes) == 0x000008, "Member 'FEmitterRunTimeInfo::EmitterTimes' has a wrong offset!");
static_assert(offsetof(FEmitterRunTimeInfo, RunningResult) == 0x00000C, "Member 'FEmitterRunTimeInfo::RunningResult' has a wrong offset!");

// ScriptStruct Game.SkillRunTimeInfo
// 0x0040 (0x0040 - 0x0000)
struct FSkillRunTimeInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterName;                                     // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                Type;                                              // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterType                                  MonsterType;                                       // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillID;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilityComponentBase>   LauncherAbility;                                   // 0x0014(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastTime;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerTimes;                                      // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitTimes;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmitterRunTimeInfo>            Infos;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillRunTimeInfo) == 0x000008, "Wrong alignment on FSkillRunTimeInfo");
static_assert(sizeof(FSkillRunTimeInfo) == 0x000040, "Wrong size on FSkillRunTimeInfo");
static_assert(offsetof(FSkillRunTimeInfo, ID) == 0x000000, "Member 'FSkillRunTimeInfo::ID' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, CharacterName) == 0x000004, "Member 'FSkillRunTimeInfo::CharacterName' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, Type) == 0x00000C, "Member 'FSkillRunTimeInfo::Type' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, MonsterType) == 0x00000D, "Member 'FSkillRunTimeInfo::MonsterType' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, SkillID) == 0x000010, "Member 'FSkillRunTimeInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, LauncherAbility) == 0x000014, "Member 'FSkillRunTimeInfo::LauncherAbility' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, CastTime) == 0x00001C, "Member 'FSkillRunTimeInfo::CastTime' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, TriggerTimes) == 0x000020, "Member 'FSkillRunTimeInfo::TriggerTimes' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, HitTimes) == 0x000024, "Member 'FSkillRunTimeInfo::HitTimes' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, Damage) == 0x000028, "Member 'FSkillRunTimeInfo::Damage' has a wrong offset!");
static_assert(offsetof(FSkillRunTimeInfo, Infos) == 0x000030, "Member 'FSkillRunTimeInfo::Infos' has a wrong offset!");

// ScriptStruct Game.InteractionScope
// 0x0008 (0x0008 - 0x0000)
struct FInteractionScope final
{
public:
	float                                         Max;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionScope) == 0x000004, "Wrong alignment on FInteractionScope");
static_assert(sizeof(FInteractionScope) == 0x000008, "Wrong size on FInteractionScope");
static_assert(offsetof(FInteractionScope, Max) == 0x000000, "Member 'FInteractionScope::Max' has a wrong offset!");
static_assert(offsetof(FInteractionScope, Min) == 0x000004, "Member 'FInteractionScope::Min' has a wrong offset!");

// ScriptStruct Game.SpecialAttributeData
// 0x0010 (0x0010 - 0x0000)
struct FSpecialAttributeData final
{
public:
	int32                                         MaxValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityAttribute*                      Attribute;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialAttributeData) == 0x000008, "Wrong alignment on FSpecialAttributeData");
static_assert(sizeof(FSpecialAttributeData) == 0x000010, "Wrong size on FSpecialAttributeData");
static_assert(offsetof(FSpecialAttributeData, MaxValue) == 0x000000, "Member 'FSpecialAttributeData::MaxValue' has a wrong offset!");
static_assert(offsetof(FSpecialAttributeData, CurValue) == 0x000004, "Member 'FSpecialAttributeData::CurValue' has a wrong offset!");
static_assert(offsetof(FSpecialAttributeData, Attribute) == 0x000008, "Member 'FSpecialAttributeData::Attribute' has a wrong offset!");

// ScriptStruct Game.ollowPlaySkill
// 0x0018 (0x0018 - 0x0000)
struct FOllowPlaySkill final
{
public:
	int32                                         PlayerSkillID;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AccessorySkillID;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOllowPlaySkill) == 0x000008, "Wrong alignment on FOllowPlaySkill");
static_assert(sizeof(FOllowPlaySkill) == 0x000018, "Wrong size on FOllowPlaySkill");
static_assert(offsetof(FOllowPlaySkill, PlayerSkillID) == 0x000000, "Member 'FOllowPlaySkill::PlayerSkillID' has a wrong offset!");
static_assert(offsetof(FOllowPlaySkill, AccessorySkillID) == 0x000008, "Member 'FOllowPlaySkill::AccessorySkillID' has a wrong offset!");

// ScriptStruct Game.AIDirectorEnmityConfig
// 0x0008 (0x0020 - 0x0018)
struct FAIDirectorEnmityConfig final : public FAIDirectorTargetConfig
{
public:
	float                                         EnmityChange;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDirectorEnmityConfig) == 0x000008, "Wrong alignment on FAIDirectorEnmityConfig");
static_assert(sizeof(FAIDirectorEnmityConfig) == 0x000020, "Wrong size on FAIDirectorEnmityConfig");
static_assert(offsetof(FAIDirectorEnmityConfig, EnmityChange) == 0x000018, "Member 'FAIDirectorEnmityConfig::EnmityChange' has a wrong offset!");

// ScriptStruct Game.SimpleMoveConfig
// 0x002C (0x002C - 0x0000)
struct FSimpleMoveConfig final
{
public:
	float                                         FinishMoveRadius;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMoveRadius;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMoveTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimpleMoveRadius;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLookAtSceneTargetForwardRadius;               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeDistance;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingRadius;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingSpeed;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotUseClosetNavPointForDestination;               // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepMoveWhenCaptainStop;                          // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalcDestinationBasedOnSlope;                      // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopTimeWhenCaptainStop;                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopVelocityWhenCaptainStop;                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleMoveConfig) == 0x000004, "Wrong alignment on FSimpleMoveConfig");
static_assert(sizeof(FSimpleMoveConfig) == 0x00002C, "Wrong size on FSimpleMoveConfig");
static_assert(offsetof(FSimpleMoveConfig, FinishMoveRadius) == 0x000000, "Member 'FSimpleMoveConfig::FinishMoveRadius' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, DelayMoveRadius) == 0x000004, "Member 'FSimpleMoveConfig::DelayMoveRadius' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, DelayMoveTime) == 0x000008, "Member 'FSimpleMoveConfig::DelayMoveTime' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, SimpleMoveRadius) == 0x00000C, "Member 'FSimpleMoveConfig::SimpleMoveRadius' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, StartLookAtSceneTargetForwardRadius) == 0x000010, "Member 'FSimpleMoveConfig::StartLookAtSceneTargetForwardRadius' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, BrakeDistance) == 0x000014, "Member 'FSimpleMoveConfig::BrakeDistance' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, SwingRadius) == 0x000018, "Member 'FSimpleMoveConfig::SwingRadius' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, SwingSpeed) == 0x00001C, "Member 'FSimpleMoveConfig::SwingSpeed' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, bNotUseClosetNavPointForDestination) == 0x000020, "Member 'FSimpleMoveConfig::bNotUseClosetNavPointForDestination' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, bKeepMoveWhenCaptainStop) == 0x000021, "Member 'FSimpleMoveConfig::bKeepMoveWhenCaptainStop' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, bCalcDestinationBasedOnSlope) == 0x000022, "Member 'FSimpleMoveConfig::bCalcDestinationBasedOnSlope' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, StopTimeWhenCaptainStop) == 0x000024, "Member 'FSimpleMoveConfig::StopTimeWhenCaptainStop' has a wrong offset!");
static_assert(offsetof(FSimpleMoveConfig, StopVelocityWhenCaptainStop) == 0x000028, "Member 'FSimpleMoveConfig::StopVelocityWhenCaptainStop' has a wrong offset!");

// ScriptStruct Game.AITeamConfig
// 0x0048 (0x0050 - 0x0008)
struct FAITeamConfig final : public FTableRowBase
{
public:
	class FString                                 TeamConfigName;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Remark;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAITeamSlotConfigAsset>  AITeamSlotConfigAsset;                             // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITeamConfig) == 0x000008, "Wrong alignment on FAITeamConfig");
static_assert(sizeof(FAITeamConfig) == 0x000050, "Wrong size on FAITeamConfig");
static_assert(offsetof(FAITeamConfig, TeamConfigName) == 0x000008, "Member 'FAITeamConfig::TeamConfigName' has a wrong offset!");
static_assert(offsetof(FAITeamConfig, Remark) == 0x000018, "Member 'FAITeamConfig::Remark' has a wrong offset!");
static_assert(offsetof(FAITeamConfig, AITeamSlotConfigAsset) == 0x000028, "Member 'FAITeamConfig::AITeamSlotConfigAsset' has a wrong offset!");

// ScriptStruct Game.OnlineTD2TeamAbility
// 0x000C (0x000C - 0x0000)
struct FOnlineTD2TeamAbility final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostNum;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineTD2TeamAbility) == 0x000004, "Wrong alignment on FOnlineTD2TeamAbility");
static_assert(sizeof(FOnlineTD2TeamAbility) == 0x00000C, "Wrong size on FOnlineTD2TeamAbility");
static_assert(offsetof(FOnlineTD2TeamAbility, ID) == 0x000000, "Member 'FOnlineTD2TeamAbility::ID' has a wrong offset!");
static_assert(offsetof(FOnlineTD2TeamAbility, CostNum) == 0x000004, "Member 'FOnlineTD2TeamAbility::CostNum' has a wrong offset!");
static_assert(offsetof(FOnlineTD2TeamAbility, IsActive) == 0x000008, "Member 'FOnlineTD2TeamAbility::IsActive' has a wrong offset!");

// ScriptStruct Game.AIBaseConfig
// 0x0080 (0x0088 - 0x0008)
struct FAIBaseConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamID;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BaseBT;                                            // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BaseSMClass;                                       // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                States;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EMovementMode                                 AIMovementMode;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAIPerception;                               // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogicScriptFile;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIBaseConfig) == 0x000008, "Wrong alignment on FAIBaseConfig");
static_assert(sizeof(FAIBaseConfig) == 0x000088, "Wrong size on FAIBaseConfig");
static_assert(offsetof(FAIBaseConfig, ID) == 0x000008, "Member 'FAIBaseConfig::ID' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, ParamID) == 0x00000C, "Member 'FAIBaseConfig::ParamID' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, BaseBT) == 0x000010, "Member 'FAIBaseConfig::BaseBT' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, BaseSMClass) == 0x000038, "Member 'FAIBaseConfig::BaseSMClass' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, States) == 0x000060, "Member 'FAIBaseConfig::States' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, AIMovementMode) == 0x000070, "Member 'FAIBaseConfig::AIMovementMode' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, bEnableAIPerception) == 0x000071, "Member 'FAIBaseConfig::bEnableAIPerception' has a wrong offset!");
static_assert(offsetof(FAIBaseConfig, LogicScriptFile) == 0x000078, "Member 'FAIBaseConfig::LogicScriptFile' has a wrong offset!");

// ScriptStruct Game.RandomFloatValue
// 0x000C (0x000C - 0x0000)
struct FRandomFloatValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Random;                                            // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomFloatValue) == 0x000004, "Wrong alignment on FRandomFloatValue");
static_assert(sizeof(FRandomFloatValue) == 0x00000C, "Wrong size on FRandomFloatValue");
static_assert(offsetof(FRandomFloatValue, Value) == 0x000000, "Member 'FRandomFloatValue::Value' has a wrong offset!");
static_assert(offsetof(FRandomFloatValue, Random) == 0x000004, "Member 'FRandomFloatValue::Random' has a wrong offset!");

// ScriptStruct Game.AngleArray
// 0x0010 (0x0010 - 0x0000)
struct FAngleArray final
{
public:
	TArray<struct FAIValueRange>                  AngleRanges;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAngleArray) == 0x000008, "Wrong alignment on FAngleArray");
static_assert(sizeof(FAngleArray) == 0x000010, "Wrong size on FAngleArray");
static_assert(offsetof(FAngleArray, AngleRanges) == 0x000000, "Member 'FAngleArray::AngleRanges' has a wrong offset!");

// ScriptStruct Game.AICharacterTalkParam
// 0x0040 (0x0040 - 0x0000)
struct FAICharacterTalkParam final
{
public:
	class FName                                   MonTag;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TalkID;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TalkState;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InteractText;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Icon;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractAngle;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerInteractAngle;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxInteractDistance;                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICharacterTalkParam) == 0x000008, "Wrong alignment on FAICharacterTalkParam");
static_assert(sizeof(FAICharacterTalkParam) == 0x000040, "Wrong size on FAICharacterTalkParam");
static_assert(offsetof(FAICharacterTalkParam, MonTag) == 0x000000, "Member 'FAICharacterTalkParam::MonTag' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, TalkID) == 0x000008, "Member 'FAICharacterTalkParam::TalkID' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, TalkState) == 0x000010, "Member 'FAICharacterTalkParam::TalkState' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, InteractText) == 0x000020, "Member 'FAICharacterTalkParam::InteractText' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, Icon) == 0x000030, "Member 'FAICharacterTalkParam::Icon' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, InteractAngle) == 0x000034, "Member 'FAICharacterTalkParam::InteractAngle' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, PlayerInteractAngle) == 0x000038, "Member 'FAICharacterTalkParam::PlayerInteractAngle' has a wrong offset!");
static_assert(offsetof(FAICharacterTalkParam, MaxInteractDistance) == 0x00003C, "Member 'FAICharacterTalkParam::MaxInteractDistance' has a wrong offset!");

// ScriptStruct Game.AIDirectorCDGroup
// 0x000C (0x000C - 0x0000)
struct FAIDirectorCDGroup final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillRangeType                               TokenType;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsElite;                                           // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowCD;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDirectorCDGroup) == 0x000004, "Wrong alignment on FAIDirectorCDGroup");
static_assert(sizeof(FAIDirectorCDGroup) == 0x00000C, "Wrong size on FAIDirectorCDGroup");
static_assert(offsetof(FAIDirectorCDGroup, ID) == 0x000000, "Member 'FAIDirectorCDGroup::ID' has a wrong offset!");
static_assert(offsetof(FAIDirectorCDGroup, TokenType) == 0x000004, "Member 'FAIDirectorCDGroup::TokenType' has a wrong offset!");
static_assert(offsetof(FAIDirectorCDGroup, IsElite) == 0x000005, "Member 'FAIDirectorCDGroup::IsElite' has a wrong offset!");
static_assert(offsetof(FAIDirectorCDGroup, NowCD) == 0x000008, "Member 'FAIDirectorCDGroup::NowCD' has a wrong offset!");

// ScriptStruct Game.TokenNum
// 0x000C (0x000C - 0x0000)
struct FTokenNum final
{
public:
	int32                                         MaxTokenNum;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OccupiedTokenNum;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTokenNum) == 0x000004, "Wrong alignment on FTokenNum");
static_assert(sizeof(FTokenNum) == 0x00000C, "Wrong size on FTokenNum");
static_assert(offsetof(FTokenNum, MaxTokenNum) == 0x000000, "Member 'FTokenNum::MaxTokenNum' has a wrong offset!");
static_assert(offsetof(FTokenNum, OccupiedTokenNum) == 0x000004, "Member 'FTokenNum::OccupiedTokenNum' has a wrong offset!");
static_assert(offsetof(FTokenNum, CD) == 0x000008, "Member 'FTokenNum::CD' has a wrong offset!");

// ScriptStruct Game.AIDirectorGroup
// 0x0098 (0x0098 - 0x0000)
struct FAIDirectorGroup final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAICondition*>                   FilterConditions;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<ESkillRangeType, struct FTokenNum>       TokenConfig;                                       // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         EliteTokenRatio;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIDirectorEvent*>               InitialEvents;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDirectorGroup) == 0x000008, "Wrong alignment on FAIDirectorGroup");
static_assert(sizeof(FAIDirectorGroup) == 0x000098, "Wrong size on FAIDirectorGroup");
static_assert(offsetof(FAIDirectorGroup, ID) == 0x000000, "Member 'FAIDirectorGroup::ID' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, Remark) == 0x000008, "Member 'FAIDirectorGroup::Remark' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, bActive) == 0x000018, "Member 'FAIDirectorGroup::bActive' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, FilterConditions) == 0x000020, "Member 'FAIDirectorGroup::FilterConditions' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, TokenConfig) == 0x000030, "Member 'FAIDirectorGroup::TokenConfig' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, EliteTokenRatio) == 0x000080, "Member 'FAIDirectorGroup::EliteTokenRatio' has a wrong offset!");
static_assert(offsetof(FAIDirectorGroup, InitialEvents) == 0x000088, "Member 'FAIDirectorGroup::InitialEvents' has a wrong offset!");

// ScriptStruct Game.CompositeId
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCompositeId final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeId) == 0x000004, "Wrong alignment on FCompositeId");
static_assert(sizeof(FCompositeId) == 0x000008, "Wrong size on FCompositeId");

// ScriptStruct Game.FriendPalState
// 0x0004 (0x0004 - 0x0000)
struct FFriendPalState final
{
public:
	int32                                         CurHp;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendPalState) == 0x000004, "Wrong alignment on FFriendPalState");
static_assert(sizeof(FFriendPalState) == 0x000004, "Wrong size on FFriendPalState");
static_assert(offsetof(FFriendPalState, CurHp) == 0x000000, "Member 'FFriendPalState::CurHp' has a wrong offset!");

// ScriptStruct Game.AIArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAIArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIArray) == 0x000008, "Wrong alignment on FAIArray");
static_assert(sizeof(FAIArray) == 0x000010, "Wrong size on FAIArray");

// ScriptStruct Game.AISkillConf
// 0x0018 (0x0018 - 0x0000)
struct FAISkillConf final
{
public:
	float                                         GlobalCD;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAISkillGroup>                  Groups;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillConf) == 0x000008, "Wrong alignment on FAISkillConf");
static_assert(sizeof(FAISkillConf) == 0x000018, "Wrong size on FAISkillConf");
static_assert(offsetof(FAISkillConf, GlobalCD) == 0x000000, "Member 'FAISkillConf::GlobalCD' has a wrong offset!");
static_assert(offsetof(FAISkillConf, Groups) == 0x000008, "Member 'FAISkillConf::Groups' has a wrong offset!");

// ScriptStruct Game.FragmentStoryInfo
// 0x000C (0x000C - 0x0000)
struct FFragmentStoryInfo final
{
public:
	bool                                          IsFragmentDrop;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FragmentId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGroupFragment;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFragmentStoryInfo) == 0x000004, "Wrong alignment on FFragmentStoryInfo");
static_assert(sizeof(FFragmentStoryInfo) == 0x00000C, "Wrong size on FFragmentStoryInfo");
static_assert(offsetof(FFragmentStoryInfo, IsFragmentDrop) == 0x000000, "Member 'FFragmentStoryInfo::IsFragmentDrop' has a wrong offset!");
static_assert(offsetof(FFragmentStoryInfo, FragmentId) == 0x000004, "Member 'FFragmentStoryInfo::FragmentId' has a wrong offset!");
static_assert(offsetof(FFragmentStoryInfo, IsGroupFragment) == 0x000008, "Member 'FFragmentStoryInfo::IsGroupFragment' has a wrong offset!");

// ScriptStruct Game.VoiceMonsterInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FVoiceMonsterInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoiceMonsterInfo) == 0x000008, "Wrong alignment on FVoiceMonsterInfo");
static_assert(sizeof(FVoiceMonsterInfo) == 0x000018, "Wrong size on FVoiceMonsterInfo");

// ScriptStruct Game.SaveSkeletonSocket
// 0x0038 (0x0038 - 0x0000)
struct FSaveSkeletonSocket final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAlwaysAnimated;                              // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveSkeletonSocket) == 0x000004, "Wrong alignment on FSaveSkeletonSocket");
static_assert(sizeof(FSaveSkeletonSocket) == 0x000038, "Wrong size on FSaveSkeletonSocket");
static_assert(offsetof(FSaveSkeletonSocket, SocketName) == 0x000000, "Member 'FSaveSkeletonSocket::SocketName' has a wrong offset!");
static_assert(offsetof(FSaveSkeletonSocket, BoneName) == 0x000008, "Member 'FSaveSkeletonSocket::BoneName' has a wrong offset!");
static_assert(offsetof(FSaveSkeletonSocket, RelativeLocation) == 0x000010, "Member 'FSaveSkeletonSocket::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FSaveSkeletonSocket, RelativeRotation) == 0x00001C, "Member 'FSaveSkeletonSocket::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FSaveSkeletonSocket, RelativeScale) == 0x000028, "Member 'FSaveSkeletonSocket::RelativeScale' has a wrong offset!");
static_assert(offsetof(FSaveSkeletonSocket, bForceAlwaysAnimated) == 0x000034, "Member 'FSaveSkeletonSocket::bForceAlwaysAnimated' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimInfo
// 0x0008 (0x0008 - 0x0000)
struct FPerformanceAnimInfo final
{
public:
	int32                                         AnimSeqID;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceAnimInfo) == 0x000004, "Wrong alignment on FPerformanceAnimInfo");
static_assert(sizeof(FPerformanceAnimInfo) == 0x000008, "Wrong size on FPerformanceAnimInfo");
static_assert(offsetof(FPerformanceAnimInfo, AnimSeqID) == 0x000000, "Member 'FPerformanceAnimInfo::AnimSeqID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimInfo, Weight) == 0x000004, "Member 'FPerformanceAnimInfo::Weight' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimSequenceSection
// 0x0038 (0x0038 - 0x0000)
struct FPerformanceAnimSequenceSection final
{
public:
	TArray<struct FPerformanceAnimInfo>           PreviewAnimSections;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SilentTimeRange;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SilentTime_FirstEntryRange;                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer_NoEntryDelay;                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsCharacterWalkIn;                                // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceAnimSequenceSection) == 0x000008, "Wrong alignment on FPerformanceAnimSequenceSection");
static_assert(sizeof(FPerformanceAnimSequenceSection) == 0x000038, "Wrong size on FPerformanceAnimSequenceSection");
static_assert(offsetof(FPerformanceAnimSequenceSection, PreviewAnimSections) == 0x000000, "Member 'FPerformanceAnimSequenceSection::PreviewAnimSections' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection, SilentTimeRange) == 0x000010, "Member 'FPerformanceAnimSequenceSection::SilentTimeRange' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection, SilentTime_FirstEntryRange) == 0x000018, "Member 'FPerformanceAnimSequenceSection::SilentTime_FirstEntryRange' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection, WidgetContainer_NoEntryDelay) == 0x000020, "Member 'FPerformanceAnimSequenceSection::WidgetContainer_NoEntryDelay' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection, bIsCharacterWalkIn) == 0x000030, "Member 'FPerformanceAnimSequenceSection::bIsCharacterWalkIn' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimSequenceSection_SkinContainer
// 0x0018 (0x0018 - 0x0000)
struct FPerformanceAnimSequenceSection_SkinContainer final
{
public:
	TArray<struct FPerformanceAnimSequenceSection> PreviewAnimSequence_Skin;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SkinTemplateID;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharacterWalkIn;                                // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceAnimSequenceSection_SkinContainer) == 0x000008, "Wrong alignment on FPerformanceAnimSequenceSection_SkinContainer");
static_assert(sizeof(FPerformanceAnimSequenceSection_SkinContainer) == 0x000018, "Wrong size on FPerformanceAnimSequenceSection_SkinContainer");
static_assert(offsetof(FPerformanceAnimSequenceSection_SkinContainer, PreviewAnimSequence_Skin) == 0x000000, "Member 'FPerformanceAnimSequenceSection_SkinContainer::PreviewAnimSequence_Skin' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection_SkinContainer, SkinTemplateID) == 0x000010, "Member 'FPerformanceAnimSequenceSection_SkinContainer::SkinTemplateID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceSection_SkinContainer, bIsCharacterWalkIn) == 0x000014, "Member 'FPerformanceAnimSequenceSection_SkinContainer::bIsCharacterWalkIn' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimSequenceLoopConfigTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPerformanceAnimSequenceLoopConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerformanceAnimSequenceSection> PreviewAnimSequence;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPerformanceAnimSequenceSection_SkinContainer> PreviewAnimSequence_SkinContainer;                 // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHideWeapon;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreviewModelUIEventType                      UIEventBind;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepLoop;                                         // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceAnimSequenceLoopConfigTemplate) == 0x000008, "Wrong alignment on FPerformanceAnimSequenceLoopConfigTemplate");
static_assert(sizeof(FPerformanceAnimSequenceLoopConfigTemplate) == 0x000040, "Wrong size on FPerformanceAnimSequenceLoopConfigTemplate");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, ID) == 0x000008, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, PreviewAnimSequence) == 0x000010, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::PreviewAnimSequence' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, PreviewAnimSequence_SkinContainer) == 0x000020, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::PreviewAnimSequence_SkinContainer' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, bHideWeapon) == 0x000030, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::bHideWeapon' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, UIEventBind) == 0x000031, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::UIEventBind' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, Weight) == 0x000034, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::Weight' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, CharacterID) == 0x000038, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimSequenceLoopConfigTemplate, bKeepLoop) == 0x00003C, "Member 'FPerformanceAnimSequenceLoopConfigTemplate::bKeepLoop' has a wrong offset!");

// ScriptStruct Game.SavedAnimNotify
// 0x0038 (0x0038 - 0x0000)
struct FSavedAnimNotify final
{
public:
	int32                                         TrackIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTime;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerWeightThreshold;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotifyTriggerChance;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotifyFilterLOD;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnDedicatedServer;                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnFollower;                                // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMontageNotifyTickType                        MontageTickType;                                   // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyFilterType                             NotifyFilterType;                                  // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimNotify*                            Notify;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotifyState*                       State;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedAnimNotify) == 0x000008, "Wrong alignment on FSavedAnimNotify");
static_assert(sizeof(FSavedAnimNotify) == 0x000038, "Wrong size on FSavedAnimNotify");
static_assert(offsetof(FSavedAnimNotify, TrackIndex) == 0x000000, "Member 'FSavedAnimNotify::TrackIndex' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, NotifyName) == 0x000004, "Member 'FSavedAnimNotify::NotifyName' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, Duration) == 0x00000C, "Member 'FSavedAnimNotify::Duration' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, TriggerTime) == 0x000010, "Member 'FSavedAnimNotify::TriggerTime' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, TriggerWeightThreshold) == 0x000014, "Member 'FSavedAnimNotify::TriggerWeightThreshold' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, NotifyTriggerChance) == 0x000018, "Member 'FSavedAnimNotify::NotifyTriggerChance' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, NotifyFilterLOD) == 0x00001C, "Member 'FSavedAnimNotify::NotifyFilterLOD' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, bTriggerOnDedicatedServer) == 0x000020, "Member 'FSavedAnimNotify::bTriggerOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, bTriggerOnFollower) == 0x000021, "Member 'FSavedAnimNotify::bTriggerOnFollower' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, MontageTickType) == 0x000022, "Member 'FSavedAnimNotify::MontageTickType' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, NotifyFilterType) == 0x000023, "Member 'FSavedAnimNotify::NotifyFilterType' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, Notify) == 0x000028, "Member 'FSavedAnimNotify::Notify' has a wrong offset!");
static_assert(offsetof(FSavedAnimNotify, State) == 0x000030, "Member 'FSavedAnimNotify::State' has a wrong offset!");

// ScriptStruct Game.GameNiagaraConfigTemplate
// 0x0068 (0x0070 - 0x0008)
struct FGameNiagaraConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Template;                                          // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Attached : 1;                                      // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0064(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameNiagaraConfigTemplate) == 0x000008, "Wrong alignment on FGameNiagaraConfigTemplate");
static_assert(sizeof(FGameNiagaraConfigTemplate) == 0x000070, "Wrong size on FGameNiagaraConfigTemplate");
static_assert(offsetof(FGameNiagaraConfigTemplate, ID) == 0x000008, "Member 'FGameNiagaraConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, Template) == 0x000010, "Member 'FGameNiagaraConfigTemplate::Template' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, LocationOffset) == 0x000038, "Member 'FGameNiagaraConfigTemplate::LocationOffset' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, RotationOffset) == 0x000044, "Member 'FGameNiagaraConfigTemplate::RotationOffset' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, Scale) == 0x000050, "Member 'FGameNiagaraConfigTemplate::Scale' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, bAbsoluteScale) == 0x00005C, "Member 'FGameNiagaraConfigTemplate::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(FGameNiagaraConfigTemplate, SocketName) == 0x000064, "Member 'FGameNiagaraConfigTemplate::SocketName' has a wrong offset!");

// ScriptStruct Game.AutoPSORuntime
// 0x0024 (0x0024 - 0x0000)
struct FAutoPSORuntime final
{
public:
	int32                                         TotalAssetCount;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentAssetIndex;                                 // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalActorCount;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentActorIndex;                                 // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMapCount;                                     // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMapIndex;                                   // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentQualityLevel;                               // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssetMaxShow;                                      // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunning;                                         // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPause;                                           // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoPSORuntime) == 0x000004, "Wrong alignment on FAutoPSORuntime");
static_assert(sizeof(FAutoPSORuntime) == 0x000024, "Wrong size on FAutoPSORuntime");
static_assert(offsetof(FAutoPSORuntime, TotalAssetCount) == 0x000000, "Member 'FAutoPSORuntime::TotalAssetCount' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, CurrentAssetIndex) == 0x000004, "Member 'FAutoPSORuntime::CurrentAssetIndex' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, TotalActorCount) == 0x000008, "Member 'FAutoPSORuntime::TotalActorCount' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, CurrentActorIndex) == 0x00000C, "Member 'FAutoPSORuntime::CurrentActorIndex' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, TotalMapCount) == 0x000010, "Member 'FAutoPSORuntime::TotalMapCount' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, CurrentMapIndex) == 0x000014, "Member 'FAutoPSORuntime::CurrentMapIndex' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, CurrentQualityLevel) == 0x000018, "Member 'FAutoPSORuntime::CurrentQualityLevel' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, AssetMaxShow) == 0x00001C, "Member 'FAutoPSORuntime::AssetMaxShow' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, IsRunning) == 0x000020, "Member 'FAutoPSORuntime::IsRunning' has a wrong offset!");
static_assert(offsetof(FAutoPSORuntime, IsPause) == 0x000021, "Member 'FAutoPSORuntime::IsPause' has a wrong offset!");

// ScriptStruct Game.AvoidanceData
// 0x0018 (0x0020 - 0x0008)
struct FAvoidanceData final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceConsiderationRadius;                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceWeight;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      AvoidanceGroup;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToAvoid;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToIgnore;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvoidanceData) == 0x000008, "Wrong alignment on FAvoidanceData");
static_assert(sizeof(FAvoidanceData) == 0x000020, "Wrong size on FAvoidanceData");
static_assert(offsetof(FAvoidanceData, ID) == 0x000008, "Member 'FAvoidanceData::ID' has a wrong offset!");
static_assert(offsetof(FAvoidanceData, AvoidanceConsiderationRadius) == 0x00000C, "Member 'FAvoidanceData::AvoidanceConsiderationRadius' has a wrong offset!");
static_assert(offsetof(FAvoidanceData, AvoidanceWeight) == 0x000010, "Member 'FAvoidanceData::AvoidanceWeight' has a wrong offset!");
static_assert(offsetof(FAvoidanceData, AvoidanceGroup) == 0x000014, "Member 'FAvoidanceData::AvoidanceGroup' has a wrong offset!");
static_assert(offsetof(FAvoidanceData, GroupsToAvoid) == 0x000018, "Member 'FAvoidanceData::GroupsToAvoid' has a wrong offset!");
static_assert(offsetof(FAvoidanceData, GroupsToIgnore) == 0x00001C, "Member 'FAvoidanceData::GroupsToIgnore' has a wrong offset!");

// ScriptStruct Game.UIEventTriggerCacheData
// 0x0050 (0x0050 - 0x0000)
struct FUIEventTriggerCacheData final
{
public:
	TMap<EPreviewModelUIEventType, int32>         UIEventTriggerCache;                               // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIEventTriggerCacheData) == 0x000008, "Wrong alignment on FUIEventTriggerCacheData");
static_assert(sizeof(FUIEventTriggerCacheData) == 0x000050, "Wrong size on FUIEventTriggerCacheData");
static_assert(offsetof(FUIEventTriggerCacheData, UIEventTriggerCache) == 0x000000, "Member 'FUIEventTriggerCacheData::UIEventTriggerCache' has a wrong offset!");

// ScriptStruct Game.FacialAnimationData_Runtime
// 0x0010 (0x0010 - 0x0000)
struct FFacialAnimationData_Runtime final
{
public:
	class FName                                   MorphTargetName;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphTargetTime;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMorphTargetTime;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFacialAnimationData_Runtime) == 0x000004, "Wrong alignment on FFacialAnimationData_Runtime");
static_assert(sizeof(FFacialAnimationData_Runtime) == 0x000010, "Wrong size on FFacialAnimationData_Runtime");
static_assert(offsetof(FFacialAnimationData_Runtime, MorphTargetName) == 0x000000, "Member 'FFacialAnimationData_Runtime::MorphTargetName' has a wrong offset!");
static_assert(offsetof(FFacialAnimationData_Runtime, MorphTargetTime) == 0x000008, "Member 'FFacialAnimationData_Runtime::MorphTargetTime' has a wrong offset!");
static_assert(offsetof(FFacialAnimationData_Runtime, CurrentMorphTargetTime) == 0x00000C, "Member 'FFacialAnimationData_Runtime::CurrentMorphTargetTime' has a wrong offset!");

// ScriptStruct Game.PerformanceFacialAnimationData_Runtime
// 0x0020 (0x0020 - 0x0000)
struct FPerformanceFacialAnimationData_Runtime final
{
public:
	TArray<struct FFacialAnimationData_Runtime>   FacialAnimations;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 FacialMeshComponent;                               // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPlaying;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStoping;                                        // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceFacialAnimationData_Runtime) == 0x000008, "Wrong alignment on FPerformanceFacialAnimationData_Runtime");
static_assert(sizeof(FPerformanceFacialAnimationData_Runtime) == 0x000020, "Wrong size on FPerformanceFacialAnimationData_Runtime");
static_assert(offsetof(FPerformanceFacialAnimationData_Runtime, FacialAnimations) == 0x000000, "Member 'FPerformanceFacialAnimationData_Runtime::FacialAnimations' has a wrong offset!");
static_assert(offsetof(FPerformanceFacialAnimationData_Runtime, FacialMeshComponent) == 0x000010, "Member 'FPerformanceFacialAnimationData_Runtime::FacialMeshComponent' has a wrong offset!");
static_assert(offsetof(FPerformanceFacialAnimationData_Runtime, bIsPlaying) == 0x000018, "Member 'FPerformanceFacialAnimationData_Runtime::bIsPlaying' has a wrong offset!");
static_assert(offsetof(FPerformanceFacialAnimationData_Runtime, bIsStoping) == 0x000019, "Member 'FPerformanceFacialAnimationData_Runtime::bIsStoping' has a wrong offset!");

// ScriptStruct Game.InteractionAnimSequenceSection
// 0x0020 (0x0020 - 0x0000)
struct FInteractionAnimSequenceSection final
{
public:
	TArray<struct FPerformanceAnimInfo>           PreviewAnimSections;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SilentTimeRange;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SilentTime_FirstEntryRange;                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionAnimSequenceSection) == 0x000008, "Wrong alignment on FInteractionAnimSequenceSection");
static_assert(sizeof(FInteractionAnimSequenceSection) == 0x000020, "Wrong size on FInteractionAnimSequenceSection");
static_assert(offsetof(FInteractionAnimSequenceSection, PreviewAnimSections) == 0x000000, "Member 'FInteractionAnimSequenceSection::PreviewAnimSections' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceSection, SilentTimeRange) == 0x000010, "Member 'FInteractionAnimSequenceSection::SilentTimeRange' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceSection, SilentTime_FirstEntryRange) == 0x000018, "Member 'FInteractionAnimSequenceSection::SilentTime_FirstEntryRange' has a wrong offset!");

// ScriptStruct Game.InteractionAnimSequenceLoopConfigTemplate
// 0x0030 (0x0038 - 0x0008)
struct FInteractionAnimSequenceLoopConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionAnimSequenceSection> InteractionAnimSequences;                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHideWeapon;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterInteractionType                     Interaction;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepLoop;                                         // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionCollisionID;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionAnimSequenceLoopConfigTemplate) == 0x000008, "Wrong alignment on FInteractionAnimSequenceLoopConfigTemplate");
static_assert(sizeof(FInteractionAnimSequenceLoopConfigTemplate) == 0x000038, "Wrong size on FInteractionAnimSequenceLoopConfigTemplate");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, ID) == 0x000008, "Member 'FInteractionAnimSequenceLoopConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, CharacterID) == 0x00000C, "Member 'FInteractionAnimSequenceLoopConfigTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, SkinID) == 0x000010, "Member 'FInteractionAnimSequenceLoopConfigTemplate::SkinID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, InteractionAnimSequences) == 0x000018, "Member 'FInteractionAnimSequenceLoopConfigTemplate::InteractionAnimSequences' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, bHideWeapon) == 0x000028, "Member 'FInteractionAnimSequenceLoopConfigTemplate::bHideWeapon' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, Interaction) == 0x000029, "Member 'FInteractionAnimSequenceLoopConfigTemplate::Interaction' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, bKeepLoop) == 0x00002A, "Member 'FInteractionAnimSequenceLoopConfigTemplate::bKeepLoop' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, ActionCollisionID) == 0x00002C, "Member 'FInteractionAnimSequenceLoopConfigTemplate::ActionCollisionID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceLoopConfigTemplate, Weight) == 0x000030, "Member 'FInteractionAnimSequenceLoopConfigTemplate::Weight' has a wrong offset!");

// ScriptStruct Game.PerformanceVoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FPerformanceVoiceInfo final
{
public:
	class FString                                 VoiceID;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerformanceVoiceInfo) == 0x000008, "Wrong alignment on FPerformanceVoiceInfo");
static_assert(sizeof(FPerformanceVoiceInfo) == 0x000018, "Wrong size on FPerformanceVoiceInfo");
static_assert(offsetof(FPerformanceVoiceInfo, VoiceID) == 0x000000, "Member 'FPerformanceVoiceInfo::VoiceID' has a wrong offset!");
static_assert(offsetof(FPerformanceVoiceInfo, Weight) == 0x000010, "Member 'FPerformanceVoiceInfo::Weight' has a wrong offset!");

// ScriptStruct Game.InteractionAnimSequenceConfigTemplate
// 0x0160 (0x0168 - 0x0008)
struct FInteractionAnimSequenceConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimName;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FacialAnimName;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClickInterupt;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimBlendInTime;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequenceBase>       AnimSeq;                                           // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       AnimSeq_Facial;                                    // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FacialAnimationSectionRange;                       // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FacialAnimationDataID;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequenceBase>       EffectAsset;                                       // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectId;                                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EffectSectionRange;                                // 0x00D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPerformanceVoiceInfo>          InteractionVoiceContainer;                         // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         VoiceSectionStartTime;                             // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimFinishInteruptEffect;                         // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CameraCallerID;                                    // 0x0108(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          LevelSequence;                                     // 0x0118(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllAgesOn;                                      // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SocketNames;                                       // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 UIOfAllAges;                                       // 0x0158(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionAnimSequenceConfigTemplate) == 0x000008, "Wrong alignment on FInteractionAnimSequenceConfigTemplate");
static_assert(sizeof(FInteractionAnimSequenceConfigTemplate) == 0x000168, "Wrong size on FInteractionAnimSequenceConfigTemplate");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, ID) == 0x000008, "Member 'FInteractionAnimSequenceConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, CharacterID) == 0x00000C, "Member 'FInteractionAnimSequenceConfigTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, SkinID) == 0x000010, "Member 'FInteractionAnimSequenceConfigTemplate::SkinID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, AnimName) == 0x000018, "Member 'FInteractionAnimSequenceConfigTemplate::AnimName' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, FacialAnimName) == 0x000028, "Member 'FInteractionAnimSequenceConfigTemplate::FacialAnimName' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, bClickInterupt) == 0x000038, "Member 'FInteractionAnimSequenceConfigTemplate::bClickInterupt' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, AnimBlendInTime) == 0x00003C, "Member 'FInteractionAnimSequenceConfigTemplate::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, AnimBlendOutTime) == 0x000040, "Member 'FInteractionAnimSequenceConfigTemplate::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, AnimSeq) == 0x000048, "Member 'FInteractionAnimSequenceConfigTemplate::AnimSeq' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, AnimSeq_Facial) == 0x000070, "Member 'FInteractionAnimSequenceConfigTemplate::AnimSeq_Facial' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, FacialAnimationSectionRange) == 0x000098, "Member 'FInteractionAnimSequenceConfigTemplate::FacialAnimationSectionRange' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, FacialAnimationDataID) == 0x0000A0, "Member 'FInteractionAnimSequenceConfigTemplate::FacialAnimationDataID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, EffectAsset) == 0x0000A8, "Member 'FInteractionAnimSequenceConfigTemplate::EffectAsset' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, EffectId) == 0x0000D0, "Member 'FInteractionAnimSequenceConfigTemplate::EffectId' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, EffectSectionRange) == 0x0000D4, "Member 'FInteractionAnimSequenceConfigTemplate::EffectSectionRange' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, VoiceID) == 0x0000E0, "Member 'FInteractionAnimSequenceConfigTemplate::VoiceID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, InteractionVoiceContainer) == 0x0000F0, "Member 'FInteractionAnimSequenceConfigTemplate::InteractionVoiceContainer' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, VoiceSectionStartTime) == 0x000100, "Member 'FInteractionAnimSequenceConfigTemplate::VoiceSectionStartTime' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, bAnimFinishInteruptEffect) == 0x000104, "Member 'FInteractionAnimSequenceConfigTemplate::bAnimFinishInteruptEffect' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, CameraCallerID) == 0x000108, "Member 'FInteractionAnimSequenceConfigTemplate::CameraCallerID' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, LevelSequence) == 0x000118, "Member 'FInteractionAnimSequenceConfigTemplate::LevelSequence' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, bIsAllAgesOn) == 0x000140, "Member 'FInteractionAnimSequenceConfigTemplate::bIsAllAgesOn' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, SocketNames) == 0x000148, "Member 'FInteractionAnimSequenceConfigTemplate::SocketNames' has a wrong offset!");
static_assert(offsetof(FInteractionAnimSequenceConfigTemplate, UIOfAllAges) == 0x000158, "Member 'FInteractionAnimSequenceConfigTemplate::UIOfAllAges' has a wrong offset!");

// ScriptStruct Game.InteractionBodyPartPhySection
// 0x0018 (0x0018 - 0x0000)
struct FInteractionBodyPartPhySection final
{
public:
	struct FInteractionScope                      Radius;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CustomReboundCurve;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DampingCurve;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionBodyPartPhySection) == 0x000008, "Wrong alignment on FInteractionBodyPartPhySection");
static_assert(sizeof(FInteractionBodyPartPhySection) == 0x000018, "Wrong size on FInteractionBodyPartPhySection");
static_assert(offsetof(FInteractionBodyPartPhySection, Radius) == 0x000000, "Member 'FInteractionBodyPartPhySection::Radius' has a wrong offset!");
static_assert(offsetof(FInteractionBodyPartPhySection, CustomReboundCurve) == 0x000008, "Member 'FInteractionBodyPartPhySection::CustomReboundCurve' has a wrong offset!");
static_assert(offsetof(FInteractionBodyPartPhySection, DampingCurve) == 0x000010, "Member 'FInteractionBodyPartPhySection::DampingCurve' has a wrong offset!");

// ScriptStruct Game.InteractionCustomBreastPhyConfigTemplate
// 0x0128 (0x0130 - 0x0008)
struct FInteractionCustomBreastPhyConfigTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CameraLocationID;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomInteractionType                        InteractionType;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomInteractionBodyPartsType               BodyParts;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftSideFrontAndBackOffset;                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSideFrontAndBackOffset;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftSideUpAndDownOffset;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSideUpAndDownOffset;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBlendSpace>             BlendSpace;                                        // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollisionID;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPhysicsAsset>           PhyAnimSeq;                                        // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionBodyPartPhySection         BodyParameters;                                    // 0x0088(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnimBlendInTime;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NewAnimCondition;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewInterAnimSequenceLoopConfigKey;                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlush;                                            // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceFacialAnim;                                // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequenceBase>       IKOrBSAnimSeq_Facial;                              // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeOfIK;                                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftShoeDroppedValue;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightShoeDroppedValue;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixLeftFootIK;                                    // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixLeftHandIK;                                    // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FixLeftHandValue;                                  // 0x00F0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixRightHandIK;                                   // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FixRightHandValue;                                 // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyeTracking;                                      // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPerformanceVoiceInfo>          InteractionVoiceContainer;                         // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCustomBreastPhyConfigTemplate) == 0x000008, "Wrong alignment on FInteractionCustomBreastPhyConfigTemplate");
static_assert(sizeof(FInteractionCustomBreastPhyConfigTemplate) == 0x000130, "Wrong size on FInteractionCustomBreastPhyConfigTemplate");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, ID) == 0x000008, "Member 'FInteractionCustomBreastPhyConfigTemplate::ID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, CharacterID) == 0x00000C, "Member 'FInteractionCustomBreastPhyConfigTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, SkinID) == 0x000010, "Member 'FInteractionCustomBreastPhyConfigTemplate::SkinID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, CameraLocationID) == 0x000014, "Member 'FInteractionCustomBreastPhyConfigTemplate::CameraLocationID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, InteractionType) == 0x000018, "Member 'FInteractionCustomBreastPhyConfigTemplate::InteractionType' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, BodyParts) == 0x000019, "Member 'FInteractionCustomBreastPhyConfigTemplate::BodyParts' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, LeftSideFrontAndBackOffset) == 0x00001C, "Member 'FInteractionCustomBreastPhyConfigTemplate::LeftSideFrontAndBackOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, RightSideFrontAndBackOffset) == 0x000020, "Member 'FInteractionCustomBreastPhyConfigTemplate::RightSideFrontAndBackOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, LeftSideUpAndDownOffset) == 0x000024, "Member 'FInteractionCustomBreastPhyConfigTemplate::LeftSideUpAndDownOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, RightSideUpAndDownOffset) == 0x000028, "Member 'FInteractionCustomBreastPhyConfigTemplate::RightSideUpAndDownOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, BlendSpace) == 0x000030, "Member 'FInteractionCustomBreastPhyConfigTemplate::BlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, CollisionID) == 0x000058, "Member 'FInteractionCustomBreastPhyConfigTemplate::CollisionID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, PhyAnimSeq) == 0x000060, "Member 'FInteractionCustomBreastPhyConfigTemplate::PhyAnimSeq' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, BodyParameters) == 0x000088, "Member 'FInteractionCustomBreastPhyConfigTemplate::BodyParameters' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, AnimBlendInTime) == 0x0000A0, "Member 'FInteractionCustomBreastPhyConfigTemplate::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, AnimBlendOutTime) == 0x0000A4, "Member 'FInteractionCustomBreastPhyConfigTemplate::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, NewAnimCondition) == 0x0000A8, "Member 'FInteractionCustomBreastPhyConfigTemplate::NewAnimCondition' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, NewInterAnimSequenceLoopConfigKey) == 0x0000B0, "Member 'FInteractionCustomBreastPhyConfigTemplate::NewInterAnimSequenceLoopConfigKey' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bBlush) == 0x0000B4, "Member 'FInteractionCustomBreastPhyConfigTemplate::bBlush' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bReplaceFacialAnim) == 0x0000B5, "Member 'FInteractionCustomBreastPhyConfigTemplate::bReplaceFacialAnim' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, IKOrBSAnimSeq_Facial) == 0x0000B8, "Member 'FInteractionCustomBreastPhyConfigTemplate::IKOrBSAnimSeq_Facial' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, SlopeOfIK) == 0x0000E0, "Member 'FInteractionCustomBreastPhyConfigTemplate::SlopeOfIK' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, LeftShoeDroppedValue) == 0x0000E4, "Member 'FInteractionCustomBreastPhyConfigTemplate::LeftShoeDroppedValue' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, RightShoeDroppedValue) == 0x0000E8, "Member 'FInteractionCustomBreastPhyConfigTemplate::RightShoeDroppedValue' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bFixLeftFootIK) == 0x0000EC, "Member 'FInteractionCustomBreastPhyConfigTemplate::bFixLeftFootIK' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bFixLeftHandIK) == 0x0000ED, "Member 'FInteractionCustomBreastPhyConfigTemplate::bFixLeftHandIK' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, FixLeftHandValue) == 0x0000F0, "Member 'FInteractionCustomBreastPhyConfigTemplate::FixLeftHandValue' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bFixRightHandIK) == 0x0000FC, "Member 'FInteractionCustomBreastPhyConfigTemplate::bFixRightHandIK' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, FixRightHandValue) == 0x000100, "Member 'FInteractionCustomBreastPhyConfigTemplate::FixRightHandValue' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, bEyeTracking) == 0x00010C, "Member 'FInteractionCustomBreastPhyConfigTemplate::bEyeTracking' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, VoiceID) == 0x000110, "Member 'FInteractionCustomBreastPhyConfigTemplate::VoiceID' has a wrong offset!");
static_assert(offsetof(FInteractionCustomBreastPhyConfigTemplate, InteractionVoiceContainer) == 0x000120, "Member 'FInteractionCustomBreastPhyConfigTemplate::InteractionVoiceContainer' has a wrong offset!");

// ScriptStruct Game.InteractionUIEventTriggerCacheData
// 0x0050 (0x0050 - 0x0000)
struct FInteractionUIEventTriggerCacheData final
{
public:
	TMap<ECharacterInteractionType, int32>        InteractionUIEventTriggerCache;                    // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionUIEventTriggerCacheData) == 0x000008, "Wrong alignment on FInteractionUIEventTriggerCacheData");
static_assert(sizeof(FInteractionUIEventTriggerCacheData) == 0x000050, "Wrong size on FInteractionUIEventTriggerCacheData");
static_assert(offsetof(FInteractionUIEventTriggerCacheData, InteractionUIEventTriggerCache) == 0x000000, "Member 'FInteractionUIEventTriggerCacheData::InteractionUIEventTriggerCache' has a wrong offset!");

// ScriptStruct Game.CharacterPerformanceAnimSequenceData_Runtime
// 0x05B0 (0x05B0 - 0x0000)
struct FCharacterPerformanceAnimSequenceData_Runtime final
{
public:
	class FName                                   CharacterName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AnimSequenceCandidateKeys;                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InteractionAnimSequenceCandidateKeys;              // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentAnimSequenceLoopConfigKey;                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentInteractionAnimSequenceLoopConfigKey;       // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerformanceAnimSequenceLoopConfigTemplate CurrentLoopAnimSequenceData;                       // 0x0030(0x0040)(NativeAccessSpecifierPublic)
	struct FInteractionAnimSequenceLoopConfigTemplate CurrentInteractionLoopAnimSequenceData;            // 0x0070(0x0038)(NativeAccessSpecifierPublic)
	int32                                         CurrentAnimSequenceLoopConfigKey_UIEvent;          // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentInteractionAnimSequenceLoopConfigKey_UIEvent; // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerformanceAnimSequenceLoopConfigTemplate CurrentLoopAnimSequenceData_UIEvent;               // 0x00B0(0x0040)(NativeAccessSpecifierPublic)
	struct FInteractionAnimSequenceLoopConfigTemplate CurrentInteractionLoopAnimSequenceData_UIEvent;    // 0x00F0(0x0038)(NativeAccessSpecifierPublic)
	int32                                         CurrentAnimSequenceKey;                            // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentInteractionAnimSequenceKey;                 // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewInterAnimSequenceLoopConfigKey;                 // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerformanceAnimSequenceConfigTemplate CurrentAnimSequenceData;                           // 0x0138(0x0158)(NativeAccessSpecifierPublic)
	struct FInteractionAnimSequenceConfigTemplate CurrentInteractionAnimSequenceData;                // 0x0290(0x0168)(NativeAccessSpecifierPublic)
	TArray<struct FInteractionCustomBreastPhyConfigTemplate> InteractionCustomBreastPhyConfigContainer;         // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPerformanceAnimSequenceLoopConfigTemplate> AnimSequenceData_UIEventAnimContainer;             // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInteractionAnimSequenceLoopConfigTemplate> InteractionAnimSequenceData_UIEventAnimContainer;  // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInteractionCustomBreastPhyConfigTemplate> BlendSpaceConfigContainer;                         // 0x0428(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInteractionCustomBreastPhyConfigTemplate> IKConfigContainer;                                 // 0x0438(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EUIWidgetAnimType, struct FUIEventTriggerCacheData> WidgetEventTriggerCacheContainer;                  // 0x0448(0x0050)(NativeAccessSpecifierPublic)
	TMap<EUIWidgetAnimType, struct FInteractionUIEventTriggerCacheData> InteractionWidgetEventTriggerCacheContainer;       // 0x0498(0x0050)(NativeAccessSpecifierPublic)
	float                                         AnimSeqTime_Elapsed;                               // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSeqTime_Total;                                 // 0x04EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSeqTime_SilentTime;                            // 0x04F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x04F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSilenting;                                      // 0x04F5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstEntry;                                     // 0x04F6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractionFirstEntry;                          // 0x04F7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingRotateCompelete;                           // 0x04F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingRotateCompelete_UIEvent;                   // 0x04F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractiveCharacter;                           // 0x04FA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllAgesOnEventTriggered;                        // 0x04FB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIWidgetAnimType                             WidgetAnimType;                                    // 0x04FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoiceTriggered;                                   // 0x04FD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaciaAnimTriggered;                               // 0x04FE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectTriggered;                                  // 0x04FF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraAnimTriggered;                              // 0x0500(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingLoopEffect;                                // 0x0501(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponHiding;                                     // 0x0502(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUIWidgetTransOn;                                  // 0x0503(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopAnimSeqIndex;                                  // 0x0504(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopInteractionAnimSeqIndex;                       // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopAnimSeqIndex_UIEvent;                          // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionLoopAnimSeqIndex_UIEvent;               // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewCharacterAnimInstance*          PreviewAnimInstance;                               // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentGirlName;                                   // 0x0520(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentWeaponName;                                 // 0x0530(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCharacterSkinTemplateId;                    // 0x0540(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PlayingMontage;                                    // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     PlayingEffect;                                     // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThirdPersonPlayerCameraManager*        PlayerCameraManager;                               // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerformanceFacialAnimationData_Runtime FacialAnimationInstance;                           // 0x0560(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              CurrentPerformanceAnimAssetContainer;              // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ASkeletalMeshActor*>             CurrentMeshReplaceActorContainer;                  // 0x0590(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x10];                                     // 0x05A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterPerformanceAnimSequenceData_Runtime) == 0x000008, "Wrong alignment on FCharacterPerformanceAnimSequenceData_Runtime");
static_assert(sizeof(FCharacterPerformanceAnimSequenceData_Runtime) == 0x0005B0, "Wrong size on FCharacterPerformanceAnimSequenceData_Runtime");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CharacterName) == 0x000000, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CharacterName' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, AnimSequenceCandidateKeys) == 0x000008, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::AnimSequenceCandidateKeys' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, InteractionAnimSequenceCandidateKeys) == 0x000018, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::InteractionAnimSequenceCandidateKeys' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentAnimSequenceLoopConfigKey) == 0x000028, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentAnimSequenceLoopConfigKey' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionAnimSequenceLoopConfigKey) == 0x00002C, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionAnimSequenceLoopConfigKey' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentLoopAnimSequenceData) == 0x000030, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentLoopAnimSequenceData' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionLoopAnimSequenceData) == 0x000070, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionLoopAnimSequenceData' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentAnimSequenceLoopConfigKey_UIEvent) == 0x0000A8, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentAnimSequenceLoopConfigKey_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionAnimSequenceLoopConfigKey_UIEvent) == 0x0000AC, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionAnimSequenceLoopConfigKey_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentLoopAnimSequenceData_UIEvent) == 0x0000B0, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentLoopAnimSequenceData_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionLoopAnimSequenceData_UIEvent) == 0x0000F0, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionLoopAnimSequenceData_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentAnimSequenceKey) == 0x000128, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentAnimSequenceKey' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionAnimSequenceKey) == 0x00012C, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionAnimSequenceKey' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, NewInterAnimSequenceLoopConfigKey) == 0x000130, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::NewInterAnimSequenceLoopConfigKey' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentAnimSequenceData) == 0x000138, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentAnimSequenceData' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentInteractionAnimSequenceData) == 0x000290, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentInteractionAnimSequenceData' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, InteractionCustomBreastPhyConfigContainer) == 0x0003F8, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::InteractionCustomBreastPhyConfigContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, AnimSequenceData_UIEventAnimContainer) == 0x000408, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::AnimSequenceData_UIEventAnimContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, InteractionAnimSequenceData_UIEventAnimContainer) == 0x000418, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::InteractionAnimSequenceData_UIEventAnimContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, BlendSpaceConfigContainer) == 0x000428, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::BlendSpaceConfigContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, IKConfigContainer) == 0x000438, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::IKConfigContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, WidgetEventTriggerCacheContainer) == 0x000448, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::WidgetEventTriggerCacheContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, InteractionWidgetEventTriggerCacheContainer) == 0x000498, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::InteractionWidgetEventTriggerCacheContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, AnimSeqTime_Elapsed) == 0x0004E8, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::AnimSeqTime_Elapsed' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, AnimSeqTime_Total) == 0x0004EC, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::AnimSeqTime_Total' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, AnimSeqTime_SilentTime) == 0x0004F0, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::AnimSeqTime_SilentTime' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsPlaying) == 0x0004F4, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsPlaying' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsSilenting) == 0x0004F5, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsSilenting' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsFirstEntry) == 0x0004F6, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsFirstEntry' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsInteractionFirstEntry) == 0x0004F7, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsInteractionFirstEntry' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bWaitingRotateCompelete) == 0x0004F8, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bWaitingRotateCompelete' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bWaitingRotateCompelete_UIEvent) == 0x0004F9, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bWaitingRotateCompelete_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsInteractiveCharacter) == 0x0004FA, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsInteractiveCharacter' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bIsAllAgesOnEventTriggered) == 0x0004FB, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bIsAllAgesOnEventTriggered' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, WidgetAnimType) == 0x0004FC, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::WidgetAnimType' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bVoiceTriggered) == 0x0004FD, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bVoiceTriggered' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bFaciaAnimTriggered) == 0x0004FE, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bFaciaAnimTriggered' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bEffectTriggered) == 0x0004FF, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bEffectTriggered' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bCameraAnimTriggered) == 0x000500, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bCameraAnimTriggered' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bPlayingLoopEffect) == 0x000501, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bPlayingLoopEffect' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bWeaponHiding) == 0x000502, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bWeaponHiding' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, bUIWidgetTransOn) == 0x000503, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::bUIWidgetTransOn' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, LoopAnimSeqIndex) == 0x000504, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::LoopAnimSeqIndex' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, LoopInteractionAnimSeqIndex) == 0x000508, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::LoopInteractionAnimSeqIndex' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, LoopAnimSeqIndex_UIEvent) == 0x00050C, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::LoopAnimSeqIndex_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, InteractionLoopAnimSeqIndex_UIEvent) == 0x000510, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::InteractionLoopAnimSeqIndex_UIEvent' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, PreviewAnimInstance) == 0x000518, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::PreviewAnimInstance' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentGirlName) == 0x000520, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentGirlName' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentWeaponName) == 0x000530, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentWeaponName' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentCharacterSkinTemplateId) == 0x000540, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentCharacterSkinTemplateId' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, PlayingMontage) == 0x000548, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::PlayingMontage' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, PlayingEffect) == 0x000550, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::PlayingEffect' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, PlayerCameraManager) == 0x000558, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, FacialAnimationInstance) == 0x000560, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::FacialAnimationInstance' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentPerformanceAnimAssetContainer) == 0x000580, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentPerformanceAnimAssetContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceData_Runtime, CurrentMeshReplaceActorContainer) == 0x000590, "Member 'FCharacterPerformanceAnimSequenceData_Runtime::CurrentMeshReplaceActorContainer' has a wrong offset!");

// ScriptStruct Game.BoneChildArray
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBoneChildArray final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneChildArray) == 0x000008, "Wrong alignment on FBoneChildArray");
static_assert(sizeof(FBoneChildArray) == 0x000018, "Wrong size on FBoneChildArray");

// ScriptStruct Game.Boneinfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FBoneinfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneinfo) == 0x000004, "Wrong alignment on FBoneinfo");
static_assert(sizeof(FBoneinfo) == 0x000014, "Wrong size on FBoneinfo");

// ScriptStruct Game.ScaredCrowPartitionData
// 0x0110 (0x0110 - 0x0000)
struct FScaredCrowPartitionData final
{
public:
	struct FPartitionData                         ScaredCrowPartitionData;                           // 0x0000(0x0100)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x0100(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerActor;                                        // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScaredCrowPartitionData) == 0x000008, "Wrong alignment on FScaredCrowPartitionData");
static_assert(sizeof(FScaredCrowPartitionData) == 0x000110, "Wrong size on FScaredCrowPartitionData");
static_assert(offsetof(FScaredCrowPartitionData, ScaredCrowPartitionData) == 0x000000, "Member 'FScaredCrowPartitionData::ScaredCrowPartitionData' has a wrong offset!");
static_assert(offsetof(FScaredCrowPartitionData, SkeletalMeshComp) == 0x000100, "Member 'FScaredCrowPartitionData::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(FScaredCrowPartitionData, OwnerActor) == 0x000108, "Member 'FScaredCrowPartitionData::OwnerActor' has a wrong offset!");

// ScriptStruct Game.GamepadPressInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FGamepadPressInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamepadPressInfo) == 0x000008, "Wrong alignment on FGamepadPressInfo");
static_assert(sizeof(FGamepadPressInfo) == 0x000038, "Wrong size on FGamepadPressInfo");

// ScriptStruct Game.PartEditorData
// 0x0070 (0x0070 - 0x0000)
struct FPartEditorData final
{
public:
	class FString                                 PartBoneNames;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExtraBoneName;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeakPart;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInefficiently;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainPart;                                         // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaknessDamageScale;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InefficiencyDamageScale;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncePre;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceExtraPre;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitLagMulti;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartTag;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsScareCrowPart;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScareCrowTargetPartTag;                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartEditorData) == 0x000008, "Wrong alignment on FPartEditorData");
static_assert(sizeof(FPartEditorData) == 0x000070, "Wrong size on FPartEditorData");
static_assert(offsetof(FPartEditorData, PartBoneNames) == 0x000000, "Member 'FPartEditorData::PartBoneNames' has a wrong offset!");
static_assert(offsetof(FPartEditorData, ExtraBoneName) == 0x000010, "Member 'FPartEditorData::ExtraBoneName' has a wrong offset!");
static_assert(offsetof(FPartEditorData, bWeakPart) == 0x000020, "Member 'FPartEditorData::bWeakPart' has a wrong offset!");
static_assert(offsetof(FPartEditorData, bInefficiently) == 0x000021, "Member 'FPartEditorData::bInefficiently' has a wrong offset!");
static_assert(offsetof(FPartEditorData, bMainPart) == 0x000022, "Member 'FPartEditorData::bMainPart' has a wrong offset!");
static_assert(offsetof(FPartEditorData, WeaknessDamageScale) == 0x000024, "Member 'FPartEditorData::WeaknessDamageScale' has a wrong offset!");
static_assert(offsetof(FPartEditorData, InefficiencyDamageScale) == 0x000028, "Member 'FPartEditorData::InefficiencyDamageScale' has a wrong offset!");
static_assert(offsetof(FPartEditorData, BouncePre) == 0x00002C, "Member 'FPartEditorData::BouncePre' has a wrong offset!");
static_assert(offsetof(FPartEditorData, BounceExtraPre) == 0x000030, "Member 'FPartEditorData::BounceExtraPre' has a wrong offset!");
static_assert(offsetof(FPartEditorData, HitLagMulti) == 0x000034, "Member 'FPartEditorData::HitLagMulti' has a wrong offset!");
static_assert(offsetof(FPartEditorData, PartTag) == 0x000038, "Member 'FPartEditorData::PartTag' has a wrong offset!");
static_assert(offsetof(FPartEditorData, bAsScareCrowPart) == 0x000048, "Member 'FPartEditorData::bAsScareCrowPart' has a wrong offset!");
static_assert(offsetof(FPartEditorData, ScareCrowTargetPartTag) == 0x000050, "Member 'FPartEditorData::ScareCrowTargetPartTag' has a wrong offset!");
static_assert(offsetof(FPartEditorData, LocationOffset) == 0x000060, "Member 'FPartEditorData::LocationOffset' has a wrong offset!");

// ScriptStruct Game.PartitionEditorData
// 0x0050 (0x0050 - 0x0000)
struct FPartitionEditorData final
{
public:
	class FString                                 PartitionBone;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPartEditorData>                PartInfos;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOtherBonesNewPart;                                // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonBodyType                                  BodyType;                                          // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElemExplosionUptakeEfficien;                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartitionTag;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsScareCrowPartition;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScareCrowTargetPartition;                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartitionEditorData) == 0x000008, "Wrong alignment on FPartitionEditorData");
static_assert(sizeof(FPartitionEditorData) == 0x000050, "Wrong size on FPartitionEditorData");
static_assert(offsetof(FPartitionEditorData, PartitionBone) == 0x000000, "Member 'FPartitionEditorData::PartitionBone' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, PartInfos) == 0x000010, "Member 'FPartitionEditorData::PartInfos' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, bOtherBonesNewPart) == 0x000020, "Member 'FPartitionEditorData::bOtherBonesNewPart' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, BodyType) == 0x000021, "Member 'FPartitionEditorData::BodyType' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, ElemExplosionUptakeEfficien) == 0x000024, "Member 'FPartitionEditorData::ElemExplosionUptakeEfficien' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, PartitionTag) == 0x000028, "Member 'FPartitionEditorData::PartitionTag' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, bAsScareCrowPartition) == 0x000038, "Member 'FPartitionEditorData::bAsScareCrowPartition' has a wrong offset!");
static_assert(offsetof(FPartitionEditorData, ScareCrowTargetPartition) == 0x000040, "Member 'FPartitionEditorData::ScareCrowTargetPartition' has a wrong offset!");

// ScriptStruct Game.SpecialAssetReplace
// 0x0070 (0x0078 - 0x0008)
struct FSpecialAssetReplace final : public FTableRowBase
{
public:
	int32                                         D;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SpecialOrignalAsset;                               // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FSoftObjectPath>           SpecialReplaceAsset;                               // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialAssetReplace) == 0x000008, "Wrong alignment on FSpecialAssetReplace");
static_assert(sizeof(FSpecialAssetReplace) == 0x000078, "Wrong size on FSpecialAssetReplace");
static_assert(offsetof(FSpecialAssetReplace, D) == 0x000008, "Member 'FSpecialAssetReplace::D' has a wrong offset!");
static_assert(offsetof(FSpecialAssetReplace, P) == 0x00000C, "Member 'FSpecialAssetReplace::P' has a wrong offset!");
static_assert(offsetof(FSpecialAssetReplace, SpecialOrignalAsset) == 0x000010, "Member 'FSpecialAssetReplace::SpecialOrignalAsset' has a wrong offset!");
static_assert(offsetof(FSpecialAssetReplace, SpecialReplaceAsset) == 0x000028, "Member 'FSpecialAssetReplace::SpecialReplaceAsset' has a wrong offset!");

// ScriptStruct Game.PartBounceData
// 0x0008 (0x0008 - 0x0000)
struct FPartBounceData final
{
public:
	float                                         BouncePre;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceExtraPre;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartBounceData) == 0x000004, "Wrong alignment on FPartBounceData");
static_assert(sizeof(FPartBounceData) == 0x000008, "Wrong size on FPartBounceData");
static_assert(offsetof(FPartBounceData, BouncePre) == 0x000000, "Member 'FPartBounceData::BouncePre' has a wrong offset!");
static_assert(offsetof(FPartBounceData, BounceExtraPre) == 0x000004, "Member 'FPartBounceData::BounceExtraPre' has a wrong offset!");

// ScriptStruct Game.PlayerShopValid
// 0x0010 (0x0010 - 0x0000)
struct FPlayerShopValid final
{
public:
	class AActor*                                 Player;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsValidShop : 1;                                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerShopValid) == 0x000008, "Wrong alignment on FPlayerShopValid");
static_assert(sizeof(FPlayerShopValid) == 0x000010, "Wrong size on FPlayerShopValid");
static_assert(offsetof(FPlayerShopValid, Player) == 0x000000, "Member 'FPlayerShopValid::Player' has a wrong offset!");

// ScriptStruct Game.BulletCollection
// 0x0010 (0x0010 - 0x0000)
struct FBulletCollection final
{
public:
	TArray<class ABullet*>                        Bullets;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletCollection) == 0x000008, "Wrong alignment on FBulletCollection");
static_assert(sizeof(FBulletCollection) == 0x000010, "Wrong size on FBulletCollection");
static_assert(offsetof(FBulletCollection, Bullets) == 0x000000, "Member 'FBulletCollection::Bullets' has a wrong offset!");

// ScriptStruct Game.BulletCommonMoveData
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x10) FBulletCommonMoveData final
{
public:
	uint8                                         Pad_0[0x110];                                      // 0x0000(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletCommonMoveData) == 0x000010, "Wrong alignment on FBulletCommonMoveData");
static_assert(sizeof(FBulletCommonMoveData) == 0x000110, "Wrong size on FBulletCommonMoveData");

// ScriptStruct Game.BowArrowResidueData
// 0x0100 (0x0100 - 0x0000)
struct FBowArrowResidueData final
{
public:
	class FName                                   BowArrowTag;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BowArrowResidueID;                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BowArrowResidueTime;                               // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQueryResult                           HitTarget;                                         // 0x0010(0x0090)(BlueprintVisible, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     HitTargetComponent;                                // 0x00A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x00B0(0x0030)(BlueprintVisible, Transient, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWillRemove;                                       // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBowArrowResidueType                          ResidueType;                                       // 0x00E1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UModifier*                              MarkModifier;                                      // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  MarkTarget;                                        // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MarkModifierRuntimeID;                             // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBowArrowResidueData) == 0x000010, "Wrong alignment on FBowArrowResidueData");
static_assert(sizeof(FBowArrowResidueData) == 0x000100, "Wrong size on FBowArrowResidueData");
static_assert(offsetof(FBowArrowResidueData, BowArrowTag) == 0x000000, "Member 'FBowArrowResidueData::BowArrowTag' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, BowArrowResidueID) == 0x000008, "Member 'FBowArrowResidueData::BowArrowResidueID' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, BowArrowResidueTime) == 0x00000C, "Member 'FBowArrowResidueData::BowArrowResidueTime' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, HitTarget) == 0x000010, "Member 'FBowArrowResidueData::HitTarget' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, HitTargetComponent) == 0x0000A0, "Member 'FBowArrowResidueData::HitTargetComponent' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, Socket) == 0x0000A8, "Member 'FBowArrowResidueData::Socket' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, RelativeTransform) == 0x0000B0, "Member 'FBowArrowResidueData::RelativeTransform' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, bWillRemove) == 0x0000E0, "Member 'FBowArrowResidueData::bWillRemove' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, ResidueType) == 0x0000E1, "Member 'FBowArrowResidueData::ResidueType' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, MarkModifier) == 0x0000E8, "Member 'FBowArrowResidueData::MarkModifier' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, MarkTarget) == 0x0000F0, "Member 'FBowArrowResidueData::MarkTarget' has a wrong offset!");
static_assert(offsetof(FBowArrowResidueData, MarkModifierRuntimeID) == 0x0000F8, "Member 'FBowArrowResidueData::MarkModifierRuntimeID' has a wrong offset!");

// ScriptStruct Game.ClusterBulletStage
// 0x0058 (0x0058 - 0x0000)
struct FClusterBulletStage final
{
public:
	EBulletMovementType                           MoveType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StageTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitSpeed;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDir;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FixedEmitterID;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAngularSpeed;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFixedHomingAngularSpeed : 1;                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurveFloat;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClusterBulletStage) == 0x000008, "Wrong alignment on FClusterBulletStage");
static_assert(sizeof(FClusterBulletStage) == 0x000058, "Wrong size on FClusterBulletStage");
static_assert(offsetof(FClusterBulletStage, MoveType) == 0x000000, "Member 'FClusterBulletStage::MoveType' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, StageTime) == 0x000004, "Member 'FClusterBulletStage::StageTime' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, InitSpeed) == 0x000008, "Member 'FClusterBulletStage::InitSpeed' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, Acceleration) == 0x00000C, "Member 'FClusterBulletStage::Acceleration' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, GravityScale) == 0x000010, "Member 'FClusterBulletStage::GravityScale' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, MoveDir) == 0x000014, "Member 'FClusterBulletStage::MoveDir' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, FixedEmitterID) == 0x000020, "Member 'FClusterBulletStage::FixedEmitterID' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, HomingAngularSpeed) == 0x000024, "Member 'FClusterBulletStage::HomingAngularSpeed' has a wrong offset!");
static_assert(offsetof(FClusterBulletStage, CurveFloat) == 0x000030, "Member 'FClusterBulletStage::CurveFloat' has a wrong offset!");

// ScriptStruct Game.ClusterBulletBaseInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FClusterBulletBaseInfo
{
public:
	int32                                         UniqueId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletUniquerID;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQueryResult                           QueryResult;                                       // 0x0018(0x0090)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FClusterBulletStage>            Stages;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterBulletBaseInfo) == 0x000008, "Wrong alignment on FClusterBulletBaseInfo");
static_assert(sizeof(FClusterBulletBaseInfo) == 0x0000B8, "Wrong size on FClusterBulletBaseInfo");
static_assert(offsetof(FClusterBulletBaseInfo, UniqueId) == 0x000000, "Member 'FClusterBulletBaseInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseInfo, BulletID) == 0x000004, "Member 'FClusterBulletBaseInfo::BulletID' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseInfo, BulletUniquerID) == 0x000008, "Member 'FClusterBulletBaseInfo::BulletUniquerID' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseInfo, SpawnLocation) == 0x00000C, "Member 'FClusterBulletBaseInfo::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseInfo, QueryResult) == 0x000018, "Member 'FClusterBulletBaseInfo::QueryResult' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseInfo, Stages) == 0x0000A8, "Member 'FClusterBulletBaseInfo::Stages' has a wrong offset!");

// ScriptStruct Game.ClusterBulletRuntimeInfo
// 0x0110 (0x01C8 - 0x00B8)
struct FClusterBulletRuntimeInfo final : public FClusterBulletBaseInfo
{
public:
	int32                                         StageIndex;                                        // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlive;                                            // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x00BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickTotalTime;                                     // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageElapseTime;                                   // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveForward;                                       // 0x00CC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x00D8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurAcceleration;                                   // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurGravityScale;                                   // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x00EC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x00F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitTraceStart;                                     // 0x0104(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurEmitterID;                                      // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            BulletHitNiagara;                                  // 0x0118(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UWwiseComponent*                        FlyWwiseComponent;                                 // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestinationPoint;                                  // 0x0180(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HomingTarget;                                      // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HomingSocket;                                      // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HomingTargetComponent;                             // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HomingSocketOffset;                                // 0x01A8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterp;                                    // 0x01B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     BulletParticle;                                    // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletNiagaraIndex;                                // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletTailNiagaraIndex;                            // 0x01C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterBulletRuntimeInfo) == 0x000008, "Wrong alignment on FClusterBulletRuntimeInfo");
static_assert(sizeof(FClusterBulletRuntimeInfo) == 0x0001C8, "Wrong size on FClusterBulletRuntimeInfo");
static_assert(offsetof(FClusterBulletRuntimeInfo, StageIndex) == 0x0000B8, "Member 'FClusterBulletRuntimeInfo::StageIndex' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, bAlive) == 0x0000BC, "Member 'FClusterBulletRuntimeInfo::bAlive' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, bMoving) == 0x0000BD, "Member 'FClusterBulletRuntimeInfo::bMoving' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, TickTotalTime) == 0x0000C0, "Member 'FClusterBulletRuntimeInfo::TickTotalTime' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, StageElapseTime) == 0x0000C4, "Member 'FClusterBulletRuntimeInfo::StageElapseTime' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, LifeTime) == 0x0000C8, "Member 'FClusterBulletRuntimeInfo::LifeTime' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, MoveForward) == 0x0000CC, "Member 'FClusterBulletRuntimeInfo::MoveForward' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, Velocity) == 0x0000D8, "Member 'FClusterBulletRuntimeInfo::Velocity' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, CurAcceleration) == 0x0000E4, "Member 'FClusterBulletRuntimeInfo::CurAcceleration' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, CurGravityScale) == 0x0000E8, "Member 'FClusterBulletRuntimeInfo::CurGravityScale' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, TraceStart) == 0x0000EC, "Member 'FClusterBulletRuntimeInfo::TraceStart' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, TraceEnd) == 0x0000F8, "Member 'FClusterBulletRuntimeInfo::TraceEnd' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, HitTraceStart) == 0x000104, "Member 'FClusterBulletRuntimeInfo::HitTraceStart' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, CurEmitterID) == 0x000110, "Member 'FClusterBulletRuntimeInfo::CurEmitterID' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, BulletHitNiagara) == 0x000118, "Member 'FClusterBulletRuntimeInfo::BulletHitNiagara' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, IgnoreActors) == 0x000168, "Member 'FClusterBulletRuntimeInfo::IgnoreActors' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, FlyWwiseComponent) == 0x000178, "Member 'FClusterBulletRuntimeInfo::FlyWwiseComponent' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, DestinationPoint) == 0x000180, "Member 'FClusterBulletRuntimeInfo::DestinationPoint' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, HomingTarget) == 0x000190, "Member 'FClusterBulletRuntimeInfo::HomingTarget' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, HomingSocket) == 0x000198, "Member 'FClusterBulletRuntimeInfo::HomingSocket' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, HomingTargetComponent) == 0x0001A0, "Member 'FClusterBulletRuntimeInfo::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, HomingSocketOffset) == 0x0001A8, "Member 'FClusterBulletRuntimeInfo::HomingSocketOffset' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, RotationInterp) == 0x0001B4, "Member 'FClusterBulletRuntimeInfo::RotationInterp' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, BulletParticle) == 0x0001B8, "Member 'FClusterBulletRuntimeInfo::BulletParticle' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, BulletNiagaraIndex) == 0x0001C0, "Member 'FClusterBulletRuntimeInfo::BulletNiagaraIndex' has a wrong offset!");
static_assert(offsetof(FClusterBulletRuntimeInfo, BulletTailNiagaraIndex) == 0x0001C4, "Member 'FClusterBulletRuntimeInfo::BulletTailNiagaraIndex' has a wrong offset!");

// ScriptStruct Game.CameraSocketInfo
// 0x0030 (0x0030 - 0x0000)
struct FCameraSocketInfo final
{
public:
	class FName                                   Socket;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutBlendMaxTime;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendMaxTime;                                    // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FOVCurve;                                          // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESocketCameraType                             CurrentType;                                       // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraSocketInfo) == 0x000008, "Wrong alignment on FCameraSocketInfo");
static_assert(sizeof(FCameraSocketInfo) == 0x000030, "Wrong size on FCameraSocketInfo");
static_assert(offsetof(FCameraSocketInfo, Socket) == 0x000000, "Member 'FCameraSocketInfo::Socket' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, Time) == 0x000008, "Member 'FCameraSocketInfo::Time' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, MaxTime) == 0x00000C, "Member 'FCameraSocketInfo::MaxTime' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, OutBlendMaxTime) == 0x000010, "Member 'FCameraSocketInfo::OutBlendMaxTime' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, BlendOutTime) == 0x000014, "Member 'FCameraSocketInfo::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, InBlendMaxTime) == 0x000018, "Member 'FCameraSocketInfo::InBlendMaxTime' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, BlendInTime) == 0x00001C, "Member 'FCameraSocketInfo::BlendInTime' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, FOVCurve) == 0x000020, "Member 'FCameraSocketInfo::FOVCurve' has a wrong offset!");
static_assert(offsetof(FCameraSocketInfo, CurrentType) == 0x000028, "Member 'FCameraSocketInfo::CurrentType' has a wrong offset!");

// ScriptStruct Game.ClusterBulletBaseCircleInfo
// 0x0038 (0x0038 - 0x0000)
struct FClusterBulletBaseCircleInfo final
{
public:
	int32                                         UniqueId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StageIndex;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotDir;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleSpeed;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterMoveSpeed;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusSpeed;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterUniqueID;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterBulletBaseCircleInfo) == 0x000004, "Wrong alignment on FClusterBulletBaseCircleInfo");
static_assert(sizeof(FClusterBulletBaseCircleInfo) == 0x000038, "Wrong size on FClusterBulletBaseCircleInfo");
static_assert(offsetof(FClusterBulletBaseCircleInfo, UniqueId) == 0x000000, "Member 'FClusterBulletBaseCircleInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, StageIndex) == 0x000004, "Member 'FClusterBulletBaseCircleInfo::StageIndex' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, Center) == 0x000008, "Member 'FClusterBulletBaseCircleInfo::Center' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, Axis) == 0x000014, "Member 'FClusterBulletBaseCircleInfo::Axis' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, Radius) == 0x000020, "Member 'FClusterBulletBaseCircleInfo::Radius' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, RotDir) == 0x000024, "Member 'FClusterBulletBaseCircleInfo::RotDir' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, AngleSpeed) == 0x000028, "Member 'FClusterBulletBaseCircleInfo::AngleSpeed' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, CenterMoveSpeed) == 0x00002C, "Member 'FClusterBulletBaseCircleInfo::CenterMoveSpeed' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, RadiusSpeed) == 0x000030, "Member 'FClusterBulletBaseCircleInfo::RadiusSpeed' has a wrong offset!");
static_assert(offsetof(FClusterBulletBaseCircleInfo, CenterUniqueID) == 0x000034, "Member 'FClusterBulletBaseCircleInfo::CenterUniqueID' has a wrong offset!");

// ScriptStruct Game.BulletScreenRay
// 0x0028 (0x0028 - 0x0000)
struct FBulletScreenRay final
{
public:
	float                                         CurTime;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoTickDamage;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletScreenRay) == 0x000004, "Wrong alignment on FBulletScreenRay");
static_assert(sizeof(FBulletScreenRay) == 0x000028, "Wrong size on FBulletScreenRay");
static_assert(offsetof(FBulletScreenRay, CurTime) == 0x000000, "Member 'FBulletScreenRay::CurTime' has a wrong offset!");
static_assert(offsetof(FBulletScreenRay, EndTime) == 0x000004, "Member 'FBulletScreenRay::EndTime' has a wrong offset!");
static_assert(offsetof(FBulletScreenRay, StartPos) == 0x000008, "Member 'FBulletScreenRay::StartPos' has a wrong offset!");
static_assert(offsetof(FBulletScreenRay, EndPos) == 0x000014, "Member 'FBulletScreenRay::EndPos' has a wrong offset!");
static_assert(offsetof(FBulletScreenRay, BulletID) == 0x000020, "Member 'FBulletScreenRay::BulletID' has a wrong offset!");
static_assert(offsetof(FBulletScreenRay, bAutoTickDamage) == 0x000024, "Member 'FBulletScreenRay::bAutoTickDamage' has a wrong offset!");

// ScriptStruct Game.BunkerQueryData
// 0x0010 (0x0010 - 0x0000)
struct FBunkerQueryData final
{
public:
	class UBunkerPointComponent*                  BunkerPoint;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBunkerQueryData) == 0x000008, "Wrong alignment on FBunkerQueryData");
static_assert(sizeof(FBunkerQueryData) == 0x000010, "Wrong size on FBunkerQueryData");
static_assert(offsetof(FBunkerQueryData, BunkerPoint) == 0x000000, "Member 'FBunkerQueryData::BunkerPoint' has a wrong offset!");

// ScriptStruct Game.HouseMassagePointInfo
// 0x0098 (0x0098 - 0x0000)
struct FHouseMassagePointInfo final
{
public:
	int32                                         NpcId;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupId;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dir;                                               // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateBoneNearest;                                 // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHouseMassagePowerType                        PowerType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseForcePos;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceTime;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringLength;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ForceStrengthCurve;                                // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x47];                                      // 0x0049(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsHandleComponent*                OwnedPhysicsHandle;                                // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseMassagePointInfo) == 0x000008, "Wrong alignment on FHouseMassagePointInfo");
static_assert(sizeof(FHouseMassagePointInfo) == 0x000098, "Wrong size on FHouseMassagePointInfo");
static_assert(offsetof(FHouseMassagePointInfo, NpcId) == 0x000000, "Member 'FHouseMassagePointInfo::NpcId' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, GroupId) == 0x000004, "Member 'FHouseMassagePointInfo::GroupId' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, Dir) == 0x000008, "Member 'FHouseMassagePointInfo::Dir' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, UpdateBoneNearest) == 0x000014, "Member 'FHouseMassagePointInfo::UpdateBoneNearest' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, BoneName) == 0x000018, "Member 'FHouseMassagePointInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, PowerType) == 0x000020, "Member 'FHouseMassagePointInfo::PowerType' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, UseForcePos) == 0x000021, "Member 'FHouseMassagePointInfo::UseForcePos' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, ForceTime) == 0x000024, "Member 'FHouseMassagePointInfo::ForceTime' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, SpringLength) == 0x000028, "Member 'FHouseMassagePointInfo::SpringLength' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, ForceStrengthCurve) == 0x000030, "Member 'FHouseMassagePointInfo::ForceStrengthCurve' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, bAccelChange) == 0x000048, "Member 'FHouseMassagePointInfo::bAccelChange' has a wrong offset!");
static_assert(offsetof(FHouseMassagePointInfo, OwnedPhysicsHandle) == 0x000090, "Member 'FHouseMassagePointInfo::OwnedPhysicsHandle' has a wrong offset!");

// ScriptStruct Game.HouseMassageInfo
// 0x0020 (0x0028 - 0x0008)
struct FHouseMassageInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcId;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupId;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHouseMassagePointInfo>         Points;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseMassageInfo) == 0x000008, "Wrong alignment on FHouseMassageInfo");
static_assert(sizeof(FHouseMassageInfo) == 0x000028, "Wrong size on FHouseMassageInfo");
static_assert(offsetof(FHouseMassageInfo, ID) == 0x000008, "Member 'FHouseMassageInfo::ID' has a wrong offset!");
static_assert(offsetof(FHouseMassageInfo, NpcId) == 0x00000C, "Member 'FHouseMassageInfo::NpcId' has a wrong offset!");
static_assert(offsetof(FHouseMassageInfo, GroupId) == 0x000010, "Member 'FHouseMassageInfo::GroupId' has a wrong offset!");
static_assert(offsetof(FHouseMassageInfo, Points) == 0x000018, "Member 'FHouseMassageInfo::Points' has a wrong offset!");

// ScriptStruct Game.CameraAnimationSequenceReader
// 0x0020 (0x0020 - 0x0000)
struct FCameraAnimationSequenceReader final
{
public:
	class UCameraAnimationSequence*               Sequence;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USequenceCameraShakeSequencePlayer*     Player;                                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USequenceCameraShakeCameraStandIn*      CameraStandIn;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCameraAnimationSequenceReader) == 0x000008, "Wrong alignment on FCameraAnimationSequenceReader");
static_assert(sizeof(FCameraAnimationSequenceReader) == 0x000020, "Wrong size on FCameraAnimationSequenceReader");
static_assert(offsetof(FCameraAnimationSequenceReader, Sequence) == 0x000000, "Member 'FCameraAnimationSequenceReader::Sequence' has a wrong offset!");
static_assert(offsetof(FCameraAnimationSequenceReader, Player) == 0x000008, "Member 'FCameraAnimationSequenceReader::Player' has a wrong offset!");
static_assert(offsetof(FCameraAnimationSequenceReader, CameraStandIn) == 0x000010, "Member 'FCameraAnimationSequenceReader::CameraStandIn' has a wrong offset!");
static_assert(offsetof(FCameraAnimationSequenceReader, DurationTime) == 0x000018, "Member 'FCameraAnimationSequenceReader::DurationTime' has a wrong offset!");
static_assert(offsetof(FCameraAnimationSequenceReader, ElapsedTime) == 0x00001C, "Member 'FCameraAnimationSequenceReader::ElapsedTime' has a wrong offset!");

// ScriptStruct Game.HitReactSectionInfo
// 0x0018 (0x0018 - 0x0000)
struct FHitReactSectionInfo final
{
public:
	float                                         TopLimitValue;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorLimitValue;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleCrossLine;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      HitReactAnim;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactSectionInfo) == 0x000008, "Wrong alignment on FHitReactSectionInfo");
static_assert(sizeof(FHitReactSectionInfo) == 0x000018, "Wrong size on FHitReactSectionInfo");
static_assert(offsetof(FHitReactSectionInfo, TopLimitValue) == 0x000000, "Member 'FHitReactSectionInfo::TopLimitValue' has a wrong offset!");
static_assert(offsetof(FHitReactSectionInfo, FloorLimitValue) == 0x000004, "Member 'FHitReactSectionInfo::FloorLimitValue' has a wrong offset!");
static_assert(offsetof(FHitReactSectionInfo, bHandleCrossLine) == 0x000008, "Member 'FHitReactSectionInfo::bHandleCrossLine' has a wrong offset!");
static_assert(offsetof(FHitReactSectionInfo, HitReactAnim) == 0x000010, "Member 'FHitReactSectionInfo::HitReactAnim' has a wrong offset!");

// ScriptStruct Game.InfluenceAbilityAttributeConfig
// 0x0090 (0x0090 - 0x0000)
struct FInfluenceAbilityAttributeConfig final
{
public:
	class UAbilityAttribute*                      InfluenceAbilityAttribute;                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     InfluenceCurve;                                    // 0x0008(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInfluenceAbilityAttributeConfig) == 0x000008, "Wrong alignment on FInfluenceAbilityAttributeConfig");
static_assert(sizeof(FInfluenceAbilityAttributeConfig) == 0x000090, "Wrong size on FInfluenceAbilityAttributeConfig");
static_assert(offsetof(FInfluenceAbilityAttributeConfig, InfluenceAbilityAttribute) == 0x000000, "Member 'FInfluenceAbilityAttributeConfig::InfluenceAbilityAttribute' has a wrong offset!");
static_assert(offsetof(FInfluenceAbilityAttributeConfig, InfluenceCurve) == 0x000008, "Member 'FInfluenceAbilityAttributeConfig::InfluenceCurve' has a wrong offset!");

// ScriptStruct Game.CharacterAbnormalRenderStateInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FCharacterAbnormalRenderStateInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAbnormalRenderState*          StateObject;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xC8];                                      // 0x0010(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAbnormalRenderStateInfo) == 0x000008, "Wrong alignment on FCharacterAbnormalRenderStateInfo");
static_assert(sizeof(FCharacterAbnormalRenderStateInfo) == 0x0000D8, "Wrong size on FCharacterAbnormalRenderStateInfo");
static_assert(offsetof(FCharacterAbnormalRenderStateInfo, StateObject) == 0x000008, "Member 'FCharacterAbnormalRenderStateInfo::StateObject' has a wrong offset!");

// ScriptStruct Game.DesignationData
// 0x0008 (0x0008 - 0x0000)
struct FDesignationData final
{
public:
	EDesignationType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Data;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignationData) == 0x000004, "Wrong alignment on FDesignationData");
static_assert(sizeof(FDesignationData) == 0x000008, "Wrong size on FDesignationData");
static_assert(offsetof(FDesignationData, Type) == 0x000000, "Member 'FDesignationData::Type' has a wrong offset!");
static_assert(offsetof(FDesignationData, Data) == 0x000004, "Member 'FDesignationData::Data' has a wrong offset!");

// ScriptStruct Game.HouseStepTriggerData
// 0x0050 (0x0050 - 0x0000)
struct FHouseStepTriggerData final
{
public:
	TMap<EPhysicalSurface, int32>                 HitEffectSetup;                                    // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseStepTriggerData) == 0x000008, "Wrong alignment on FHouseStepTriggerData");
static_assert(sizeof(FHouseStepTriggerData) == 0x000050, "Wrong size on FHouseStepTriggerData");
static_assert(offsetof(FHouseStepTriggerData, HitEffectSetup) == 0x000000, "Member 'FHouseStepTriggerData::HitEffectSetup' has a wrong offset!");

// ScriptStruct Game.CharacterMaterialRuntimeInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCharacterMaterialRuntimeInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMaterialRuntimeInfo) == 0x000008, "Wrong alignment on FCharacterMaterialRuntimeInfo");
static_assert(sizeof(FCharacterMaterialRuntimeInfo) == 0x000028, "Wrong size on FCharacterMaterialRuntimeInfo");

// ScriptStruct Game.HandIKCorrectionBoneIno
// 0x0138 (0x0138 - 0x0000)
struct FHandIKCorrectionBoneIno final
{
public:
	class FName                                   FingerSocketName;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandSocketName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponHoldHandSocketName;                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponHoldHandShoulderSocketName;                  // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalCorrectionDuration;                           // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     HandIKCorrection;                                  // 0x0028(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HandIKCorrection_BlendIn;                          // 0x00B0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandIKCorrectionBoneIno) == 0x000008, "Wrong alignment on FHandIKCorrectionBoneIno");
static_assert(sizeof(FHandIKCorrectionBoneIno) == 0x000138, "Wrong size on FHandIKCorrectionBoneIno");
static_assert(offsetof(FHandIKCorrectionBoneIno, FingerSocketName) == 0x000000, "Member 'FHandIKCorrectionBoneIno::FingerSocketName' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, HandSocketName) == 0x000008, "Member 'FHandIKCorrectionBoneIno::HandSocketName' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, WeaponHoldHandSocketName) == 0x000010, "Member 'FHandIKCorrectionBoneIno::WeaponHoldHandSocketName' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, WeaponHoldHandShoulderSocketName) == 0x000018, "Member 'FHandIKCorrectionBoneIno::WeaponHoldHandShoulderSocketName' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, TotalCorrectionDuration) == 0x000020, "Member 'FHandIKCorrectionBoneIno::TotalCorrectionDuration' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, HandIKCorrection) == 0x000028, "Member 'FHandIKCorrectionBoneIno::HandIKCorrection' has a wrong offset!");
static_assert(offsetof(FHandIKCorrectionBoneIno, HandIKCorrection_BlendIn) == 0x0000B0, "Member 'FHandIKCorrectionBoneIno::HandIKCorrection_BlendIn' has a wrong offset!");

// ScriptStruct Game.CharacterMCSlotMaterialRuntimeDetailInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCharacterMCSlotMaterialRuntimeDetailInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMCSlotMaterialRuntimeDetailInfo) == 0x000008, "Wrong alignment on FCharacterMCSlotMaterialRuntimeDetailInfo");
static_assert(sizeof(FCharacterMCSlotMaterialRuntimeDetailInfo) == 0x000020, "Wrong size on FCharacterMCSlotMaterialRuntimeDetailInfo");

// ScriptStruct Game.CharacterMCSlotMaterialRuntimeInfo
// 0x03E8 (0x03E8 - 0x0000)
struct alignas(0x08) FCharacterMCSlotMaterialRuntimeInfo final
{
public:
	uint8                                         Pad_0[0x3E8];                                      // 0x0000(0x03E8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMCSlotMaterialRuntimeInfo) == 0x000008, "Wrong alignment on FCharacterMCSlotMaterialRuntimeInfo");
static_assert(sizeof(FCharacterMCSlotMaterialRuntimeInfo) == 0x0003E8, "Wrong size on FCharacterMCSlotMaterialRuntimeInfo");

// ScriptStruct Game.CharacterDefaultMaterialInfo
// 0x0068 (0x0068 - 0x0000)
struct FCharacterDefaultMaterialInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DefaultMIDs;                                       // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OriginMIs;                                         // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             CachedOriginOutlineMIs;                            // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OriginOutlineMIs;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       OutlineMIDs;                                       // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OriginTertiaryMIs;                                 // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDefaultMaterialInfo) == 0x000008, "Wrong alignment on FCharacterDefaultMaterialInfo");
static_assert(sizeof(FCharacterDefaultMaterialInfo) == 0x000068, "Wrong size on FCharacterDefaultMaterialInfo");
static_assert(offsetof(FCharacterDefaultMaterialInfo, DefaultMIDs) == 0x000008, "Member 'FCharacterDefaultMaterialInfo::DefaultMIDs' has a wrong offset!");
static_assert(offsetof(FCharacterDefaultMaterialInfo, OriginMIs) == 0x000018, "Member 'FCharacterDefaultMaterialInfo::OriginMIs' has a wrong offset!");
static_assert(offsetof(FCharacterDefaultMaterialInfo, CachedOriginOutlineMIs) == 0x000028, "Member 'FCharacterDefaultMaterialInfo::CachedOriginOutlineMIs' has a wrong offset!");
static_assert(offsetof(FCharacterDefaultMaterialInfo, OriginOutlineMIs) == 0x000038, "Member 'FCharacterDefaultMaterialInfo::OriginOutlineMIs' has a wrong offset!");
static_assert(offsetof(FCharacterDefaultMaterialInfo, OutlineMIDs) == 0x000048, "Member 'FCharacterDefaultMaterialInfo::OutlineMIDs' has a wrong offset!");
static_assert(offsetof(FCharacterDefaultMaterialInfo, OriginTertiaryMIs) == 0x000058, "Member 'FCharacterDefaultMaterialInfo::OriginTertiaryMIs' has a wrong offset!");

// ScriptStruct Game.WeaponRecoilConfig
// 0x00A8 (0x00B0 - 0x0008)
struct FWeaponRecoilConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMassPointType, struct FMassPointSetup>  MassPointSetups;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ERangeAttackState, struct FRecoilSetup>  RecoilSetup;                                       // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRecoilConfig) == 0x000008, "Wrong alignment on FWeaponRecoilConfig");
static_assert(sizeof(FWeaponRecoilConfig) == 0x0000B0, "Wrong size on FWeaponRecoilConfig");
static_assert(offsetof(FWeaponRecoilConfig, ID) == 0x000008, "Member 'FWeaponRecoilConfig::ID' has a wrong offset!");
static_assert(offsetof(FWeaponRecoilConfig, MassPointSetups) == 0x000010, "Member 'FWeaponRecoilConfig::MassPointSetups' has a wrong offset!");
static_assert(offsetof(FWeaponRecoilConfig, RecoilSetup) == 0x000060, "Member 'FWeaponRecoilConfig::RecoilSetup' has a wrong offset!");

// ScriptStruct Game.CharacterEffectParameters
// 0x0068 (0x0068 - 0x0000)
struct FCharacterEffectParameters final
{
public:
	ECharacterRenderStateType                     StateType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlexibleEnumValue                     CharacterEffectType;                               // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTranslucent2Mask;                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDepth;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomDepth;                                      // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomStencil;                                 // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomStencil;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondarySlot;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SecondaryMaterial;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialStateParameter                Parameters;                                        // 0x0028(0x0040)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterEffectParameters) == 0x000008, "Wrong alignment on FCharacterEffectParameters");
static_assert(sizeof(FCharacterEffectParameters) == 0x000068, "Wrong size on FCharacterEffectParameters");
static_assert(offsetof(FCharacterEffectParameters, StateType) == 0x000000, "Member 'FCharacterEffectParameters::StateType' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, CharacterEffectType) == 0x000004, "Member 'FCharacterEffectParameters::CharacterEffectType' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, Priority) == 0x000008, "Member 'FCharacterEffectParameters::Priority' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, Slot) == 0x00000C, "Member 'FCharacterEffectParameters::Slot' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, bIgnoreTranslucent2Mask) == 0x000010, "Member 'FCharacterEffectParameters::bIgnoreTranslucent2Mask' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, bUseCustomDepth) == 0x000011, "Member 'FCharacterEffectParameters::bUseCustomDepth' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, bCustomDepth) == 0x000012, "Member 'FCharacterEffectParameters::bCustomDepth' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, bUseCustomStencil) == 0x000013, "Member 'FCharacterEffectParameters::bUseCustomStencil' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, CustomStencil) == 0x000014, "Member 'FCharacterEffectParameters::CustomStencil' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, SecondarySlot) == 0x000018, "Member 'FCharacterEffectParameters::SecondarySlot' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, SecondaryMaterial) == 0x000020, "Member 'FCharacterEffectParameters::SecondaryMaterial' has a wrong offset!");
static_assert(offsetof(FCharacterEffectParameters, Parameters) == 0x000028, "Member 'FCharacterEffectParameters::Parameters' has a wrong offset!");

// ScriptStruct Game.MaterialStateParameterWithFadeout
// 0x0030 (0x0070 - 0x0040)
struct FMaterialStateParameterWithFadeout final : public FMaterialStateParameter
{
public:
	bool                                          bHasFadeout;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutTime;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialParameter*>             FadeoutMaterialParameters;                         // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialParameter*>             SecondaryFadeoutMaterialParameters;                // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialStateParameterWithFadeout) == 0x000008, "Wrong alignment on FMaterialStateParameterWithFadeout");
static_assert(sizeof(FMaterialStateParameterWithFadeout) == 0x000070, "Wrong size on FMaterialStateParameterWithFadeout");
static_assert(offsetof(FMaterialStateParameterWithFadeout, bHasFadeout) == 0x000040, "Member 'FMaterialStateParameterWithFadeout::bHasFadeout' has a wrong offset!");
static_assert(offsetof(FMaterialStateParameterWithFadeout, FadeOutTime) == 0x000044, "Member 'FMaterialStateParameterWithFadeout::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FMaterialStateParameterWithFadeout, FadeoutMaterialParameters) == 0x000048, "Member 'FMaterialStateParameterWithFadeout::FadeoutMaterialParameters' has a wrong offset!");
static_assert(offsetof(FMaterialStateParameterWithFadeout, SecondaryFadeoutMaterialParameters) == 0x000058, "Member 'FMaterialStateParameterWithFadeout::SecondaryFadeoutMaterialParameters' has a wrong offset!");

// ScriptStruct Game.CustomHipPhyDataTemplate
// 0x0020 (0x0028 - 0x0008)
struct FCustomHipPhyDataTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterSkinID;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomHipPhyDataSection>       CustomHipPhyDataContainer;                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomHipPhyDataTemplate) == 0x000008, "Wrong alignment on FCustomHipPhyDataTemplate");
static_assert(sizeof(FCustomHipPhyDataTemplate) == 0x000028, "Wrong size on FCustomHipPhyDataTemplate");
static_assert(offsetof(FCustomHipPhyDataTemplate, ID) == 0x000008, "Member 'FCustomHipPhyDataTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCustomHipPhyDataTemplate, CharacterID) == 0x00000C, "Member 'FCustomHipPhyDataTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FCustomHipPhyDataTemplate, CharacterSkinID) == 0x000010, "Member 'FCustomHipPhyDataTemplate::CharacterSkinID' has a wrong offset!");
static_assert(offsetof(FCustomHipPhyDataTemplate, CustomHipPhyDataContainer) == 0x000018, "Member 'FCustomHipPhyDataTemplate::CustomHipPhyDataContainer' has a wrong offset!");

// ScriptStruct Game.ItemToload
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FItemToload final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemToload) == 0x000008, "Wrong alignment on FItemToload");
static_assert(sizeof(FItemToload) == 0x000018, "Wrong size on FItemToload");

// ScriptStruct Game.MeshReplaceTemplate
// 0x00D0 (0x00D8 - 0x0008)
struct FMeshReplaceTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           CharacterReplaceMesh_Body;                         // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterReplaceMesh_Body_AllAges;                 // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterReplaceMesh_Head;                         // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FAnimReplaceData>          AnimReplaceDataContainer;                          // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshReplaceTemplate) == 0x000008, "Wrong alignment on FMeshReplaceTemplate");
static_assert(sizeof(FMeshReplaceTemplate) == 0x0000D8, "Wrong size on FMeshReplaceTemplate");
static_assert(offsetof(FMeshReplaceTemplate, ID) == 0x000008, "Member 'FMeshReplaceTemplate::ID' has a wrong offset!");
static_assert(offsetof(FMeshReplaceTemplate, CharacterReplaceMesh_Body) == 0x000010, "Member 'FMeshReplaceTemplate::CharacterReplaceMesh_Body' has a wrong offset!");
static_assert(offsetof(FMeshReplaceTemplate, CharacterReplaceMesh_Body_AllAges) == 0x000038, "Member 'FMeshReplaceTemplate::CharacterReplaceMesh_Body_AllAges' has a wrong offset!");
static_assert(offsetof(FMeshReplaceTemplate, CharacterReplaceMesh_Head) == 0x000060, "Member 'FMeshReplaceTemplate::CharacterReplaceMesh_Head' has a wrong offset!");
static_assert(offsetof(FMeshReplaceTemplate, AnimReplaceDataContainer) == 0x000088, "Member 'FMeshReplaceTemplate::AnimReplaceDataContainer' has a wrong offset!");

// ScriptStruct Game.BulletRecoverTemplate
// 0x0040 (0x0048 - 0x0008)
struct FBulletRecoverTemplate final : public FTableRowBase
{
public:
	bool                                          bForegroundEnable;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForegroundDelayTimeFight;                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForegroundDelayTimeSwitch;                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForegroundDelayTimeFire;                           // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBulletRecoverWeaponTemplate>   ForegroundWeaponConfig;                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bBackgroundEnable;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackgroundDelayTimeFight;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackgroundDelayTimeSwitch;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBulletRecoverWeaponTemplate>   BackgroundWeaponConfig;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletRecoverTemplate) == 0x000008, "Wrong alignment on FBulletRecoverTemplate");
static_assert(sizeof(FBulletRecoverTemplate) == 0x000048, "Wrong size on FBulletRecoverTemplate");
static_assert(offsetof(FBulletRecoverTemplate, bForegroundEnable) == 0x000008, "Member 'FBulletRecoverTemplate::bForegroundEnable' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, ForegroundDelayTimeFight) == 0x00000C, "Member 'FBulletRecoverTemplate::ForegroundDelayTimeFight' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, ForegroundDelayTimeSwitch) == 0x000010, "Member 'FBulletRecoverTemplate::ForegroundDelayTimeSwitch' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, ForegroundDelayTimeFire) == 0x000014, "Member 'FBulletRecoverTemplate::ForegroundDelayTimeFire' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, ForegroundWeaponConfig) == 0x000018, "Member 'FBulletRecoverTemplate::ForegroundWeaponConfig' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, bBackgroundEnable) == 0x000028, "Member 'FBulletRecoverTemplate::bBackgroundEnable' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, BackgroundDelayTimeFight) == 0x00002C, "Member 'FBulletRecoverTemplate::BackgroundDelayTimeFight' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, BackgroundDelayTimeSwitch) == 0x000030, "Member 'FBulletRecoverTemplate::BackgroundDelayTimeSwitch' has a wrong offset!");
static_assert(offsetof(FBulletRecoverTemplate, BackgroundWeaponConfig) == 0x000038, "Member 'FBulletRecoverTemplate::BackgroundWeaponConfig' has a wrong offset!");

// ScriptStruct Game.KeyToSequence
// 0x0030 (0x0038 - 0x0008)
struct FKeyToSequence final : public FTableRowBase
{
public:
	class FName                                   Key;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          SequenceToFind;                                    // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyToSequence) == 0x000008, "Wrong alignment on FKeyToSequence");
static_assert(sizeof(FKeyToSequence) == 0x000038, "Wrong size on FKeyToSequence");
static_assert(offsetof(FKeyToSequence, Key) == 0x000008, "Member 'FKeyToSequence::Key' has a wrong offset!");
static_assert(offsetof(FKeyToSequence, SequenceToFind) == 0x000010, "Member 'FKeyToSequence::SequenceToFind' has a wrong offset!");

// ScriptStruct Game.KeyToUMG
// 0x0020 (0x0028 - 0x0008)
struct FKeyToUMG final : public FTableRowBase
{
public:
	class FName                                   Key;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         UMGToFind;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyToUMG) == 0x000008, "Wrong alignment on FKeyToUMG");
static_assert(sizeof(FKeyToUMG) == 0x000028, "Wrong size on FKeyToUMG");
static_assert(offsetof(FKeyToUMG, Key) == 0x000008, "Member 'FKeyToUMG::Key' has a wrong offset!");
static_assert(offsetof(FKeyToUMG, UMGToFind) == 0x000010, "Member 'FKeyToUMG::UMGToFind' has a wrong offset!");

// ScriptStruct Game.MaterialIndex
// 0x0058 (0x0058 - 0x0000)
struct FMaterialIndex final
{
public:
	EUIWidgetAnimType                             PreviewType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, TSoftObjectPtr<class UMaterialInterface>> MapMaterial;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialIndex) == 0x000008, "Wrong alignment on FMaterialIndex");
static_assert(sizeof(FMaterialIndex) == 0x000058, "Wrong size on FMaterialIndex");
static_assert(offsetof(FMaterialIndex, PreviewType) == 0x000000, "Member 'FMaterialIndex::PreviewType' has a wrong offset!");
static_assert(offsetof(FMaterialIndex, MapMaterial) == 0x000008, "Member 'FMaterialIndex::MapMaterial' has a wrong offset!");

// ScriptStruct Game.ModelMaterialModify
// 0x0018 (0x0020 - 0x0008)
struct FModelMaterialModify final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialIndex>                 ArrayMaterialModify;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModelMaterialModify) == 0x000008, "Wrong alignment on FModelMaterialModify");
static_assert(sizeof(FModelMaterialModify) == 0x000020, "Wrong size on FModelMaterialModify");
static_assert(offsetof(FModelMaterialModify, ID) == 0x000008, "Member 'FModelMaterialModify::ID' has a wrong offset!");
static_assert(offsetof(FModelMaterialModify, ArrayMaterialModify) == 0x000010, "Member 'FModelMaterialModify::ArrayMaterialModify' has a wrong offset!");

// ScriptStruct Game.InteractionCharacterEmojiData
// 0x0018 (0x0018 - 0x0000)
struct FInteractionCharacterEmojiData final
{
public:
	float                                         CurEmojiValue;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetEmojiValue;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PendingTargetEmojiValues;                          // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCharacterEmojiData) == 0x000008, "Wrong alignment on FInteractionCharacterEmojiData");
static_assert(sizeof(FInteractionCharacterEmojiData) == 0x000018, "Wrong size on FInteractionCharacterEmojiData");
static_assert(offsetof(FInteractionCharacterEmojiData, CurEmojiValue) == 0x000000, "Member 'FInteractionCharacterEmojiData::CurEmojiValue' has a wrong offset!");
static_assert(offsetof(FInteractionCharacterEmojiData, TargetEmojiValue) == 0x000004, "Member 'FInteractionCharacterEmojiData::TargetEmojiValue' has a wrong offset!");
static_assert(offsetof(FInteractionCharacterEmojiData, PendingTargetEmojiValues) == 0x000008, "Member 'FInteractionCharacterEmojiData::PendingTargetEmojiValues' has a wrong offset!");

// ScriptStruct Game.PreviewHeadAnimNameMappingGreenTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPreviewHeadAnimNameMappingGreenTemplate final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimResName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOriginalSkin;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewHeadAnimNameMappingGreenTemplate) == 0x000008, "Wrong alignment on FPreviewHeadAnimNameMappingGreenTemplate");
static_assert(sizeof(FPreviewHeadAnimNameMappingGreenTemplate) == 0x000040, "Wrong size on FPreviewHeadAnimNameMappingGreenTemplate");
static_assert(offsetof(FPreviewHeadAnimNameMappingGreenTemplate, VariableName) == 0x000008, "Member 'FPreviewHeadAnimNameMappingGreenTemplate::VariableName' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingGreenTemplate, AnimResName) == 0x000018, "Member 'FPreviewHeadAnimNameMappingGreenTemplate::AnimResName' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingGreenTemplate, WidgetContainer) == 0x000028, "Member 'FPreviewHeadAnimNameMappingGreenTemplate::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingGreenTemplate, bUseWeaponSubType) == 0x000038, "Member 'FPreviewHeadAnimNameMappingGreenTemplate::bUseWeaponSubType' has a wrong offset!");
static_assert(offsetof(FPreviewHeadAnimNameMappingGreenTemplate, bUseOriginalSkin) == 0x000039, "Member 'FPreviewHeadAnimNameMappingGreenTemplate::bUseOriginalSkin' has a wrong offset!");

// ScriptStruct Game.PreviewUIWidgetTransitionAnimTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPreviewUIWidgetTransitionAnimTemplate final : public FTableRowBase
{
public:
	EUIWidgetAnimType                             DepartureAnimType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIWidgetAnimType                             DestinationAnimType;                               // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DepartureToDestinationAnimName;                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestinationAnimName;                               // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTransitionAnim;                                // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsComplexSituation;                               // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOriginalSkin;                                   // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewUIWidgetTransitionAnimTemplate) == 0x000008, "Wrong alignment on FPreviewUIWidgetTransitionAnimTemplate");
static_assert(sizeof(FPreviewUIWidgetTransitionAnimTemplate) == 0x000040, "Wrong size on FPreviewUIWidgetTransitionAnimTemplate");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, DepartureAnimType) == 0x000008, "Member 'FPreviewUIWidgetTransitionAnimTemplate::DepartureAnimType' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, DestinationAnimType) == 0x000009, "Member 'FPreviewUIWidgetTransitionAnimTemplate::DestinationAnimType' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, DepartureToDestinationAnimName) == 0x000010, "Member 'FPreviewUIWidgetTransitionAnimTemplate::DepartureToDestinationAnimName' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, DestinationAnimName) == 0x000020, "Member 'FPreviewUIWidgetTransitionAnimTemplate::DestinationAnimName' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, bUseWeaponSubType) == 0x000030, "Member 'FPreviewUIWidgetTransitionAnimTemplate::bUseWeaponSubType' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, bUseTransitionAnim) == 0x000031, "Member 'FPreviewUIWidgetTransitionAnimTemplate::bUseTransitionAnim' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, bIsComplexSituation) == 0x000032, "Member 'FPreviewUIWidgetTransitionAnimTemplate::bIsComplexSituation' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, bIsOriginalSkin) == 0x000033, "Member 'FPreviewUIWidgetTransitionAnimTemplate::bIsOriginalSkin' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, BlendInTime) == 0x000034, "Member 'FPreviewUIWidgetTransitionAnimTemplate::BlendInTime' has a wrong offset!");
static_assert(offsetof(FPreviewUIWidgetTransitionAnimTemplate, BlendOutTime) == 0x000038, "Member 'FPreviewUIWidgetTransitionAnimTemplate::BlendOutTime' has a wrong offset!");

// ScriptStruct Game.CompositeAttachInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FCompositeAttachInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeAttachInfo) == 0x000010, "Wrong alignment on FCompositeAttachInfo");
static_assert(sizeof(FCompositeAttachInfo) == 0x000050, "Wrong size on FCompositeAttachInfo");

// ScriptStruct Game.PreviewAnimNameMappingGreenTemplate
// 0x0038 (0x0040 - 0x0008)
struct FPreviewAnimNameMappingGreenTemplate final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimResName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewAnimNameMappingGreenTemplate) == 0x000008, "Wrong alignment on FPreviewAnimNameMappingGreenTemplate");
static_assert(sizeof(FPreviewAnimNameMappingGreenTemplate) == 0x000040, "Wrong size on FPreviewAnimNameMappingGreenTemplate");
static_assert(offsetof(FPreviewAnimNameMappingGreenTemplate, VariableName) == 0x000008, "Member 'FPreviewAnimNameMappingGreenTemplate::VariableName' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingGreenTemplate, AnimResName) == 0x000018, "Member 'FPreviewAnimNameMappingGreenTemplate::AnimResName' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingGreenTemplate, WidgetContainer) == 0x000028, "Member 'FPreviewAnimNameMappingGreenTemplate::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FPreviewAnimNameMappingGreenTemplate, bUseWeaponSubType) == 0x000038, "Member 'FPreviewAnimNameMappingGreenTemplate::bUseWeaponSubType' has a wrong offset!");

// ScriptStruct Game.CharacterSkinTemplate
// 0x0308 (0x0310 - 0x0008)
struct FCharacterSkinTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterAnimSuffix;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body;                            // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body_AllAges;                    // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body_Gameplay;                   // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body_Gameplay_AllAges;           // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body_Manifestation;              // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Body_Manifestation_AllAges;      // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Body_Preview;       // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinLinkAnimInstanceClass_Body_Preview;   // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Body_Gameplay;      // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Body_Manifestation; // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinLinkAnimInstanceClass_Body_Manifestation; // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            CharacterSkinMeshMaterialSlotMap_Body;             // 0x0188(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Head;                            // 0x01D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePhys;                                     // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePhysicsAnimType;                          // 0x0201(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGamePhysicsControlGroupDataAsset*      ControlGroupDataAsset;                             // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGamePhysicsControlDataAsset*           PhysicsControlDataAsset;                           // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsAnimType                              PhysicsAnimType;                                   // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOrigin;                                         // 0x0219(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           OriginalCharacterSkinMesh_Head;                    // 0x0220(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         OriginalCharacterSkinAnimInstanceClass_Head_Preview; // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterSkinMesh_Head_Gameplay;                   // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Head_Preview;       // 0x0288(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Head_Gameplay;      // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterSkinAnimInstanceClass_Head_Manifestation; // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinMaterialOverrideInfo>      CharacterSkinMeshMaterialOverrideContainer_Head;   // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAutoLoadFinishSequencerMesh;                      // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         GamePhysicsControlClass;                           // 0x02E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootPrintId;                                       // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraMeshOffsetZ;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraMeshOffsetZ_Preview;                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BattleMinLOD;                                      // 0x030C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSkinTemplate) == 0x000008, "Wrong alignment on FCharacterSkinTemplate");
static_assert(sizeof(FCharacterSkinTemplate) == 0x000310, "Wrong size on FCharacterSkinTemplate");
static_assert(offsetof(FCharacterSkinTemplate, ID) == 0x000008, "Member 'FCharacterSkinTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterID) == 0x00000C, "Member 'FCharacterSkinTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterAnimSuffix) == 0x000010, "Member 'FCharacterSkinTemplate::CharacterAnimSuffix' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body) == 0x000020, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body_AllAges) == 0x000048, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body_AllAges' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body_Gameplay) == 0x000070, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body_Gameplay' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body_Gameplay_AllAges) == 0x000098, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body_Gameplay_AllAges' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body_Manifestation) == 0x0000C0, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body_Manifestation' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Body_Manifestation_AllAges) == 0x0000E8, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Body_Manifestation_AllAges' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Body_Preview) == 0x000110, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Body_Preview' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinLinkAnimInstanceClass_Body_Preview) == 0x000128, "Member 'FCharacterSkinTemplate::CharacterSkinLinkAnimInstanceClass_Body_Preview' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Body_Gameplay) == 0x000140, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Body_Gameplay' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Body_Manifestation) == 0x000158, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Body_Manifestation' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinLinkAnimInstanceClass_Body_Manifestation) == 0x000170, "Member 'FCharacterSkinTemplate::CharacterSkinLinkAnimInstanceClass_Body_Manifestation' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMeshMaterialSlotMap_Body) == 0x000188, "Member 'FCharacterSkinTemplate::CharacterSkinMeshMaterialSlotMap_Body' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Head) == 0x0001D8, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Head' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, bOverridePhys) == 0x000200, "Member 'FCharacterSkinTemplate::bOverridePhys' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, bOverridePhysicsAnimType) == 0x000201, "Member 'FCharacterSkinTemplate::bOverridePhysicsAnimType' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, ControlGroupDataAsset) == 0x000208, "Member 'FCharacterSkinTemplate::ControlGroupDataAsset' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, PhysicsControlDataAsset) == 0x000210, "Member 'FCharacterSkinTemplate::PhysicsControlDataAsset' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, PhysicsAnimType) == 0x000218, "Member 'FCharacterSkinTemplate::PhysicsAnimType' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, bIsOrigin) == 0x000219, "Member 'FCharacterSkinTemplate::bIsOrigin' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, OriginalCharacterSkinMesh_Head) == 0x000220, "Member 'FCharacterSkinTemplate::OriginalCharacterSkinMesh_Head' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, OriginalCharacterSkinAnimInstanceClass_Head_Preview) == 0x000248, "Member 'FCharacterSkinTemplate::OriginalCharacterSkinAnimInstanceClass_Head_Preview' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMesh_Head_Gameplay) == 0x000260, "Member 'FCharacterSkinTemplate::CharacterSkinMesh_Head_Gameplay' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Head_Preview) == 0x000288, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Head_Preview' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Head_Gameplay) == 0x0002A0, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Head_Gameplay' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinAnimInstanceClass_Head_Manifestation) == 0x0002B8, "Member 'FCharacterSkinTemplate::CharacterSkinAnimInstanceClass_Head_Manifestation' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, CharacterSkinMeshMaterialOverrideContainer_Head) == 0x0002D0, "Member 'FCharacterSkinTemplate::CharacterSkinMeshMaterialOverrideContainer_Head' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, bAutoLoadFinishSequencerMesh) == 0x0002E0, "Member 'FCharacterSkinTemplate::bAutoLoadFinishSequencerMesh' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, GamePhysicsControlClass) == 0x0002E8, "Member 'FCharacterSkinTemplate::GamePhysicsControlClass' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, FootPrintId) == 0x000300, "Member 'FCharacterSkinTemplate::FootPrintId' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, ExtraMeshOffsetZ) == 0x000304, "Member 'FCharacterSkinTemplate::ExtraMeshOffsetZ' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, ExtraMeshOffsetZ_Preview) == 0x000308, "Member 'FCharacterSkinTemplate::ExtraMeshOffsetZ_Preview' has a wrong offset!");
static_assert(offsetof(FCharacterSkinTemplate, BattleMinLOD) == 0x00030C, "Member 'FCharacterSkinTemplate::BattleMinLOD' has a wrong offset!");

// ScriptStruct Game.SurfaceHitResultTemplate
// 0x0030 (0x0038 - 0x0008)
struct FSurfaceHitResultTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Hard;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Soft;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Water;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceHitResultTemplate) == 0x000008, "Wrong alignment on FSurfaceHitResultTemplate");
static_assert(sizeof(FSurfaceHitResultTemplate) == 0x000038, "Wrong size on FSurfaceHitResultTemplate");
static_assert(offsetof(FSurfaceHitResultTemplate, ID) == 0x000008, "Member 'FSurfaceHitResultTemplate::ID' has a wrong offset!");
static_assert(offsetof(FSurfaceHitResultTemplate, Desc) == 0x000010, "Member 'FSurfaceHitResultTemplate::Desc' has a wrong offset!");
static_assert(offsetof(FSurfaceHitResultTemplate, Hard) == 0x000020, "Member 'FSurfaceHitResultTemplate::Hard' has a wrong offset!");
static_assert(offsetof(FSurfaceHitResultTemplate, Soft) == 0x000028, "Member 'FSurfaceHitResultTemplate::Soft' has a wrong offset!");
static_assert(offsetof(FSurfaceHitResultTemplate, Water) == 0x000030, "Member 'FSurfaceHitResultTemplate::Water' has a wrong offset!");

// ScriptStruct Game.ControlProtectionData
// 0x0018 (0x0018 - 0x0000)
struct FControlProtectionData final
{
public:
	int32                                         ControlProtection;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicProtectionTime;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProtectionTimeFactor;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProtectionExtensionTime;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImmuneThreshold;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlTimeLimit;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlProtectionData) == 0x000004, "Wrong alignment on FControlProtectionData");
static_assert(sizeof(FControlProtectionData) == 0x000018, "Wrong size on FControlProtectionData");
static_assert(offsetof(FControlProtectionData, ControlProtection) == 0x000000, "Member 'FControlProtectionData::ControlProtection' has a wrong offset!");
static_assert(offsetof(FControlProtectionData, BasicProtectionTime) == 0x000004, "Member 'FControlProtectionData::BasicProtectionTime' has a wrong offset!");
static_assert(offsetof(FControlProtectionData, ProtectionTimeFactor) == 0x000008, "Member 'FControlProtectionData::ProtectionTimeFactor' has a wrong offset!");
static_assert(offsetof(FControlProtectionData, ProtectionExtensionTime) == 0x00000C, "Member 'FControlProtectionData::ProtectionExtensionTime' has a wrong offset!");
static_assert(offsetof(FControlProtectionData, ControlImmuneThreshold) == 0x000010, "Member 'FControlProtectionData::ControlImmuneThreshold' has a wrong offset!");
static_assert(offsetof(FControlProtectionData, ControlTimeLimit) == 0x000014, "Member 'FControlProtectionData::ControlTimeLimit' has a wrong offset!");

// ScriptStruct Game.CharacterCardGrowTemplate
// 0x00B0 (0x00B8 - 0x0008)
struct FCharacterCardGrowTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Defence;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityBulletResistance;                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireResistance;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceResistance;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThunderResistance;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperpowersResistance;                             // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FieldResistance;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldType;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldRecoverInterval;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDelayTime;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShieldRecoverSpeed;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Health;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalValue;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageAddtion;                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRatio;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamageScaler;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillShieldDamageScaler;                           // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BreathlessTime;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitLag                                MaxHitLag;                                         // 0x005C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RangeDamageReduction;                              // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Command;                                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterEnergy;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterEnergyEfficiency;                         // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterEnergyRecoverValue;                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterEnergyRecoverDelta;                       // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitRecoeverEnergy;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShiledInjuredRecoverEnergy;                        // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealthInjuredRecoverEnergy;                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnmityCoefficient;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatDecayPercent;                                // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectCoefficient;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FControlProtectionData                 ControlProtectionTemplateData;                     // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCardGrowTemplate) == 0x000008, "Wrong alignment on FCharacterCardGrowTemplate");
static_assert(sizeof(FCharacterCardGrowTemplate) == 0x0000B8, "Wrong size on FCharacterCardGrowTemplate");
static_assert(offsetof(FCharacterCardGrowTemplate, ID) == 0x000008, "Member 'FCharacterCardGrowTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, Attack) == 0x00000C, "Member 'FCharacterCardGrowTemplate::Attack' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, Defence) == 0x000010, "Member 'FCharacterCardGrowTemplate::Defence' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, EntityBulletResistance) == 0x000014, "Member 'FCharacterCardGrowTemplate::EntityBulletResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, FireResistance) == 0x000018, "Member 'FCharacterCardGrowTemplate::FireResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, IceResistance) == 0x00001C, "Member 'FCharacterCardGrowTemplate::IceResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ThunderResistance) == 0x000020, "Member 'FCharacterCardGrowTemplate::ThunderResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, SuperpowersResistance) == 0x000024, "Member 'FCharacterCardGrowTemplate::SuperpowersResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, FieldResistance) == 0x000028, "Member 'FCharacterCardGrowTemplate::FieldResistance' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShieldType) == 0x00002C, "Member 'FCharacterCardGrowTemplate::ShieldType' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, Shield) == 0x000030, "Member 'FCharacterCardGrowTemplate::Shield' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShieldRecoverInterval) == 0x000034, "Member 'FCharacterCardGrowTemplate::ShieldRecoverInterval' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShieldDelayTime) == 0x000038, "Member 'FCharacterCardGrowTemplate::ShieldDelayTime' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShieldRecoverSpeed) == 0x00003C, "Member 'FCharacterCardGrowTemplate::ShieldRecoverSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, Health) == 0x000040, "Member 'FCharacterCardGrowTemplate::Health' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CriticalValue) == 0x000044, "Member 'FCharacterCardGrowTemplate::CriticalValue' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CriticalDamageAddtion) == 0x000048, "Member 'FCharacterCardGrowTemplate::CriticalDamageAddtion' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, SpeedRatio) == 0x00004C, "Member 'FCharacterCardGrowTemplate::SpeedRatio' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShieldDamageScaler) == 0x000050, "Member 'FCharacterCardGrowTemplate::ShieldDamageScaler' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, SkillShieldDamageScaler) == 0x000054, "Member 'FCharacterCardGrowTemplate::SkillShieldDamageScaler' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, BreathlessTime) == 0x000058, "Member 'FCharacterCardGrowTemplate::BreathlessTime' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, MaxHitLag) == 0x00005C, "Member 'FCharacterCardGrowTemplate::MaxHitLag' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, RangeDamageReduction) == 0x000070, "Member 'FCharacterCardGrowTemplate::RangeDamageReduction' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, Command) == 0x000074, "Member 'FCharacterCardGrowTemplate::Command' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CharacterEnergy) == 0x000078, "Member 'FCharacterCardGrowTemplate::CharacterEnergy' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CharacterEnergyEfficiency) == 0x00007C, "Member 'FCharacterCardGrowTemplate::CharacterEnergyEfficiency' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CharacterEnergyRecoverValue) == 0x000080, "Member 'FCharacterCardGrowTemplate::CharacterEnergyRecoverValue' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, CharacterEnergyRecoverDelta) == 0x000084, "Member 'FCharacterCardGrowTemplate::CharacterEnergyRecoverDelta' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, HitRecoeverEnergy) == 0x000088, "Member 'FCharacterCardGrowTemplate::HitRecoeverEnergy' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ShiledInjuredRecoverEnergy) == 0x00008C, "Member 'FCharacterCardGrowTemplate::ShiledInjuredRecoverEnergy' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, HealthInjuredRecoverEnergy) == 0x000090, "Member 'FCharacterCardGrowTemplate::HealthInjuredRecoverEnergy' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, EnmityCoefficient) == 0x000094, "Member 'FCharacterCardGrowTemplate::EnmityCoefficient' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ThreatDecayPercent) == 0x000098, "Member 'FCharacterCardGrowTemplate::ThreatDecayPercent' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, EffectCoefficient) == 0x00009C, "Member 'FCharacterCardGrowTemplate::EffectCoefficient' has a wrong offset!");
static_assert(offsetof(FCharacterCardGrowTemplate, ControlProtectionTemplateData) == 0x0000A0, "Member 'FCharacterCardGrowTemplate::ControlProtectionTemplateData' has a wrong offset!");

// ScriptStruct Game.PressurePointAttribute
// 0x0024 (0x0024 - 0x0000)
struct FPressurePointAttribute final
{
public:
	float                                         PressureAttenuation;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureTargetCheckRadius;                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureAddition_EnemyTarget;                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureAddition_ShootHit;                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureAddition_LightShootHit;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureAddition_ShieldDamage;                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureAddition_HealthDamage;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureLevelDecrease_PressurePointKeepEmptyTime;  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressureLevelDecreaseValue;                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPressurePointAttribute) == 0x000004, "Wrong alignment on FPressurePointAttribute");
static_assert(sizeof(FPressurePointAttribute) == 0x000024, "Wrong size on FPressurePointAttribute");
static_assert(offsetof(FPressurePointAttribute, PressureAttenuation) == 0x000000, "Member 'FPressurePointAttribute::PressureAttenuation' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureTargetCheckRadius) == 0x000004, "Member 'FPressurePointAttribute::PressureTargetCheckRadius' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureAddition_EnemyTarget) == 0x000008, "Member 'FPressurePointAttribute::PressureAddition_EnemyTarget' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureAddition_ShootHit) == 0x00000C, "Member 'FPressurePointAttribute::PressureAddition_ShootHit' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureAddition_LightShootHit) == 0x000010, "Member 'FPressurePointAttribute::PressureAddition_LightShootHit' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureAddition_ShieldDamage) == 0x000014, "Member 'FPressurePointAttribute::PressureAddition_ShieldDamage' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureAddition_HealthDamage) == 0x000018, "Member 'FPressurePointAttribute::PressureAddition_HealthDamage' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureLevelDecrease_PressurePointKeepEmptyTime) == 0x00001C, "Member 'FPressurePointAttribute::PressureLevelDecrease_PressurePointKeepEmptyTime' has a wrong offset!");
static_assert(offsetof(FPressurePointAttribute, PressureLevelDecreaseValue) == 0x000020, "Member 'FPressurePointAttribute::PressureLevelDecreaseValue' has a wrong offset!");

// ScriptStruct Game.GamePhysicsControlGroupData
// 0x00B0 (0x00B0 - 0x0000)
struct FGamePhysicsControlGroupData final
{
public:
	TArray<struct FPhysicsControlLimbSetupData>   LimbSetupData;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EPhysicsControlModifierGroupType, struct FPhysicsControlNames> BodyModifiersToSet;                                // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EPhysicsControlGroupType, struct FPhysicsControlNames> ControlToSet;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamePhysicsControlGroupData) == 0x000008, "Wrong alignment on FGamePhysicsControlGroupData");
static_assert(sizeof(FGamePhysicsControlGroupData) == 0x0000B0, "Wrong size on FGamePhysicsControlGroupData");
static_assert(offsetof(FGamePhysicsControlGroupData, LimbSetupData) == 0x000000, "Member 'FGamePhysicsControlGroupData::LimbSetupData' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlGroupData, BodyModifiersToSet) == 0x000010, "Member 'FGamePhysicsControlGroupData::BodyModifiersToSet' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlGroupData, ControlToSet) == 0x000060, "Member 'FGamePhysicsControlGroupData::ControlToSet' has a wrong offset!");

// ScriptStruct Game.RageValueAttribute
// 0x0010 (0x0010 - 0x0000)
struct FRageValueAttribute final
{
public:
	float                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attenuation;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepFullTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRageValueAttribute) == 0x000004, "Wrong alignment on FRageValueAttribute");
static_assert(sizeof(FRageValueAttribute) == 0x000010, "Wrong size on FRageValueAttribute");
static_assert(offsetof(FRageValueAttribute, MaxValue) == 0x000000, "Member 'FRageValueAttribute::MaxValue' has a wrong offset!");
static_assert(offsetof(FRageValueAttribute, InitValue) == 0x000004, "Member 'FRageValueAttribute::InitValue' has a wrong offset!");
static_assert(offsetof(FRageValueAttribute, Attenuation) == 0x000008, "Member 'FRageValueAttribute::Attenuation' has a wrong offset!");
static_assert(offsetof(FRageValueAttribute, KeepFullTime) == 0x00000C, "Member 'FRageValueAttribute::KeepFullTime' has a wrong offset!");

// ScriptStruct Game.BurnAttribute
// 0x0018 (0x0018 - 0x0000)
struct FBurnAttribute final
{
public:
	float                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attenuation;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepFullTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceAfterFullTime;                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierID;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBurnAttribute) == 0x000004, "Wrong alignment on FBurnAttribute");
static_assert(sizeof(FBurnAttribute) == 0x000018, "Wrong size on FBurnAttribute");
static_assert(offsetof(FBurnAttribute, MaxValue) == 0x000000, "Member 'FBurnAttribute::MaxValue' has a wrong offset!");
static_assert(offsetof(FBurnAttribute, InitValue) == 0x000004, "Member 'FBurnAttribute::InitValue' has a wrong offset!");
static_assert(offsetof(FBurnAttribute, Attenuation) == 0x000008, "Member 'FBurnAttribute::Attenuation' has a wrong offset!");
static_assert(offsetof(FBurnAttribute, KeepFullTime) == 0x00000C, "Member 'FBurnAttribute::KeepFullTime' has a wrong offset!");
static_assert(offsetof(FBurnAttribute, ReduceAfterFullTime) == 0x000010, "Member 'FBurnAttribute::ReduceAfterFullTime' has a wrong offset!");
static_assert(offsetof(FBurnAttribute, ModifierID) == 0x000014, "Member 'FBurnAttribute::ModifierID' has a wrong offset!");

// ScriptStruct Game.EnergyAttribute
// 0x0018 (0x0018 - 0x0000)
struct FEnergyAttribute final
{
public:
	float                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attenuation;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationIntervalTime;                           // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepFullTime;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceAfterFullTime;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnergyAttribute) == 0x000004, "Wrong alignment on FEnergyAttribute");
static_assert(sizeof(FEnergyAttribute) == 0x000018, "Wrong size on FEnergyAttribute");
static_assert(offsetof(FEnergyAttribute, MaxValue) == 0x000000, "Member 'FEnergyAttribute::MaxValue' has a wrong offset!");
static_assert(offsetof(FEnergyAttribute, InitValue) == 0x000004, "Member 'FEnergyAttribute::InitValue' has a wrong offset!");
static_assert(offsetof(FEnergyAttribute, Attenuation) == 0x000008, "Member 'FEnergyAttribute::Attenuation' has a wrong offset!");
static_assert(offsetof(FEnergyAttribute, AttenuationIntervalTime) == 0x00000C, "Member 'FEnergyAttribute::AttenuationIntervalTime' has a wrong offset!");
static_assert(offsetof(FEnergyAttribute, KeepFullTime) == 0x000010, "Member 'FEnergyAttribute::KeepFullTime' has a wrong offset!");
static_assert(offsetof(FEnergyAttribute, ReduceAfterFullTime) == 0x000014, "Member 'FEnergyAttribute::ReduceAfterFullTime' has a wrong offset!");

// ScriptStruct Game.CharacterPhysiqueTypeTemplate
// 0x0010 (0x0018 - 0x0008)
struct FCharacterPhysiqueTypeTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysiqueType                                 PhysiqueType;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectScale;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterPhysiqueTypeTemplate) == 0x000008, "Wrong alignment on FCharacterPhysiqueTypeTemplate");
static_assert(sizeof(FCharacterPhysiqueTypeTemplate) == 0x000018, "Wrong size on FCharacterPhysiqueTypeTemplate");
static_assert(offsetof(FCharacterPhysiqueTypeTemplate, ID) == 0x000008, "Member 'FCharacterPhysiqueTypeTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterPhysiqueTypeTemplate, PhysiqueType) == 0x00000C, "Member 'FCharacterPhysiqueTypeTemplate::PhysiqueType' has a wrong offset!");
static_assert(offsetof(FCharacterPhysiqueTypeTemplate, EffectScale) == 0x000010, "Member 'FCharacterPhysiqueTypeTemplate::EffectScale' has a wrong offset!");

// ScriptStruct Game.BlockByControlProtectionKeepEffectInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FBlockByControlProtectionKeepEffectInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlockByControlProtectionKeepEffectInfo) == 0x000008, "Wrong alignment on FBlockByControlProtectionKeepEffectInfo");
static_assert(sizeof(FBlockByControlProtectionKeepEffectInfo) == 0x000050, "Wrong size on FBlockByControlProtectionKeepEffectInfo");

// ScriptStruct Game.DynamicLevelTemplate
// 0x0010 (0x0018 - 0x0008)
struct FDynamicLevelTemplate final : public FTableRowBase
{
public:
	int32                                         PlayerLevel;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealLevel;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjustLevel;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDynamicLevelTemplate) == 0x000008, "Wrong alignment on FDynamicLevelTemplate");
static_assert(sizeof(FDynamicLevelTemplate) == 0x000018, "Wrong size on FDynamicLevelTemplate");
static_assert(offsetof(FDynamicLevelTemplate, PlayerLevel) == 0x000008, "Member 'FDynamicLevelTemplate::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FDynamicLevelTemplate, RealLevel) == 0x00000C, "Member 'FDynamicLevelTemplate::RealLevel' has a wrong offset!");
static_assert(offsetof(FDynamicLevelTemplate, AdjustLevel) == 0x000010, "Member 'FDynamicLevelTemplate::AdjustLevel' has a wrong offset!");

// ScriptStruct Game.CharacterCareerEnemySearch
// 0x0078 (0x0080 - 0x0008)
struct FCharacterCareerEnemySearch final : public FTableRowBase
{
public:
	EMonsCareerType                               Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DescUseless;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisScoreScale;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScoreScale;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatScoreScale;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMonsCareerType, float>                  ToOtherCareerScore;                                // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCareerEnemySearch) == 0x000008, "Wrong alignment on FCharacterCareerEnemySearch");
static_assert(sizeof(FCharacterCareerEnemySearch) == 0x000080, "Wrong size on FCharacterCareerEnemySearch");
static_assert(offsetof(FCharacterCareerEnemySearch, Type) == 0x000008, "Member 'FCharacterCareerEnemySearch::Type' has a wrong offset!");
static_assert(offsetof(FCharacterCareerEnemySearch, DescUseless) == 0x000010, "Member 'FCharacterCareerEnemySearch::DescUseless' has a wrong offset!");
static_assert(offsetof(FCharacterCareerEnemySearch, DisScoreScale) == 0x000020, "Member 'FCharacterCareerEnemySearch::DisScoreScale' has a wrong offset!");
static_assert(offsetof(FCharacterCareerEnemySearch, DamageScoreScale) == 0x000024, "Member 'FCharacterCareerEnemySearch::DamageScoreScale' has a wrong offset!");
static_assert(offsetof(FCharacterCareerEnemySearch, ThreatScoreScale) == 0x000028, "Member 'FCharacterCareerEnemySearch::ThreatScoreScale' has a wrong offset!");
static_assert(offsetof(FCharacterCareerEnemySearch, ToOtherCareerScore) == 0x000030, "Member 'FCharacterCareerEnemySearch::ToOtherCareerScore' has a wrong offset!");

// ScriptStruct Game.AbnormalStateCooling
// 0x0008 (0x0008 - 0x0000)
struct FAbnormalStateCooling final
{
public:
	EAllowedCoolingAbnormalState                  AbnormalState;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolingTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnormalStateCooling) == 0x000004, "Wrong alignment on FAbnormalStateCooling");
static_assert(sizeof(FAbnormalStateCooling) == 0x000008, "Wrong size on FAbnormalStateCooling");
static_assert(offsetof(FAbnormalStateCooling, AbnormalState) == 0x000000, "Member 'FAbnormalStateCooling::AbnormalState' has a wrong offset!");
static_assert(offsetof(FAbnormalStateCooling, CoolingTime) == 0x000004, "Member 'FAbnormalStateCooling::CoolingTime' has a wrong offset!");

// ScriptStruct Game.CharacterTemplateEx
// 0x0498 (0x04A0 - 0x0008)
struct FCharacterTemplateEx final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DescUseless;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterTemplateId;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AI;                                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceCampType;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlexibleEnumValue                     CampType;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceCharacterType;                              // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                Type;                                              // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceDamageFloatType;                            // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                DamageFloatType;                                   // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceCareerType;                                 // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsCareerType                               CareerType;                                        // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceBlueprint;                                  // 0x0046(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceAccessories;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftClassPath>                 Accessories;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceDestroyValue;                               // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDestroyValue;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrowAttributeID;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplacePatrolSpeedModify;                          // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PatrolSpeedModify;                                 // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplacePassiveModifierID;                          // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PassiveModifierID;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceBornIgnoreAbnormal;                         // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornIgnoreAbnormal;                               // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceBornGod;                                    // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornGod;                                          // 0x00A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceBornNoAoeSearch;                            // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornNoAoeSearch;                                  // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceForbiddenAbnormal;                          // 0x00A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAllowedForbidAbnormalState>           ForbiddenAbnormal;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceAbnormalStateCooling;                       // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbnormalStateCooling>          AbnormalStateCooling;                              // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceHitStateResistance;                         // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHitState>                             HitStateResistance;                                // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceIgnoreModifierTag;                          // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   IgnoreModifierTag;                                 // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewModel;                                      // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceProfileID;                                  // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProfileID;                                         // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplaceOwnedFightElements;                         // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OwnedFightElements;                                // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceHpSubsection;                               // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 HpSubsection;                                      // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceShieldSubsection;                           // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ShieldSubsection;                                  // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReplaceBreakShieldEffect;                          // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BreakShieldEffectEx;                               // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakShieldSocket;                                 // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakShieldEffectScale;                            // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapsuleHeight;                                     // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x308];                                    // 0x0198(0x0308)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterTemplateEx) == 0x000008, "Wrong alignment on FCharacterTemplateEx");
static_assert(sizeof(FCharacterTemplateEx) == 0x0004A0, "Wrong size on FCharacterTemplateEx");
static_assert(offsetof(FCharacterTemplateEx, ID) == 0x000008, "Member 'FCharacterTemplateEx::ID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, DescUseless) == 0x000010, "Member 'FCharacterTemplateEx::DescUseless' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, SpawnName) == 0x000020, "Member 'FCharacterTemplateEx::SpawnName' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, MonsterTemplateId) == 0x000030, "Member 'FCharacterTemplateEx::MonsterTemplateId' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, AI) == 0x000034, "Member 'FCharacterTemplateEx::AI' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceCampType) == 0x000038, "Member 'FCharacterTemplateEx::ReplaceCampType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, CampType) == 0x00003C, "Member 'FCharacterTemplateEx::CampType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceCharacterType) == 0x000040, "Member 'FCharacterTemplateEx::ReplaceCharacterType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, Type) == 0x000041, "Member 'FCharacterTemplateEx::Type' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceDamageFloatType) == 0x000042, "Member 'FCharacterTemplateEx::ReplaceDamageFloatType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, DamageFloatType) == 0x000043, "Member 'FCharacterTemplateEx::DamageFloatType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceCareerType) == 0x000044, "Member 'FCharacterTemplateEx::ReplaceCareerType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, CareerType) == 0x000045, "Member 'FCharacterTemplateEx::CareerType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceBlueprint) == 0x000046, "Member 'FCharacterTemplateEx::ReplaceBlueprint' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, Blueprint) == 0x000048, "Member 'FCharacterTemplateEx::Blueprint' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceAccessories) == 0x000060, "Member 'FCharacterTemplateEx::ReplaceAccessories' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, Accessories) == 0x000068, "Member 'FCharacterTemplateEx::Accessories' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceDestroyValue) == 0x000078, "Member 'FCharacterTemplateEx::ReplaceDestroyValue' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, bUseDestroyValue) == 0x000079, "Member 'FCharacterTemplateEx::bUseDestroyValue' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, GrowAttributeID) == 0x00007C, "Member 'FCharacterTemplateEx::GrowAttributeID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, MaxSpeed) == 0x000080, "Member 'FCharacterTemplateEx::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplacePatrolSpeedModify) == 0x000084, "Member 'FCharacterTemplateEx::ReplacePatrolSpeedModify' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, PatrolSpeedModify) == 0x000088, "Member 'FCharacterTemplateEx::PatrolSpeedModify' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplacePassiveModifierID) == 0x00008C, "Member 'FCharacterTemplateEx::ReplacePassiveModifierID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, PassiveModifierID) == 0x000090, "Member 'FCharacterTemplateEx::PassiveModifierID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceBornIgnoreAbnormal) == 0x0000A0, "Member 'FCharacterTemplateEx::ReplaceBornIgnoreAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, bBornIgnoreAbnormal) == 0x0000A1, "Member 'FCharacterTemplateEx::bBornIgnoreAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceBornGod) == 0x0000A2, "Member 'FCharacterTemplateEx::ReplaceBornGod' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, bBornGod) == 0x0000A3, "Member 'FCharacterTemplateEx::bBornGod' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceBornNoAoeSearch) == 0x0000A4, "Member 'FCharacterTemplateEx::ReplaceBornNoAoeSearch' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, bBornNoAoeSearch) == 0x0000A5, "Member 'FCharacterTemplateEx::bBornNoAoeSearch' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceForbiddenAbnormal) == 0x0000A6, "Member 'FCharacterTemplateEx::ReplaceForbiddenAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ForbiddenAbnormal) == 0x0000A8, "Member 'FCharacterTemplateEx::ForbiddenAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceAbnormalStateCooling) == 0x0000B8, "Member 'FCharacterTemplateEx::ReplaceAbnormalStateCooling' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, AbnormalStateCooling) == 0x0000C0, "Member 'FCharacterTemplateEx::AbnormalStateCooling' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceHitStateResistance) == 0x0000D0, "Member 'FCharacterTemplateEx::ReplaceHitStateResistance' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, HitStateResistance) == 0x0000D8, "Member 'FCharacterTemplateEx::HitStateResistance' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceIgnoreModifierTag) == 0x0000E8, "Member 'FCharacterTemplateEx::ReplaceIgnoreModifierTag' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, IgnoreModifierTag) == 0x0000F0, "Member 'FCharacterTemplateEx::IgnoreModifierTag' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, PreviewModel) == 0x000100, "Member 'FCharacterTemplateEx::PreviewModel' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceProfileID) == 0x000118, "Member 'FCharacterTemplateEx::ReplaceProfileID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ProfileID) == 0x00011C, "Member 'FCharacterTemplateEx::ProfileID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceOwnedFightElements) == 0x000120, "Member 'FCharacterTemplateEx::ReplaceOwnedFightElements' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, OwnedFightElements) == 0x000128, "Member 'FCharacterTemplateEx::OwnedFightElements' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceHpSubsection) == 0x000138, "Member 'FCharacterTemplateEx::ReplaceHpSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, HpSubsection) == 0x000140, "Member 'FCharacterTemplateEx::HpSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceShieldSubsection) == 0x000150, "Member 'FCharacterTemplateEx::ReplaceShieldSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ShieldSubsection) == 0x000158, "Member 'FCharacterTemplateEx::ShieldSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, ReplaceBreakShieldEffect) == 0x000168, "Member 'FCharacterTemplateEx::ReplaceBreakShieldEffect' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, BreakShieldEffectEx) == 0x000170, "Member 'FCharacterTemplateEx::BreakShieldEffectEx' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, BreakShieldSocket) == 0x000188, "Member 'FCharacterTemplateEx::BreakShieldSocket' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, BreakShieldEffectScale) == 0x000190, "Member 'FCharacterTemplateEx::BreakShieldEffectScale' has a wrong offset!");
static_assert(offsetof(FCharacterTemplateEx, CapsuleHeight) == 0x000194, "Member 'FCharacterTemplateEx::CapsuleHeight' has a wrong offset!");

// ScriptStruct Game.CharacterTemplate
// 0x02F8 (0x0300 - 0x0008)
struct FCharacterTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterName;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResNameDec;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AI;                                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Camp;                                              // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsCareerType                               CareerType;                                        // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFlexibleEnumValue                     CampType;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                Type;                                              // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterType                                DamageFloatType;                                   // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysiqueType                                 PhysiqueType;                                      // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSign;                                         // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighLightBorder;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProfileID;                                         // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriangleAttributeType                        TriangleType;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinReplaceMeshInfo>           SkinReplaceMesh;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PreviewModel;                                      // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UICameraID;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DeadPerformanceAsset;                              // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDestroyValue;                                  // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrowAttributeID;                                   // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMinion;                                           // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinionGrowID;                                      // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveModifierID;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolSpeedModify;                                 // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornIgnoreAbnormal;                               // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornGod;                                          // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornNoAoeSearch;                                  // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillAsSummoned;                                  // 0x00FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepelToFloatInAir;                                // 0x00FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAllowedForbidAbnormalState>           ForbiddenAbnormal;                                 // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAbnormalStateCooling>          AbnormalStateCooling;                              // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EHitState>                             HitStateResistance;                                // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   IgnoreModifierTag;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         WeaknessPart;                                      // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         InefficientPart;                                   // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ForceLOD;                                          // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitBlockPushPriority;                              // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushAwaySlowerOthers;                             // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushDistance;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushAwayPlayer;                                   // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DamageSelfScale;                                   // 0x0171(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedAddToCaches;                                  // 0x0172(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_173[0x1];                                      // 0x0173(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMoveConfig                      SimpleMoveConfig;                                  // 0x0174(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPreventRotationToMovement;                        // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Hardness;                                          // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 HpSubsection;                                      // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ShieldSubsection;                                  // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              ShieldSurfaceType;                                 // 0x01C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA[0x6];                                      // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BreakShieldEffect;                                 // 0x01D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakShieldSocket;                                 // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakShieldEffectScale;                            // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ERangeAttackState, TSoftObjectPtr<class UHitReactData>> StateHitReactionData;                              // 0x01F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UHitReactPhysicalData>   HitPhysData;                                       // 0x0248(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAbnormalReactData>      AbnormalReactData;                                 // 0x0270(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BounceValue;                                       // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckOWEndFightOuterNavCost;                       // 0x029C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OwnedFightElements;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreWhenReturnPos;                            // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CapsuleHeight;                                     // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTemplateId                            DefaultWeaponId;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReloadSkill;                                       // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           UnFixModeMesh;                                     // 0x02D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterTemplate) == 0x000008, "Wrong alignment on FCharacterTemplate");
static_assert(sizeof(FCharacterTemplate) == 0x000300, "Wrong size on FCharacterTemplate");
static_assert(offsetof(FCharacterTemplate, ID) == 0x000008, "Member 'FCharacterTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, CharacterName) == 0x000010, "Member 'FCharacterTemplate::CharacterName' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, SpawnName) == 0x000020, "Member 'FCharacterTemplate::SpawnName' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ResNameDec) == 0x000030, "Member 'FCharacterTemplate::ResNameDec' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, AI) == 0x000040, "Member 'FCharacterTemplate::AI' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, Camp) == 0x000044, "Member 'FCharacterTemplate::Camp' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, CareerType) == 0x000045, "Member 'FCharacterTemplate::CareerType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, CampType) == 0x000048, "Member 'FCharacterTemplate::CampType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, Type) == 0x00004C, "Member 'FCharacterTemplate::Type' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, DamageFloatType) == 0x00004D, "Member 'FCharacterTemplate::DamageFloatType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, PhysiqueType) == 0x00004E, "Member 'FCharacterTemplate::PhysiqueType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bShowSign) == 0x00004F, "Member 'FCharacterTemplate::bShowSign' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bHighLightBorder) == 0x000050, "Member 'FCharacterTemplate::bHighLightBorder' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ProfileID) == 0x000054, "Member 'FCharacterTemplate::ProfileID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, TriangleType) == 0x000058, "Member 'FCharacterTemplate::TriangleType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, Blueprint) == 0x000060, "Member 'FCharacterTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, SkinReplaceMesh) == 0x000078, "Member 'FCharacterTemplate::SkinReplaceMesh' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, Accessories) == 0x000088, "Member 'FCharacterTemplate::Accessories' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, PreviewModel) == 0x000098, "Member 'FCharacterTemplate::PreviewModel' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, UICameraID) == 0x0000B0, "Member 'FCharacterTemplate::UICameraID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, DeadPerformanceAsset) == 0x0000B8, "Member 'FCharacterTemplate::DeadPerformanceAsset' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bUseDestroyValue) == 0x0000D0, "Member 'FCharacterTemplate::bUseDestroyValue' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, GrowAttributeID) == 0x0000D4, "Member 'FCharacterTemplate::GrowAttributeID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bMinion) == 0x0000D8, "Member 'FCharacterTemplate::bMinion' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, MinionGrowID) == 0x0000DC, "Member 'FCharacterTemplate::MinionGrowID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, PassiveModifierID) == 0x0000E0, "Member 'FCharacterTemplate::PassiveModifierID' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, MaxSpeed) == 0x0000F0, "Member 'FCharacterTemplate::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, PatrolSpeedModify) == 0x0000F4, "Member 'FCharacterTemplate::PatrolSpeedModify' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bBornIgnoreAbnormal) == 0x0000F8, "Member 'FCharacterTemplate::bBornIgnoreAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bBornGod) == 0x0000F9, "Member 'FCharacterTemplate::bBornGod' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bBornNoAoeSearch) == 0x0000FA, "Member 'FCharacterTemplate::bBornNoAoeSearch' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bSkillAsSummoned) == 0x0000FB, "Member 'FCharacterTemplate::bSkillAsSummoned' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bRepelToFloatInAir) == 0x0000FC, "Member 'FCharacterTemplate::bRepelToFloatInAir' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ForbiddenAbnormal) == 0x000100, "Member 'FCharacterTemplate::ForbiddenAbnormal' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, AbnormalStateCooling) == 0x000110, "Member 'FCharacterTemplate::AbnormalStateCooling' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, HitStateResistance) == 0x000120, "Member 'FCharacterTemplate::HitStateResistance' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, IgnoreModifierTag) == 0x000130, "Member 'FCharacterTemplate::IgnoreModifierTag' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, WeaknessPart) == 0x000140, "Member 'FCharacterTemplate::WeaknessPart' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, InefficientPart) == 0x000150, "Member 'FCharacterTemplate::InefficientPart' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ForceLOD) == 0x000160, "Member 'FCharacterTemplate::ForceLOD' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, HitBlockPushPriority) == 0x000164, "Member 'FCharacterTemplate::HitBlockPushPriority' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bPushAwaySlowerOthers) == 0x000168, "Member 'FCharacterTemplate::bPushAwaySlowerOthers' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, PushDistance) == 0x00016C, "Member 'FCharacterTemplate::PushDistance' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bPushAwayPlayer) == 0x000170, "Member 'FCharacterTemplate::bPushAwayPlayer' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, DamageSelfScale) == 0x000171, "Member 'FCharacterTemplate::DamageSelfScale' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bNeedAddToCaches) == 0x000172, "Member 'FCharacterTemplate::bNeedAddToCaches' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, SimpleMoveConfig) == 0x000174, "Member 'FCharacterTemplate::SimpleMoveConfig' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bPreventRotationToMovement) == 0x0001A0, "Member 'FCharacterTemplate::bPreventRotationToMovement' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, Hardness) == 0x0001A4, "Member 'FCharacterTemplate::Hardness' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, HpSubsection) == 0x0001A8, "Member 'FCharacterTemplate::HpSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ShieldSubsection) == 0x0001B8, "Member 'FCharacterTemplate::ShieldSubsection' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, SurfaceType) == 0x0001C8, "Member 'FCharacterTemplate::SurfaceType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ShieldSurfaceType) == 0x0001C9, "Member 'FCharacterTemplate::ShieldSurfaceType' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, BreakShieldEffect) == 0x0001D0, "Member 'FCharacterTemplate::BreakShieldEffect' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, BreakShieldSocket) == 0x0001E8, "Member 'FCharacterTemplate::BreakShieldSocket' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, BreakShieldEffectScale) == 0x0001F0, "Member 'FCharacterTemplate::BreakShieldEffectScale' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, StateHitReactionData) == 0x0001F8, "Member 'FCharacterTemplate::StateHitReactionData' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, HitPhysData) == 0x000248, "Member 'FCharacterTemplate::HitPhysData' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, AbnormalReactData) == 0x000270, "Member 'FCharacterTemplate::AbnormalReactData' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, BounceValue) == 0x000298, "Member 'FCharacterTemplate::BounceValue' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, CheckOWEndFightOuterNavCost) == 0x00029C, "Member 'FCharacterTemplate::CheckOWEndFightOuterNavCost' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, OwnedFightElements) == 0x0002A0, "Member 'FCharacterTemplate::OwnedFightElements' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, bIsIgnoreWhenReturnPos) == 0x0002B0, "Member 'FCharacterTemplate::bIsIgnoreWhenReturnPos' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, CapsuleHeight) == 0x0002B4, "Member 'FCharacterTemplate::CapsuleHeight' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, DefaultWeaponId) == 0x0002B8, "Member 'FCharacterTemplate::DefaultWeaponId' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, ReloadSkill) == 0x0002C8, "Member 'FCharacterTemplate::ReloadSkill' has a wrong offset!");
static_assert(offsetof(FCharacterTemplate, UnFixModeMesh) == 0x0002D0, "Member 'FCharacterTemplate::UnFixModeMesh' has a wrong offset!");

// ScriptStruct Game.CampRelation
// 0x0058 (0x0060 - 0x0008)
struct FCampRelation final : public FTableRowBase
{
public:
	struct FFlexibleEnumValue                     CampType;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFlexibleEnumValue>             FriendlyCamp;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             LittleFriendCamp;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             NeutralCamp;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             UnFriendlyCamp;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFlexibleEnumValue>             EnermyCamp;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampRelation) == 0x000008, "Wrong alignment on FCampRelation");
static_assert(sizeof(FCampRelation) == 0x000060, "Wrong size on FCampRelation");
static_assert(offsetof(FCampRelation, CampType) == 0x000008, "Member 'FCampRelation::CampType' has a wrong offset!");
static_assert(offsetof(FCampRelation, FriendlyCamp) == 0x000010, "Member 'FCampRelation::FriendlyCamp' has a wrong offset!");
static_assert(offsetof(FCampRelation, LittleFriendCamp) == 0x000020, "Member 'FCampRelation::LittleFriendCamp' has a wrong offset!");
static_assert(offsetof(FCampRelation, NeutralCamp) == 0x000030, "Member 'FCampRelation::NeutralCamp' has a wrong offset!");
static_assert(offsetof(FCampRelation, UnFriendlyCamp) == 0x000040, "Member 'FCampRelation::UnFriendlyCamp' has a wrong offset!");
static_assert(offsetof(FCampRelation, EnermyCamp) == 0x000050, "Member 'FCampRelation::EnermyCamp' has a wrong offset!");

// ScriptStruct Game.LoveWaterGunWaitNpcPos
// 0x0010 (0x0010 - 0x0000)
struct FLoveWaterGunWaitNpcPos final
{
public:
	class USceneComponent*                        Root;                                              // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CameraTrans;                                       // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoveWaterGunWaitNpcPos) == 0x000008, "Wrong alignment on FLoveWaterGunWaitNpcPos");
static_assert(sizeof(FLoveWaterGunWaitNpcPos) == 0x000010, "Wrong size on FLoveWaterGunWaitNpcPos");
static_assert(offsetof(FLoveWaterGunWaitNpcPos, Root) == 0x000000, "Member 'FLoveWaterGunWaitNpcPos::Root' has a wrong offset!");
static_assert(offsetof(FLoveWaterGunWaitNpcPos, CameraTrans) == 0x000008, "Member 'FLoveWaterGunWaitNpcPos::CameraTrans' has a wrong offset!");

// ScriptStruct Game.ChessPoolData
// 0x0010 (0x0010 - 0x0000)
struct FChessPoolData final
{
public:
	TArray<class AChessActor*>                    List;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChessPoolData) == 0x000008, "Wrong alignment on FChessPoolData");
static_assert(sizeof(FChessPoolData) == 0x000010, "Wrong size on FChessPoolData");
static_assert(offsetof(FChessPoolData, List) == 0x000000, "Member 'FChessPoolData::List' has a wrong offset!");

// ScriptStruct Game.AnimNotifyInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAnimNotifyInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNotifyInfo) == 0x000008, "Wrong alignment on FAnimNotifyInfo");
static_assert(sizeof(FAnimNotifyInfo) == 0x000010, "Wrong size on FAnimNotifyInfo");

// ScriptStruct Game.GridMeshInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FGridMeshInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridMeshInfo) == 0x000004, "Wrong alignment on FGridMeshInfo");
static_assert(sizeof(FGridMeshInfo) == 0x000010, "Wrong size on FGridMeshInfo");

// ScriptStruct Game.ContactModifyInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FContactModifyInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContactModifyInfo) == 0x000008, "Wrong alignment on FContactModifyInfo");
static_assert(sizeof(FContactModifyInfo) == 0x000020, "Wrong size on FContactModifyInfo");

// ScriptStruct Game.PlayerCustomShopData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerCustomShopData final
{
public:
	int64                                         PlayerID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBufferShopStateEnum                          State;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpen;                                            // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCustomShopData) == 0x000008, "Wrong alignment on FPlayerCustomShopData");
static_assert(sizeof(FPlayerCustomShopData) == 0x000010, "Wrong size on FPlayerCustomShopData");
static_assert(offsetof(FPlayerCustomShopData, PlayerID) == 0x000000, "Member 'FPlayerCustomShopData::PlayerID' has a wrong offset!");
static_assert(offsetof(FPlayerCustomShopData, State) == 0x000008, "Member 'FPlayerCustomShopData::State' has a wrong offset!");
static_assert(offsetof(FPlayerCustomShopData, IsOpen) == 0x000009, "Member 'FPlayerCustomShopData::IsOpen' has a wrong offset!");

// ScriptStruct Game.HouseActionWeight
// 0x0008 (0x0008 - 0x0000)
struct FHouseActionWeight final
{
public:
	EBornActionType                               bornAction;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionWeight;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseActionWeight) == 0x000004, "Wrong alignment on FHouseActionWeight");
static_assert(sizeof(FHouseActionWeight) == 0x000008, "Wrong size on FHouseActionWeight");
static_assert(offsetof(FHouseActionWeight, bornAction) == 0x000000, "Member 'FHouseActionWeight::bornAction' has a wrong offset!");
static_assert(offsetof(FHouseActionWeight, ActionWeight) == 0x000004, "Member 'FHouseActionWeight::ActionWeight' has a wrong offset!");

// ScriptStruct Game.HouseAreaBornCfg
// 0x0040 (0x0048 - 0x0008)
struct FHouseAreaBornCfg final : public FTableRowBase
{
public:
	EAreaType                                     AreaType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNpcCount;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHouseActionWeight>             Actions;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IgnoreNpcIds;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllowNpcIds;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseAreaBornCfg) == 0x000008, "Wrong alignment on FHouseAreaBornCfg");
static_assert(sizeof(FHouseAreaBornCfg) == 0x000048, "Wrong size on FHouseAreaBornCfg");
static_assert(offsetof(FHouseAreaBornCfg, AreaType) == 0x000008, "Member 'FHouseAreaBornCfg::AreaType' has a wrong offset!");
static_assert(offsetof(FHouseAreaBornCfg, Weight) == 0x00000C, "Member 'FHouseAreaBornCfg::Weight' has a wrong offset!");
static_assert(offsetof(FHouseAreaBornCfg, MaxNpcCount) == 0x000010, "Member 'FHouseAreaBornCfg::MaxNpcCount' has a wrong offset!");
static_assert(offsetof(FHouseAreaBornCfg, Actions) == 0x000018, "Member 'FHouseAreaBornCfg::Actions' has a wrong offset!");
static_assert(offsetof(FHouseAreaBornCfg, IgnoreNpcIds) == 0x000028, "Member 'FHouseAreaBornCfg::IgnoreNpcIds' has a wrong offset!");
static_assert(offsetof(FHouseAreaBornCfg, AllowNpcIds) == 0x000038, "Member 'FHouseAreaBornCfg::AllowNpcIds' has a wrong offset!");

// ScriptStruct Game.CacheDamageFloatWidget
// 0x0028 (0x0028 - 0x0000)
struct FCacheDamageFloatWidget final
{
public:
	EModifyHPResult                               HitTypes;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         AnimWidget;                                        // 0x0008(0x0018)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWorldPos;                                      // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCacheDamageFloatWidget) == 0x000008, "Wrong alignment on FCacheDamageFloatWidget");
static_assert(sizeof(FCacheDamageFloatWidget) == 0x000028, "Wrong size on FCacheDamageFloatWidget");
static_assert(offsetof(FCacheDamageFloatWidget, HitTypes) == 0x000000, "Member 'FCacheDamageFloatWidget::HitTypes' has a wrong offset!");
static_assert(offsetof(FCacheDamageFloatWidget, AnimWidget) == 0x000008, "Member 'FCacheDamageFloatWidget::AnimWidget' has a wrong offset!");
static_assert(offsetof(FCacheDamageFloatWidget, bUseWorldPos) == 0x000020, "Member 'FCacheDamageFloatWidget::bUseWorldPos' has a wrong offset!");

// ScriptStruct Game.GameRepOverrideData
// 0x0010 (0x0010 - 0x0000)
struct FGameRepOverrideData final
{
public:
	bool                                          bAlwaysRelevant;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNetLoadOnClient;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetCullDistanceSquared;                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetUpdateFrequency;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinNetUpdateFrequency;                             // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameRepOverrideData) == 0x000004, "Wrong alignment on FGameRepOverrideData");
static_assert(sizeof(FGameRepOverrideData) == 0x000010, "Wrong size on FGameRepOverrideData");
static_assert(offsetof(FGameRepOverrideData, bAlwaysRelevant) == 0x000000, "Member 'FGameRepOverrideData::bAlwaysRelevant' has a wrong offset!");
static_assert(offsetof(FGameRepOverrideData, bNetLoadOnClient) == 0x000001, "Member 'FGameRepOverrideData::bNetLoadOnClient' has a wrong offset!");
static_assert(offsetof(FGameRepOverrideData, NetCullDistanceSquared) == 0x000004, "Member 'FGameRepOverrideData::NetCullDistanceSquared' has a wrong offset!");
static_assert(offsetof(FGameRepOverrideData, NetUpdateFrequency) == 0x000008, "Member 'FGameRepOverrideData::NetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(FGameRepOverrideData, MinNetUpdateFrequency) == 0x00000C, "Member 'FGameRepOverrideData::MinNetUpdateFrequency' has a wrong offset!");

// ScriptStruct Game.DamageFloatRecord
// 0x0058 (0x0058 - 0x0000)
struct FDamageFloatRecord final
{
public:
	TMap<float, int32>                            ShowTimeMap;                                       // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          bClearFinish;                                      // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllSum;                                            // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageFloatRecord) == 0x000008, "Wrong alignment on FDamageFloatRecord");
static_assert(sizeof(FDamageFloatRecord) == 0x000058, "Wrong size on FDamageFloatRecord");
static_assert(offsetof(FDamageFloatRecord, ShowTimeMap) == 0x000000, "Member 'FDamageFloatRecord::ShowTimeMap' has a wrong offset!");
static_assert(offsetof(FDamageFloatRecord, bClearFinish) == 0x000050, "Member 'FDamageFloatRecord::bClearFinish' has a wrong offset!");
static_assert(offsetof(FDamageFloatRecord, AllSum) == 0x000054, "Member 'FDamageFloatRecord::AllSum' has a wrong offset!");

// ScriptStruct Game.KidRideSoundParam
// 0x0028 (0x0028 - 0x0000)
struct FKidRideSoundParam final
{
public:
	class FString                                 SoundName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoopSound;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StopSoundName;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideSoundParam) == 0x000008, "Wrong alignment on FKidRideSoundParam");
static_assert(sizeof(FKidRideSoundParam) == 0x000028, "Wrong size on FKidRideSoundParam");
static_assert(offsetof(FKidRideSoundParam, SoundName) == 0x000000, "Member 'FKidRideSoundParam::SoundName' has a wrong offset!");
static_assert(offsetof(FKidRideSoundParam, bIsLoopSound) == 0x000010, "Member 'FKidRideSoundParam::bIsLoopSound' has a wrong offset!");
static_assert(offsetof(FKidRideSoundParam, StopSoundName) == 0x000018, "Member 'FKidRideSoundParam::StopSoundName' has a wrong offset!");

// ScriptStruct Game.KidRideSoundItem
// 0x0030 (0x0030 - 0x0000)
struct FKidRideSoundItem final
{
public:
	EKidRideEffectType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKidRideSoundParam                     Param;                                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideSoundItem) == 0x000008, "Wrong alignment on FKidRideSoundItem");
static_assert(sizeof(FKidRideSoundItem) == 0x000030, "Wrong size on FKidRideSoundItem");
static_assert(offsetof(FKidRideSoundItem, Type) == 0x000000, "Member 'FKidRideSoundItem::Type' has a wrong offset!");
static_assert(offsetof(FKidRideSoundItem, Param) == 0x000008, "Member 'FKidRideSoundItem::Param' has a wrong offset!");

// ScriptStruct Game.EmitterSearchSetting
// 0x0308 (0x0308 - 0x0000)
struct FEmitterSearchSetting final
{
public:
	ESearchSettingType                            TargetType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointSelectType                              PointSelectType;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointTargetUseType                           OuterInheritType;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PointTargetsInheritEmitterID;                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimLocPointRangeLimit;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointTargetSelectRule                        PointInAnchorType;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetPointNum;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EApplyLocationType                            TargetPointLocationType;                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnchorSetting                         PointAnchorRangeSelector;                          // 0x0020(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EHitOriginType                                PointTraceCheckOriginType;                         // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PointTraceCheckOriginSocket;                       // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               PointTraceChannel;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointFilterByAirBlock;                            // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginType                                PointDistanceCheckOriginType;                      // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PointDistanceCheckOriginSocket;                    // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PointRangeLimit;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointOutRangeRule                            OutRangePointDealRule;                             // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NavigationRule;                                    // 0x0119(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECampRelation>                         TargetCampRelations;                               // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESearchTargetPartType                         TargetPartType;                                    // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetPartToAccessActor;                          // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESearchTargetType>                     ActorType;                                         // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EActorSelectType                              ActorSelectType;                                   // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAppointTargetType                            AppointTargetType;                                 // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         TrapClassPath;                                     // 0x0150(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppointFilterTargets;                             // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActorTargetUseType                           ActorInheritType;                                  // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActorTargetsInheritEmitterID;                      // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecifiedSkillID;                                  // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SceneTargetsTag;                                   // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SearcherTargets;                                   // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchorSetting                         ActorAnchorRangeSelector;                          // 0x01A0(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         EmitterRolePickTypes;                              // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginType                                ActorTraceCheckOriginType;                         // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorTraceCheckOriginSocket;                       // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ActorTraceChannel;                                 // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorFilterByAirBlock;                            // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginType                                ActorDistanceCheckOriginType;                      // 0x027A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B[0x5];                                      // 0x027B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorDistanceCheckOriginSocket;                    // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ActorRangeLimit;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerifyClosestDistance;                            // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RequireModifierIDs;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockModifierIDs;                                  // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RequireModifierTags;                               // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlockModifierTags;                                 // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FStateBlockTypeNames>           StateBlockTypeNames;                               // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 SearcherFilter;                                    // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bFiltrateTrapIfHas;                                // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterSearchSetting) == 0x000008, "Wrong alignment on FEmitterSearchSetting");
static_assert(sizeof(FEmitterSearchSetting) == 0x000308, "Wrong size on FEmitterSearchSetting");
static_assert(offsetof(FEmitterSearchSetting, TargetType) == 0x000000, "Member 'FEmitterSearchSetting::TargetType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointSelectType) == 0x000001, "Member 'FEmitterSearchSetting::PointSelectType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, OuterInheritType) == 0x000002, "Member 'FEmitterSearchSetting::OuterInheritType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointTargetsInheritEmitterID) == 0x000004, "Member 'FEmitterSearchSetting::PointTargetsInheritEmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, AimLocPointRangeLimit) == 0x000008, "Member 'FEmitterSearchSetting::AimLocPointRangeLimit' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointInAnchorType) == 0x000010, "Member 'FEmitterSearchSetting::PointInAnchorType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, TargetPointNum) == 0x000014, "Member 'FEmitterSearchSetting::TargetPointNum' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, TargetPointLocationType) == 0x000018, "Member 'FEmitterSearchSetting::TargetPointLocationType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointAnchorRangeSelector) == 0x000020, "Member 'FEmitterSearchSetting::PointAnchorRangeSelector' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointTraceCheckOriginType) == 0x0000E0, "Member 'FEmitterSearchSetting::PointTraceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointTraceCheckOriginSocket) == 0x0000E8, "Member 'FEmitterSearchSetting::PointTraceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointTraceChannel) == 0x0000F8, "Member 'FEmitterSearchSetting::PointTraceChannel' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bPointFilterByAirBlock) == 0x0000F9, "Member 'FEmitterSearchSetting::bPointFilterByAirBlock' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointDistanceCheckOriginType) == 0x0000FA, "Member 'FEmitterSearchSetting::PointDistanceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointDistanceCheckOriginSocket) == 0x000100, "Member 'FEmitterSearchSetting::PointDistanceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, PointRangeLimit) == 0x000110, "Member 'FEmitterSearchSetting::PointRangeLimit' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, OutRangePointDealRule) == 0x000118, "Member 'FEmitterSearchSetting::OutRangePointDealRule' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, NavigationRule) == 0x000119, "Member 'FEmitterSearchSetting::NavigationRule' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, TargetCampRelations) == 0x000120, "Member 'FEmitterSearchSetting::TargetCampRelations' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, TargetPartType) == 0x000130, "Member 'FEmitterSearchSetting::TargetPartType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bTargetPartToAccessActor) == 0x000131, "Member 'FEmitterSearchSetting::bTargetPartToAccessActor' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorType) == 0x000138, "Member 'FEmitterSearchSetting::ActorType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorSelectType) == 0x000148, "Member 'FEmitterSearchSetting::ActorSelectType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, AppointTargetType) == 0x000149, "Member 'FEmitterSearchSetting::AppointTargetType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, CharacterID) == 0x00014C, "Member 'FEmitterSearchSetting::CharacterID' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, TrapClassPath) == 0x000150, "Member 'FEmitterSearchSetting::TrapClassPath' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bAppointFilterTargets) == 0x000168, "Member 'FEmitterSearchSetting::bAppointFilterTargets' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorInheritType) == 0x000169, "Member 'FEmitterSearchSetting::ActorInheritType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorTargetsInheritEmitterID) == 0x00016C, "Member 'FEmitterSearchSetting::ActorTargetsInheritEmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, SpecifiedSkillID) == 0x000170, "Member 'FEmitterSearchSetting::SpecifiedSkillID' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, SceneTargetsTag) == 0x000178, "Member 'FEmitterSearchSetting::SceneTargetsTag' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, SearcherTargets) == 0x000188, "Member 'FEmitterSearchSetting::SearcherTargets' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorAnchorRangeSelector) == 0x0001A0, "Member 'FEmitterSearchSetting::ActorAnchorRangeSelector' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, EmitterRolePickTypes) == 0x000260, "Member 'FEmitterSearchSetting::EmitterRolePickTypes' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorTraceCheckOriginType) == 0x000264, "Member 'FEmitterSearchSetting::ActorTraceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorTraceCheckOriginSocket) == 0x000268, "Member 'FEmitterSearchSetting::ActorTraceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorTraceChannel) == 0x000278, "Member 'FEmitterSearchSetting::ActorTraceChannel' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bActorFilterByAirBlock) == 0x000279, "Member 'FEmitterSearchSetting::bActorFilterByAirBlock' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorDistanceCheckOriginType) == 0x00027A, "Member 'FEmitterSearchSetting::ActorDistanceCheckOriginType' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorDistanceCheckOriginSocket) == 0x000280, "Member 'FEmitterSearchSetting::ActorDistanceCheckOriginSocket' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, ActorRangeLimit) == 0x000290, "Member 'FEmitterSearchSetting::ActorRangeLimit' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bVerifyClosestDistance) == 0x000298, "Member 'FEmitterSearchSetting::bVerifyClosestDistance' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, RequireModifierIDs) == 0x0002A0, "Member 'FEmitterSearchSetting::RequireModifierIDs' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, BlockModifierIDs) == 0x0002B0, "Member 'FEmitterSearchSetting::BlockModifierIDs' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, RequireModifierTags) == 0x0002C0, "Member 'FEmitterSearchSetting::RequireModifierTags' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, BlockModifierTags) == 0x0002D0, "Member 'FEmitterSearchSetting::BlockModifierTags' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, StateBlockTypeNames) == 0x0002E0, "Member 'FEmitterSearchSetting::StateBlockTypeNames' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, SearcherFilter) == 0x0002F0, "Member 'FEmitterSearchSetting::SearcherFilter' has a wrong offset!");
static_assert(offsetof(FEmitterSearchSetting, bFiltrateTrapIfHas) == 0x000300, "Member 'FEmitterSearchSetting::bFiltrateTrapIfHas' has a wrong offset!");

// ScriptStruct Game.EmitterSortRule
// 0x0028 (0x0028 - 0x0000)
struct FEmitterSortRule final
{
public:
	struct FSoftClassPath                         SortRule;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     Infos;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterSortRule) == 0x000008, "Wrong alignment on FEmitterSortRule");
static_assert(sizeof(FEmitterSortRule) == 0x000028, "Wrong size on FEmitterSortRule");
static_assert(offsetof(FEmitterSortRule, SortRule) == 0x000000, "Member 'FEmitterSortRule::SortRule' has a wrong offset!");
static_assert(offsetof(FEmitterSortRule, Infos) == 0x000018, "Member 'FEmitterSortRule::Infos' has a wrong offset!");

// ScriptStruct Game.BulletSpawnSetting
// 0x0048 (0x0048 - 0x0000)
struct FBulletSpawnSetting final
{
public:
	Game::EBulletType                             BulletType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClusterBullet;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BulletScreenEditorClass;                           // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletSpawnPointType                         SpawnPointType;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBulletSpawnPointFixRule                      FixRule;                                           // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BulletSocket;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStorageSocketTransform;                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkRunning;                                      // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletSpawnSetting) == 0x000008, "Wrong alignment on FBulletSpawnSetting");
static_assert(sizeof(FBulletSpawnSetting) == 0x000048, "Wrong size on FBulletSpawnSetting");
static_assert(offsetof(FBulletSpawnSetting, BulletType) == 0x000000, "Member 'FBulletSpawnSetting::BulletType' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, BulletID) == 0x000004, "Member 'FBulletSpawnSetting::BulletID' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, bUseClusterBullet) == 0x000008, "Member 'FBulletSpawnSetting::bUseClusterBullet' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, BulletScreenEditorClass) == 0x000010, "Member 'FBulletSpawnSetting::BulletScreenEditorClass' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, SpawnPointType) == 0x000028, "Member 'FBulletSpawnSetting::SpawnPointType' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, FixRule) == 0x000029, "Member 'FBulletSpawnSetting::FixRule' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, BulletSocket) == 0x000030, "Member 'FBulletSpawnSetting::BulletSocket' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, bStorageSocketTransform) == 0x000040, "Member 'FBulletSpawnSetting::bStorageSocketTransform' has a wrong offset!");
static_assert(offsetof(FBulletSpawnSetting, bMarkRunning) == 0x000041, "Member 'FBulletSpawnSetting::bMarkRunning' has a wrong offset!");

// ScriptStruct Game.AnchorPointEffectInfo
// 0x0070 (0x0070 - 0x0000)
struct FAnchorPointEffectInfo final
{
public:
	struct FSoftObjectPath                        AnchorPointEffectPath;                             // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AnchorPointEffectRelativeTransform;                // 0x0020(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RandomRot;                                         // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bParticleFollowAnchor;                             // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnchorPointEffectSocket;                           // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnchorPointEffectInfo) == 0x000010, "Wrong alignment on FAnchorPointEffectInfo");
static_assert(sizeof(FAnchorPointEffectInfo) == 0x000070, "Wrong size on FAnchorPointEffectInfo");
static_assert(offsetof(FAnchorPointEffectInfo, AnchorPointEffectPath) == 0x000000, "Member 'FAnchorPointEffectInfo::AnchorPointEffectPath' has a wrong offset!");
static_assert(offsetof(FAnchorPointEffectInfo, AnchorPointEffectRelativeTransform) == 0x000020, "Member 'FAnchorPointEffectInfo::AnchorPointEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(FAnchorPointEffectInfo, RandomRot) == 0x000050, "Member 'FAnchorPointEffectInfo::RandomRot' has a wrong offset!");
static_assert(offsetof(FAnchorPointEffectInfo, bParticleFollowAnchor) == 0x00005C, "Member 'FAnchorPointEffectInfo::bParticleFollowAnchor' has a wrong offset!");
static_assert(offsetof(FAnchorPointEffectInfo, AnchorPointEffectSocket) == 0x000060, "Member 'FAnchorPointEffectInfo::AnchorPointEffectSocket' has a wrong offset!");

// ScriptStruct Game.EmitterEffectExhibitionInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FEmitterEffectExhibitionInfo final
{
public:
	EHitExhibitionLocationType                    BaseExhibitionLocationType;                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OriginSocketName;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveHitEffect;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitEffectPath;                                     // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectNotAttach;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectFaceToLauncher;                          // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectInTargetFace;                            // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitEffectRelativeTransform;                        // 0x0040(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RandomRot;                                         // 0x0070(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EParticleEndPlayTriggerType                   HitEffectEndPlayTriggerType;                       // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HitSoundEvent;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitSocket;                                         // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         HitCameraShakePath;                                // 0x0098(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitShakeEffectSelfOnly;                           // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitShakeMaxValidDistance;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitShakeAttenuation;                               // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterEffectExhibitionInfo) == 0x000010, "Wrong alignment on FEmitterEffectExhibitionInfo");
static_assert(sizeof(FEmitterEffectExhibitionInfo) == 0x0000C0, "Wrong size on FEmitterEffectExhibitionInfo");
static_assert(offsetof(FEmitterEffectExhibitionInfo, BaseExhibitionLocationType) == 0x000000, "Member 'FEmitterEffectExhibitionInfo::BaseExhibitionLocationType' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, OriginSocketName) == 0x000008, "Member 'FEmitterEffectExhibitionInfo::OriginSocketName' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, bHaveHitEffect) == 0x000018, "Member 'FEmitterEffectExhibitionInfo::bHaveHitEffect' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitEffectPath) == 0x000020, "Member 'FEmitterEffectExhibitionInfo::HitEffectPath' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, bHitEffectNotAttach) == 0x000038, "Member 'FEmitterEffectExhibitionInfo::bHitEffectNotAttach' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, bHitEffectFaceToLauncher) == 0x000039, "Member 'FEmitterEffectExhibitionInfo::bHitEffectFaceToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, bHitEffectInTargetFace) == 0x00003A, "Member 'FEmitterEffectExhibitionInfo::bHitEffectInTargetFace' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitEffectRelativeTransform) == 0x000040, "Member 'FEmitterEffectExhibitionInfo::HitEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, RandomRot) == 0x000070, "Member 'FEmitterEffectExhibitionInfo::RandomRot' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitEffectEndPlayTriggerType) == 0x00007C, "Member 'FEmitterEffectExhibitionInfo::HitEffectEndPlayTriggerType' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitSoundEvent) == 0x000080, "Member 'FEmitterEffectExhibitionInfo::HitSoundEvent' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitSocket) == 0x000090, "Member 'FEmitterEffectExhibitionInfo::HitSocket' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitCameraShakePath) == 0x000098, "Member 'FEmitterEffectExhibitionInfo::HitCameraShakePath' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, bHitShakeEffectSelfOnly) == 0x0000B0, "Member 'FEmitterEffectExhibitionInfo::bHitShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitShakeMaxValidDistance) == 0x0000B4, "Member 'FEmitterEffectExhibitionInfo::HitShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FEmitterEffectExhibitionInfo, HitShakeAttenuation) == 0x0000B8, "Member 'FEmitterEffectExhibitionInfo::HitShakeAttenuation' has a wrong offset!");

// ScriptStruct Game.EmitterInfo
// 0x0498 (0x04A0 - 0x0008)
struct FEmitterInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedActive;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepaceData;                                       // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplaceParamArray;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEmitterSearchSetting>          SearchSettings;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESearchResultCommitRule                       TargetArrayRule;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommintSame;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SameTargetMaxNum;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetNum;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmitterSortRule>               SortRules;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EEffectTargetType                             EffectTarget;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterResultEffectPriority                  ResultPriority;                                    // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetMaxApplyNum;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBulletSpawnSetting>            BulletSettings;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHasAnchorPointEffect;                             // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnchorPointEffectInfo>         AnchorPointEffects;                                // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AnchorEffectActorClassesPath;                      // 0x0080(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleEndPlayTriggerType                   AnchorPointEndPlayTriggerType;                     // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnchorPointSoundEvent;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AnchorPointCameraShakePath;                        // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnchorShakeEffectSelfOnly;                        // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnchorShakeMaxValidDistance;                       // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnchorShakeAttenuation;                            // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsAttack;                                         // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitEffect;                                     // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginType                                AttackOriginType;                                  // 0x00D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitOriginLocation                            AttackOriginLocation;                              // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttackOriginSocket;                                // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEmitterEffectExhibitionInfo           BaseExhibitionInfo;                                // 0x00F0(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitDeadState;                                      // 0x01B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeChangeValueGrowup>    AttibuteChangeGrowup;                              // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESkillCriteType                               CriteType;                                         // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BaseEffectDamageAttenuationCurve;                  // 0x01D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPropertyChangeValueGrowup>     BaseEffectPropertyChangeGrowup;                    // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FModifierDamageEffect>          BaseEffectDamageEffects;                           // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAbnormalStateApplyInfo>        BaseEffectAbnormalInfos;                           // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCastModifierCondition>         AddModifiersToLauncher;                            // 0x0218(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 KeepModifiersToLauncher;                           // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveModifiersToLauncher;                         // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCastModifierCondition>         AddModifiersToTarget;                              // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveModifiersToTarget;                           // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 EmitterIDs;                                        // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEmitterHitSetting                     HitEffectSetting;                                  // 0x0280(0x01A0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FirstDelayTime;                                    // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiApply;                                       // 0x0424(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectiveTimes;                                    // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyTimeDilation;                                // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveUntilSkillMoveEnd;                          // 0x0431(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x6];                                      // 0x0432(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 JumpToSectionName;                                 // 0x0438(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JumpToSectionNameOnFinished;                       // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConditionSetting>              EndConditions;                                     // 0x0458(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         EmitterTypePath;                                   // 0x0468(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParamInfo>                     Params;                                            // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bMarkRunning;                                      // 0x0490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletAttenuationDistance;                         // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DivideDamage;                                      // 0x0498(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceEffect;                                    // 0x0499(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49A[0x6];                                      // 0x049A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterInfo) == 0x000010, "Wrong alignment on FEmitterInfo");
static_assert(sizeof(FEmitterInfo) == 0x0004A0, "Wrong size on FEmitterInfo");
static_assert(offsetof(FEmitterInfo, ID) == 0x000008, "Member 'FEmitterInfo::ID' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bNeedActive) == 0x00000C, "Member 'FEmitterInfo::bNeedActive' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bRepaceData) == 0x00000D, "Member 'FEmitterInfo::bRepaceData' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, ReplaceParamArray) == 0x000010, "Member 'FEmitterInfo::ReplaceParamArray' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, SearchSettings) == 0x000020, "Member 'FEmitterInfo::SearchSettings' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, TargetArrayRule) == 0x000030, "Member 'FEmitterInfo::TargetArrayRule' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bCommintSame) == 0x000031, "Member 'FEmitterInfo::bCommintSame' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, SameTargetMaxNum) == 0x000034, "Member 'FEmitterInfo::SameTargetMaxNum' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, MaxTargetNum) == 0x000038, "Member 'FEmitterInfo::MaxTargetNum' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, SortRules) == 0x000040, "Member 'FEmitterInfo::SortRules' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, EffectTarget) == 0x000050, "Member 'FEmitterInfo::EffectTarget' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, ResultPriority) == 0x000051, "Member 'FEmitterInfo::ResultPriority' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, TargetMaxApplyNum) == 0x000054, "Member 'FEmitterInfo::TargetMaxApplyNum' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BulletSettings) == 0x000058, "Member 'FEmitterInfo::BulletSettings' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bHasAnchorPointEffect) == 0x000068, "Member 'FEmitterInfo::bHasAnchorPointEffect' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorPointEffects) == 0x000070, "Member 'FEmitterInfo::AnchorPointEffects' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorEffectActorClassesPath) == 0x000080, "Member 'FEmitterInfo::AnchorEffectActorClassesPath' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorPointEndPlayTriggerType) == 0x000098, "Member 'FEmitterInfo::AnchorPointEndPlayTriggerType' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorPointSoundEvent) == 0x0000A0, "Member 'FEmitterInfo::AnchorPointSoundEvent' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorPointCameraShakePath) == 0x0000B0, "Member 'FEmitterInfo::AnchorPointCameraShakePath' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bAnchorShakeEffectSelfOnly) == 0x0000C8, "Member 'FEmitterInfo::bAnchorShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorShakeMaxValidDistance) == 0x0000CC, "Member 'FEmitterInfo::AnchorShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AnchorShakeAttenuation) == 0x0000D0, "Member 'FEmitterInfo::AnchorShakeAttenuation' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bAsAttack) == 0x0000D1, "Member 'FEmitterInfo::bAsAttack' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bUseHitEffect) == 0x0000D2, "Member 'FEmitterInfo::bUseHitEffect' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AttackOriginType) == 0x0000D3, "Member 'FEmitterInfo::AttackOriginType' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AttackOriginLocation) == 0x0000D4, "Member 'FEmitterInfo::AttackOriginLocation' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AttackOriginSocket) == 0x0000D8, "Member 'FEmitterInfo::AttackOriginSocket' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BaseExhibitionInfo) == 0x0000F0, "Member 'FEmitterInfo::BaseExhibitionInfo' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, HitDeadState) == 0x0001B0, "Member 'FEmitterInfo::HitDeadState' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AttibuteChangeGrowup) == 0x0001B8, "Member 'FEmitterInfo::AttibuteChangeGrowup' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, CriteType) == 0x0001C8, "Member 'FEmitterInfo::CriteType' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BaseEffectDamageAttenuationCurve) == 0x0001D0, "Member 'FEmitterInfo::BaseEffectDamageAttenuationCurve' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BaseEffectPropertyChangeGrowup) == 0x0001E8, "Member 'FEmitterInfo::BaseEffectPropertyChangeGrowup' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BaseEffectDamageEffects) == 0x0001F8, "Member 'FEmitterInfo::BaseEffectDamageEffects' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BaseEffectAbnormalInfos) == 0x000208, "Member 'FEmitterInfo::BaseEffectAbnormalInfos' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AddModifiersToLauncher) == 0x000218, "Member 'FEmitterInfo::AddModifiersToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, KeepModifiersToLauncher) == 0x000228, "Member 'FEmitterInfo::KeepModifiersToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, RemoveModifiersToLauncher) == 0x000238, "Member 'FEmitterInfo::RemoveModifiersToLauncher' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, AddModifiersToTarget) == 0x000248, "Member 'FEmitterInfo::AddModifiersToTarget' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, RemoveModifiersToTarget) == 0x000258, "Member 'FEmitterInfo::RemoveModifiersToTarget' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, EmitterIDs) == 0x000268, "Member 'FEmitterInfo::EmitterIDs' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, HitEffectSetting) == 0x000280, "Member 'FEmitterInfo::HitEffectSetting' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, FirstDelayTime) == 0x000420, "Member 'FEmitterInfo::FirstDelayTime' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bMultiApply) == 0x000424, "Member 'FEmitterInfo::bMultiApply' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, EffectiveTimes) == 0x000428, "Member 'FEmitterInfo::EffectiveTimes' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, Interval) == 0x00042C, "Member 'FEmitterInfo::Interval' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bApplyTimeDilation) == 0x000430, "Member 'FEmitterInfo::bApplyTimeDilation' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bActiveUntilSkillMoveEnd) == 0x000431, "Member 'FEmitterInfo::bActiveUntilSkillMoveEnd' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, JumpToSectionName) == 0x000438, "Member 'FEmitterInfo::JumpToSectionName' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, JumpToSectionNameOnFinished) == 0x000448, "Member 'FEmitterInfo::JumpToSectionNameOnFinished' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, EndConditions) == 0x000458, "Member 'FEmitterInfo::EndConditions' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, EmitterTypePath) == 0x000468, "Member 'FEmitterInfo::EmitterTypePath' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, Params) == 0x000480, "Member 'FEmitterInfo::Params' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bMarkRunning) == 0x000490, "Member 'FEmitterInfo::bMarkRunning' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, BulletAttenuationDistance) == 0x000494, "Member 'FEmitterInfo::BulletAttenuationDistance' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, DivideDamage) == 0x000498, "Member 'FEmitterInfo::DivideDamage' has a wrong offset!");
static_assert(offsetof(FEmitterInfo, bReplaceEffect) == 0x000499, "Member 'FEmitterInfo::bReplaceEffect' has a wrong offset!");

// ScriptStruct Game.GetUpMoveInfo
// 0x0010 (0x0010 - 0x0000)
struct FGetUpMoveInfo final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetUpMoveInfo) == 0x000004, "Wrong alignment on FGetUpMoveInfo");
static_assert(sizeof(FGetUpMoveInfo) == 0x000010, "Wrong size on FGetUpMoveInfo");
static_assert(offsetof(FGetUpMoveInfo, Direction) == 0x000000, "Member 'FGetUpMoveInfo::Direction' has a wrong offset!");
static_assert(offsetof(FGetUpMoveInfo, KeepTime) == 0x00000C, "Member 'FGetUpMoveInfo::KeepTime' has a wrong offset!");

// ScriptStruct Game.DamageFloatDetail
// 0x0040 (0x0048 - 0x0008)
struct FDamageFloatDetail final : public FTableRowBase
{
public:
	class FString                                 SpecialType;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EModifyHPResult>                       HitTypes;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDamageFloatDetailInfo>         DetailInfos;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageFloatDetail) == 0x000008, "Wrong alignment on FDamageFloatDetail");
static_assert(sizeof(FDamageFloatDetail) == 0x000048, "Wrong size on FDamageFloatDetail");
static_assert(offsetof(FDamageFloatDetail, SpecialType) == 0x000008, "Member 'FDamageFloatDetail::SpecialType' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetail, HitTypes) == 0x000018, "Member 'FDamageFloatDetail::HitTypes' has a wrong offset!");
static_assert(offsetof(FDamageFloatDetail, DetailInfos) == 0x000028, "Member 'FDamageFloatDetail::DetailInfos' has a wrong offset!");

// ScriptStruct Game.MovieSceneGameWidgetMaterialSectionTemplate
// 0x0008 (0x0088 - 0x0080)
struct FMovieSceneGameWidgetMaterialSectionTemplate final : public FMovieSceneParameterSectionTemplate
{
public:
	int32                                         MaterialIndex;                                     // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneGameWidgetMaterialSectionTemplate) == 0x000008, "Wrong alignment on FMovieSceneGameWidgetMaterialSectionTemplate");
static_assert(sizeof(FMovieSceneGameWidgetMaterialSectionTemplate) == 0x000088, "Wrong size on FMovieSceneGameWidgetMaterialSectionTemplate");
static_assert(offsetof(FMovieSceneGameWidgetMaterialSectionTemplate, MaterialIndex) == 0x000080, "Member 'FMovieSceneGameWidgetMaterialSectionTemplate::MaterialIndex' has a wrong offset!");

// ScriptStruct Game.MyWidgetInfo
// 0x0010 (0x0010 - 0x0000)
struct FMyWidgetInfo final
{
public:
	TArray<class UDamageFloat_Base*>              Widgets;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMyWidgetInfo) == 0x000008, "Wrong alignment on FMyWidgetInfo");
static_assert(sizeof(FMyWidgetInfo) == 0x000010, "Wrong size on FMyWidgetInfo");
static_assert(offsetof(FMyWidgetInfo, Widgets) == 0x000000, "Member 'FMyWidgetInfo::Widgets' has a wrong offset!");

// ScriptStruct Game.DarkZonePreLoadHandle
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDarkZonePreLoadHandle final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkZonePreLoadHandle) == 0x000008, "Wrong alignment on FDarkZonePreLoadHandle");
static_assert(sizeof(FDarkZonePreLoadHandle) == 0x000028, "Wrong size on FDarkZonePreLoadHandle");

// ScriptStruct Game.PathInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FPathInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathInfo) == 0x000004, "Wrong alignment on FPathInfo");
static_assert(sizeof(FPathInfo) == 0x000008, "Wrong size on FPathInfo");

// ScriptStruct Game.Arr2D
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FArr2D final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArr2D) == 0x000008, "Wrong alignment on FArr2D");
static_assert(sizeof(FArr2D) == 0x000020, "Wrong size on FArr2D");

// ScriptStruct Game.HellSkillInfo
// 0x0014 (0x0014 - 0x0000)
struct FHellSkillInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectorSkillId;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadyTime;                                         // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHellSkillInfo) == 0x000004, "Wrong alignment on FHellSkillInfo");
static_assert(sizeof(FHellSkillInfo) == 0x000014, "Wrong size on FHellSkillInfo");
static_assert(offsetof(FHellSkillInfo, SkillID) == 0x000000, "Member 'FHellSkillInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FHellSkillInfo, ConfigId) == 0x000004, "Member 'FHellSkillInfo::ConfigId' has a wrong offset!");
static_assert(offsetof(FHellSkillInfo, SelectorSkillId) == 0x000008, "Member 'FHellSkillInfo::SelectorSkillId' has a wrong offset!");
static_assert(offsetof(FHellSkillInfo, ReadyTime) == 0x00000C, "Member 'FHellSkillInfo::ReadyTime' has a wrong offset!");
static_assert(offsetof(FHellSkillInfo, CD) == 0x000010, "Member 'FHellSkillInfo::CD' has a wrong offset!");

// ScriptStruct Game.ARSeqData
// 0x0048 (0x0050 - 0x0008)
struct FARSeqData final : public FTableRowBase
{
public:
	int32                                         SeqID;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToScreen;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachRelativeTransform;                           // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FARSeqConfig>                   SequenceCfg;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FARSeqData) == 0x000010, "Wrong alignment on FARSeqData");
static_assert(sizeof(FARSeqData) == 0x000050, "Wrong size on FARSeqData");
static_assert(offsetof(FARSeqData, SeqID) == 0x000008, "Member 'FARSeqData::SeqID' has a wrong offset!");
static_assert(offsetof(FARSeqData, bAttachToScreen) == 0x00000C, "Member 'FARSeqData::bAttachToScreen' has a wrong offset!");
static_assert(offsetof(FARSeqData, AttachRelativeTransform) == 0x000010, "Member 'FARSeqData::AttachRelativeTransform' has a wrong offset!");
static_assert(offsetof(FARSeqData, SequenceCfg) == 0x000040, "Member 'FARSeqData::SequenceCfg' has a wrong offset!");

// ScriptStruct Game.ARAnimData
// 0x0060 (0x0068 - 0x0008)
struct FARAnimData final : public FTableRowBase
{
public:
	int32                                         ActionID;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Anim;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FaceAnim;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendIn;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWeapon;                                       // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FARAnimData) == 0x000008, "Wrong alignment on FARAnimData");
static_assert(sizeof(FARAnimData) == 0x000068, "Wrong size on FARAnimData");
static_assert(offsetof(FARAnimData, ActionID) == 0x000008, "Member 'FARAnimData::ActionID' has a wrong offset!");
static_assert(offsetof(FARAnimData, Anim) == 0x000010, "Member 'FARAnimData::Anim' has a wrong offset!");
static_assert(offsetof(FARAnimData, FaceAnim) == 0x000028, "Member 'FARAnimData::FaceAnim' has a wrong offset!");
static_assert(offsetof(FARAnimData, BlendIn) == 0x000040, "Member 'FARAnimData::BlendIn' has a wrong offset!");
static_assert(offsetof(FARAnimData, BlendOut) == 0x000044, "Member 'FARAnimData::BlendOut' has a wrong offset!");
static_assert(offsetof(FARAnimData, CharacterID) == 0x000048, "Member 'FARAnimData::CharacterID' has a wrong offset!");
static_assert(offsetof(FARAnimData, VoiceID) == 0x000050, "Member 'FARAnimData::VoiceID' has a wrong offset!");
static_assert(offsetof(FARAnimData, bHideWeapon) == 0x000060, "Member 'FARAnimData::bHideWeapon' has a wrong offset!");

// ScriptStruct Game.SkillMoveParamInfo
// 0x0070 (0x0070 - 0x0000)
struct FSkillMoveParamInfo final
{
public:
	TArray<struct FParamInfo>                     Params;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param1;                                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param2;                                            // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param3;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param4;                                            // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param5;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FParamInfo                             Param6;                                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillMoveParamInfo) == 0x000008, "Wrong alignment on FSkillMoveParamInfo");
static_assert(sizeof(FSkillMoveParamInfo) == 0x000070, "Wrong size on FSkillMoveParamInfo");
static_assert(offsetof(FSkillMoveParamInfo, Params) == 0x000000, "Member 'FSkillMoveParamInfo::Params' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param1) == 0x000010, "Member 'FSkillMoveParamInfo::Param1' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param2) == 0x000020, "Member 'FSkillMoveParamInfo::Param2' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param3) == 0x000030, "Member 'FSkillMoveParamInfo::Param3' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param4) == 0x000040, "Member 'FSkillMoveParamInfo::Param4' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param5) == 0x000050, "Member 'FSkillMoveParamInfo::Param5' has a wrong offset!");
static_assert(offsetof(FSkillMoveParamInfo, Param6) == 0x000060, "Member 'FSkillMoveParamInfo::Param6' has a wrong offset!");

// ScriptStruct Game.EditorSnowConfig
// 0x0078 (0x0080 - 0x0008)
struct FEditorSnowConfig final : public FTableRowBase
{
public:
	float                                         OpenSnow;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SnowColor;                                         // 0x000C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FluorescentColors;                                 // 0x001C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FlashColor;                                        // 0x002C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistributionRange;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnhancedPollution;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistributionTransition;                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopRange;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopTransition;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionUV;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexUV;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashUV;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterColor;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluorescenceIntensity;                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetailParticle;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashIntensity;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveScale;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveRange;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Normal;                                            // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AO;                                                // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorSnowConfig) == 0x000008, "Wrong alignment on FEditorSnowConfig");
static_assert(sizeof(FEditorSnowConfig) == 0x000080, "Wrong size on FEditorSnowConfig");
static_assert(offsetof(FEditorSnowConfig, OpenSnow) == 0x000008, "Member 'FEditorSnowConfig::OpenSnow' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, SnowColor) == 0x00000C, "Member 'FEditorSnowConfig::SnowColor' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, FluorescentColors) == 0x00001C, "Member 'FEditorSnowConfig::FluorescentColors' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, FlashColor) == 0x00002C, "Member 'FEditorSnowConfig::FlashColor' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, DistributionRange) == 0x00003C, "Member 'FEditorSnowConfig::DistributionRange' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, EnhancedPollution) == 0x000040, "Member 'FEditorSnowConfig::EnhancedPollution' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, DistributionTransition) == 0x000044, "Member 'FEditorSnowConfig::DistributionTransition' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, TopRange) == 0x000048, "Member 'FEditorSnowConfig::TopRange' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, TopTransition) == 0x00004C, "Member 'FEditorSnowConfig::TopTransition' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, TransitionUV) == 0x000050, "Member 'FEditorSnowConfig::TransitionUV' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, TexUV) == 0x000054, "Member 'FEditorSnowConfig::TexUV' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, FlashUV) == 0x000058, "Member 'FEditorSnowConfig::FlashUV' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, CenterColor) == 0x00005C, "Member 'FEditorSnowConfig::CenterColor' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, FluorescenceIntensity) == 0x000060, "Member 'FEditorSnowConfig::FluorescenceIntensity' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, DetailParticle) == 0x000064, "Member 'FEditorSnowConfig::DetailParticle' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, FlashIntensity) == 0x000068, "Member 'FEditorSnowConfig::FlashIntensity' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, EmissiveScale) == 0x00006C, "Member 'FEditorSnowConfig::EmissiveScale' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, EmissiveRange) == 0x000070, "Member 'FEditorSnowConfig::EmissiveRange' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, Roughness) == 0x000074, "Member 'FEditorSnowConfig::Roughness' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, Normal) == 0x000078, "Member 'FEditorSnowConfig::Normal' has a wrong offset!");
static_assert(offsetof(FEditorSnowConfig, AO) == 0x00007C, "Member 'FEditorSnowConfig::AO' has a wrong offset!");

// ScriptStruct Game.GraphicsSettingVariable
// 0x0018 (0x0020 - 0x0008)
struct FGraphicsSettingVariable final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetForce;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraphicsSettingVariable) == 0x000008, "Wrong alignment on FGraphicsSettingVariable");
static_assert(sizeof(FGraphicsSettingVariable) == 0x000020, "Wrong size on FGraphicsSettingVariable");
static_assert(offsetof(FGraphicsSettingVariable, Name) == 0x000008, "Member 'FGraphicsSettingVariable::Name' has a wrong offset!");
static_assert(offsetof(FGraphicsSettingVariable, bSetForce) == 0x000018, "Member 'FGraphicsSettingVariable::bSetForce' has a wrong offset!");

// ScriptStruct Game.GraphicsSettingRow
// 0x0018 (0x0020 - 0x0008)
struct FGraphicsSettingRow final : public FTableRowBase
{
public:
	EGraphicsSettingCategory                      Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGraphicsSettingVariable>       Variables;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraphicsSettingRow) == 0x000008, "Wrong alignment on FGraphicsSettingRow");
static_assert(sizeof(FGraphicsSettingRow) == 0x000020, "Wrong size on FGraphicsSettingRow");
static_assert(offsetof(FGraphicsSettingRow, Category) == 0x000008, "Member 'FGraphicsSettingRow::Category' has a wrong offset!");
static_assert(offsetof(FGraphicsSettingRow, Variables) == 0x000010, "Member 'FGraphicsSettingRow::Variables' has a wrong offset!");

// ScriptStruct Game.EditorFogConfig
// 0x0048 (0x0050 - 0x0008)
struct FEditorFogConfig final : public FTableRowBase
{
public:
	struct FLinearColor                           FogColor1st;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDesity1st;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFallOff1st;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity1st;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance1st;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogColor2st;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDensity2st;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightMax2st;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightMin2st;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFade2st;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightOffset2st;                                // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEditorFogConfig) == 0x000008, "Wrong alignment on FEditorFogConfig");
static_assert(sizeof(FEditorFogConfig) == 0x000050, "Wrong size on FEditorFogConfig");
static_assert(offsetof(FEditorFogConfig, FogColor1st) == 0x000008, "Member 'FEditorFogConfig::FogColor1st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogDesity1st) == 0x000018, "Member 'FEditorFogConfig::FogDesity1st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogHeightFallOff1st) == 0x00001C, "Member 'FEditorFogConfig::FogHeightFallOff1st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogMaxOpacity1st) == 0x000020, "Member 'FEditorFogConfig::FogMaxOpacity1st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, StartDistance1st) == 0x000024, "Member 'FEditorFogConfig::StartDistance1st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogColor2st) == 0x000028, "Member 'FEditorFogConfig::FogColor2st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogDensity2st) == 0x000038, "Member 'FEditorFogConfig::FogDensity2st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogHeightMax2st) == 0x00003C, "Member 'FEditorFogConfig::FogHeightMax2st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogHeightMin2st) == 0x000040, "Member 'FEditorFogConfig::FogHeightMin2st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogHeightFade2st) == 0x000044, "Member 'FEditorFogConfig::FogHeightFade2st' has a wrong offset!");
static_assert(offsetof(FEditorFogConfig, FogHeightOffset2st) == 0x000048, "Member 'FEditorFogConfig::FogHeightOffset2st' has a wrong offset!");

// ScriptStruct Game.TalkInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTalkInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkInfo) == 0x000008, "Wrong alignment on FTalkInfo");
static_assert(sizeof(FTalkInfo) == 0x000030, "Wrong size on FTalkInfo");

// ScriptStruct Game.CameraShakeData
// 0x0030 (0x0030 - 0x0000)
struct FCameraShakeData final
{
public:
	EShakeType                                    ShakeType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BlendInCurve;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendOutCurve;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetValue;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FMaxOffset;                                        // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraShakeData) == 0x000008, "Wrong alignment on FCameraShakeData");
static_assert(sizeof(FCameraShakeData) == 0x000030, "Wrong size on FCameraShakeData");
static_assert(offsetof(FCameraShakeData, ShakeType) == 0x000000, "Member 'FCameraShakeData::ShakeType' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, StartTime) == 0x000004, "Member 'FCameraShakeData::StartTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, TotalTime) == 0x000008, "Member 'FCameraShakeData::TotalTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, BlendInTime) == 0x00000C, "Member 'FCameraShakeData::BlendInTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, BlendInCurve) == 0x000010, "Member 'FCameraShakeData::BlendInCurve' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, BlendOutTime) == 0x000018, "Member 'FCameraShakeData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, BlendOutCurve) == 0x000020, "Member 'FCameraShakeData::BlendOutCurve' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, OffsetValue) == 0x000028, "Member 'FCameraShakeData::OffsetValue' has a wrong offset!");
static_assert(offsetof(FCameraShakeData, FMaxOffset) == 0x00002C, "Member 'FCameraShakeData::FMaxOffset' has a wrong offset!");

// ScriptStruct Game.ModifierKeepEffectConfig
// 0x0020 (0x0028 - 0x0008)
struct FModifierKeepEffectConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ParticlePath;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierKeepEffectConfig) == 0x000008, "Wrong alignment on FModifierKeepEffectConfig");
static_assert(sizeof(FModifierKeepEffectConfig) == 0x000028, "Wrong size on FModifierKeepEffectConfig");
static_assert(offsetof(FModifierKeepEffectConfig, ID) == 0x000008, "Member 'FModifierKeepEffectConfig::ID' has a wrong offset!");
static_assert(offsetof(FModifierKeepEffectConfig, ParticlePath) == 0x000010, "Member 'FModifierKeepEffectConfig::ParticlePath' has a wrong offset!");

// ScriptStruct Game.ChainEffectInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FChainEffectInfo final
{
public:
	class AActor*                                 StartActor;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EndActor;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     RayParticleRef;                                    // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTransform;                                     // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartOffset;                                       // 0x0030(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EndOffset;                                         // 0x0060(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0090(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChainEffectInfo) == 0x000010, "Wrong alignment on FChainEffectInfo");
static_assert(sizeof(FChainEffectInfo) == 0x0000A0, "Wrong size on FChainEffectInfo");
static_assert(offsetof(FChainEffectInfo, StartActor) == 0x000000, "Member 'FChainEffectInfo::StartActor' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, EndActor) == 0x000008, "Member 'FChainEffectInfo::EndActor' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, Socket) == 0x000010, "Member 'FChainEffectInfo::Socket' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, RayParticleRef) == 0x000018, "Member 'FChainEffectInfo::RayParticleRef' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, bUseTransform) == 0x000020, "Member 'FChainEffectInfo::bUseTransform' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, StartOffset) == 0x000030, "Member 'FChainEffectInfo::StartOffset' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, EndOffset) == 0x000060, "Member 'FChainEffectInfo::EndOffset' has a wrong offset!");
static_assert(offsetof(FChainEffectInfo, Offset) == 0x000090, "Member 'FChainEffectInfo::Offset' has a wrong offset!");

// ScriptStruct Game.TargetSortResult
// 0x0018 (0x0018 - 0x0000)
struct FTargetSortResult final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQueryResult>                   SamePriorityResults;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetSortResult) == 0x000008, "Wrong alignment on FTargetSortResult");
static_assert(sizeof(FTargetSortResult) == 0x000018, "Wrong size on FTargetSortResult");
static_assert(offsetof(FTargetSortResult, Priority) == 0x000000, "Member 'FTargetSortResult::Priority' has a wrong offset!");
static_assert(offsetof(FTargetSortResult, SamePriorityResults) == 0x000008, "Member 'FTargetSortResult::SamePriorityResults' has a wrong offset!");

// ScriptStruct Game.FinishAnimInfo
// 0x0018 (0x0018 - 0x0000)
struct FFinishAnimInfo final
{
public:
	class FString                                 MontageName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFinishAnimInfo) == 0x000008, "Wrong alignment on FFinishAnimInfo");
static_assert(sizeof(FFinishAnimInfo) == 0x000018, "Wrong size on FFinishAnimInfo");
static_assert(offsetof(FFinishAnimInfo, MontageName) == 0x000000, "Member 'FFinishAnimInfo::MontageName' has a wrong offset!");
static_assert(offsetof(FFinishAnimInfo, Weight) == 0x000010, "Member 'FFinishAnimInfo::Weight' has a wrong offset!");

// ScriptStruct Game.EndlessTDSpawnInfo
// 0x0120 (0x0120 - 0x0000)
struct FEndlessTDSpawnInfo final
{
public:
	struct FSpawnNpcByStruct                      SpawnInfo;                                         // 0x0000(0x0118)(Edit, NativeAccessSpecifierPublic)
	int32                                         MonsterCount;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndlessTDSpawnInfo) == 0x000008, "Wrong alignment on FEndlessTDSpawnInfo");
static_assert(sizeof(FEndlessTDSpawnInfo) == 0x000120, "Wrong size on FEndlessTDSpawnInfo");
static_assert(offsetof(FEndlessTDSpawnInfo, SpawnInfo) == 0x000000, "Member 'FEndlessTDSpawnInfo::SpawnInfo' has a wrong offset!");
static_assert(offsetof(FEndlessTDSpawnInfo, MonsterCount) == 0x000118, "Member 'FEndlessTDSpawnInfo::MonsterCount' has a wrong offset!");

// ScriptStruct Game.EndlessTDMonster
// 0x0050 (0x0058 - 0x0008)
struct FEndlessTDMonster final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndlessTDSpawnInfo>            MonsterInfo;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IntervalMin;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMax;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaveCountMin;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaveCountMax;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBossWave;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinWheelRewardCount;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWheelRewardCount;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreRatio;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerSpeedupNumber;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndSpeedupNumber;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndlessTDMonster) == 0x000008, "Wrong alignment on FEndlessTDMonster");
static_assert(sizeof(FEndlessTDMonster) == 0x000058, "Wrong size on FEndlessTDMonster");
static_assert(offsetof(FEndlessTDMonster, ID) == 0x000008, "Member 'FEndlessTDMonster::ID' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, Comment) == 0x000010, "Member 'FEndlessTDMonster::Comment' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, MonsterInfo) == 0x000020, "Member 'FEndlessTDMonster::MonsterInfo' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, IntervalMin) == 0x000030, "Member 'FEndlessTDMonster::IntervalMin' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, IntervalMax) == 0x000034, "Member 'FEndlessTDMonster::IntervalMax' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, WaveCountMin) == 0x000038, "Member 'FEndlessTDMonster::WaveCountMin' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, WaveCountMax) == 0x00003C, "Member 'FEndlessTDMonster::WaveCountMax' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, bIsBossWave) == 0x000040, "Member 'FEndlessTDMonster::bIsBossWave' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, MinWheelRewardCount) == 0x000044, "Member 'FEndlessTDMonster::MinWheelRewardCount' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, MaxWheelRewardCount) == 0x000048, "Member 'FEndlessTDMonster::MaxWheelRewardCount' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, ScoreRatio) == 0x00004C, "Member 'FEndlessTDMonster::ScoreRatio' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, TriggerSpeedupNumber) == 0x000050, "Member 'FEndlessTDMonster::TriggerSpeedupNumber' has a wrong offset!");
static_assert(offsetof(FEndlessTDMonster, EndSpeedupNumber) == 0x000054, "Member 'FEndlessTDMonster::EndSpeedupNumber' has a wrong offset!");

// ScriptStruct Game.HouseCameraInfo
// 0x0038 (0x0038 - 0x0000)
struct FHouseCameraInfo final
{
public:
	float                                         CameraArmLength;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraArmPosition;                                 // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CameraSocketOffsetCurve;                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraSocketOffset;                                // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHouseCameraInfo) == 0x000008, "Wrong alignment on FHouseCameraInfo");
static_assert(sizeof(FHouseCameraInfo) == 0x000038, "Wrong size on FHouseCameraInfo");
static_assert(offsetof(FHouseCameraInfo, CameraArmLength) == 0x000000, "Member 'FHouseCameraInfo::CameraArmLength' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, CameraFOV) == 0x000004, "Member 'FHouseCameraInfo::CameraFOV' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, CameraArmPosition) == 0x000008, "Member 'FHouseCameraInfo::CameraArmPosition' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, CameraSocketOffsetCurve) == 0x000018, "Member 'FHouseCameraInfo::CameraSocketOffsetCurve' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, CameraSocketOffset) == 0x000020, "Member 'FHouseCameraInfo::CameraSocketOffset' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, LerpSpeed) == 0x00002C, "Member 'FHouseCameraInfo::LerpSpeed' has a wrong offset!");
static_assert(offsetof(FHouseCameraInfo, EndTime) == 0x000030, "Member 'FHouseCameraInfo::EndTime' has a wrong offset!");

// ScriptStruct Game.UpdateCollectionData
// 0x00A8 (0x00A8 - 0x0000)
struct FUpdateCollectionData final
{
public:
	class UMaterialParameterCollection*           Collection;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, EUpdateScalarType>          ScalarParameters;                                  // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, EUpdateVectorType>          VectorParameters;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdateCollectionData) == 0x000008, "Wrong alignment on FUpdateCollectionData");
static_assert(sizeof(FUpdateCollectionData) == 0x0000A8, "Wrong size on FUpdateCollectionData");
static_assert(offsetof(FUpdateCollectionData, Collection) == 0x000000, "Member 'FUpdateCollectionData::Collection' has a wrong offset!");
static_assert(offsetof(FUpdateCollectionData, ScalarParameters) == 0x000008, "Member 'FUpdateCollectionData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FUpdateCollectionData, VectorParameters) == 0x000058, "Member 'FUpdateCollectionData::VectorParameters' has a wrong offset!");

// ScriptStruct Game.ExplosiveActorTemplate
// 0x0040 (0x0048 - 0x0008)
struct FExplosiveActorTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DescUseless;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnName;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Blueprint;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplosiveActorTemplate) == 0x000008, "Wrong alignment on FExplosiveActorTemplate");
static_assert(sizeof(FExplosiveActorTemplate) == 0x000048, "Wrong size on FExplosiveActorTemplate");
static_assert(offsetof(FExplosiveActorTemplate, ID) == 0x000008, "Member 'FExplosiveActorTemplate::ID' has a wrong offset!");
static_assert(offsetof(FExplosiveActorTemplate, DescUseless) == 0x000010, "Member 'FExplosiveActorTemplate::DescUseless' has a wrong offset!");
static_assert(offsetof(FExplosiveActorTemplate, SpawnName) == 0x000020, "Member 'FExplosiveActorTemplate::SpawnName' has a wrong offset!");
static_assert(offsetof(FExplosiveActorTemplate, Blueprint) == 0x000030, "Member 'FExplosiveActorTemplate::Blueprint' has a wrong offset!");

// ScriptStruct Game.MonsterAttractInfo
// 0x000C (0x000C - 0x0000)
struct FMonsterAttractInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Mon;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMonsterAttractInfo) == 0x000004, "Wrong alignment on FMonsterAttractInfo");
static_assert(sizeof(FMonsterAttractInfo) == 0x00000C, "Wrong size on FMonsterAttractInfo");
static_assert(offsetof(FMonsterAttractInfo, Mon) == 0x000000, "Member 'FMonsterAttractInfo::Mon' has a wrong offset!");

// ScriptStruct Game.MultiMonsterEntry
// 0x0028 (0x0028 - 0x0000)
struct FMultiMonsterEntry final
{
public:
	TArray<int32>                                 Ids;                                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TaskId;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpawnEffectIds;                                    // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiMonsterEntry) == 0x000008, "Wrong alignment on FMultiMonsterEntry");
static_assert(sizeof(FMultiMonsterEntry) == 0x000028, "Wrong size on FMultiMonsterEntry");
static_assert(offsetof(FMultiMonsterEntry, Ids) == 0x000000, "Member 'FMultiMonsterEntry::Ids' has a wrong offset!");
static_assert(offsetof(FMultiMonsterEntry, TaskId) == 0x000010, "Member 'FMultiMonsterEntry::TaskId' has a wrong offset!");
static_assert(offsetof(FMultiMonsterEntry, SpawnEffectIds) == 0x000018, "Member 'FMultiMonsterEntry::SpawnEffectIds' has a wrong offset!");

// ScriptStruct Game.AimUIPositionAnimConfig
// 0x0018 (0x0018 - 0x0000)
struct FAimUIPositionAnimConfig final
{
public:
	class FString                                 UIName;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UIEndPosition;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimUIPositionAnimConfig) == 0x000008, "Wrong alignment on FAimUIPositionAnimConfig");
static_assert(sizeof(FAimUIPositionAnimConfig) == 0x000018, "Wrong size on FAimUIPositionAnimConfig");
static_assert(offsetof(FAimUIPositionAnimConfig, UIName) == 0x000000, "Member 'FAimUIPositionAnimConfig::UIName' has a wrong offset!");
static_assert(offsetof(FAimUIPositionAnimConfig, UIEndPosition) == 0x000010, "Member 'FAimUIPositionAnimConfig::UIEndPosition' has a wrong offset!");

// ScriptStruct Game.AimUIPositionAnimData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FAimUIPositionAnimData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UWidget>                 Widget;                                            // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimUIPositionAnimData) == 0x000008, "Wrong alignment on FAimUIPositionAnimData");
static_assert(sizeof(FAimUIPositionAnimData) == 0x000040, "Wrong size on FAimUIPositionAnimData");
static_assert(offsetof(FAimUIPositionAnimData, Widget) == 0x000030, "Member 'FAimUIPositionAnimData::Widget' has a wrong offset!");

// ScriptStruct Game.ActorSlomoInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FActorSlomoInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xA8];                                       // 0x0008(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSlomoInfo) == 0x000008, "Wrong alignment on FActorSlomoInfo");
static_assert(sizeof(FActorSlomoInfo) == 0x0000B0, "Wrong size on FActorSlomoInfo");
static_assert(offsetof(FActorSlomoInfo, Actor) == 0x000000, "Member 'FActorSlomoInfo::Actor' has a wrong offset!");

// ScriptStruct Game.AzimuthItem
// 0x0018 (0x0018 - 0x0000)
struct FAzimuthItem final
{
public:
	class AActor*                                 BindActor;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Widget;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUse;                                              // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFightMonsterTipsType                         Type;                                              // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAzimuthItem) == 0x000008, "Wrong alignment on FAzimuthItem");
static_assert(sizeof(FAzimuthItem) == 0x000018, "Wrong size on FAzimuthItem");
static_assert(offsetof(FAzimuthItem, BindActor) == 0x000000, "Member 'FAzimuthItem::BindActor' has a wrong offset!");
static_assert(offsetof(FAzimuthItem, Widget) == 0x000008, "Member 'FAzimuthItem::Widget' has a wrong offset!");
static_assert(offsetof(FAzimuthItem, bUse) == 0x000010, "Member 'FAzimuthItem::bUse' has a wrong offset!");
static_assert(offsetof(FAzimuthItem, Type) == 0x000011, "Member 'FAzimuthItem::Type' has a wrong offset!");

// ScriptStruct Game.Girl021BarState
// 0x000C (0x000C - 0x0000)
struct FGirl021BarState final
{
public:
	class FName                                   FullAnim;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFull;                                            // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastIsFull;                                        // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGirl021BarState) == 0x000004, "Wrong alignment on FGirl021BarState");
static_assert(sizeof(FGirl021BarState) == 0x00000C, "Wrong size on FGirl021BarState");
static_assert(offsetof(FGirl021BarState, FullAnim) == 0x000000, "Member 'FGirl021BarState::FullAnim' has a wrong offset!");
static_assert(offsetof(FGirl021BarState, IsFull) == 0x000008, "Member 'FGirl021BarState::IsFull' has a wrong offset!");
static_assert(offsetof(FGirl021BarState, LastIsFull) == 0x000009, "Member 'FGirl021BarState::LastIsFull' has a wrong offset!");

// ScriptStruct Game.SingleAccessoryUIDisplay
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FSingleAccessoryUIDisplay final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSingleAccessoryUIDisplay) == 0x000008, "Wrong alignment on FSingleAccessoryUIDisplay");
static_assert(sizeof(FSingleAccessoryUIDisplay) == 0x000088, "Wrong size on FSingleAccessoryUIDisplay");

// ScriptStruct Game.SingleStateUI
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSingleStateUI final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSingleStateUI) == 0x000008, "Wrong alignment on FSingleStateUI");
static_assert(sizeof(FSingleStateUI) == 0x000050, "Wrong size on FSingleStateUI");

// ScriptStruct Game.GameKeyboardItem
// 0x00A0 (0x00A8 - 0x0008)
struct FGameKeyboardItem final : public FTableRowBase
{
public:
	class FString                                 I18N;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionName;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionKey;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowKeyboard;                                    // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGamepad;                                     // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCombinedKey;                                 // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRepeat;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLongPress;                                   // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GamepadType;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            DefaultInputChord;                                 // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            DefaultPS4InputChord;                              // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            DefaultXBoxInputChord;                             // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameKeyboardItem) == 0x000008, "Wrong alignment on FGameKeyboardItem");
static_assert(sizeof(FGameKeyboardItem) == 0x0000A8, "Wrong size on FGameKeyboardItem");
static_assert(offsetof(FGameKeyboardItem, I18N) == 0x000008, "Member 'FGameKeyboardItem::I18N' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, ActionName) == 0x000018, "Member 'FGameKeyboardItem::ActionName' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bActionKey) == 0x000028, "Member 'FGameKeyboardItem::bActionKey' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bAllowKeyboard) == 0x000029, "Member 'FGameKeyboardItem::bAllowKeyboard' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bAllowGamepad) == 0x00002A, "Member 'FGameKeyboardItem::bAllowGamepad' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bAllowCombinedKey) == 0x00002B, "Member 'FGameKeyboardItem::bAllowCombinedKey' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bAllowRepeat) == 0x00002C, "Member 'FGameKeyboardItem::bAllowRepeat' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, bAllowLongPress) == 0x00002D, "Member 'FGameKeyboardItem::bAllowLongPress' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, GamepadType) == 0x000030, "Member 'FGameKeyboardItem::GamepadType' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, DefaultInputChord) == 0x000040, "Member 'FGameKeyboardItem::DefaultInputChord' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, DefaultPS4InputChord) == 0x000060, "Member 'FGameKeyboardItem::DefaultPS4InputChord' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, DefaultXBoxInputChord) == 0x000080, "Member 'FGameKeyboardItem::DefaultXBoxInputChord' has a wrong offset!");
static_assert(offsetof(FGameKeyboardItem, Value) == 0x0000A0, "Member 'FGameKeyboardItem::Value' has a wrong offset!");

// ScriptStruct Game.AccessoryBindUIDisplayConfig
// 0x0030 (0x0030 - 0x0000)
struct FAccessoryBindUIDisplayConfig final
{
public:
	class FName                                   BindToWidget;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterAccessory>        BindSingleAccessory;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACharacterAccessory>> BindMultipleShellAccessory;                        // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACharacterAccessory>> BindMultipleCoreAccessory;                         // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryBindUIDisplayConfig) == 0x000008, "Wrong alignment on FAccessoryBindUIDisplayConfig");
static_assert(sizeof(FAccessoryBindUIDisplayConfig) == 0x000030, "Wrong size on FAccessoryBindUIDisplayConfig");
static_assert(offsetof(FAccessoryBindUIDisplayConfig, BindToWidget) == 0x000000, "Member 'FAccessoryBindUIDisplayConfig::BindToWidget' has a wrong offset!");
static_assert(offsetof(FAccessoryBindUIDisplayConfig, BindSingleAccessory) == 0x000008, "Member 'FAccessoryBindUIDisplayConfig::BindSingleAccessory' has a wrong offset!");
static_assert(offsetof(FAccessoryBindUIDisplayConfig, BindMultipleShellAccessory) == 0x000010, "Member 'FAccessoryBindUIDisplayConfig::BindMultipleShellAccessory' has a wrong offset!");
static_assert(offsetof(FAccessoryBindUIDisplayConfig, BindMultipleCoreAccessory) == 0x000020, "Member 'FAccessoryBindUIDisplayConfig::BindMultipleCoreAccessory' has a wrong offset!");

// ScriptStruct Game.FishingAnimInfo
// 0x0030 (0x0030 - 0x0000)
struct FFishingAnimInfo final
{
public:
	TSubclassOf<class UAnimInstance>              AnimLinkLayerClass;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFishingAnimData>        FishingAnimDataRef;                                // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishingAnimInfo) == 0x000008, "Wrong alignment on FFishingAnimInfo");
static_assert(sizeof(FFishingAnimInfo) == 0x000030, "Wrong size on FFishingAnimInfo");
static_assert(offsetof(FFishingAnimInfo, AnimLinkLayerClass) == 0x000000, "Member 'FFishingAnimInfo::AnimLinkLayerClass' has a wrong offset!");
static_assert(offsetof(FFishingAnimInfo, FishingAnimDataRef) == 0x000008, "Member 'FFishingAnimInfo::FishingAnimDataRef' has a wrong offset!");

// ScriptStruct Game.GraphicsWorldTypeSettingRow
// 0x0018 (0x0020 - 0x0008)
struct FGraphicsWorldTypeSettingRow final : public FTableRowBase
{
public:
	EGraphicsSpecialSettingType                   WorldType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapType;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         WorldNames;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraphicsWorldTypeSettingRow) == 0x000008, "Wrong alignment on FGraphicsWorldTypeSettingRow");
static_assert(sizeof(FGraphicsWorldTypeSettingRow) == 0x000020, "Wrong size on FGraphicsWorldTypeSettingRow");
static_assert(offsetof(FGraphicsWorldTypeSettingRow, WorldType) == 0x000008, "Member 'FGraphicsWorldTypeSettingRow::WorldType' has a wrong offset!");
static_assert(offsetof(FGraphicsWorldTypeSettingRow, MapType) == 0x00000C, "Member 'FGraphicsWorldTypeSettingRow::MapType' has a wrong offset!");
static_assert(offsetof(FGraphicsWorldTypeSettingRow, WorldNames) == 0x000010, "Member 'FGraphicsWorldTypeSettingRow::WorldNames' has a wrong offset!");

// ScriptStruct Game.FogConfig1st
// 0x0024 (0x0024 - 0x0000)
struct FFogConfig1st final
{
public:
	struct FLinearColor                           FogColor1st;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogDesity1st;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFallOff1st;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity1st;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance1st;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomHeight1st;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFogConfig1st) == 0x000004, "Wrong alignment on FFogConfig1st");
static_assert(sizeof(FFogConfig1st) == 0x000024, "Wrong size on FFogConfig1st");
static_assert(offsetof(FFogConfig1st, FogColor1st) == 0x000000, "Member 'FFogConfig1st::FogColor1st' has a wrong offset!");
static_assert(offsetof(FFogConfig1st, FogDesity1st) == 0x000010, "Member 'FFogConfig1st::FogDesity1st' has a wrong offset!");
static_assert(offsetof(FFogConfig1st, FogHeightFallOff1st) == 0x000014, "Member 'FFogConfig1st::FogHeightFallOff1st' has a wrong offset!");
static_assert(offsetof(FFogConfig1st, FogMaxOpacity1st) == 0x000018, "Member 'FFogConfig1st::FogMaxOpacity1st' has a wrong offset!");
static_assert(offsetof(FFogConfig1st, StartDistance1st) == 0x00001C, "Member 'FFogConfig1st::StartDistance1st' has a wrong offset!");
static_assert(offsetof(FFogConfig1st, CustomHeight1st) == 0x000020, "Member 'FFogConfig1st::CustomHeight1st' has a wrong offset!");

// ScriptStruct Game.AllAttributeSettings
// 0x0028 (0x0030 - 0x0008)
struct FAllAttributeSettings final : public FTableRowBase
{
public:
	class FString                                 AttriubteName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AttriubtePath;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAllAttributeSettings) == 0x000008, "Wrong alignment on FAllAttributeSettings");
static_assert(sizeof(FAllAttributeSettings) == 0x000030, "Wrong size on FAllAttributeSettings");
static_assert(offsetof(FAllAttributeSettings, AttriubteName) == 0x000008, "Member 'FAllAttributeSettings::AttriubteName' has a wrong offset!");
static_assert(offsetof(FAllAttributeSettings, AttriubtePath) == 0x000018, "Member 'FAllAttributeSettings::AttriubtePath' has a wrong offset!");

// ScriptStruct Game.SourceAbilityAttribute
// 0x0010 (0x0010 - 0x0000)
struct FSourceAbilityAttribute final
{
public:
	EAbilityType                                  AbilityType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityAttribute*                      AbilityAttribute;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSourceAbilityAttribute) == 0x000008, "Wrong alignment on FSourceAbilityAttribute");
static_assert(sizeof(FSourceAbilityAttribute) == 0x000010, "Wrong size on FSourceAbilityAttribute");
static_assert(offsetof(FSourceAbilityAttribute, AbilityType) == 0x000000, "Member 'FSourceAbilityAttribute::AbilityType' has a wrong offset!");
static_assert(offsetof(FSourceAbilityAttribute, AbilityAttribute) == 0x000008, "Member 'FSourceAbilityAttribute::AbilityAttribute' has a wrong offset!");

// ScriptStruct Game.ITS_DelayInfo
// 0x0218 (0x0218 - 0x0000)
struct FITS_DelayInfo final
{
public:
	class UAbilityComponentBase*                  LpLauncher;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAbilityComponentBase*>          Targets;                                           // 0x0008(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInjuryTransmission;                               // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPreDamageResultData                   PreResultData;                                     // 0x0028(0x01E0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0208(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScaleCount;                                        // 0x020C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0210(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FITS_DelayInfo) == 0x000008, "Wrong alignment on FITS_DelayInfo");
static_assert(sizeof(FITS_DelayInfo) == 0x000218, "Wrong size on FITS_DelayInfo");
static_assert(offsetof(FITS_DelayInfo, LpLauncher) == 0x000000, "Member 'FITS_DelayInfo::LpLauncher' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, Targets) == 0x000008, "Member 'FITS_DelayInfo::Targets' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, EmitterID) == 0x000018, "Member 'FITS_DelayInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, Scale) == 0x00001C, "Member 'FITS_DelayInfo::Scale' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, bInjuryTransmission) == 0x000020, "Member 'FITS_DelayInfo::bInjuryTransmission' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, PreResultData) == 0x000028, "Member 'FITS_DelayInfo::PreResultData' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, DelayTime) == 0x000208, "Member 'FITS_DelayInfo::DelayTime' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, ScaleCount) == 0x00020C, "Member 'FITS_DelayInfo::ScaleCount' has a wrong offset!");
static_assert(offsetof(FITS_DelayInfo, StartTime) == 0x000210, "Member 'FITS_DelayInfo::StartTime' has a wrong offset!");

// ScriptStruct Game.DeriveSkillIDs
// 0x0010 (0x0010 - 0x0000)
struct FDeriveSkillIDs final
{
public:
	TArray<int32>                                 DeriveSkillIDs;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeriveSkillIDs) == 0x000008, "Wrong alignment on FDeriveSkillIDs");
static_assert(sizeof(FDeriveSkillIDs) == 0x000010, "Wrong size on FDeriveSkillIDs");
static_assert(offsetof(FDeriveSkillIDs, DeriveSkillIDs) == 0x000000, "Member 'FDeriveSkillIDs::DeriveSkillIDs' has a wrong offset!");

// ScriptStruct Game.HitReactPerformanceData
// 0x0098 (0x0098 - 0x0000)
struct FHitReactPerformanceData final
{
public:
	TMap<EHitDirectionType, struct FHitReactSectionInfo> HitReactAnimContainer;                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 ExcludBoneContainer;                               // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSeasunInputBlendPose                  CustomLayerSetup;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         HitReactionCoolDownTime;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionDuration;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaScale;                                        // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x008C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactPerformanceData) == 0x000008, "Wrong alignment on FHitReactPerformanceData");
static_assert(sizeof(FHitReactPerformanceData) == 0x000098, "Wrong size on FHitReactPerformanceData");
static_assert(offsetof(FHitReactPerformanceData, HitReactAnimContainer) == 0x000000, "Member 'FHitReactPerformanceData::HitReactAnimContainer' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, ExcludBoneContainer) == 0x000050, "Member 'FHitReactPerformanceData::ExcludBoneContainer' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, CustomLayerSetup) == 0x000060, "Member 'FHitReactPerformanceData::CustomLayerSetup' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, HitReactionCoolDownTime) == 0x000070, "Member 'FHitReactPerformanceData::HitReactionCoolDownTime' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, HitReactionDuration) == 0x000074, "Member 'FHitReactPerformanceData::HitReactionDuration' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, BlendInTime) == 0x000078, "Member 'FHitReactPerformanceData::BlendInTime' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, BlendOutTime) == 0x00007C, "Member 'FHitReactPerformanceData::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, PlayRate) == 0x000080, "Member 'FHitReactPerformanceData::PlayRate' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, AlphaScale) == 0x000084, "Member 'FHitReactPerformanceData::AlphaScale' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, BlendWeight) == 0x000088, "Member 'FHitReactPerformanceData::BlendWeight' has a wrong offset!");
static_assert(offsetof(FHitReactPerformanceData, SlotName) == 0x00008C, "Member 'FHitReactPerformanceData::SlotName' has a wrong offset!");

// ScriptStruct Game.MontageSectionInfo
// 0x0004 (0x0004 - 0x0000)
struct FMontageSectionInfo final
{
public:
	float                                         SectionRealLength;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMontageSectionInfo) == 0x000004, "Wrong alignment on FMontageSectionInfo");
static_assert(sizeof(FMontageSectionInfo) == 0x000004, "Wrong size on FMontageSectionInfo");
static_assert(offsetof(FMontageSectionInfo, SectionRealLength) == 0x000000, "Member 'FMontageSectionInfo::SectionRealLength' has a wrong offset!");

// ScriptStruct Game.CurveDataCoolDownRuntimeData
// 0x0014 (0x0014 - 0x0000)
struct FCurveDataCoolDownRuntimeData final
{
public:
	bool                                          bPhysicalRecoilValid_Hair;                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhysicalRecoilValid_Cloth;                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhysicalRecoilValid_Hat;                          // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponRecoilValid;                                // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRecoilEvaluateTime;                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalRecoilEvaluateTime_Hair;                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalRecoilEvaluateTime_Cloth;                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalRecoilEvaluateTime_Hat;                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveDataCoolDownRuntimeData) == 0x000004, "Wrong alignment on FCurveDataCoolDownRuntimeData");
static_assert(sizeof(FCurveDataCoolDownRuntimeData) == 0x000014, "Wrong size on FCurveDataCoolDownRuntimeData");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, bPhysicalRecoilValid_Hair) == 0x000000, "Member 'FCurveDataCoolDownRuntimeData::bPhysicalRecoilValid_Hair' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, bPhysicalRecoilValid_Cloth) == 0x000001, "Member 'FCurveDataCoolDownRuntimeData::bPhysicalRecoilValid_Cloth' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, bPhysicalRecoilValid_Hat) == 0x000002, "Member 'FCurveDataCoolDownRuntimeData::bPhysicalRecoilValid_Hat' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, bWeaponRecoilValid) == 0x000003, "Member 'FCurveDataCoolDownRuntimeData::bWeaponRecoilValid' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, WeaponRecoilEvaluateTime) == 0x000004, "Member 'FCurveDataCoolDownRuntimeData::WeaponRecoilEvaluateTime' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, PhysicalRecoilEvaluateTime_Hair) == 0x000008, "Member 'FCurveDataCoolDownRuntimeData::PhysicalRecoilEvaluateTime_Hair' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, PhysicalRecoilEvaluateTime_Cloth) == 0x00000C, "Member 'FCurveDataCoolDownRuntimeData::PhysicalRecoilEvaluateTime_Cloth' has a wrong offset!");
static_assert(offsetof(FCurveDataCoolDownRuntimeData, PhysicalRecoilEvaluateTime_Hat) == 0x000010, "Member 'FCurveDataCoolDownRuntimeData::PhysicalRecoilEvaluateTime_Hat' has a wrong offset!");

// ScriptStruct Game.FinishAnimConfig
// 0x0018 (0x0020 - 0x0008)
struct FFinishAnimConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFinishAnimInfo>                FinishAnimContainer;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFinishAnimConfig) == 0x000008, "Wrong alignment on FFinishAnimConfig");
static_assert(sizeof(FFinishAnimConfig) == 0x000020, "Wrong size on FFinishAnimConfig");
static_assert(offsetof(FFinishAnimConfig, ID) == 0x000008, "Member 'FFinishAnimConfig::ID' has a wrong offset!");
static_assert(offsetof(FFinishAnimConfig, FinishAnimContainer) == 0x000010, "Member 'FFinishAnimConfig::FinishAnimContainer' has a wrong offset!");

// ScriptStruct Game.AnimNameMapping
// 0x0038 (0x0040 - 0x0008)
struct FAnimNameMapping final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimResName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EUIWidgetAnimType>                     WidgetContainer;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponSubType;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimResType                                  AnimResType;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNameMapping) == 0x000008, "Wrong alignment on FAnimNameMapping");
static_assert(sizeof(FAnimNameMapping) == 0x000040, "Wrong size on FAnimNameMapping");
static_assert(offsetof(FAnimNameMapping, VariableName) == 0x000008, "Member 'FAnimNameMapping::VariableName' has a wrong offset!");
static_assert(offsetof(FAnimNameMapping, AnimResName) == 0x000018, "Member 'FAnimNameMapping::AnimResName' has a wrong offset!");
static_assert(offsetof(FAnimNameMapping, WidgetContainer) == 0x000028, "Member 'FAnimNameMapping::WidgetContainer' has a wrong offset!");
static_assert(offsetof(FAnimNameMapping, bUseWeaponSubType) == 0x000038, "Member 'FAnimNameMapping::bUseWeaponSubType' has a wrong offset!");
static_assert(offsetof(FAnimNameMapping, AnimResType) == 0x000039, "Member 'FAnimNameMapping::AnimResType' has a wrong offset!");

// ScriptStruct Game.AnimationStateNode
// 0x000C (0x000C - 0x0000)
struct FAnimationStateNode final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossfadeDuration;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationStateNode) == 0x000004, "Wrong alignment on FAnimationStateNode");
static_assert(sizeof(FAnimationStateNode) == 0x00000C, "Wrong size on FAnimationStateNode");
static_assert(offsetof(FAnimationStateNode, StateName) == 0x000000, "Member 'FAnimationStateNode::StateName' has a wrong offset!");
static_assert(offsetof(FAnimationStateNode, CrossfadeDuration) == 0x000008, "Member 'FAnimationStateNode::CrossfadeDuration' has a wrong offset!");

// ScriptStruct Game.BattleInfo
// 0x0020 (0x0028 - 0x0008)
struct FBattleInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReviveCount;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoReviveTime;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoReviveHealthScale;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitPlayerTime;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitReconnectTime;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitCloseDSTime;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleInfo) == 0x000008, "Wrong alignment on FBattleInfo");
static_assert(sizeof(FBattleInfo) == 0x000028, "Wrong size on FBattleInfo");
static_assert(offsetof(FBattleInfo, ID) == 0x000008, "Member 'FBattleInfo::ID' has a wrong offset!");
static_assert(offsetof(FBattleInfo, ReviveCount) == 0x00000C, "Member 'FBattleInfo::ReviveCount' has a wrong offset!");
static_assert(offsetof(FBattleInfo, AutoReviveTime) == 0x000010, "Member 'FBattleInfo::AutoReviveTime' has a wrong offset!");
static_assert(offsetof(FBattleInfo, AutoReviveHealthScale) == 0x000014, "Member 'FBattleInfo::AutoReviveHealthScale' has a wrong offset!");
static_assert(offsetof(FBattleInfo, WaitPlayerTime) == 0x000018, "Member 'FBattleInfo::WaitPlayerTime' has a wrong offset!");
static_assert(offsetof(FBattleInfo, WaitReconnectTime) == 0x00001C, "Member 'FBattleInfo::WaitReconnectTime' has a wrong offset!");
static_assert(offsetof(FBattleInfo, WaitCloseDSTime) == 0x000020, "Member 'FBattleInfo::WaitCloseDSTime' has a wrong offset!");

// ScriptStruct Game.CameraShakeGroup
// 0x0010 (0x0010 - 0x0000)
struct FCameraShakeGroup final
{
public:
	TArray<struct FCameraShakeData>               ShakeDatas;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraShakeGroup) == 0x000008, "Wrong alignment on FCameraShakeGroup");
static_assert(sizeof(FCameraShakeGroup) == 0x000010, "Wrong size on FCameraShakeGroup");
static_assert(offsetof(FCameraShakeGroup, ShakeDatas) == 0x000000, "Member 'FCameraShakeGroup::ShakeDatas' has a wrong offset!");

// ScriptStruct Game.CharacterAnimLoadInfo
// 0x0020 (0x0028 - 0x0008)
struct FCharacterAnimLoadInfo final : public FTableRowBase
{
public:
	class FString                                 VariableName;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResPath;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimLoadInfo) == 0x000008, "Wrong alignment on FCharacterAnimLoadInfo");
static_assert(sizeof(FCharacterAnimLoadInfo) == 0x000028, "Wrong size on FCharacterAnimLoadInfo");
static_assert(offsetof(FCharacterAnimLoadInfo, VariableName) == 0x000008, "Member 'FCharacterAnimLoadInfo::VariableName' has a wrong offset!");
static_assert(offsetof(FCharacterAnimLoadInfo, ResPath) == 0x000018, "Member 'FCharacterAnimLoadInfo::ResPath' has a wrong offset!");

// ScriptStruct Game.CharacterPool
// 0x0010 (0x0010 - 0x0000)
struct FCharacterPool final
{
public:
	TArray<class AGameCharacter*>                 List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPool) == 0x000008, "Wrong alignment on FCharacterPool");
static_assert(sizeof(FCharacterPool) == 0x000010, "Wrong size on FCharacterPool");
static_assert(offsetof(FCharacterPool, List) == 0x000000, "Member 'FCharacterPool::List' has a wrong offset!");

// ScriptStruct Game.GameInteractorData
// 0x0010 (0x0010 - 0x0000)
struct FGameInteractorData final
{
public:
	EGameInteractorState                          State;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGamePlayerController*                  WhoInteract;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameInteractorData) == 0x000008, "Wrong alignment on FGameInteractorData");
static_assert(sizeof(FGameInteractorData) == 0x000010, "Wrong size on FGameInteractorData");
static_assert(offsetof(FGameInteractorData, State) == 0x000000, "Member 'FGameInteractorData::State' has a wrong offset!");
static_assert(offsetof(FGameInteractorData, WhoInteract) == 0x000008, "Member 'FGameInteractorData::WhoInteract' has a wrong offset!");

// ScriptStruct Game.IbItemInfo
// 0x0088 (0x0088 - 0x0000)
struct FIbItemInfo final
{
public:
	class FString                                 ProductID;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductName;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductDesc;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Currency;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomInfo;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameTradeNum;                                      // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CallbackUrl;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AddParams;                                         // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIbItemInfo) == 0x000008, "Wrong alignment on FIbItemInfo");
static_assert(sizeof(FIbItemInfo) == 0x000088, "Wrong size on FIbItemInfo");
static_assert(offsetof(FIbItemInfo, ProductID) == 0x000000, "Member 'FIbItemInfo::ProductID' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, ProductName) == 0x000010, "Member 'FIbItemInfo::ProductName' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, ProductDesc) == 0x000020, "Member 'FIbItemInfo::ProductDesc' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, Price) == 0x000030, "Member 'FIbItemInfo::Price' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, Currency) == 0x000038, "Member 'FIbItemInfo::Currency' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, CustomInfo) == 0x000048, "Member 'FIbItemInfo::CustomInfo' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, GameTradeNum) == 0x000058, "Member 'FIbItemInfo::GameTradeNum' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, CallbackUrl) == 0x000068, "Member 'FIbItemInfo::CallbackUrl' has a wrong offset!");
static_assert(offsetof(FIbItemInfo, AddParams) == 0x000078, "Member 'FIbItemInfo::AddParams' has a wrong offset!");

// ScriptStruct Game.LoginParam
// 0x0038 (0x0038 - 0x0000)
struct FLoginParam final
{
public:
	class FString                                 Provider;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoginErrorCode;                                    // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoginErrorMsg;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginParam) == 0x000008, "Wrong alignment on FLoginParam");
static_assert(sizeof(FLoginParam) == 0x000038, "Wrong size on FLoginParam");
static_assert(offsetof(FLoginParam, Provider) == 0x000000, "Member 'FLoginParam::Provider' has a wrong offset!");
static_assert(offsetof(FLoginParam, Token) == 0x000010, "Member 'FLoginParam::Token' has a wrong offset!");
static_assert(offsetof(FLoginParam, LoginErrorCode) == 0x000020, "Member 'FLoginParam::LoginErrorCode' has a wrong offset!");
static_assert(offsetof(FLoginParam, LoginErrorMsg) == 0x000028, "Member 'FLoginParam::LoginErrorMsg' has a wrong offset!");

// ScriptStruct Game.OnDamageParameters
// 0x00D0 (0x00D0 - 0x0000)
struct FOnDamageParameters final
{
public:
	class AGameCharacter*                         Launcher;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameCharacter*                         Target;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FApplyDamageResultData                 DamageResult;                                      // 0x0010(0x00C0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnDamageParameters) == 0x000008, "Wrong alignment on FOnDamageParameters");
static_assert(sizeof(FOnDamageParameters) == 0x0000D0, "Wrong size on FOnDamageParameters");
static_assert(offsetof(FOnDamageParameters, Launcher) == 0x000000, "Member 'FOnDamageParameters::Launcher' has a wrong offset!");
static_assert(offsetof(FOnDamageParameters, Target) == 0x000008, "Member 'FOnDamageParameters::Target' has a wrong offset!");
static_assert(offsetof(FOnDamageParameters, DamageResult) == 0x000010, "Member 'FOnDamageParameters::DamageResult' has a wrong offset!");

// ScriptStruct Game.GamepadQuickInfo
// 0x0020 (0x0068 - 0x0048)
struct FGamepadQuickInfo final : public FGamepadQuickKeyInfo
{
public:
	class FString                                 RelationName;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Describe;                                          // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadQuickInfo) == 0x000008, "Wrong alignment on FGamepadQuickInfo");
static_assert(sizeof(FGamepadQuickInfo) == 0x000068, "Wrong size on FGamepadQuickInfo");
static_assert(offsetof(FGamepadQuickInfo, RelationName) == 0x000048, "Member 'FGamepadQuickInfo::RelationName' has a wrong offset!");
static_assert(offsetof(FGamepadQuickInfo, Describe) == 0x000058, "Member 'FGamepadQuickInfo::Describe' has a wrong offset!");

// ScriptStruct Game.SkinReplaceInfo
// 0x0050 (0x0058 - 0x0008)
struct FSkinReplaceInfo final : public FTableRowBase
{
public:
	int32                                         G;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         D;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P;                                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         L;                                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GirlName;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GirlName_Skin;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UMG_GirlName;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UMG_GirlName_Skin;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinReplaceInfo) == 0x000008, "Wrong alignment on FSkinReplaceInfo");
static_assert(sizeof(FSkinReplaceInfo) == 0x000058, "Wrong size on FSkinReplaceInfo");
static_assert(offsetof(FSkinReplaceInfo, G) == 0x000008, "Member 'FSkinReplaceInfo::G' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, D) == 0x00000C, "Member 'FSkinReplaceInfo::D' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, P) == 0x000010, "Member 'FSkinReplaceInfo::P' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, L) == 0x000014, "Member 'FSkinReplaceInfo::L' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, GirlName) == 0x000018, "Member 'FSkinReplaceInfo::GirlName' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, GirlName_Skin) == 0x000028, "Member 'FSkinReplaceInfo::GirlName_Skin' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, UMG_GirlName) == 0x000038, "Member 'FSkinReplaceInfo::UMG_GirlName' has a wrong offset!");
static_assert(offsetof(FSkinReplaceInfo, UMG_GirlName_Skin) == 0x000048, "Member 'FSkinReplaceInfo::UMG_GirlName_Skin' has a wrong offset!");

// ScriptStruct Game.GamePhysicsControlData
// 0x0080 (0x0080 - 0x0000)
struct FGamePhysicsControlData final
{
public:
	struct FPhysicsControlData                    WorldSpaceControlData;                             // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                WorldSpaceControlSettings;                         // 0x0020(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldSpaceControls;                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicsControlData                    ParentSpaceControlData;                            // 0x003C(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                ParentSpaceControlSettings;                        // 0x005C(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableParentSpaceControls;                        // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsMovementType                          PhysicsMovementType;                               // 0x0075(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityMultiplier;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamePhysicsControlData) == 0x000004, "Wrong alignment on FGamePhysicsControlData");
static_assert(sizeof(FGamePhysicsControlData) == 0x000080, "Wrong size on FGamePhysicsControlData");
static_assert(offsetof(FGamePhysicsControlData, WorldSpaceControlData) == 0x000000, "Member 'FGamePhysicsControlData::WorldSpaceControlData' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, WorldSpaceControlSettings) == 0x000020, "Member 'FGamePhysicsControlData::WorldSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, bEnableWorldSpaceControls) == 0x000038, "Member 'FGamePhysicsControlData::bEnableWorldSpaceControls' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, ParentSpaceControlData) == 0x00003C, "Member 'FGamePhysicsControlData::ParentSpaceControlData' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, ParentSpaceControlSettings) == 0x00005C, "Member 'FGamePhysicsControlData::ParentSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, bEnableParentSpaceControls) == 0x000074, "Member 'FGamePhysicsControlData::bEnableParentSpaceControls' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, PhysicsMovementType) == 0x000075, "Member 'FGamePhysicsControlData::PhysicsMovementType' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, GravityMultiplier) == 0x000078, "Member 'FGamePhysicsControlData::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(FGamePhysicsControlData, PhysicsBlendWeight) == 0x00007C, "Member 'FGamePhysicsControlData::PhysicsBlendWeight' has a wrong offset!");

// ScriptStruct Game.StepTriggerRunTimeData
// 0x01A0 (0x01A0 - 0x0000)
struct alignas(0x10) FStepTriggerRunTimeData final
{
public:
	class UWwiseComponent*                        AudioPlayer;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x198];                                      // 0x0008(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStepTriggerRunTimeData) == 0x000010, "Wrong alignment on FStepTriggerRunTimeData");
static_assert(sizeof(FStepTriggerRunTimeData) == 0x0001A0, "Wrong size on FStepTriggerRunTimeData");
static_assert(offsetof(FStepTriggerRunTimeData, AudioPlayer) == 0x000000, "Member 'FStepTriggerRunTimeData::AudioPlayer' has a wrong offset!");

// ScriptStruct Game.PlayerHpVoiceInfo
// 0x0018 (0x0018 - 0x0000)
struct FPlayerHpVoiceInfo final
{
public:
	float                                         HPPercent;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHpVoiceInfo) == 0x000008, "Wrong alignment on FPlayerHpVoiceInfo");
static_assert(sizeof(FPlayerHpVoiceInfo) == 0x000018, "Wrong size on FPlayerHpVoiceInfo");
static_assert(offsetof(FPlayerHpVoiceInfo, HPPercent) == 0x000000, "Member 'FPlayerHpVoiceInfo::HPPercent' has a wrong offset!");
static_assert(offsetof(FPlayerHpVoiceInfo, VoiceID) == 0x000008, "Member 'FPlayerHpVoiceInfo::VoiceID' has a wrong offset!");

// ScriptStruct Game.CameraOffset
// 0x001C (0x001C - 0x0000)
struct FCameraOffset final
{
public:
	struct FVector                                CameraSocketOffset;                                // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMinAdditive;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMaxAdditive;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraOffset) == 0x000004, "Wrong alignment on FCameraOffset");
static_assert(sizeof(FCameraOffset) == 0x00001C, "Wrong size on FCameraOffset");
static_assert(offsetof(FCameraOffset, CameraSocketOffset) == 0x000000, "Member 'FCameraOffset::CameraSocketOffset' has a wrong offset!");
static_assert(offsetof(FCameraOffset, CameraFOV) == 0x00000C, "Member 'FCameraOffset::CameraFOV' has a wrong offset!");
static_assert(offsetof(FCameraOffset, LerpSpeed) == 0x000010, "Member 'FCameraOffset::LerpSpeed' has a wrong offset!");
static_assert(offsetof(FCameraOffset, ViewPitchMinAdditive) == 0x000014, "Member 'FCameraOffset::ViewPitchMinAdditive' has a wrong offset!");
static_assert(offsetof(FCameraOffset, ViewPitchMaxAdditive) == 0x000018, "Member 'FCameraOffset::ViewPitchMaxAdditive' has a wrong offset!");

// ScriptStruct Game.HitBlurInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FHitBlurInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitBlurInfo) == 0x000004, "Wrong alignment on FHitBlurInfo");
static_assert(sizeof(FHitBlurInfo) == 0x00001C, "Wrong size on FHitBlurInfo");

// ScriptStruct Game.MixFireHandle
// 0x0008 (0x0008 - 0x0000)
struct FMixFireHandle final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExciteActionType                             ActionType;                                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMixFireHandle) == 0x000004, "Wrong alignment on FMixFireHandle");
static_assert(sizeof(FMixFireHandle) == 0x000008, "Wrong size on FMixFireHandle");
static_assert(offsetof(FMixFireHandle, Valid) == 0x000000, "Member 'FMixFireHandle::Valid' has a wrong offset!");
static_assert(offsetof(FMixFireHandle, ActionType) == 0x000001, "Member 'FMixFireHandle::ActionType' has a wrong offset!");
static_assert(offsetof(FMixFireHandle, Delay) == 0x000004, "Member 'FMixFireHandle::Delay' has a wrong offset!");

// ScriptStruct Game.SkillEffectState
// 0x0010 (0x0010 - 0x0000)
struct FSkillEffectState final
{
public:
	class USkillEffectComponent*                  SkillEffect;                                       // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillEffectState                             SkillEffectState;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillEffectState) == 0x000008, "Wrong alignment on FSkillEffectState");
static_assert(sizeof(FSkillEffectState) == 0x000010, "Wrong size on FSkillEffectState");
static_assert(offsetof(FSkillEffectState, SkillEffect) == 0x000000, "Member 'FSkillEffectState::SkillEffect' has a wrong offset!");
static_assert(offsetof(FSkillEffectState, SkillEffectState) == 0x000008, "Member 'FSkillEffectState::SkillEffectState' has a wrong offset!");

// ScriptStruct Game.WwisePathReplace
// 0x0060 (0x0068 - 0x0008)
struct FWwisePathReplace final : public FTableRowBase
{
public:
	class FString                                 Path;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, class FString>                    Paths;                                             // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWwisePathReplace) == 0x000008, "Wrong alignment on FWwisePathReplace");
static_assert(sizeof(FWwisePathReplace) == 0x000068, "Wrong size on FWwisePathReplace");
static_assert(offsetof(FWwisePathReplace, Path) == 0x000008, "Member 'FWwisePathReplace::Path' has a wrong offset!");
static_assert(offsetof(FWwisePathReplace, Paths) == 0x000018, "Member 'FWwisePathReplace::Paths' has a wrong offset!");

// ScriptStruct Game.HouseCameraConfig_lua
// 0x00A8 (0x00A8 - 0x0000)
struct FHouseCameraConfig_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionAnimID;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionAnimName;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ActionAnim;                                        // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PoseAnimName;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           PoseAnim;                                          // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          CameraAnimRes;                                     // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseCameraConfig_lua) == 0x000008, "Wrong alignment on FHouseCameraConfig_lua");
static_assert(sizeof(FHouseCameraConfig_lua) == 0x0000A8, "Wrong size on FHouseCameraConfig_lua");
static_assert(offsetof(FHouseCameraConfig_lua, ID) == 0x000000, "Member 'FHouseCameraConfig_lua::ID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, SkinID) == 0x000004, "Member 'FHouseCameraConfig_lua::SkinID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, ActionAnimID) == 0x000008, "Member 'FHouseCameraConfig_lua::ActionAnimID' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, ActionAnimName) == 0x000010, "Member 'FHouseCameraConfig_lua::ActionAnimName' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, ActionAnim) == 0x000020, "Member 'FHouseCameraConfig_lua::ActionAnim' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, PoseAnimName) == 0x000048, "Member 'FHouseCameraConfig_lua::PoseAnimName' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, PoseAnim) == 0x000058, "Member 'FHouseCameraConfig_lua::PoseAnim' has a wrong offset!");
static_assert(offsetof(FHouseCameraConfig_lua, CameraAnimRes) == 0x000080, "Member 'FHouseCameraConfig_lua::CameraAnimRes' has a wrong offset!");

// ScriptStruct Game.HouseCharacterTemplate
// 0x0198 (0x01A0 - 0x0008)
struct FHouseCharacterTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GirlId;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FHouseCharacterSuitInfo>   SuitMap;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories_Rep2;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories_Rep3;                                  // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories_Rep4;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 Accessories_Rep5;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FSoftObjectPath>           PlayerRingMap;                                     // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BaseRotationSpeed;                                 // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResName;                                           // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpineName;                                         // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOnMap;                                         // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBornOnOpen;                                       // 0x0159(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x2];                                      // 0x015A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedBornArea;                                     // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTree;                                      // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         IdleMontages;                                      // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseNeckBlendSpace;                                 // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHouseCharacterTemplate) == 0x000008, "Wrong alignment on FHouseCharacterTemplate");
static_assert(sizeof(FHouseCharacterTemplate) == 0x0001A0, "Wrong size on FHouseCharacterTemplate");
static_assert(offsetof(FHouseCharacterTemplate, ID) == 0x000008, "Member 'FHouseCharacterTemplate::ID' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Blueprint) == 0x000010, "Member 'FHouseCharacterTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, GirlId) == 0x000028, "Member 'FHouseCharacterTemplate::GirlId' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, SuitMap) == 0x000030, "Member 'FHouseCharacterTemplate::SuitMap' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Accessories) == 0x000080, "Member 'FHouseCharacterTemplate::Accessories' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Accessories_Rep2) == 0x000090, "Member 'FHouseCharacterTemplate::Accessories_Rep2' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Accessories_Rep3) == 0x0000A0, "Member 'FHouseCharacterTemplate::Accessories_Rep3' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Accessories_Rep4) == 0x0000B0, "Member 'FHouseCharacterTemplate::Accessories_Rep4' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, Accessories_Rep5) == 0x0000C0, "Member 'FHouseCharacterTemplate::Accessories_Rep5' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, PlayerRingMap) == 0x0000D0, "Member 'FHouseCharacterTemplate::PlayerRingMap' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, BaseRotationSpeed) == 0x000120, "Member 'FHouseCharacterTemplate::BaseRotationSpeed' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, ResName) == 0x000128, "Member 'FHouseCharacterTemplate::ResName' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, SpineName) == 0x000138, "Member 'FHouseCharacterTemplate::SpineName' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, IconPath) == 0x000148, "Member 'FHouseCharacterTemplate::IconPath' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, ShowOnMap) == 0x000158, "Member 'FHouseCharacterTemplate::ShowOnMap' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, bBornOnOpen) == 0x000159, "Member 'FHouseCharacterTemplate::bBornOnOpen' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, FixedBornArea) == 0x00015C, "Member 'FHouseCharacterTemplate::FixedBornArea' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, BehaviorTree) == 0x000160, "Member 'FHouseCharacterTemplate::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, IdleMontages) == 0x000188, "Member 'FHouseCharacterTemplate::IdleMontages' has a wrong offset!");
static_assert(offsetof(FHouseCharacterTemplate, UseNeckBlendSpace) == 0x000198, "Member 'FHouseCharacterTemplate::UseNeckBlendSpace' has a wrong offset!");

// ScriptStruct Game.HouseFurSafeFixInfo
// 0x0050 (0x0050 - 0x0000)
struct FHouseFurSafeFixInfo final
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMeshToReplace;                               // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMeshToReplace;                             // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseFurSafeFixInfo) == 0x000008, "Wrong alignment on FHouseFurSafeFixInfo");
static_assert(sizeof(FHouseFurSafeFixInfo) == 0x000050, "Wrong size on FHouseFurSafeFixInfo");
static_assert(offsetof(FHouseFurSafeFixInfo, StaticMeshToReplace) == 0x000000, "Member 'FHouseFurSafeFixInfo::StaticMeshToReplace' has a wrong offset!");
static_assert(offsetof(FHouseFurSafeFixInfo, SkeletalMeshToReplace) == 0x000028, "Member 'FHouseFurSafeFixInfo::SkeletalMeshToReplace' has a wrong offset!");

// ScriptStruct Game.HouseFurnitureTemplate
// 0x00E0 (0x00E8 - 0x0008)
struct FHouseFurnitureTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InteractMontageName;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CpInteractMontageName;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 IgnoreNpcIdList;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllowedNpcIdList;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SubAllowedNpcIdList;                               // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NpcIdList_MultiCp;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          FaceToPlayerOnInteract;                            // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FVector>                   NpcInteractOffset;                                 // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          OpenKawaiiWhenInteractByNpc;                       // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockCollisionAndGravityWhenInteractByNpc;         // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowHiddenAtPhoto;                                // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetAccRep;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseFurnitureTemplate) == 0x000008, "Wrong alignment on FHouseFurnitureTemplate");
static_assert(sizeof(FHouseFurnitureTemplate) == 0x0000E8, "Wrong size on FHouseFurnitureTemplate");
static_assert(offsetof(FHouseFurnitureTemplate, ID) == 0x000008, "Member 'FHouseFurnitureTemplate::ID' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, Blueprint) == 0x000010, "Member 'FHouseFurnitureTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, InteractMontageName) == 0x000028, "Member 'FHouseFurnitureTemplate::InteractMontageName' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, CpInteractMontageName) == 0x000038, "Member 'FHouseFurnitureTemplate::CpInteractMontageName' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, IgnoreNpcIdList) == 0x000048, "Member 'FHouseFurnitureTemplate::IgnoreNpcIdList' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, AllowedNpcIdList) == 0x000058, "Member 'FHouseFurnitureTemplate::AllowedNpcIdList' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, SubAllowedNpcIdList) == 0x000068, "Member 'FHouseFurnitureTemplate::SubAllowedNpcIdList' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, NpcIdList_MultiCp) == 0x000078, "Member 'FHouseFurnitureTemplate::NpcIdList_MultiCp' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, FaceToPlayerOnInteract) == 0x000088, "Member 'FHouseFurnitureTemplate::FaceToPlayerOnInteract' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, NpcInteractOffset) == 0x000090, "Member 'FHouseFurnitureTemplate::NpcInteractOffset' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, OpenKawaiiWhenInteractByNpc) == 0x0000E0, "Member 'FHouseFurnitureTemplate::OpenKawaiiWhenInteractByNpc' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, BlockCollisionAndGravityWhenInteractByNpc) == 0x0000E1, "Member 'FHouseFurnitureTemplate::BlockCollisionAndGravityWhenInteractByNpc' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, AllowHiddenAtPhoto) == 0x0000E2, "Member 'FHouseFurnitureTemplate::AllowHiddenAtPhoto' has a wrong offset!");
static_assert(offsetof(FHouseFurnitureTemplate, TargetAccRep) == 0x0000E4, "Member 'FHouseFurnitureTemplate::TargetAccRep' has a wrong offset!");

// ScriptStruct Game.HouseLoveAddAttributesCfg
// 0x0014 (0x0014 - 0x0000)
struct FHouseLoveAddAttributesCfg final
{
public:
	int32                                         Health;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attack;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Defence;                                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Shield;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLevel;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseLoveAddAttributesCfg) == 0x000004, "Wrong alignment on FHouseLoveAddAttributesCfg");
static_assert(sizeof(FHouseLoveAddAttributesCfg) == 0x000014, "Wrong size on FHouseLoveAddAttributesCfg");
static_assert(offsetof(FHouseLoveAddAttributesCfg, Health) == 0x000000, "Member 'FHouseLoveAddAttributesCfg::Health' has a wrong offset!");
static_assert(offsetof(FHouseLoveAddAttributesCfg, Attack) == 0x000004, "Member 'FHouseLoveAddAttributesCfg::Attack' has a wrong offset!");
static_assert(offsetof(FHouseLoveAddAttributesCfg, Defence) == 0x000008, "Member 'FHouseLoveAddAttributesCfg::Defence' has a wrong offset!");
static_assert(offsetof(FHouseLoveAddAttributesCfg, Shield) == 0x00000C, "Member 'FHouseLoveAddAttributesCfg::Shield' has a wrong offset!");
static_assert(offsetof(FHouseLoveAddAttributesCfg, BuffLevel) == 0x000010, "Member 'FHouseLoveAddAttributesCfg::BuffLevel' has a wrong offset!");

// ScriptStruct Game.HouseMassagePointExportButton
// 0x0001 (0x0001 - 0x0000)
struct FHouseMassagePointExportButton final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHouseMassagePointExportButton) == 0x000001, "Wrong alignment on FHouseMassagePointExportButton");
static_assert(sizeof(FHouseMassagePointExportButton) == 0x000001, "Wrong size on FHouseMassagePointExportButton");

// ScriptStruct Game.HouseParamNameToSet
// 0x0010 (0x0010 - 0x0000)
struct FHouseParamNameToSet final
{
public:
	TArray<class FName>                           ToSetParamName;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseParamNameToSet) == 0x000008, "Wrong alignment on FHouseParamNameToSet");
static_assert(sizeof(FHouseParamNameToSet) == 0x000010, "Wrong size on FHouseParamNameToSet");
static_assert(offsetof(FHouseParamNameToSet, ToSetParamName) == 0x000000, "Member 'FHouseParamNameToSet::ToSetParamName' has a wrong offset!");

// ScriptStruct Game.HouseMovementTypeInSet
// 0x0018 (0x0018 - 0x0000)
struct FHouseMovementTypeInSet final
{
public:
	EPhysicsMovementType                          MovementType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SetNames;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseMovementTypeInSet) == 0x000008, "Wrong alignment on FHouseMovementTypeInSet");
static_assert(sizeof(FHouseMovementTypeInSet) == 0x000018, "Wrong size on FHouseMovementTypeInSet");
static_assert(offsetof(FHouseMovementTypeInSet, MovementType) == 0x000000, "Member 'FHouseMovementTypeInSet::MovementType' has a wrong offset!");
static_assert(offsetof(FHouseMovementTypeInSet, SetNames) == 0x000008, "Member 'FHouseMovementTypeInSet::SetNames' has a wrong offset!");

// ScriptStruct Game.LimbToSet
// 0x0010 (0x0010 - 0x0000)
struct FLimbToSet final
{
public:
	TArray<class FName>                           BodyModifiers;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimbToSet) == 0x000008, "Wrong alignment on FLimbToSet");
static_assert(sizeof(FLimbToSet) == 0x000010, "Wrong size on FLimbToSet");
static_assert(offsetof(FLimbToSet, BodyModifiers) == 0x000000, "Member 'FLimbToSet::BodyModifiers' has a wrong offset!");

// ScriptStruct Game.HousePhysicsControlData
// 0x0160 (0x0168 - 0x0008)
struct FHousePhysicsControlData final : public FTableRowBase
{
public:
	int32                                         NpcIndex;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcId;                                             // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPhysicsControlLimbSetupData>   LimbSetupData;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FHouseParamNameToSet> BodyModifiersToSet;                                // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FHouseMovementTypeInSet>        MovementTypesInSet;                                // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLimbToSet>          LimbToSet;                                         // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FLimbControlData>               LimbControlData;                                   // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlData                    WorldSpaceControlData;                             // 0x00E8(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                WorldSpaceControlSettings;                         // 0x0108(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldSpaceControls;                         // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicsControlData                    ParentSpaceControlData;                            // 0x0124(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                ParentSpaceControlSettings;                        // 0x0144(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableParentSpaceControls;                        // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsMovementType                          PhysicsMovementType;                               // 0x015D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15E[0x2];                                      // 0x015E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityMultiplier;                                 // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHousePhysicsControlData) == 0x000008, "Wrong alignment on FHousePhysicsControlData");
static_assert(sizeof(FHousePhysicsControlData) == 0x000168, "Wrong size on FHousePhysicsControlData");
static_assert(offsetof(FHousePhysicsControlData, NpcIndex) == 0x000008, "Member 'FHousePhysicsControlData::NpcIndex' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, NpcId) == 0x00000C, "Member 'FHousePhysicsControlData::NpcId' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, LimbSetupData) == 0x000018, "Member 'FHousePhysicsControlData::LimbSetupData' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, BodyModifiersToSet) == 0x000028, "Member 'FHousePhysicsControlData::BodyModifiersToSet' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, MovementTypesInSet) == 0x000078, "Member 'FHousePhysicsControlData::MovementTypesInSet' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, LimbToSet) == 0x000088, "Member 'FHousePhysicsControlData::LimbToSet' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, LimbControlData) == 0x0000D8, "Member 'FHousePhysicsControlData::LimbControlData' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, WorldSpaceControlData) == 0x0000E8, "Member 'FHousePhysicsControlData::WorldSpaceControlData' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, WorldSpaceControlSettings) == 0x000108, "Member 'FHousePhysicsControlData::WorldSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, bEnableWorldSpaceControls) == 0x000120, "Member 'FHousePhysicsControlData::bEnableWorldSpaceControls' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, ParentSpaceControlData) == 0x000124, "Member 'FHousePhysicsControlData::ParentSpaceControlData' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, ParentSpaceControlSettings) == 0x000144, "Member 'FHousePhysicsControlData::ParentSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, bEnableParentSpaceControls) == 0x00015C, "Member 'FHousePhysicsControlData::bEnableParentSpaceControls' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, PhysicsMovementType) == 0x00015D, "Member 'FHousePhysicsControlData::PhysicsMovementType' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, GravityMultiplier) == 0x000160, "Member 'FHousePhysicsControlData::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(FHousePhysicsControlData, PhysicsBlendWeight) == 0x000164, "Member 'FHousePhysicsControlData::PhysicsBlendWeight' has a wrong offset!");

// ScriptStruct Game.TalkCameraInfo
// 0x000C (0x000C - 0x0000)
struct FTalkCameraInfo final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkCameraInfo) == 0x000004, "Wrong alignment on FTalkCameraInfo");
static_assert(sizeof(FTalkCameraInfo) == 0x00000C, "Wrong size on FTalkCameraInfo");
static_assert(offsetof(FTalkCameraInfo, Angle) == 0x000000, "Member 'FTalkCameraInfo::Angle' has a wrong offset!");
static_assert(offsetof(FTalkCameraInfo, Length) == 0x000004, "Member 'FTalkCameraInfo::Length' has a wrong offset!");
static_assert(offsetof(FTalkCameraInfo, Height) == 0x000008, "Member 'FTalkCameraInfo::Height' has a wrong offset!");

// ScriptStruct Game.SitBoxActionRequired
// 0x0018 (0x0018 - 0x0000)
struct FSitBoxActionRequired final
{
public:
	int32                                         NpcId;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSitBoxActionRequired) == 0x000008, "Wrong alignment on FSitBoxActionRequired");
static_assert(sizeof(FSitBoxActionRequired) == 0x000018, "Wrong size on FSitBoxActionRequired");
static_assert(offsetof(FSitBoxActionRequired, NpcId) == 0x000000, "Member 'FSitBoxActionRequired::NpcId' has a wrong offset!");
static_assert(offsetof(FSitBoxActionRequired, ActionName) == 0x000008, "Member 'FSitBoxActionRequired::ActionName' has a wrong offset!");

// ScriptStruct Game.HyperTextResource
// 0x0028 (0x0030 - 0x0008)
struct FHyperTextResource final : public FTableRowBase
{
public:
	class FString                                 Key;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Resource;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHyperTextResource) == 0x000008, "Wrong alignment on FHyperTextResource");
static_assert(sizeof(FHyperTextResource) == 0x000030, "Wrong size on FHyperTextResource");
static_assert(offsetof(FHyperTextResource, Key) == 0x000008, "Member 'FHyperTextResource::Key' has a wrong offset!");
static_assert(offsetof(FHyperTextResource, Resource) == 0x000018, "Member 'FHyperTextResource::Resource' has a wrong offset!");

// ScriptStruct Game.MassagePointInfo
// 0x0068 (0x0068 - 0x0000)
struct FMassagePointInfo final
{
public:
	int32                                         PointID;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            SoothingNumMap;                                    // 0x0008(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CurrentSoothingNum;                                // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMassagePointInfo) == 0x000008, "Wrong alignment on FMassagePointInfo");
static_assert(sizeof(FMassagePointInfo) == 0x000068, "Wrong size on FMassagePointInfo");
static_assert(offsetof(FMassagePointInfo, PointID) == 0x000000, "Member 'FMassagePointInfo::PointID' has a wrong offset!");
static_assert(offsetof(FMassagePointInfo, SoothingNumMap) == 0x000008, "Member 'FMassagePointInfo::SoothingNumMap' has a wrong offset!");
static_assert(offsetof(FMassagePointInfo, CurrentSoothingNum) == 0x000058, "Member 'FMassagePointInfo::CurrentSoothingNum' has a wrong offset!");
static_assert(offsetof(FMassagePointInfo, SocketName) == 0x00005C, "Member 'FMassagePointInfo::SocketName' has a wrong offset!");

// ScriptStruct Game.MassageBSScaleDef
// 0x0001 (0x0001 - 0x0000)
struct FMassageBSScaleDef final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMassageBSScaleDef) == 0x000001, "Wrong alignment on FMassageBSScaleDef");
static_assert(sizeof(FMassageBSScaleDef) == 0x000001, "Wrong size on FMassageBSScaleDef");

// ScriptStruct Game.TalkHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FTalkHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkHandle) == 0x000004, "Wrong alignment on FTalkHandle");
static_assert(sizeof(FTalkHandle) == 0x000008, "Wrong size on FTalkHandle");

// ScriptStruct Game.IOUploadItem
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FIOUploadItem final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIOUploadItem) == 0x000008, "Wrong alignment on FIOUploadItem");
static_assert(sizeof(FIOUploadItem) == 0x000028, "Wrong size on FIOUploadItem");

// ScriptStruct Game.KidRiddingExContactModifyInfo
// 0x0030 (0x0030 - 0x0000)
struct FKidRiddingExContactModifyInfo final
{
public:
	struct FVector2D                              TargetAngleRange;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetSpeedRange;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExRestitution;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExForce;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExForceCD;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExAngularDamp;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffTime;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExAngularDampCD;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DispatchCollisionEventWhenMatch;                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetCollisionEventId;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRiddingExContactModifyInfo) == 0x000004, "Wrong alignment on FKidRiddingExContactModifyInfo");
static_assert(sizeof(FKidRiddingExContactModifyInfo) == 0x000030, "Wrong size on FKidRiddingExContactModifyInfo");
static_assert(offsetof(FKidRiddingExContactModifyInfo, TargetAngleRange) == 0x000000, "Member 'FKidRiddingExContactModifyInfo::TargetAngleRange' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, TargetSpeedRange) == 0x000008, "Member 'FKidRiddingExContactModifyInfo::TargetSpeedRange' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, ExRestitution) == 0x000010, "Member 'FKidRiddingExContactModifyInfo::ExRestitution' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, ExForce) == 0x000014, "Member 'FKidRiddingExContactModifyInfo::ExForce' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, ExForceCD) == 0x000018, "Member 'FKidRiddingExContactModifyInfo::ExForceCD' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, ExAngularDamp) == 0x00001C, "Member 'FKidRiddingExContactModifyInfo::ExAngularDamp' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, EffTime) == 0x000020, "Member 'FKidRiddingExContactModifyInfo::EffTime' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, ExAngularDampCD) == 0x000024, "Member 'FKidRiddingExContactModifyInfo::ExAngularDampCD' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, DispatchCollisionEventWhenMatch) == 0x000028, "Member 'FKidRiddingExContactModifyInfo::DispatchCollisionEventWhenMatch' has a wrong offset!");
static_assert(offsetof(FKidRiddingExContactModifyInfo, TargetCollisionEventId) == 0x00002C, "Member 'FKidRiddingExContactModifyInfo::TargetCollisionEventId' has a wrong offset!");

// ScriptStruct Game.KidRiddingContactModifyInfo
// 0x0070 (0x0070 - 0x0000)
struct FKidRiddingContactModifyInfo final
{
public:
	class FName                                   ContactModifySurfaceName;                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContactRestitution;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContactRestitution;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ContactRestitutionCurve;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ContactRestitutionScale_SpeedCurve;                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ContactRestitutionScale_AngleCurve;                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContactDynamicFriction;                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContactDynamicFriction;                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ContactFrictionCurve;                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ModifyNormalCurve;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ModifyNormalSpeedScaleCurve;                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HandleConcave;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConcaveAngleOnSpline;                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcaveExFriction;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcaveExRestitution;                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKidRiddingExContactModifyInfo> SpContactModifies;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseSlideRotateRes_Block;                           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideRotateRestitution_BlockScale;                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRiddingContactModifyInfo) == 0x000008, "Wrong alignment on FKidRiddingContactModifyInfo");
static_assert(sizeof(FKidRiddingContactModifyInfo) == 0x000070, "Wrong size on FKidRiddingContactModifyInfo");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactModifySurfaceName) == 0x000000, "Member 'FKidRiddingContactModifyInfo::ContactModifySurfaceName' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, bUseContactRestitution) == 0x000008, "Member 'FKidRiddingContactModifyInfo::bUseContactRestitution' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactRestitution) == 0x00000C, "Member 'FKidRiddingContactModifyInfo::ContactRestitution' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactRestitutionCurve) == 0x000010, "Member 'FKidRiddingContactModifyInfo::ContactRestitutionCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactRestitutionScale_SpeedCurve) == 0x000018, "Member 'FKidRiddingContactModifyInfo::ContactRestitutionScale_SpeedCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactRestitutionScale_AngleCurve) == 0x000020, "Member 'FKidRiddingContactModifyInfo::ContactRestitutionScale_AngleCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, bUseContactDynamicFriction) == 0x000028, "Member 'FKidRiddingContactModifyInfo::bUseContactDynamicFriction' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactDynamicFriction) == 0x00002C, "Member 'FKidRiddingContactModifyInfo::ContactDynamicFriction' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ContactFrictionCurve) == 0x000030, "Member 'FKidRiddingContactModifyInfo::ContactFrictionCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ModifyNormalCurve) == 0x000038, "Member 'FKidRiddingContactModifyInfo::ModifyNormalCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ModifyNormalSpeedScaleCurve) == 0x000040, "Member 'FKidRiddingContactModifyInfo::ModifyNormalSpeedScaleCurve' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, HandleConcave) == 0x000048, "Member 'FKidRiddingContactModifyInfo::HandleConcave' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ConcaveAngleOnSpline) == 0x00004C, "Member 'FKidRiddingContactModifyInfo::ConcaveAngleOnSpline' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ConcaveExFriction) == 0x000050, "Member 'FKidRiddingContactModifyInfo::ConcaveExFriction' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, ConcaveExRestitution) == 0x000054, "Member 'FKidRiddingContactModifyInfo::ConcaveExRestitution' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, SpContactModifies) == 0x000058, "Member 'FKidRiddingContactModifyInfo::SpContactModifies' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, UseSlideRotateRes_Block) == 0x000068, "Member 'FKidRiddingContactModifyInfo::UseSlideRotateRes_Block' has a wrong offset!");
static_assert(offsetof(FKidRiddingContactModifyInfo, SlideRotateRestitution_BlockScale) == 0x00006C, "Member 'FKidRiddingContactModifyInfo::SlideRotateRestitution_BlockScale' has a wrong offset!");

// ScriptStruct Game.KidRideNiagaraList
// 0x0010 (0x0010 - 0x0000)
struct FKidRideNiagaraList final
{
public:
	TArray<class UNiagaraComponent*>              Components;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideNiagaraList) == 0x000008, "Wrong alignment on FKidRideNiagaraList");
static_assert(sizeof(FKidRideNiagaraList) == 0x000010, "Wrong size on FKidRideNiagaraList");
static_assert(offsetof(FKidRideNiagaraList, Components) == 0x000000, "Member 'FKidRideNiagaraList::Components' has a wrong offset!");

// ScriptStruct Game.KidRideCollisionEffectItem
// 0x0050 (0x0050 - 0x0000)
struct FKidRideCollisionEffectItem final
{
public:
	class FName                                   CollisionSurfaceName;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKidRideEffectParam                    Param;                                             // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideCollisionEffectItem) == 0x000008, "Wrong alignment on FKidRideCollisionEffectItem");
static_assert(sizeof(FKidRideCollisionEffectItem) == 0x000050, "Wrong size on FKidRideCollisionEffectItem");
static_assert(offsetof(FKidRideCollisionEffectItem, CollisionSurfaceName) == 0x000000, "Member 'FKidRideCollisionEffectItem::CollisionSurfaceName' has a wrong offset!");
static_assert(offsetof(FKidRideCollisionEffectItem, Param) == 0x000008, "Member 'FKidRideCollisionEffectItem::Param' has a wrong offset!");

// ScriptStruct Game.KidRideEffectItem
// 0x0018 (0x0018 - 0x0000)
struct FKidRideEffectItem final
{
public:
	EKidRideEffectType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKidRideEffectParam>            Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKidRideEffectItem) == 0x000008, "Wrong alignment on FKidRideEffectItem");
static_assert(sizeof(FKidRideEffectItem) == 0x000018, "Wrong size on FKidRideEffectItem");
static_assert(offsetof(FKidRideEffectItem, Type) == 0x000000, "Member 'FKidRideEffectItem::Type' has a wrong offset!");
static_assert(offsetof(FKidRideEffectItem, Params) == 0x000008, "Member 'FKidRideEffectItem::Params' has a wrong offset!");

// ScriptStruct Game.KideRideStateFadeParams
// 0x0010 (0x0010 - 0x0000)
struct FKideRideStateFadeParams final
{
public:
	float                                         CameraLagSpeed;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmLagSpeed;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKideRideStateFadeParams) == 0x000004, "Wrong alignment on FKideRideStateFadeParams");
static_assert(sizeof(FKideRideStateFadeParams) == 0x000010, "Wrong size on FKideRideStateFadeParams");
static_assert(offsetof(FKideRideStateFadeParams, CameraLagSpeed) == 0x000000, "Member 'FKideRideStateFadeParams::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(FKideRideStateFadeParams, CameraRotationLagSpeed) == 0x000004, "Member 'FKideRideStateFadeParams::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(FKideRideStateFadeParams, SpringArmLagSpeed) == 0x000008, "Member 'FKideRideStateFadeParams::SpringArmLagSpeed' has a wrong offset!");
static_assert(offsetof(FKideRideStateFadeParams, Duration) == 0x00000C, "Member 'FKideRideStateFadeParams::Duration' has a wrong offset!");

// ScriptStruct Game.SpawnEffet
// 0x00A8 (0x00B0 - 0x0008)
struct FSpawnEffet final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectPath;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnEffetMode                               Mode;                                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime;                                         // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowRedPoint;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sound;                                             // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingNewBornEffect;                             // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BornTrailEffect;                                   // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornEffectMaxHeight;                               // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareDuration;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrePareUpDuration;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TrailSound;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnEffet) == 0x000008, "Wrong alignment on FSpawnEffet");
static_assert(sizeof(FSpawnEffet) == 0x0000B0, "Wrong size on FSpawnEffet");
static_assert(offsetof(FSpawnEffet, ID) == 0x000008, "Member 'FSpawnEffet::ID' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, Remark) == 0x000010, "Member 'FSpawnEffet::Remark' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, EffectPath) == 0x000020, "Member 'FSpawnEffet::EffectPath' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, Offset) == 0x000038, "Member 'FSpawnEffet::Offset' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, Scale) == 0x000044, "Member 'FSpawnEffet::Scale' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, Mode) == 0x000050, "Member 'FSpawnEffet::Mode' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, DelayTime) == 0x000054, "Member 'FSpawnEffet::DelayTime' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, ShowRedPoint) == 0x000058, "Member 'FSpawnEffet::ShowRedPoint' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, Sound) == 0x000060, "Member 'FSpawnEffet::Sound' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, bIsUsingNewBornEffect) == 0x000070, "Member 'FSpawnEffet::bIsUsingNewBornEffect' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, BornTrailEffect) == 0x000078, "Member 'FSpawnEffet::BornTrailEffect' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, BornEffectMaxHeight) == 0x000090, "Member 'FSpawnEffet::BornEffectMaxHeight' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, PrePareDuration) == 0x000094, "Member 'FSpawnEffet::PrePareDuration' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, PrePareUpDuration) == 0x000098, "Member 'FSpawnEffet::PrePareUpDuration' has a wrong offset!");
static_assert(offsetof(FSpawnEffet, TrailSound) == 0x0000A0, "Member 'FSpawnEffet::TrailSound' has a wrong offset!");

// ScriptStruct Game.OpenWorldExploreItem
// 0x0020 (0x0028 - 0x0008)
struct FOpenWorldExploreItem final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOpenWorldExploreItem) == 0x000008, "Wrong alignment on FOpenWorldExploreItem");
static_assert(sizeof(FOpenWorldExploreItem) == 0x000028, "Wrong size on FOpenWorldExploreItem");
static_assert(offsetof(FOpenWorldExploreItem, ID) == 0x000008, "Member 'FOpenWorldExploreItem::ID' has a wrong offset!");
static_assert(offsetof(FOpenWorldExploreItem, Blueprint) == 0x000010, "Member 'FOpenWorldExploreItem::Blueprint' has a wrong offset!");

// ScriptStruct Game.ActiveWavesTemplate
// 0x0068 (0x0070 - 0x0008)
struct FActiveWavesTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Boxes;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Waves;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         KillCondition;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AIEvents;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitDelayTime;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveWavesTemplate) == 0x000008, "Wrong alignment on FActiveWavesTemplate");
static_assert(sizeof(FActiveWavesTemplate) == 0x000070, "Wrong size on FActiveWavesTemplate");
static_assert(offsetof(FActiveWavesTemplate, ID) == 0x000008, "Member 'FActiveWavesTemplate::ID' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, Remark) == 0x000010, "Member 'FActiveWavesTemplate::Remark' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, Boxes) == 0x000020, "Member 'FActiveWavesTemplate::Boxes' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, Waves) == 0x000030, "Member 'FActiveWavesTemplate::Waves' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, KillCondition) == 0x000040, "Member 'FActiveWavesTemplate::KillCondition' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, AIEvents) == 0x000048, "Member 'FActiveWavesTemplate::AIEvents' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, IntervalTime) == 0x000058, "Member 'FActiveWavesTemplate::IntervalTime' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, InitDelayTime) == 0x00005C, "Member 'FActiveWavesTemplate::InitDelayTime' has a wrong offset!");
static_assert(offsetof(FActiveWavesTemplate, Team) == 0x000060, "Member 'FActiveWavesTemplate::Team' has a wrong offset!");

// ScriptStruct Game.SpawnerConfigArray
// 0x0010 (0x0010 - 0x0000)
struct FSpawnerConfigArray final
{
public:
	TArray<struct FSpawnerConfig>                 SpawnerConfigs;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnerConfigArray) == 0x000008, "Wrong alignment on FSpawnerConfigArray");
static_assert(sizeof(FSpawnerConfigArray) == 0x000010, "Wrong size on FSpawnerConfigArray");
static_assert(offsetof(FSpawnerConfigArray, SpawnerConfigs) == 0x000000, "Member 'FSpawnerConfigArray::SpawnerConfigs' has a wrong offset!");

// ScriptStruct Game.WavesTemplate
// 0x0040 (0x0048 - 0x0008)
struct FWavesTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillModify;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnerConfigArray>            SpawnerConfigArrays;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Levels;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWavesTemplate) == 0x000008, "Wrong alignment on FWavesTemplate");
static_assert(sizeof(FWavesTemplate) == 0x000048, "Wrong size on FWavesTemplate");
static_assert(offsetof(FWavesTemplate, ID) == 0x000008, "Member 'FWavesTemplate::ID' has a wrong offset!");
static_assert(offsetof(FWavesTemplate, Remark) == 0x000010, "Member 'FWavesTemplate::Remark' has a wrong offset!");
static_assert(offsetof(FWavesTemplate, DelayTime) == 0x000020, "Member 'FWavesTemplate::DelayTime' has a wrong offset!");
static_assert(offsetof(FWavesTemplate, KillModify) == 0x000024, "Member 'FWavesTemplate::KillModify' has a wrong offset!");
static_assert(offsetof(FWavesTemplate, SpawnerConfigArrays) == 0x000028, "Member 'FWavesTemplate::SpawnerConfigArrays' has a wrong offset!");
static_assert(offsetof(FWavesTemplate, Levels) == 0x000038, "Member 'FWavesTemplate::Levels' has a wrong offset!");

// ScriptStruct Game.PatrolNpcSpawnersTemplate
// 0x0068 (0x0070 - 0x0008)
struct FPatrolNpcSpawnersTemplate final : public FTableRowBase
{
public:
	class FString                                 TeamID;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Remark;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnmityTeam;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Points;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPatrolNpcSpawnerConfig>        SpawnerConfigs;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActiveRange;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AICtrlID;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PatrolSpLevelStrength;                             // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatrolNpcSpawnersTemplate) == 0x000008, "Wrong alignment on FPatrolNpcSpawnersTemplate");
static_assert(sizeof(FPatrolNpcSpawnersTemplate) == 0x000070, "Wrong size on FPatrolNpcSpawnersTemplate");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, TeamID) == 0x000008, "Member 'FPatrolNpcSpawnersTemplate::TeamID' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, Remark) == 0x000018, "Member 'FPatrolNpcSpawnersTemplate::Remark' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, EnmityTeam) == 0x000028, "Member 'FPatrolNpcSpawnersTemplate::EnmityTeam' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, Level) == 0x000038, "Member 'FPatrolNpcSpawnersTemplate::Level' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, Points) == 0x000040, "Member 'FPatrolNpcSpawnersTemplate::Points' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, SpawnerConfigs) == 0x000050, "Member 'FPatrolNpcSpawnersTemplate::SpawnerConfigs' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, ActiveRange) == 0x000060, "Member 'FPatrolNpcSpawnersTemplate::ActiveRange' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, AICtrlID) == 0x000064, "Member 'FPatrolNpcSpawnersTemplate::AICtrlID' has a wrong offset!");
static_assert(offsetof(FPatrolNpcSpawnersTemplate, PatrolSpLevelStrength) == 0x000068, "Member 'FPatrolNpcSpawnersTemplate::PatrolSpLevelStrength' has a wrong offset!");

// ScriptStruct Game.ActiveSpawnersFragmentsTemplate
// 0x0000 (0x0088 - 0x0088)
struct FActiveSpawnersFragmentsTemplate final : public FActiveSpawnersTemplate
{
};
static_assert(alignof(FActiveSpawnersFragmentsTemplate) == 0x000008, "Wrong alignment on FActiveSpawnersFragmentsTemplate");
static_assert(sizeof(FActiveSpawnersFragmentsTemplate) == 0x000088, "Wrong size on FActiveSpawnersFragmentsTemplate");

// ScriptStruct Game.ActiveSpawnersDailyTemplate
// 0x0000 (0x0088 - 0x0088)
struct FActiveSpawnersDailyTemplate final : public FActiveSpawnersTemplate
{
};
static_assert(alignof(FActiveSpawnersDailyTemplate) == 0x000008, "Wrong alignment on FActiveSpawnersDailyTemplate");
static_assert(sizeof(FActiveSpawnersDailyTemplate) == 0x000088, "Wrong size on FActiveSpawnersDailyTemplate");

// ScriptStruct Game.ActiveDestroyTemplate
// 0x0050 (0x0058 - 0x0008)
struct FActiveDestroyTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Points;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Blueprint;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveDestroyTemplate) == 0x000008, "Wrong alignment on FActiveDestroyTemplate");
static_assert(sizeof(FActiveDestroyTemplate) == 0x000058, "Wrong size on FActiveDestroyTemplate");
static_assert(offsetof(FActiveDestroyTemplate, ID) == 0x000008, "Member 'FActiveDestroyTemplate::ID' has a wrong offset!");
static_assert(offsetof(FActiveDestroyTemplate, Comment) == 0x000010, "Member 'FActiveDestroyTemplate::Comment' has a wrong offset!");
static_assert(offsetof(FActiveDestroyTemplate, Points) == 0x000020, "Member 'FActiveDestroyTemplate::Points' has a wrong offset!");
static_assert(offsetof(FActiveDestroyTemplate, Tags) == 0x000030, "Member 'FActiveDestroyTemplate::Tags' has a wrong offset!");
static_assert(offsetof(FActiveDestroyTemplate, Blueprint) == 0x000040, "Member 'FActiveDestroyTemplate::Blueprint' has a wrong offset!");

// ScriptStruct Game.SpawnBarricadePointParams
// 0x0010 (0x0010 - 0x0000)
struct FSpawnBarricadePointParams final
{
public:
	class FString                                 PointName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnBarricadePointParams) == 0x000008, "Wrong alignment on FSpawnBarricadePointParams");
static_assert(sizeof(FSpawnBarricadePointParams) == 0x000010, "Wrong size on FSpawnBarricadePointParams");
static_assert(offsetof(FSpawnBarricadePointParams, PointName) == 0x000000, "Member 'FSpawnBarricadePointParams::PointName' has a wrong offset!");

// ScriptStruct Game.SpawnMonsterParameters
// 0x0008 (0x0138 - 0x0130)
struct FSpawnMonsterParameters final : public FSpawnNpcParams
{
public:
	int32                                         DynamicLevel;                                      // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnMonsterParameters) == 0x000008, "Wrong alignment on FSpawnMonsterParameters");
static_assert(sizeof(FSpawnMonsterParameters) == 0x000138, "Wrong size on FSpawnMonsterParameters");
static_assert(offsetof(FSpawnMonsterParameters, DynamicLevel) == 0x000130, "Member 'FSpawnMonsterParameters::DynamicLevel' has a wrong offset!");

// ScriptStruct Game.SpecializedProperty
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FSpecializedProperty final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecializedProperty) == 0x000004, "Wrong alignment on FSpecializedProperty");
static_assert(sizeof(FSpecializedProperty) == 0x00002C, "Wrong size on FSpecializedProperty");

// ScriptStruct Game.DropEffectTemplate
// 0x01B8 (0x01C0 - 0x0008)
struct FDropEffectTemplate final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Remark;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DropName;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LifeSpanRandom;                                    // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartFlashTime;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickRadius;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitedByNum;                                      // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPickWhenLifeSpanExpired;                      // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoPickRadius;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DropBPPath;                                        // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPickWhenPlaySkillAnim;                         // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PickWwiseEvent;                                    // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CustomParams;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllocationRule_Normal;                             // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllocationRule_Specialized;                        // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GetLevelPoint;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDropApplyMode                                ApplyMode;                                         // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ApplyTarget;                                       // 0x00F0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyPick;                                        // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ApplyFunc;                                         // 0x0120(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ApplyTarget_Client;                                // 0x0148(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ApplyFunc_Client;                                  // 0x0170(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifierID;                                        // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BornPosOffset;                                     // 0x019C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomEndPosRange;                                 // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomEndPosMulti;                                 // 0x01AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomEndPosMultiTimes;                            // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskTag;                                           // 0x01B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDropEffectTemplate) == 0x000008, "Wrong alignment on FDropEffectTemplate");
static_assert(sizeof(FDropEffectTemplate) == 0x0001C0, "Wrong size on FDropEffectTemplate");
static_assert(offsetof(FDropEffectTemplate, ID) == 0x000030, "Member 'FDropEffectTemplate::ID' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, Remark) == 0x000038, "Member 'FDropEffectTemplate::Remark' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, DropName) == 0x000048, "Member 'FDropEffectTemplate::DropName' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, LifeSpan) == 0x000058, "Member 'FDropEffectTemplate::LifeSpan' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, LifeSpanRandom) == 0x00005C, "Member 'FDropEffectTemplate::LifeSpanRandom' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, StartFlashTime) == 0x000064, "Member 'FDropEffectTemplate::StartFlashTime' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, PickRadius) == 0x000068, "Member 'FDropEffectTemplate::PickRadius' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, LimitedByNum) == 0x00006C, "Member 'FDropEffectTemplate::LimitedByNum' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, bAutoPickWhenLifeSpanExpired) == 0x00006D, "Member 'FDropEffectTemplate::bAutoPickWhenLifeSpanExpired' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, AutoPickRadius) == 0x000070, "Member 'FDropEffectTemplate::AutoPickRadius' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, DropBPPath) == 0x000078, "Member 'FDropEffectTemplate::DropBPPath' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, bCanPickWhenPlaySkillAnim) == 0x0000A0, "Member 'FDropEffectTemplate::bCanPickWhenPlaySkillAnim' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, PickWwiseEvent) == 0x0000A8, "Member 'FDropEffectTemplate::PickWwiseEvent' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, CustomParams) == 0x0000B8, "Member 'FDropEffectTemplate::CustomParams' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, AllocationRule_Normal) == 0x0000C8, "Member 'FDropEffectTemplate::AllocationRule_Normal' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, AllocationRule_Specialized) == 0x0000D8, "Member 'FDropEffectTemplate::AllocationRule_Specialized' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, GetLevelPoint) == 0x0000E8, "Member 'FDropEffectTemplate::GetLevelPoint' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ApplyMode) == 0x0000EC, "Member 'FDropEffectTemplate::ApplyMode' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ApplyTarget) == 0x0000F0, "Member 'FDropEffectTemplate::ApplyTarget' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, bApplyPick) == 0x000118, "Member 'FDropEffectTemplate::bApplyPick' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ApplyFunc) == 0x000120, "Member 'FDropEffectTemplate::ApplyFunc' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ApplyTarget_Client) == 0x000148, "Member 'FDropEffectTemplate::ApplyTarget_Client' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ApplyFunc_Client) == 0x000170, "Member 'FDropEffectTemplate::ApplyFunc_Client' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, ModifierID) == 0x000198, "Member 'FDropEffectTemplate::ModifierID' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, BornPosOffset) == 0x00019C, "Member 'FDropEffectTemplate::BornPosOffset' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, RandomEndPosRange) == 0x0001A8, "Member 'FDropEffectTemplate::RandomEndPosRange' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, RandomEndPosMulti) == 0x0001AC, "Member 'FDropEffectTemplate::RandomEndPosMulti' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, RandomEndPosMultiTimes) == 0x0001B0, "Member 'FDropEffectTemplate::RandomEndPosMultiTimes' has a wrong offset!");
static_assert(offsetof(FDropEffectTemplate, TaskTag) == 0x0001B4, "Member 'FDropEffectTemplate::TaskTag' has a wrong offset!");

// ScriptStruct Game.OnlineMoneyInfo
// 0x0018 (0x0018 - 0x0000)
struct FOnlineMoneyInfo final
{
public:
	uint32                                        Guid;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineMoneyState                             State;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Count;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineMoneyInfo) == 0x000004, "Wrong alignment on FOnlineMoneyInfo");
static_assert(sizeof(FOnlineMoneyInfo) == 0x000018, "Wrong size on FOnlineMoneyInfo");
static_assert(offsetof(FOnlineMoneyInfo, Guid) == 0x000000, "Member 'FOnlineMoneyInfo::Guid' has a wrong offset!");
static_assert(offsetof(FOnlineMoneyInfo, Position) == 0x000004, "Member 'FOnlineMoneyInfo::Position' has a wrong offset!");
static_assert(offsetof(FOnlineMoneyInfo, State) == 0x000010, "Member 'FOnlineMoneyInfo::State' has a wrong offset!");
static_assert(offsetof(FOnlineMoneyInfo, Count) == 0x000014, "Member 'FOnlineMoneyInfo::Count' has a wrong offset!");

// ScriptStruct Game.PathLineInfo
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FPathLineInfo final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathLineInfo) == 0x000004, "Wrong alignment on FPathLineInfo");
static_assert(sizeof(FPathLineInfo) == 0x00006C, "Wrong size on FPathLineInfo");

// ScriptStruct Game.StarTaskProperty
// 0x0040 (0x0040 - 0x0000)
struct FStarTaskProperty final
{
public:
	int32                                         TypeId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentState;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinished;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFinished;                                      // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAchieveFailed;                                    // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStarTaskProperty) == 0x000008, "Wrong alignment on FStarTaskProperty");
static_assert(sizeof(FStarTaskProperty) == 0x000040, "Wrong size on FStarTaskProperty");
static_assert(offsetof(FStarTaskProperty, TypeId) == 0x000000, "Member 'FStarTaskProperty::TypeId' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, Progress) == 0x000004, "Member 'FStarTaskProperty::Progress' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, Description) == 0x000008, "Member 'FStarTaskProperty::Description' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, CurrentState) == 0x000018, "Member 'FStarTaskProperty::CurrentState' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, bFinished) == 0x000028, "Member 'FStarTaskProperty::bFinished' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, bHasFinished) == 0x000029, "Member 'FStarTaskProperty::bHasFinished' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, bAchieveFailed) == 0x00002A, "Member 'FStarTaskProperty::bAchieveFailed' has a wrong offset!");
static_assert(offsetof(FStarTaskProperty, Params) == 0x000030, "Member 'FStarTaskProperty::Params' has a wrong offset!");

// ScriptStruct Game.UIInfo
// 0x0040 (0x0048 - 0x0008)
struct FUIInfo final : public FTableRowBase
{
public:
	struct FSoftClassPath                         UIWidgetClass;                                     // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIType                                       Type;                                              // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Music;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnOpenOther;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIInfo) == 0x000008, "Wrong alignment on FUIInfo");
static_assert(sizeof(FUIInfo) == 0x000048, "Wrong size on FUIInfo");
static_assert(offsetof(FUIInfo, UIWidgetClass) == 0x000008, "Member 'FUIInfo::UIWidgetClass' has a wrong offset!");
static_assert(offsetof(FUIInfo, Order) == 0x000020, "Member 'FUIInfo::Order' has a wrong offset!");
static_assert(offsetof(FUIInfo, Priority) == 0x000024, "Member 'FUIInfo::Priority' has a wrong offset!");
static_assert(offsetof(FUIInfo, Type) == 0x000028, "Member 'FUIInfo::Type' has a wrong offset!");
static_assert(offsetof(FUIInfo, Music) == 0x000030, "Member 'FUIInfo::Music' has a wrong offset!");
static_assert(offsetof(FUIInfo, HideOnOpenOther) == 0x000040, "Member 'FUIInfo::HideOnOpenOther' has a wrong offset!");

// ScriptStruct Game.MapInfo
// 0x0078 (0x0078 - 0x0000)
struct FMapInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LuaClass;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadingImage;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Music;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ambience;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionParam;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapInfo) == 0x000008, "Wrong alignment on FMapInfo");
static_assert(sizeof(FMapInfo) == 0x000078, "Wrong size on FMapInfo");
static_assert(offsetof(FMapInfo, ID) == 0x000000, "Member 'FMapInfo::ID' has a wrong offset!");
static_assert(offsetof(FMapInfo, Type) == 0x000004, "Member 'FMapInfo::Type' has a wrong offset!");
static_assert(offsetof(FMapInfo, MapPath) == 0x000008, "Member 'FMapInfo::MapPath' has a wrong offset!");
static_assert(offsetof(FMapInfo, GameMode) == 0x000018, "Member 'FMapInfo::GameMode' has a wrong offset!");
static_assert(offsetof(FMapInfo, LuaClass) == 0x000028, "Member 'FMapInfo::LuaClass' has a wrong offset!");
static_assert(offsetof(FMapInfo, LoadingImage) == 0x000038, "Member 'FMapInfo::LoadingImage' has a wrong offset!");
static_assert(offsetof(FMapInfo, Music) == 0x000048, "Member 'FMapInfo::Music' has a wrong offset!");
static_assert(offsetof(FMapInfo, Ambience) == 0x000058, "Member 'FMapInfo::Ambience' has a wrong offset!");
static_assert(offsetof(FMapInfo, AdditionParam) == 0x000068, "Member 'FMapInfo::AdditionParam' has a wrong offset!");

// ScriptStruct Game.MaskImageStyle
// 0x01A0 (0x01A8 - 0x0008)
struct FMaskImageStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            Image;                                             // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Mask;                                              // 0x0090(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              MaskGrid;                                          // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Material;                                          // 0x0120(0x0088)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaskImageStyle) == 0x000008, "Wrong alignment on FMaskImageStyle");
static_assert(sizeof(FMaskImageStyle) == 0x0001A8, "Wrong size on FMaskImageStyle");
static_assert(offsetof(FMaskImageStyle, Image) == 0x000008, "Member 'FMaskImageStyle::Image' has a wrong offset!");
static_assert(offsetof(FMaskImageStyle, Mask) == 0x000090, "Member 'FMaskImageStyle::Mask' has a wrong offset!");
static_assert(offsetof(FMaskImageStyle, MaskGrid) == 0x000118, "Member 'FMaskImageStyle::MaskGrid' has a wrong offset!");
static_assert(offsetof(FMaskImageStyle, Material) == 0x000120, "Member 'FMaskImageStyle::Material' has a wrong offset!");

// ScriptStruct Game.CacheMassAttackEmitterInfo
// 0x0048 (0x0048 - 0x0000)
struct FCacheMassAttackEmitterInfo final
{
public:
	int32                                         EmitterID;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ApplyLoc;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLoc;                                         // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScaler;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  Launcher;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GrowAttributeID;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonLevel;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCacheMassAttackEmitterInfo) == 0x000008, "Wrong alignment on FCacheMassAttackEmitterInfo");
static_assert(sizeof(FCacheMassAttackEmitterInfo) == 0x000048, "Wrong size on FCacheMassAttackEmitterInfo");
static_assert(offsetof(FCacheMassAttackEmitterInfo, EmitterID) == 0x000000, "Member 'FCacheMassAttackEmitterInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, ApplyLoc) == 0x000004, "Member 'FCacheMassAttackEmitterInfo::ApplyLoc' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, OriginLoc) == 0x000010, "Member 'FCacheMassAttackEmitterInfo::OriginLoc' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, Level) == 0x00001C, "Member 'FCacheMassAttackEmitterInfo::Level' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, DamageScaler) == 0x000020, "Member 'FCacheMassAttackEmitterInfo::DamageScaler' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, Launcher) == 0x000028, "Member 'FCacheMassAttackEmitterInfo::Launcher' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, TargetActor) == 0x000030, "Member 'FCacheMassAttackEmitterInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, GrowAttributeID) == 0x000038, "Member 'FCacheMassAttackEmitterInfo::GrowAttributeID' has a wrong offset!");
static_assert(offsetof(FCacheMassAttackEmitterInfo, MonLevel) == 0x000040, "Member 'FCacheMassAttackEmitterInfo::MonLevel' has a wrong offset!");

// ScriptStruct Game.MassAICharacterPool
// 0x0018 (0x0018 - 0x0000)
struct FMassAICharacterPool final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGameMassAICharacter*>           List;                                              // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMassAICharacterPool) == 0x000008, "Wrong alignment on FMassAICharacterPool");
static_assert(sizeof(FMassAICharacterPool) == 0x000018, "Wrong size on FMassAICharacterPool");
static_assert(offsetof(FMassAICharacterPool, List) == 0x000008, "Member 'FMassAICharacterPool::List' has a wrong offset!");

// ScriptStruct Game.VectorParameter
// 0x0024 (0x0034 - 0x0010)
struct FVectorParameter final : public FParameterBase
{
public:
	EMaterialType                                 MaterialType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyType                                   ModifyType;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ValueInLight;                                      // 0x0014(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ValueInShadow;                                     // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorParameter) == 0x000004, "Wrong alignment on FVectorParameter");
static_assert(sizeof(FVectorParameter) == 0x000034, "Wrong size on FVectorParameter");
static_assert(offsetof(FVectorParameter, MaterialType) == 0x000010, "Member 'FVectorParameter::MaterialType' has a wrong offset!");
static_assert(offsetof(FVectorParameter, ModifyType) == 0x000011, "Member 'FVectorParameter::ModifyType' has a wrong offset!");
static_assert(offsetof(FVectorParameter, ValueInLight) == 0x000014, "Member 'FVectorParameter::ValueInLight' has a wrong offset!");
static_assert(offsetof(FVectorParameter, ValueInShadow) == 0x000024, "Member 'FVectorParameter::ValueInShadow' has a wrong offset!");

// ScriptStruct Game.ScalarParameter
// 0x000C (0x001C - 0x0010)
struct FScalarParameter final : public FParameterBase
{
public:
	EMaterialType                                 MaterialType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifyType                                   ModifyType;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValueInLight;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueInShadow;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScalarParameter) == 0x000004, "Wrong alignment on FScalarParameter");
static_assert(sizeof(FScalarParameter) == 0x00001C, "Wrong size on FScalarParameter");
static_assert(offsetof(FScalarParameter, MaterialType) == 0x000010, "Member 'FScalarParameter::MaterialType' has a wrong offset!");
static_assert(offsetof(FScalarParameter, ModifyType) == 0x000011, "Member 'FScalarParameter::ModifyType' has a wrong offset!");
static_assert(offsetof(FScalarParameter, ValueInLight) == 0x000014, "Member 'FScalarParameter::ValueInLight' has a wrong offset!");
static_assert(offsetof(FScalarParameter, ValueInShadow) == 0x000018, "Member 'FScalarParameter::ValueInShadow' has a wrong offset!");

// ScriptStruct Game.SmoothValue
// 0x0014 (0x0014 - 0x0000)
struct FSmoothValue final
{
public:
	float                                         TargetValue;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSinEaseFunc                           SinEase;                                           // 0x000C(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseSinFunc : 1;                                   // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmoothValue) == 0x000004, "Wrong alignment on FSmoothValue");
static_assert(sizeof(FSmoothValue) == 0x000014, "Wrong size on FSmoothValue");
static_assert(offsetof(FSmoothValue, TargetValue) == 0x000000, "Member 'FSmoothValue::TargetValue' has a wrong offset!");
static_assert(offsetof(FSmoothValue, CurrentValue) == 0x000004, "Member 'FSmoothValue::CurrentValue' has a wrong offset!");
static_assert(offsetof(FSmoothValue, Speed) == 0x000008, "Member 'FSmoothValue::Speed' has a wrong offset!");
static_assert(offsetof(FSmoothValue, SinEase) == 0x00000C, "Member 'FSmoothValue::SinEase' has a wrong offset!");

// ScriptStruct Game.MonBloodBarData
// 0x0080 (0x0080 - 0x0000)
struct FMonBloodBarData final
{
public:
	bool                                          CanTick;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HpComponentSocketName;                             // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HpComponentOffset;                                 // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRelativeLocation;                              // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        HpComponentAttach;                                 // 0x0020(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHPWidgetBase*                          HpBar;                                             // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SceenPosition;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarScale;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x003C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowDistance;                                      // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartShowTime;                                     // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBloodBarType                                 BloodBarType;                                      // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGDataBaseComponent*                  Component;                                         // 0x0058(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetPivot;                                       // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAuxiliaryLineDirection                       Direction;                                         // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepTime;                                          // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWidgetNum;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepVisible;                                      // 0x0074(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitKeepVisible;                                  // 0x0075(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTickCount;                                  // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMonBloodBarData) == 0x000008, "Wrong alignment on FMonBloodBarData");
static_assert(sizeof(FMonBloodBarData) == 0x000080, "Wrong size on FMonBloodBarData");
static_assert(offsetof(FMonBloodBarData, CanTick) == 0x000000, "Member 'FMonBloodBarData::CanTick' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, HpComponentSocketName) == 0x000004, "Member 'FMonBloodBarData::HpComponentSocketName' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, HpComponentOffset) == 0x00000C, "Member 'FMonBloodBarData::HpComponentOffset' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, bUseRelativeLocation) == 0x000018, "Member 'FMonBloodBarData::bUseRelativeLocation' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, HpComponentAttach) == 0x000020, "Member 'FMonBloodBarData::HpComponentAttach' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, HpBar) == 0x000028, "Member 'FMonBloodBarData::HpBar' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, SceenPosition) == 0x000030, "Member 'FMonBloodBarData::SceenPosition' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, BarScale) == 0x000038, "Member 'FMonBloodBarData::BarScale' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, WorldPosition) == 0x00003C, "Member 'FMonBloodBarData::WorldPosition' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, ShowDistance) == 0x000048, "Member 'FMonBloodBarData::ShowDistance' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, StartShowTime) == 0x00004C, "Member 'FMonBloodBarData::StartShowTime' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, BloodBarType) == 0x000050, "Member 'FMonBloodBarData::BloodBarType' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, Component) == 0x000058, "Member 'FMonBloodBarData::Component' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, OffsetPivot) == 0x000060, "Member 'FMonBloodBarData::OffsetPivot' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, Direction) == 0x000068, "Member 'FMonBloodBarData::Direction' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, KeepTime) == 0x00006C, "Member 'FMonBloodBarData::KeepTime' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, MaxWidgetNum) == 0x000070, "Member 'FMonBloodBarData::MaxWidgetNum' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, bKeepVisible) == 0x000074, "Member 'FMonBloodBarData::bKeepVisible' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, bInitKeepVisible) == 0x000075, "Member 'FMonBloodBarData::bInitKeepVisible' has a wrong offset!");
static_assert(offsetof(FMonBloodBarData, CurrentTickCount) == 0x000078, "Member 'FMonBloodBarData::CurrentTickCount' has a wrong offset!");

// ScriptStruct Game.WidgetArrayWrapper
// 0x0010 (0x0010 - 0x0000)
struct FWidgetArrayWrapper final
{
public:
	TArray<class UMonsterItemBuf*>                WidgetArray;                                       // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetArrayWrapper) == 0x000008, "Wrong alignment on FWidgetArrayWrapper");
static_assert(sizeof(FWidgetArrayWrapper) == 0x000010, "Wrong size on FWidgetArrayWrapper");
static_assert(offsetof(FWidgetArrayWrapper, WidgetArray) == 0x000000, "Member 'FWidgetArrayWrapper::WidgetArray' has a wrong offset!");

// ScriptStruct Game.BubbleInfo
// 0x0010 (0x0010 - 0x0000)
struct FBubbleInfo final
{
public:
	class FName                                   BubbleText;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BubbleShowTime;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoundId;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBubbleInfo) == 0x000004, "Wrong alignment on FBubbleInfo");
static_assert(sizeof(FBubbleInfo) == 0x000010, "Wrong size on FBubbleInfo");
static_assert(offsetof(FBubbleInfo, BubbleText) == 0x000000, "Member 'FBubbleInfo::BubbleText' has a wrong offset!");
static_assert(offsetof(FBubbleInfo, BubbleShowTime) == 0x000008, "Member 'FBubbleInfo::BubbleShowTime' has a wrong offset!");
static_assert(offsetof(FBubbleInfo, SoundId) == 0x00000C, "Member 'FBubbleInfo::SoundId' has a wrong offset!");

// ScriptStruct Game.MonsterBubbleInfo
// 0x0088 (0x0088 - 0x0000)
struct FMonsterBubbleInfo final
{
public:
	TSoftObjectPtr<class UAnimMontage>            DefaultMontage;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBubbleActionInfo>              LoopMontage;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBubbleInfo>                    BubbleList;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BubbleShowRange;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAction;                                      // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BubbleLoop;                                        // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActionLoop;                                        // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInteract;                                      // 0x004F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InteractText;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBeginRange;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginRange;                                        // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterBubble*                         Bubble;                                            // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMonsterBubbleInfo) == 0x000008, "Wrong alignment on FMonsterBubbleInfo");
static_assert(sizeof(FMonsterBubbleInfo) == 0x000088, "Wrong size on FMonsterBubbleInfo");
static_assert(offsetof(FMonsterBubbleInfo, DefaultMontage) == 0x000000, "Member 'FMonsterBubbleInfo::DefaultMontage' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, LoopMontage) == 0x000028, "Member 'FMonsterBubbleInfo::LoopMontage' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, BubbleList) == 0x000038, "Member 'FMonsterBubbleInfo::BubbleList' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, BubbleShowRange) == 0x000048, "Member 'FMonsterBubbleInfo::BubbleShowRange' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, EnableAction) == 0x00004C, "Member 'FMonsterBubbleInfo::EnableAction' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, BubbleLoop) == 0x00004D, "Member 'FMonsterBubbleInfo::BubbleLoop' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, ActionLoop) == 0x00004E, "Member 'FMonsterBubbleInfo::ActionLoop' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, bCanInteract) == 0x00004F, "Member 'FMonsterBubbleInfo::bCanInteract' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, InteractText) == 0x000050, "Member 'FMonsterBubbleInfo::InteractText' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, UseBeginRange) == 0x000060, "Member 'FMonsterBubbleInfo::UseBeginRange' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, BeginRange) == 0x000064, "Member 'FMonsterBubbleInfo::BeginRange' has a wrong offset!");
static_assert(offsetof(FMonsterBubbleInfo, Bubble) == 0x000078, "Member 'FMonsterBubbleInfo::Bubble' has a wrong offset!");

// ScriptStruct Game.TargetWarpingUpdateContext
// 0x0024 (0x0024 - 0x0000)
struct FTargetWarpingUpdateContext final
{
public:
	TWeakObjectPtr<class UAnimSequenceBase>       Animation;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAnimInstanceBase>       AnimInstanceBase;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousPosition;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentPosition;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetWarpingUpdateContext) == 0x000004, "Wrong alignment on FTargetWarpingUpdateContext");
static_assert(sizeof(FTargetWarpingUpdateContext) == 0x000024, "Wrong size on FTargetWarpingUpdateContext");
static_assert(offsetof(FTargetWarpingUpdateContext, Animation) == 0x000000, "Member 'FTargetWarpingUpdateContext::Animation' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, AnimInstanceBase) == 0x000008, "Member 'FTargetWarpingUpdateContext::AnimInstanceBase' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, PreviousPosition) == 0x000010, "Member 'FTargetWarpingUpdateContext::PreviousPosition' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, CurrentPosition) == 0x000014, "Member 'FTargetWarpingUpdateContext::CurrentPosition' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, Weight) == 0x000018, "Member 'FTargetWarpingUpdateContext::Weight' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, PlayRate) == 0x00001C, "Member 'FTargetWarpingUpdateContext::PlayRate' has a wrong offset!");
static_assert(offsetof(FTargetWarpingUpdateContext, DeltaSeconds) == 0x000020, "Member 'FTargetWarpingUpdateContext::DeltaSeconds' has a wrong offset!");

// ScriptStruct Game.MultiSpawnerItemEntry
// 0x002C (0x0038 - 0x000C)
struct FMultiSpawnerItemEntry final : public FFastArraySerializerItem
{
public:
	int32                                         TaskId;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomMonsterId;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MonsterSpawnerIds;                                 // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MonsterIds;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiSpawnerItemEntry) == 0x000008, "Wrong alignment on FMultiSpawnerItemEntry");
static_assert(sizeof(FMultiSpawnerItemEntry) == 0x000038, "Wrong size on FMultiSpawnerItemEntry");
static_assert(offsetof(FMultiSpawnerItemEntry, TaskId) == 0x00000C, "Member 'FMultiSpawnerItemEntry::TaskId' has a wrong offset!");
static_assert(offsetof(FMultiSpawnerItemEntry, RandomMonsterId) == 0x000010, "Member 'FMultiSpawnerItemEntry::RandomMonsterId' has a wrong offset!");
static_assert(offsetof(FMultiSpawnerItemEntry, MonsterSpawnerIds) == 0x000018, "Member 'FMultiSpawnerItemEntry::MonsterSpawnerIds' has a wrong offset!");
static_assert(offsetof(FMultiSpawnerItemEntry, MonsterIds) == 0x000028, "Member 'FMultiSpawnerItemEntry::MonsterIds' has a wrong offset!");

// ScriptStruct Game.MultiSpawnerArray
// 0x0010 (0x0118 - 0x0108)
struct FMultiSpawnerArray final : public FFastArraySerializer
{
public:
	TArray<struct FMultiSpawnerItemEntry>         Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiSpawnerArray) == 0x000008, "Wrong alignment on FMultiSpawnerArray");
static_assert(sizeof(FMultiSpawnerArray) == 0x000118, "Wrong size on FMultiSpawnerArray");
static_assert(offsetof(FMultiSpawnerArray, Items) == 0x000108, "Member 'FMultiSpawnerArray::Items' has a wrong offset!");

// ScriptStruct Game.ANParameter
// 0x0080 (0x0080 - 0x0000)
struct FANParameter final
{
public:
	EANParameterType                              ParameterType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParameterName;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelaySet;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      ColorCurve;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloatCurveName;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bake;                                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurveSampleCount;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector2D;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0044(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletonMesh;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture2D;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EANTransformType                              Type;                                              // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EANRelativeTransformSpace                     ANTransformSpace;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FANParameter) == 0x000008, "Wrong alignment on FANParameter");
static_assert(sizeof(FANParameter) == 0x000080, "Wrong size on FANParameter");
static_assert(offsetof(FANParameter, ParameterType) == 0x000000, "Member 'FANParameter::ParameterType' has a wrong offset!");
static_assert(offsetof(FANParameter, ParameterName) == 0x000004, "Member 'FANParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(FANParameter, DelaySet) == 0x00000C, "Member 'FANParameter::DelaySet' has a wrong offset!");
static_assert(offsetof(FANParameter, ColorCurve) == 0x000010, "Member 'FANParameter::ColorCurve' has a wrong offset!");
static_assert(offsetof(FANParameter, FloatCurveName) == 0x000018, "Member 'FANParameter::FloatCurveName' has a wrong offset!");
static_assert(offsetof(FANParameter, Bake) == 0x000020, "Member 'FANParameter::Bake' has a wrong offset!");
static_assert(offsetof(FANParameter, CurveSampleCount) == 0x000024, "Member 'FANParameter::CurveSampleCount' has a wrong offset!");
static_assert(offsetof(FANParameter, Int) == 0x000028, "Member 'FANParameter::Int' has a wrong offset!");
static_assert(offsetof(FANParameter, Float) == 0x00002C, "Member 'FANParameter::Float' has a wrong offset!");
static_assert(offsetof(FANParameter, Vector2D) == 0x000030, "Member 'FANParameter::Vector2D' has a wrong offset!");
static_assert(offsetof(FANParameter, Vector) == 0x000038, "Member 'FANParameter::Vector' has a wrong offset!");
static_assert(offsetof(FANParameter, Color) == 0x000044, "Member 'FANParameter::Color' has a wrong offset!");
static_assert(offsetof(FANParameter, StaticMesh) == 0x000058, "Member 'FANParameter::StaticMesh' has a wrong offset!");
static_assert(offsetof(FANParameter, SkeletonMesh) == 0x000060, "Member 'FANParameter::SkeletonMesh' has a wrong offset!");
static_assert(offsetof(FANParameter, Texture2D) == 0x000068, "Member 'FANParameter::Texture2D' has a wrong offset!");
static_assert(offsetof(FANParameter, SocketName) == 0x000070, "Member 'FANParameter::SocketName' has a wrong offset!");
static_assert(offsetof(FANParameter, Type) == 0x000078, "Member 'FANParameter::Type' has a wrong offset!");
static_assert(offsetof(FANParameter, ANTransformSpace) == 0x000079, "Member 'FANParameter::ANTransformSpace' has a wrong offset!");
static_assert(offsetof(FANParameter, TickInterval) == 0x00007C, "Member 'FANParameter::TickInterval' has a wrong offset!");

// ScriptStruct Game.EventTypeCount
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FEventTypeCount final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventTypeCount) == 0x000004, "Wrong alignment on FEventTypeCount");
static_assert(sizeof(FEventTypeCount) == 0x000008, "Wrong size on FEventTypeCount");

// ScriptStruct Game.OnlineSeaShipInfo
// 0x0068 (0x0070 - 0x0008)
struct FOnlineSeaShipInfo final : public FTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineSeaShipType                            Type;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HP;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReduceRatio;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurretAttackRatio;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EOnlineSeaShipPartType, TSoftObjectPtr<class UStaticMesh>> PartMeshPaths;                                     // 0x0020(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaShipInfo) == 0x000008, "Wrong alignment on FOnlineSeaShipInfo");
static_assert(sizeof(FOnlineSeaShipInfo) == 0x000070, "Wrong size on FOnlineSeaShipInfo");
static_assert(offsetof(FOnlineSeaShipInfo, Level) == 0x000008, "Member 'FOnlineSeaShipInfo::Level' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, Type) == 0x00000C, "Member 'FOnlineSeaShipInfo::Type' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, HP) == 0x000010, "Member 'FOnlineSeaShipInfo::HP' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, Exp) == 0x000014, "Member 'FOnlineSeaShipInfo::Exp' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, DamageReduceRatio) == 0x000018, "Member 'FOnlineSeaShipInfo::DamageReduceRatio' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, TurretAttackRatio) == 0x00001C, "Member 'FOnlineSeaShipInfo::TurretAttackRatio' has a wrong offset!");
static_assert(offsetof(FOnlineSeaShipInfo, PartMeshPaths) == 0x000020, "Member 'FOnlineSeaShipInfo::PartMeshPaths' has a wrong offset!");

// ScriptStruct Game.OnlineSeaExpInfo
// 0x0030 (0x0038 - 0x0008)
struct FOnlineSeaExpInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LauncherTag;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpValue;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraCoin;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaExpInfo) == 0x000008, "Wrong alignment on FOnlineSeaExpInfo");
static_assert(sizeof(FOnlineSeaExpInfo) == 0x000038, "Wrong size on FOnlineSeaExpInfo");
static_assert(offsetof(FOnlineSeaExpInfo, ID) == 0x000008, "Member 'FOnlineSeaExpInfo::ID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaExpInfo, Desc) == 0x000010, "Member 'FOnlineSeaExpInfo::Desc' has a wrong offset!");
static_assert(offsetof(FOnlineSeaExpInfo, LauncherTag) == 0x000020, "Member 'FOnlineSeaExpInfo::LauncherTag' has a wrong offset!");
static_assert(offsetof(FOnlineSeaExpInfo, ExpValue) == 0x000030, "Member 'FOnlineSeaExpInfo::ExpValue' has a wrong offset!");
static_assert(offsetof(FOnlineSeaExpInfo, ExtraCoin) == 0x000034, "Member 'FOnlineSeaExpInfo::ExtraCoin' has a wrong offset!");

// ScriptStruct Game.OnlineSeaModSkillPacket
// 0x0078 (0x0080 - 0x0008)
struct FOnlineSeaModSkillPacket final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineSeaModSkillType                        Type;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillName;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EffectDesc;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ModifierID;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ApplyTag;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconResId;                                         // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineSeaModSkillOpcode                      OpCode;                                            // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param;                                             // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param2;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediate;                                         // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineSeaModSkillPacket) == 0x000008, "Wrong alignment on FOnlineSeaModSkillPacket");
static_assert(sizeof(FOnlineSeaModSkillPacket) == 0x000080, "Wrong size on FOnlineSeaModSkillPacket");
static_assert(offsetof(FOnlineSeaModSkillPacket, ID) == 0x000008, "Member 'FOnlineSeaModSkillPacket::ID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Type) == 0x00000C, "Member 'FOnlineSeaModSkillPacket::Type' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Level) == 0x000010, "Member 'FOnlineSeaModSkillPacket::Level' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, SkillName) == 0x000018, "Member 'FOnlineSeaModSkillPacket::SkillName' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Desc) == 0x000028, "Member 'FOnlineSeaModSkillPacket::Desc' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, EffectDesc) == 0x000038, "Member 'FOnlineSeaModSkillPacket::EffectDesc' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Quality) == 0x000048, "Member 'FOnlineSeaModSkillPacket::Quality' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Active) == 0x00004C, "Member 'FOnlineSeaModSkillPacket::Active' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, ModifierID) == 0x000050, "Member 'FOnlineSeaModSkillPacket::ModifierID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, SkillID) == 0x000054, "Member 'FOnlineSeaModSkillPacket::SkillID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, ApplyTag) == 0x000058, "Member 'FOnlineSeaModSkillPacket::ApplyTag' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, IconResId) == 0x000068, "Member 'FOnlineSeaModSkillPacket::IconResId' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, OpCode) == 0x00006C, "Member 'FOnlineSeaModSkillPacket::OpCode' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Param) == 0x000070, "Member 'FOnlineSeaModSkillPacket::Param' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Param2) == 0x000074, "Member 'FOnlineSeaModSkillPacket::Param2' has a wrong offset!");
static_assert(offsetof(FOnlineSeaModSkillPacket, Immediate) == 0x000078, "Member 'FOnlineSeaModSkillPacket::Immediate' has a wrong offset!");

// ScriptStruct Game.OnlineSeaGameEvent
// 0x0060 (0x0068 - 0x0008)
struct FOnlineSeaGameEvent final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineSeaGameEventType                       EventType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EventTags;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StartTips;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FinishTips;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SimplePlotId;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaGameEvent) == 0x000008, "Wrong alignment on FOnlineSeaGameEvent");
static_assert(sizeof(FOnlineSeaGameEvent) == 0x000068, "Wrong size on FOnlineSeaGameEvent");
static_assert(offsetof(FOnlineSeaGameEvent, ID) == 0x000008, "Member 'FOnlineSeaGameEvent::ID' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, Name) == 0x000010, "Member 'FOnlineSeaGameEvent::Name' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, EventType) == 0x000020, "Member 'FOnlineSeaGameEvent::EventType' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, EventTags) == 0x000028, "Member 'FOnlineSeaGameEvent::EventTags' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, StartTips) == 0x000038, "Member 'FOnlineSeaGameEvent::StartTips' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, FinishTips) == 0x000048, "Member 'FOnlineSeaGameEvent::FinishTips' has a wrong offset!");
static_assert(offsetof(FOnlineSeaGameEvent, SimplePlotId) == 0x000058, "Member 'FOnlineSeaGameEvent::SimplePlotId' has a wrong offset!");

// ScriptStruct Game.OnlineSeaPlayerModInfo
// 0x0018 (0x0018 - 0x0000)
struct FOnlineSeaPlayerModInfo final
{
public:
	int64                                         RoleId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ModIds;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSeaPlayerModInfo) == 0x000008, "Wrong alignment on FOnlineSeaPlayerModInfo");
static_assert(sizeof(FOnlineSeaPlayerModInfo) == 0x000018, "Wrong size on FOnlineSeaPlayerModInfo");
static_assert(offsetof(FOnlineSeaPlayerModInfo, RoleId) == 0x000000, "Member 'FOnlineSeaPlayerModInfo::RoleId' has a wrong offset!");
static_assert(offsetof(FOnlineSeaPlayerModInfo, ModIds) == 0x000008, "Member 'FOnlineSeaPlayerModInfo::ModIds' has a wrong offset!");

// ScriptStruct Game.EndlessBattleActionPacket
// 0x0028 (0x0028 - 0x0000)
struct FEndlessBattleActionPacket final
{
public:
	EEndlessBattleRandomEventOpCode               OpCode;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamValue;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamValue2;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndlessBattleActionPacket) == 0x000008, "Wrong alignment on FEndlessBattleActionPacket");
static_assert(sizeof(FEndlessBattleActionPacket) == 0x000028, "Wrong size on FEndlessBattleActionPacket");
static_assert(offsetof(FEndlessBattleActionPacket, OpCode) == 0x000000, "Member 'FEndlessBattleActionPacket::OpCode' has a wrong offset!");
static_assert(offsetof(FEndlessBattleActionPacket, Tag) == 0x000008, "Member 'FEndlessBattleActionPacket::Tag' has a wrong offset!");
static_assert(offsetof(FEndlessBattleActionPacket, ParamValue) == 0x000018, "Member 'FEndlessBattleActionPacket::ParamValue' has a wrong offset!");
static_assert(offsetof(FEndlessBattleActionPacket, ParamValue2) == 0x00001C, "Member 'FEndlessBattleActionPacket::ParamValue2' has a wrong offset!");
static_assert(offsetof(FEndlessBattleActionPacket, bImmediate) == 0x000020, "Member 'FEndlessBattleActionPacket::bImmediate' has a wrong offset!");

// ScriptStruct Game.EndlessBattleRandomEvent
// 0x0058 (0x0060 - 0x0008)
struct FEndlessBattleRandomEvent final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterId;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndlessBattleRandomEventOpCode               OpCode;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParamValue;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamValue2;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventTriggerTips;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventFinishTips;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndlessBattleRandomEvent) == 0x000008, "Wrong alignment on FEndlessBattleRandomEvent");
static_assert(sizeof(FEndlessBattleRandomEvent) == 0x000060, "Wrong size on FEndlessBattleRandomEvent");
static_assert(offsetof(FEndlessBattleRandomEvent, ID) == 0x000008, "Member 'FEndlessBattleRandomEvent::ID' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, Desc) == 0x000010, "Member 'FEndlessBattleRandomEvent::Desc' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, MonsterId) == 0x000020, "Member 'FEndlessBattleRandomEvent::MonsterId' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, MonsterCount) == 0x000024, "Member 'FEndlessBattleRandomEvent::MonsterCount' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, OpCode) == 0x000028, "Member 'FEndlessBattleRandomEvent::OpCode' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, ParamValue) == 0x00002C, "Member 'FEndlessBattleRandomEvent::ParamValue' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, ParamValue2) == 0x000030, "Member 'FEndlessBattleRandomEvent::ParamValue2' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, EventTriggerTips) == 0x000038, "Member 'FEndlessBattleRandomEvent::EventTriggerTips' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, EventFinishTips) == 0x000048, "Member 'FEndlessBattleRandomEvent::EventFinishTips' has a wrong offset!");
static_assert(offsetof(FEndlessBattleRandomEvent, bImmediate) == 0x000058, "Member 'FEndlessBattleRandomEvent::bImmediate' has a wrong offset!");

// ScriptStruct Game.OnlineTDSkillOptions
// 0x0008 (0x0008 - 0x0000)
struct FOnlineTDSkillOptions final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendTeam;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendSupplies;                                   // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendAirDrop;                                    // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineTDDuty                                 Duty;                                              // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDSkillOptions) == 0x000004, "Wrong alignment on FOnlineTDSkillOptions");
static_assert(sizeof(FOnlineTDSkillOptions) == 0x000008, "Wrong size on FOnlineTDSkillOptions");
static_assert(offsetof(FOnlineTDSkillOptions, SkillID) == 0x000000, "Member 'FOnlineTDSkillOptions::SkillID' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillOptions, bAppendTeam) == 0x000004, "Member 'FOnlineTDSkillOptions::bAppendTeam' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillOptions, bAppendSupplies) == 0x000005, "Member 'FOnlineTDSkillOptions::bAppendSupplies' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillOptions, bAppendAirDrop) == 0x000006, "Member 'FOnlineTDSkillOptions::bAppendAirDrop' has a wrong offset!");
static_assert(offsetof(FOnlineTDSkillOptions, Duty) == 0x000007, "Member 'FOnlineTDSkillOptions::Duty' has a wrong offset!");

// ScriptStruct Game.DamageRank
// 0x0010 (0x0010 - 0x0000)
struct FDamageRank final
{
public:
	int64                                         RolePID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRatio;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageRatioInt;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageRank) == 0x000008, "Wrong alignment on FDamageRank");
static_assert(sizeof(FDamageRank) == 0x000010, "Wrong size on FDamageRank");
static_assert(offsetof(FDamageRank, RolePID) == 0x000000, "Member 'FDamageRank::RolePID' has a wrong offset!");
static_assert(offsetof(FDamageRank, DamageRatio) == 0x000008, "Member 'FDamageRank::DamageRatio' has a wrong offset!");
static_assert(offsetof(FDamageRank, DamageRatioInt) == 0x00000C, "Member 'FDamageRank::DamageRatioInt' has a wrong offset!");

// ScriptStruct Game.OnlineTDDropInfo
// 0x0010 (0x0010 - 0x0000)
struct FOnlineTDDropInfo final
{
public:
	EOnlineTDResourceType                         Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDDropInfo) == 0x000004, "Wrong alignment on FOnlineTDDropInfo");
static_assert(sizeof(FOnlineTDDropInfo) == 0x000010, "Wrong size on FOnlineTDDropInfo");
static_assert(offsetof(FOnlineTDDropInfo, Type) == 0x000000, "Member 'FOnlineTDDropInfo::Type' has a wrong offset!");
static_assert(offsetof(FOnlineTDDropInfo, Weight) == 0x000004, "Member 'FOnlineTDDropInfo::Weight' has a wrong offset!");
static_assert(offsetof(FOnlineTDDropInfo, Min) == 0x000008, "Member 'FOnlineTDDropInfo::Min' has a wrong offset!");
static_assert(offsetof(FOnlineTDDropInfo, Max) == 0x00000C, "Member 'FOnlineTDDropInfo::Max' has a wrong offset!");

// ScriptStruct Game.OnlineTDResourceInfo
// 0x001C (0x001C - 0x0000)
struct FOnlineTDResourceInfo final
{
public:
	EOnlineTDResourceType                         Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurCount;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBuildLevel;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShareRate;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDResourceInfo) == 0x000004, "Wrong alignment on FOnlineTDResourceInfo");
static_assert(sizeof(FOnlineTDResourceInfo) == 0x00001C, "Wrong size on FOnlineTDResourceInfo");
static_assert(offsetof(FOnlineTDResourceInfo, Type) == 0x000000, "Member 'FOnlineTDResourceInfo::Type' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, Value) == 0x000004, "Member 'FOnlineTDResourceInfo::Value' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, Weight) == 0x000008, "Member 'FOnlineTDResourceInfo::Weight' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, MaxCount) == 0x00000C, "Member 'FOnlineTDResourceInfo::MaxCount' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, CurCount) == 0x000010, "Member 'FOnlineTDResourceInfo::CurCount' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, MaxBuildLevel) == 0x000014, "Member 'FOnlineTDResourceInfo::MaxBuildLevel' has a wrong offset!");
static_assert(offsetof(FOnlineTDResourceInfo, ShareRate) == 0x000018, "Member 'FOnlineTDResourceInfo::ShareRate' has a wrong offset!");

// ScriptStruct Game.OnlineTDMonsterInfo
// 0x0008 (0x0008 - 0x0000)
struct FOnlineTDMonsterInfo final
{
public:
	int32                                         MonsterId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineTDMonsterInfo) == 0x000004, "Wrong alignment on FOnlineTDMonsterInfo");
static_assert(sizeof(FOnlineTDMonsterInfo) == 0x000008, "Wrong size on FOnlineTDMonsterInfo");
static_assert(offsetof(FOnlineTDMonsterInfo, MonsterId) == 0x000000, "Member 'FOnlineTDMonsterInfo::MonsterId' has a wrong offset!");
static_assert(offsetof(FOnlineTDMonsterInfo, Damage) == 0x000004, "Member 'FOnlineTDMonsterInfo::Damage' has a wrong offset!");

// ScriptStruct Game.BaseSkillLayerInfo
// 0x0008 (0x0008 - 0x0000)
struct FBaseSkillLayerInfo final
{
public:
	int32                                         BuffId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayers;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseSkillLayerInfo) == 0x000004, "Wrong alignment on FBaseSkillLayerInfo");
static_assert(sizeof(FBaseSkillLayerInfo) == 0x000008, "Wrong size on FBaseSkillLayerInfo");
static_assert(offsetof(FBaseSkillLayerInfo, BuffId) == 0x000000, "Member 'FBaseSkillLayerInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FBaseSkillLayerInfo, BuffLayers) == 0x000004, "Member 'FBaseSkillLayerInfo::BuffLayers' has a wrong offset!");

// ScriptStruct Game.TDResourceConfig
// 0x0018 (0x0020 - 0x0008)
struct FTDResourceConfig final : public FTableRowBase
{
public:
	int32                                         ResId;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResDesc;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTDResourceConfig) == 0x000008, "Wrong alignment on FTDResourceConfig");
static_assert(sizeof(FTDResourceConfig) == 0x000020, "Wrong size on FTDResourceConfig");
static_assert(offsetof(FTDResourceConfig, ResId) == 0x000008, "Member 'FTDResourceConfig::ResId' has a wrong offset!");
static_assert(offsetof(FTDResourceConfig, ResDesc) == 0x000010, "Member 'FTDResourceConfig::ResDesc' has a wrong offset!");

// ScriptStruct Game.PalBuffInfo
// 0x000C (0x000C - 0x0000)
struct FPalBuffInfo final
{
public:
	int32                                         BuffType;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLevel;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPalBuffInfo) == 0x000004, "Wrong alignment on FPalBuffInfo");
static_assert(sizeof(FPalBuffInfo) == 0x00000C, "Wrong size on FPalBuffInfo");
static_assert(offsetof(FPalBuffInfo, BuffType) == 0x000000, "Member 'FPalBuffInfo::BuffType' has a wrong offset!");
static_assert(offsetof(FPalBuffInfo, BuffId) == 0x000004, "Member 'FPalBuffInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FPalBuffInfo, BuffLevel) == 0x000008, "Member 'FPalBuffInfo::BuffLevel' has a wrong offset!");

// ScriptStruct Game.FriendPalInfo
// 0x0038 (0x0038 - 0x0000)
struct FFriendPalInfo final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterTmpId;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPalBuffInfo>                   BuffList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AttackScale;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenseScale;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpPointScale;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorLevel;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFriendPalInfo) == 0x000008, "Wrong alignment on FFriendPalInfo");
static_assert(sizeof(FFriendPalInfo) == 0x000038, "Wrong size on FFriendPalInfo");
static_assert(offsetof(FFriendPalInfo, ItemId) == 0x000000, "Member 'FFriendPalInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, MonsterTmpId) == 0x000004, "Member 'FFriendPalInfo::MonsterTmpId' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, BuffList) == 0x000008, "Member 'FFriendPalInfo::BuffList' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, AttackScale) == 0x000018, "Member 'FFriendPalInfo::AttackScale' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, DefenseScale) == 0x00001C, "Member 'FFriendPalInfo::DefenseScale' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, HpPointScale) == 0x000020, "Member 'FFriendPalInfo::HpPointScale' has a wrong offset!");
static_assert(offsetof(FFriendPalInfo, ColorLevel) == 0x000024, "Member 'FFriendPalInfo::ColorLevel' has a wrong offset!");

// ScriptStruct Game.PalMonsterSpawnGroup
// 0x0018 (0x0020 - 0x0008)
struct FPalMonsterSpawnGroup final : public FTableRowBase
{
public:
	int32                                         GroupId;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsGroupType;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnNpcByStruct>              SpawnInfos;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPalMonsterSpawnGroup) == 0x000008, "Wrong alignment on FPalMonsterSpawnGroup");
static_assert(sizeof(FPalMonsterSpawnGroup) == 0x000020, "Wrong size on FPalMonsterSpawnGroup");
static_assert(offsetof(FPalMonsterSpawnGroup, GroupId) == 0x000008, "Member 'FPalMonsterSpawnGroup::GroupId' has a wrong offset!");
static_assert(offsetof(FPalMonsterSpawnGroup, MonsGroupType) == 0x00000C, "Member 'FPalMonsterSpawnGroup::MonsGroupType' has a wrong offset!");
static_assert(offsetof(FPalMonsterSpawnGroup, SpawnInfos) == 0x000010, "Member 'FPalMonsterSpawnGroup::SpawnInfos' has a wrong offset!");

// ScriptStruct Game.ParticleSystemComponentRuntimeInfo
// 0x0058 (0x0058 - 0x0000)
struct FParticleSystemComponentRuntimeInfo final
{
public:
	bool                                          bValid;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBox2D>                         ScreenBox;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TotalValue;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameValue;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSceneColor;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllUnlit;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        RefTextures;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalParticleCount;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTextureSamplerCount;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleCount;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODCount;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterCount;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModuleCount;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighQualityLightCount;                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllNoNeverStreaming;                              // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllTexture512;                                    // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleSystemComponentRuntimeInfo) == 0x000008, "Wrong alignment on FParticleSystemComponentRuntimeInfo");
static_assert(sizeof(FParticleSystemComponentRuntimeInfo) == 0x000058, "Wrong size on FParticleSystemComponentRuntimeInfo");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bValid) == 0x000000, "Member 'FParticleSystemComponentRuntimeInfo::bValid' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, ScreenBox) == 0x000008, "Member 'FParticleSystemComponentRuntimeInfo::ScreenBox' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, TotalValue) == 0x000018, "Member 'FParticleSystemComponentRuntimeInfo::TotalValue' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, FrameValue) == 0x00001C, "Member 'FParticleSystemComponentRuntimeInfo::FrameValue' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bHasSceneColor) == 0x000020, "Member 'FParticleSystemComponentRuntimeInfo::bHasSceneColor' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bAllUnlit) == 0x000021, "Member 'FParticleSystemComponentRuntimeInfo::bAllUnlit' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, RefTextures) == 0x000028, "Member 'FParticleSystemComponentRuntimeInfo::RefTextures' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, TotalParticleCount) == 0x000038, "Member 'FParticleSystemComponentRuntimeInfo::TotalParticleCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, TotalTextureSamplerCount) == 0x00003C, "Member 'FParticleSystemComponentRuntimeInfo::TotalTextureSamplerCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, MaxParticleCount) == 0x000040, "Member 'FParticleSystemComponentRuntimeInfo::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, LODCount) == 0x000044, "Member 'FParticleSystemComponentRuntimeInfo::LODCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, EmitterCount) == 0x000048, "Member 'FParticleSystemComponentRuntimeInfo::EmitterCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, ModuleCount) == 0x00004C, "Member 'FParticleSystemComponentRuntimeInfo::ModuleCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, HighQualityLightCount) == 0x000050, "Member 'FParticleSystemComponentRuntimeInfo::HighQualityLightCount' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bLoop) == 0x000054, "Member 'FParticleSystemComponentRuntimeInfo::bLoop' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bAllNoNeverStreaming) == 0x000055, "Member 'FParticleSystemComponentRuntimeInfo::bAllNoNeverStreaming' has a wrong offset!");
static_assert(offsetof(FParticleSystemComponentRuntimeInfo, bAllTexture512) == 0x000056, "Member 'FParticleSystemComponentRuntimeInfo::bAllTexture512' has a wrong offset!");

// ScriptStruct Game.WeightPatrolPoint
// 0x0010 (0x0010 - 0x0000)
struct FWeightPatrolPoint final
{
public:
	class AActor*                                 PatrolPoint;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightPatrolPoint) == 0x000008, "Wrong alignment on FWeightPatrolPoint");
static_assert(sizeof(FWeightPatrolPoint) == 0x000010, "Wrong size on FWeightPatrolPoint");
static_assert(offsetof(FWeightPatrolPoint, PatrolPoint) == 0x000000, "Member 'FWeightPatrolPoint::PatrolPoint' has a wrong offset!");
static_assert(offsetof(FWeightPatrolPoint, Weight) == 0x000008, "Member 'FWeightPatrolPoint::Weight' has a wrong offset!");

// ScriptStruct Game.CustomBreastPhyDataSection
// 0x000C (0x000C - 0x0000)
struct FCustomBreastPhyDataSection final
{
public:
	EUIWidgetAnimType                             WidgetAnimType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetPhyAlpha;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomSimulationSpace                        SimulationSpace;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomPhysicsType                            CustomBreastType;                                  // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomBreastPhyDataSection) == 0x000004, "Wrong alignment on FCustomBreastPhyDataSection");
static_assert(sizeof(FCustomBreastPhyDataSection) == 0x00000C, "Wrong size on FCustomBreastPhyDataSection");
static_assert(offsetof(FCustomBreastPhyDataSection, WidgetAnimType) == 0x000000, "Member 'FCustomBreastPhyDataSection::WidgetAnimType' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataSection, TargetPhyAlpha) == 0x000004, "Member 'FCustomBreastPhyDataSection::TargetPhyAlpha' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataSection, SimulationSpace) == 0x000008, "Member 'FCustomBreastPhyDataSection::SimulationSpace' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataSection, CustomBreastType) == 0x000009, "Member 'FCustomBreastPhyDataSection::CustomBreastType' has a wrong offset!");

// ScriptStruct Game.CustomBreastPhyDataTemplate
// 0x0020 (0x0028 - 0x0008)
struct FCustomBreastPhyDataTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterSkinID;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewSkeleton;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomBreastPhyDataSection>    CustomBreastPhyDataContainer;                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomBreastPhyDataTemplate) == 0x000008, "Wrong alignment on FCustomBreastPhyDataTemplate");
static_assert(sizeof(FCustomBreastPhyDataTemplate) == 0x000028, "Wrong size on FCustomBreastPhyDataTemplate");
static_assert(offsetof(FCustomBreastPhyDataTemplate, ID) == 0x000008, "Member 'FCustomBreastPhyDataTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataTemplate, CharacterID) == 0x00000C, "Member 'FCustomBreastPhyDataTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataTemplate, CharacterSkinID) == 0x000010, "Member 'FCustomBreastPhyDataTemplate::CharacterSkinID' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataTemplate, bIsNewSkeleton) == 0x000014, "Member 'FCustomBreastPhyDataTemplate::bIsNewSkeleton' has a wrong offset!");
static_assert(offsetof(FCustomBreastPhyDataTemplate, CustomBreastPhyDataContainer) == 0x000018, "Member 'FCustomBreastPhyDataTemplate::CustomBreastPhyDataContainer' has a wrong offset!");

// ScriptStruct Game.InteractionBlendSpaceAndIKTemplate
// 0x0040 (0x0048 - 0x0008)
struct FInteractionBlendSpaceAndIKTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterID;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterSkinID;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollisionID;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomInteractionType                        InteractionType;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomInteractionBodyPartsType               BodyParts;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBlendSpace>             BlendSpace;                                        // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionBlendSpaceAndIKTemplate) == 0x000008, "Wrong alignment on FInteractionBlendSpaceAndIKTemplate");
static_assert(sizeof(FInteractionBlendSpaceAndIKTemplate) == 0x000048, "Wrong size on FInteractionBlendSpaceAndIKTemplate");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, ID) == 0x000008, "Member 'FInteractionBlendSpaceAndIKTemplate::ID' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, CharacterID) == 0x00000C, "Member 'FInteractionBlendSpaceAndIKTemplate::CharacterID' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, CharacterSkinID) == 0x000010, "Member 'FInteractionBlendSpaceAndIKTemplate::CharacterSkinID' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, CollisionID) == 0x000014, "Member 'FInteractionBlendSpaceAndIKTemplate::CollisionID' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, InteractionType) == 0x000018, "Member 'FInteractionBlendSpaceAndIKTemplate::InteractionType' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, BodyParts) == 0x000019, "Member 'FInteractionBlendSpaceAndIKTemplate::BodyParts' has a wrong offset!");
static_assert(offsetof(FInteractionBlendSpaceAndIKTemplate, BlendSpace) == 0x000020, "Member 'FInteractionBlendSpaceAndIKTemplate::BlendSpace' has a wrong offset!");

// ScriptStruct Game.PerformanceAnimTrrigerCondition
// 0x0048 (0x0048 - 0x0000)
struct FPerformanceAnimTrrigerCondition final
{
public:
	TSubclassOf<class UPerformanceAnimConditionBase> Condition;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Params_Float;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<bool>                                  Params_Bool;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 Params_Enum;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         Params_String;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformanceAnimTrrigerCondition) == 0x000008, "Wrong alignment on FPerformanceAnimTrrigerCondition");
static_assert(sizeof(FPerformanceAnimTrrigerCondition) == 0x000048, "Wrong size on FPerformanceAnimTrrigerCondition");
static_assert(offsetof(FPerformanceAnimTrrigerCondition, Condition) == 0x000000, "Member 'FPerformanceAnimTrrigerCondition::Condition' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimTrrigerCondition, Params_Float) == 0x000008, "Member 'FPerformanceAnimTrrigerCondition::Params_Float' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimTrrigerCondition, Params_Bool) == 0x000018, "Member 'FPerformanceAnimTrrigerCondition::Params_Bool' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimTrrigerCondition, Params_Enum) == 0x000028, "Member 'FPerformanceAnimTrrigerCondition::Params_Enum' has a wrong offset!");
static_assert(offsetof(FPerformanceAnimTrrigerCondition, Params_String) == 0x000038, "Member 'FPerformanceAnimTrrigerCondition::Params_String' has a wrong offset!");

// ScriptStruct Game.CharacterPerformanceAnimSequenceTemplate
// 0x0060 (0x0068 - 0x0008)
struct FCharacterPerformanceAnimSequenceTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EUIWidgetAnimType>                     WidgetAnimTypeContainer;                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterPerformanceAnimTriggerType          ActivateType;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerformanceAnimTrrigerCondition> TriggerConditions;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EPerformanceTriggerConditionRelationType      TriggerConditionRelation;                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimSequenceLoopConfigID;                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterPerformanceAnimSequenceTemplate) == 0x000008, "Wrong alignment on FCharacterPerformanceAnimSequenceTemplate");
static_assert(sizeof(FCharacterPerformanceAnimSequenceTemplate) == 0x000068, "Wrong size on FCharacterPerformanceAnimSequenceTemplate");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, ID) == 0x000008, "Member 'FCharacterPerformanceAnimSequenceTemplate::ID' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, WidgetAnimTypeContainer) == 0x000010, "Member 'FCharacterPerformanceAnimSequenceTemplate::WidgetAnimTypeContainer' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, CharacterName) == 0x000020, "Member 'FCharacterPerformanceAnimSequenceTemplate::CharacterName' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, Desc) == 0x000030, "Member 'FCharacterPerformanceAnimSequenceTemplate::Desc' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, ActivateType) == 0x000040, "Member 'FCharacterPerformanceAnimSequenceTemplate::ActivateType' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, TriggerConditions) == 0x000048, "Member 'FCharacterPerformanceAnimSequenceTemplate::TriggerConditions' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, TriggerConditionRelation) == 0x000058, "Member 'FCharacterPerformanceAnimSequenceTemplate::TriggerConditionRelation' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, Priority) == 0x00005C, "Member 'FCharacterPerformanceAnimSequenceTemplate::Priority' has a wrong offset!");
static_assert(offsetof(FCharacterPerformanceAnimSequenceTemplate, AnimSequenceLoopConfigID) == 0x000060, "Member 'FCharacterPerformanceAnimSequenceTemplate::AnimSequenceLoopConfigID' has a wrong offset!");

// ScriptStruct Game.WeaponOverLoad
// 0x0060 (0x0060 - 0x0000)
struct FWeaponOverLoad final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectSlot;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         EffectAsset;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EffectTransform;                                   // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 SoundEvent;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponOverLoad) == 0x000010, "Wrong alignment on FWeaponOverLoad");
static_assert(sizeof(FWeaponOverLoad) == 0x000060, "Wrong size on FWeaponOverLoad");
static_assert(offsetof(FWeaponOverLoad, Time) == 0x000000, "Member 'FWeaponOverLoad::Time' has a wrong offset!");
static_assert(offsetof(FWeaponOverLoad, EffectSlot) == 0x000004, "Member 'FWeaponOverLoad::EffectSlot' has a wrong offset!");
static_assert(offsetof(FWeaponOverLoad, EffectAsset) == 0x000010, "Member 'FWeaponOverLoad::EffectAsset' has a wrong offset!");
static_assert(offsetof(FWeaponOverLoad, EffectTransform) == 0x000020, "Member 'FWeaponOverLoad::EffectTransform' has a wrong offset!");
static_assert(offsetof(FWeaponOverLoad, SoundEvent) == 0x000050, "Member 'FWeaponOverLoad::SoundEvent' has a wrong offset!");

// ScriptStruct Game.PortalBeforeData
// 0x0004 (0x0004 - 0x0000)
struct FPortalBeforeData final
{
public:
	float                                         Velocity;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPortalBeforeData) == 0x000004, "Wrong alignment on FPortalBeforeData");
static_assert(sizeof(FPortalBeforeData) == 0x000004, "Wrong size on FPortalBeforeData");
static_assert(offsetof(FPortalBeforeData, Velocity) == 0x000000, "Member 'FPortalBeforeData::Velocity' has a wrong offset!");

// ScriptStruct Game.CaptureTargetActorCacheInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCaptureTargetActorCacheInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaptureTargetActorCacheInfo) == 0x000004, "Wrong alignment on FCaptureTargetActorCacheInfo");
static_assert(sizeof(FCaptureTargetActorCacheInfo) == 0x00000C, "Wrong size on FCaptureTargetActorCacheInfo");

// ScriptStruct Game.PostProcessMaterialTemplate
// 0x0020 (0x0028 - 0x0008)
struct FPostProcessMaterialTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessType                              PostProcessType;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MaterialTemplatePath;                              // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessMaterialTemplate) == 0x000008, "Wrong alignment on FPostProcessMaterialTemplate");
static_assert(sizeof(FPostProcessMaterialTemplate) == 0x000028, "Wrong size on FPostProcessMaterialTemplate");
static_assert(offsetof(FPostProcessMaterialTemplate, ID) == 0x000008, "Member 'FPostProcessMaterialTemplate::ID' has a wrong offset!");
static_assert(offsetof(FPostProcessMaterialTemplate, PostProcessType) == 0x00000C, "Member 'FPostProcessMaterialTemplate::PostProcessType' has a wrong offset!");
static_assert(offsetof(FPostProcessMaterialTemplate, MaterialTemplatePath) == 0x000010, "Member 'FPostProcessMaterialTemplate::MaterialTemplatePath' has a wrong offset!");

// ScriptStruct Game.PPMaterialBlendInfo
// 0x0018 (0x0018 - 0x0000)
struct FPPMaterialBlendInfo final
{
public:
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPPMaterialBlendInfo) == 0x000008, "Wrong alignment on FPPMaterialBlendInfo");
static_assert(sizeof(FPPMaterialBlendInfo) == 0x000018, "Wrong size on FPPMaterialBlendInfo");
static_assert(offsetof(FPPMaterialBlendInfo, Mid) == 0x000000, "Member 'FPPMaterialBlendInfo::Mid' has a wrong offset!");

// ScriptStruct Game.NewPPStateInfo
// 0x0018 (0x0018 - 0x0000)
struct FNewPPStateInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessParams*                     Params;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPostProcessCommon*                     PPState;                                           // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewPPStateInfo) == 0x000008, "Wrong alignment on FNewPPStateInfo");
static_assert(sizeof(FNewPPStateInfo) == 0x000018, "Wrong size on FNewPPStateInfo");
static_assert(offsetof(FNewPPStateInfo, Params) == 0x000008, "Member 'FNewPPStateInfo::Params' has a wrong offset!");
static_assert(offsetof(FNewPPStateInfo, PPState) == 0x000010, "Member 'FNewPPStateInfo::PPState' has a wrong offset!");

// ScriptStruct Game.PreloadNpcInfo
// 0x0040 (0x0040 - 0x0000)
struct FPreloadNpcInfo final
{
public:
	TArray<int32>                                 ClientIndexes;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 ServerIndexes;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 SummonIds;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 SoundsToPreLoad;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreloadNpcInfo) == 0x000008, "Wrong alignment on FPreloadNpcInfo");
static_assert(sizeof(FPreloadNpcInfo) == 0x000040, "Wrong size on FPreloadNpcInfo");
static_assert(offsetof(FPreloadNpcInfo, ClientIndexes) == 0x000000, "Member 'FPreloadNpcInfo::ClientIndexes' has a wrong offset!");
static_assert(offsetof(FPreloadNpcInfo, ServerIndexes) == 0x000010, "Member 'FPreloadNpcInfo::ServerIndexes' has a wrong offset!");
static_assert(offsetof(FPreloadNpcInfo, SummonIds) == 0x000020, "Member 'FPreloadNpcInfo::SummonIds' has a wrong offset!");
static_assert(offsetof(FPreloadNpcInfo, SoundsToPreLoad) == 0x000030, "Member 'FPreloadNpcInfo::SoundsToPreLoad' has a wrong offset!");

// ScriptStruct Game.PreLoadNpcByStructHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPreLoadNpcByStructHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreLoadNpcByStructHandle) == 0x000008, "Wrong alignment on FPreLoadNpcByStructHandle");
static_assert(sizeof(FPreLoadNpcByStructHandle) == 0x000010, "Wrong size on FPreLoadNpcByStructHandle");

// ScriptStruct Game.WidgetBaseAccessoryAnimData_Runtime
// 0x0018 (0x0018 - 0x0000)
struct FWidgetBaseAccessoryAnimData_Runtime final
{
public:
	TArray<EUIWidgetAnimType>                     WidgetTypeContainer;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetBaseAccessoryAnimData_Runtime) == 0x000008, "Wrong alignment on FWidgetBaseAccessoryAnimData_Runtime");
static_assert(sizeof(FWidgetBaseAccessoryAnimData_Runtime) == 0x000018, "Wrong size on FWidgetBaseAccessoryAnimData_Runtime");
static_assert(offsetof(FWidgetBaseAccessoryAnimData_Runtime, WidgetTypeContainer) == 0x000000, "Member 'FWidgetBaseAccessoryAnimData_Runtime::WidgetTypeContainer' has a wrong offset!");
static_assert(offsetof(FWidgetBaseAccessoryAnimData_Runtime, AnimSequence) == 0x000010, "Member 'FWidgetBaseAccessoryAnimData_Runtime::AnimSequence' has a wrong offset!");

// ScriptStruct Game.WidgetBaseStandAnimData_Runtime
// 0x0018 (0x0018 - 0x0000)
struct FWidgetBaseStandAnimData_Runtime final
{
public:
	TArray<EUIWidgetAnimType>                     WidgetTypeContainer;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetBaseStandAnimData_Runtime) == 0x000008, "Wrong alignment on FWidgetBaseStandAnimData_Runtime");
static_assert(sizeof(FWidgetBaseStandAnimData_Runtime) == 0x000018, "Wrong size on FWidgetBaseStandAnimData_Runtime");
static_assert(offsetof(FWidgetBaseStandAnimData_Runtime, WidgetTypeContainer) == 0x000000, "Member 'FWidgetBaseStandAnimData_Runtime::WidgetTypeContainer' has a wrong offset!");
static_assert(offsetof(FWidgetBaseStandAnimData_Runtime, AnimSequence) == 0x000010, "Member 'FWidgetBaseStandAnimData_Runtime::AnimSequence' has a wrong offset!");

// ScriptStruct Game.PSHandShowElement_lua
// 0x00E8 (0x00E8 - 0x0000)
struct FPSHandShowElement_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandShowAnimID;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HandShowAnimName;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           HandShowAnim;                                      // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecilHandShow;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPSCharacterPose, TSoftObjectPtr<class UAnimSequence>> SpecilHandShows;                                   // 0x0048(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x0098(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSHandShowElement_lua) == 0x000008, "Wrong alignment on FPSHandShowElement_lua");
static_assert(sizeof(FPSHandShowElement_lua) == 0x0000E8, "Wrong size on FPSHandShowElement_lua");
static_assert(offsetof(FPSHandShowElement_lua, ID) == 0x000000, "Member 'FPSHandShowElement_lua::ID' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, HandShowAnimID) == 0x000004, "Member 'FPSHandShowElement_lua::HandShowAnimID' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, HandShowAnimName) == 0x000008, "Member 'FPSHandShowElement_lua::HandShowAnimName' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, HandShowAnim) == 0x000018, "Member 'FPSHandShowElement_lua::HandShowAnim' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, bSpecilHandShow) == 0x000040, "Member 'FPSHandShowElement_lua::bSpecilHandShow' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, SpecilHandShows) == 0x000048, "Member 'FPSHandShowElement_lua::SpecilHandShows' has a wrong offset!");
static_assert(offsetof(FPSHandShowElement_lua, OtherParams) == 0x000098, "Member 'FPSHandShowElement_lua::OtherParams' has a wrong offset!");

// ScriptStruct Game.PSMapConfig_lua
// 0x00A0 (0x00A0 - 0x0000)
struct FPSMapConfig_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          MapNames;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EPSCharacterPos>                       CharacterPos;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPSCharacterPos>                       AnalystPos;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EPSCharacterPos                               AnalystInitPos;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPSCharacterPos>                       CharacterInitPos;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSMapConfig_lua) == 0x000008, "Wrong alignment on FPSMapConfig_lua");
static_assert(sizeof(FPSMapConfig_lua) == 0x0000A0, "Wrong size on FPSMapConfig_lua");
static_assert(offsetof(FPSMapConfig_lua, ID) == 0x000000, "Member 'FPSMapConfig_lua::ID' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, MapNames) == 0x000008, "Member 'FPSMapConfig_lua::MapNames' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, CharacterPos) == 0x000018, "Member 'FPSMapConfig_lua::CharacterPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, AnalystPos) == 0x000028, "Member 'FPSMapConfig_lua::AnalystPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, AnalystInitPos) == 0x000038, "Member 'FPSMapConfig_lua::AnalystInitPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, CharacterInitPos) == 0x000040, "Member 'FPSMapConfig_lua::CharacterInitPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig_lua, OtherParams) == 0x000050, "Member 'FPSMapConfig_lua::OtherParams' has a wrong offset!");

// ScriptStruct Game.PSMapConfig
// 0x00A0 (0x00A8 - 0x0008)
struct FPSMapConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          MapNames;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EPSCharacterPos>                       CharacterPos;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPSCharacterPos>                       AnalystPos;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EPSCharacterPos                               AnalystInitPos;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPSCharacterPos>                       CharacterInitPos;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSMapConfig) == 0x000008, "Wrong alignment on FPSMapConfig");
static_assert(sizeof(FPSMapConfig) == 0x0000A8, "Wrong size on FPSMapConfig");
static_assert(offsetof(FPSMapConfig, ID) == 0x000008, "Member 'FPSMapConfig::ID' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, MapNames) == 0x000010, "Member 'FPSMapConfig::MapNames' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, CharacterPos) == 0x000020, "Member 'FPSMapConfig::CharacterPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, AnalystPos) == 0x000030, "Member 'FPSMapConfig::AnalystPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, AnalystInitPos) == 0x000040, "Member 'FPSMapConfig::AnalystInitPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, CharacterInitPos) == 0x000048, "Member 'FPSMapConfig::CharacterInitPos' has a wrong offset!");
static_assert(offsetof(FPSMapConfig, OtherParams) == 0x000058, "Member 'FPSMapConfig::OtherParams' has a wrong offset!");

// ScriptStruct Game.PSExpressionElementConfig_lua
// 0x0188 (0x0188 - 0x0000)
struct FPSExpressionElementConfig_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpressionAnimID;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpressionAnimName;                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ExpressionAnim;                                    // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecilExpress;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequence>           SpecilExpress;                                     // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlinkEyeLeft;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlinkEyeRight;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            BlinkEyeMontage;                                   // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkEyeLeft;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkEyeRight;                                    // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeBothAnim;                                  // 0x00C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeRightAnim;                                 // 0x00E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BlinkEyeLeftAnim;                                  // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x0138(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSExpressionElementConfig_lua) == 0x000008, "Wrong alignment on FPSExpressionElementConfig_lua");
static_assert(sizeof(FPSExpressionElementConfig_lua) == 0x000188, "Wrong size on FPSExpressionElementConfig_lua");
static_assert(offsetof(FPSExpressionElementConfig_lua, ID) == 0x000000, "Member 'FPSExpressionElementConfig_lua::ID' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, ExpressionAnimID) == 0x000004, "Member 'FPSExpressionElementConfig_lua::ExpressionAnimID' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, ExpressionAnimName) == 0x000008, "Member 'FPSExpressionElementConfig_lua::ExpressionAnimName' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, ExpressionAnim) == 0x000018, "Member 'FPSExpressionElementConfig_lua::ExpressionAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, bSpecilExpress) == 0x000040, "Member 'FPSExpressionElementConfig_lua::bSpecilExpress' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, SpecilExpress) == 0x000048, "Member 'FPSExpressionElementConfig_lua::SpecilExpress' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeLeft) == 0x000070, "Member 'FPSExpressionElementConfig_lua::BlinkEyeLeft' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeRight) == 0x000080, "Member 'FPSExpressionElementConfig_lua::BlinkEyeRight' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeMontage) == 0x000090, "Member 'FPSExpressionElementConfig_lua::BlinkEyeMontage' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, bBlinkEyeLeft) == 0x0000B8, "Member 'FPSExpressionElementConfig_lua::bBlinkEyeLeft' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, bBlinkEyeRight) == 0x0000B9, "Member 'FPSExpressionElementConfig_lua::bBlinkEyeRight' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeBothAnim) == 0x0000C0, "Member 'FPSExpressionElementConfig_lua::BlinkEyeBothAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeRightAnim) == 0x0000E8, "Member 'FPSExpressionElementConfig_lua::BlinkEyeRightAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, BlinkEyeLeftAnim) == 0x000110, "Member 'FPSExpressionElementConfig_lua::BlinkEyeLeftAnim' has a wrong offset!");
static_assert(offsetof(FPSExpressionElementConfig_lua, OtherParams) == 0x000138, "Member 'FPSExpressionElementConfig_lua::OtherParams' has a wrong offset!");

// ScriptStruct Game.RingConfigExtra
// 0x0080 (0x0080 - 0x0000)
struct FRingConfigExtra final
{
public:
	int32                                         SlotId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuitId;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PosOffset;                                         // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOffset;                                         // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            OtherParams;                                       // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRingConfigExtra) == 0x000008, "Wrong alignment on FRingConfigExtra");
static_assert(sizeof(FRingConfigExtra) == 0x000080, "Wrong size on FRingConfigExtra");
static_assert(offsetof(FRingConfigExtra, SlotId) == 0x000000, "Member 'FRingConfigExtra::SlotId' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, SuitId) == 0x000004, "Member 'FRingConfigExtra::SuitId' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, SlotName) == 0x000008, "Member 'FRingConfigExtra::SlotName' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, PosOffset) == 0x000010, "Member 'FRingConfigExtra::PosOffset' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, RotOffset) == 0x00001C, "Member 'FRingConfigExtra::RotOffset' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, Scale) == 0x000028, "Member 'FRingConfigExtra::Scale' has a wrong offset!");
static_assert(offsetof(FRingConfigExtra, OtherParams) == 0x000030, "Member 'FRingConfigExtra::OtherParams' has a wrong offset!");

// ScriptStruct Game.PSActionShowElementConfig_lua
// 0x0140 (0x0140 - 0x0000)
struct FPSActionShowElementConfig_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionAnimID;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionAnimName;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ActionAnim;                                        // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PoseAnimName;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           PoseAnim;                                          // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddTiveAlpha;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ULevelSequence>          CameraAnimRes;                                     // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x00B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x00BC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadFollowYawLimit;                                // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadFollowPitchLimit;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRingConfig;                                    // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRingConfigExtra>               RingOffsets;                                       // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSActionShowElementConfig_lua) == 0x000008, "Wrong alignment on FPSActionShowElementConfig_lua");
static_assert(sizeof(FPSActionShowElementConfig_lua) == 0x000140, "Wrong size on FPSActionShowElementConfig_lua");
static_assert(offsetof(FPSActionShowElementConfig_lua, ID) == 0x000000, "Member 'FPSActionShowElementConfig_lua::ID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, SkinID) == 0x000004, "Member 'FPSActionShowElementConfig_lua::SkinID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, ActionAnimID) == 0x000008, "Member 'FPSActionShowElementConfig_lua::ActionAnimID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, ActionAnimName) == 0x000010, "Member 'FPSActionShowElementConfig_lua::ActionAnimName' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, ActionAnim) == 0x000020, "Member 'FPSActionShowElementConfig_lua::ActionAnim' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, PoseAnimName) == 0x000048, "Member 'FPSActionShowElementConfig_lua::PoseAnimName' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, PoseAnim) == 0x000058, "Member 'FPSActionShowElementConfig_lua::PoseAnim' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, AddTiveAlpha) == 0x000080, "Member 'FPSActionShowElementConfig_lua::AddTiveAlpha' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, CameraAnimRes) == 0x000088, "Member 'FPSActionShowElementConfig_lua::CameraAnimRes' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, LocationOffset) == 0x0000B0, "Member 'FPSActionShowElementConfig_lua::LocationOffset' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, RotationOffset) == 0x0000BC, "Member 'FPSActionShowElementConfig_lua::RotationOffset' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, HeadFollowYawLimit) == 0x0000C8, "Member 'FPSActionShowElementConfig_lua::HeadFollowYawLimit' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, HeadFollowPitchLimit) == 0x0000D0, "Member 'FPSActionShowElementConfig_lua::HeadFollowPitchLimit' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, bUseRingConfig) == 0x0000D8, "Member 'FPSActionShowElementConfig_lua::bUseRingConfig' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, RingOffsets) == 0x0000E0, "Member 'FPSActionShowElementConfig_lua::RingOffsets' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig_lua, OtherParams) == 0x0000F0, "Member 'FPSActionShowElementConfig_lua::OtherParams' has a wrong offset!");

// ScriptStruct Game.PSActionShowElementConfig
// 0x0140 (0x0148 - 0x0008)
struct FPSActionShowElementConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinID;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionAnimID;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionAnimName;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ActionAnim;                                        // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PoseAnimName;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           PoseAnim;                                          // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddTiveAlpha;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ULevelSequence>          CameraAnimRes;                                     // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadFollowYawLimit;                                // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadFollowPitchLimit;                              // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRingConfig;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRingConfigExtra>               RingOffsets;                                       // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x00F8(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSActionShowElementConfig) == 0x000008, "Wrong alignment on FPSActionShowElementConfig");
static_assert(sizeof(FPSActionShowElementConfig) == 0x000148, "Wrong size on FPSActionShowElementConfig");
static_assert(offsetof(FPSActionShowElementConfig, ID) == 0x000008, "Member 'FPSActionShowElementConfig::ID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, SkinID) == 0x00000C, "Member 'FPSActionShowElementConfig::SkinID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, ActionAnimID) == 0x000010, "Member 'FPSActionShowElementConfig::ActionAnimID' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, ActionAnimName) == 0x000018, "Member 'FPSActionShowElementConfig::ActionAnimName' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, ActionAnim) == 0x000028, "Member 'FPSActionShowElementConfig::ActionAnim' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, PoseAnimName) == 0x000050, "Member 'FPSActionShowElementConfig::PoseAnimName' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, PoseAnim) == 0x000060, "Member 'FPSActionShowElementConfig::PoseAnim' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, AddTiveAlpha) == 0x000088, "Member 'FPSActionShowElementConfig::AddTiveAlpha' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, CameraAnimRes) == 0x000090, "Member 'FPSActionShowElementConfig::CameraAnimRes' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, LocationOffset) == 0x0000B8, "Member 'FPSActionShowElementConfig::LocationOffset' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, RotationOffset) == 0x0000C4, "Member 'FPSActionShowElementConfig::RotationOffset' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, HeadFollowYawLimit) == 0x0000D0, "Member 'FPSActionShowElementConfig::HeadFollowYawLimit' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, HeadFollowPitchLimit) == 0x0000D8, "Member 'FPSActionShowElementConfig::HeadFollowPitchLimit' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, bUseRingConfig) == 0x0000E0, "Member 'FPSActionShowElementConfig::bUseRingConfig' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, RingOffsets) == 0x0000E8, "Member 'FPSActionShowElementConfig::RingOffsets' has a wrong offset!");
static_assert(offsetof(FPSActionShowElementConfig, OtherParams) == 0x0000F8, "Member 'FPSActionShowElementConfig::OtherParams' has a wrong offset!");

// ScriptStruct Game.PhotoCharacterConfig_lua
// 0x0140 (0x0140 - 0x0000)
struct FPhotoCharacterConfig_lua final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BodyBP;                                            // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterABP;                                      // 0x0020(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FaceBP;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FaceABP;                                           // 0x0050(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FaceSocket;                                        // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutlineCfg;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionHolyLightData>      HolyLightData;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HouseSuitId;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HouseGirlID;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            BonesNames;                                        // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x00F0(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhotoCharacterConfig_lua) == 0x000008, "Wrong alignment on FPhotoCharacterConfig_lua");
static_assert(sizeof(FPhotoCharacterConfig_lua) == 0x000140, "Wrong size on FPhotoCharacterConfig_lua");
static_assert(offsetof(FPhotoCharacterConfig_lua, ID) == 0x000000, "Member 'FPhotoCharacterConfig_lua::ID' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, BodyBP) == 0x000008, "Member 'FPhotoCharacterConfig_lua::BodyBP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, CharacterABP) == 0x000020, "Member 'FPhotoCharacterConfig_lua::CharacterABP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, FaceBP) == 0x000038, "Member 'FPhotoCharacterConfig_lua::FaceBP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, FaceABP) == 0x000050, "Member 'FPhotoCharacterConfig_lua::FaceABP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, FaceSocket) == 0x000068, "Member 'FPhotoCharacterConfig_lua::FaceSocket' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, OutlineCfg) == 0x000078, "Member 'FPhotoCharacterConfig_lua::OutlineCfg' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, HolyLightData) == 0x000088, "Member 'FPhotoCharacterConfig_lua::HolyLightData' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, HouseSuitId) == 0x000098, "Member 'FPhotoCharacterConfig_lua::HouseSuitId' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, HouseGirlID) == 0x00009C, "Member 'FPhotoCharacterConfig_lua::HouseGirlID' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, BonesNames) == 0x0000A0, "Member 'FPhotoCharacterConfig_lua::BonesNames' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig_lua, OtherParams) == 0x0000F0, "Member 'FPhotoCharacterConfig_lua::OtherParams' has a wrong offset!");

// ScriptStruct Game.PhotoCharacterConfig
// 0x0140 (0x0148 - 0x0008)
struct FPhotoCharacterConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BodyBP;                                            // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterABP;                                      // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FaceBP;                                            // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FaceABP;                                           // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FaceSocket;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutlineCfg;                                        // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionHolyLightData>      HolyLightData;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HouseSuitId;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HouseGirlID;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            BonesNames;                                        // 0x00A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            OtherParams;                                       // 0x00F8(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhotoCharacterConfig) == 0x000008, "Wrong alignment on FPhotoCharacterConfig");
static_assert(sizeof(FPhotoCharacterConfig) == 0x000148, "Wrong size on FPhotoCharacterConfig");
static_assert(offsetof(FPhotoCharacterConfig, ID) == 0x000008, "Member 'FPhotoCharacterConfig::ID' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, BodyBP) == 0x000010, "Member 'FPhotoCharacterConfig::BodyBP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, CharacterABP) == 0x000028, "Member 'FPhotoCharacterConfig::CharacterABP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, FaceBP) == 0x000040, "Member 'FPhotoCharacterConfig::FaceBP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, FaceABP) == 0x000058, "Member 'FPhotoCharacterConfig::FaceABP' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, FaceSocket) == 0x000070, "Member 'FPhotoCharacterConfig::FaceSocket' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, OutlineCfg) == 0x000080, "Member 'FPhotoCharacterConfig::OutlineCfg' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, HolyLightData) == 0x000090, "Member 'FPhotoCharacterConfig::HolyLightData' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, HouseSuitId) == 0x0000A0, "Member 'FPhotoCharacterConfig::HouseSuitId' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, HouseGirlID) == 0x0000A4, "Member 'FPhotoCharacterConfig::HouseGirlID' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, BonesNames) == 0x0000A8, "Member 'FPhotoCharacterConfig::BonesNames' has a wrong offset!");
static_assert(offsetof(FPhotoCharacterConfig, OtherParams) == 0x0000F8, "Member 'FPhotoCharacterConfig::OtherParams' has a wrong offset!");

// ScriptStruct Game.PushKillScoreTextInfo
// 0x0018 (0x0020 - 0x0008)
struct FPushKillScoreTextInfo final : public FTableRowBase
{
public:
	int32                                         MinScore;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScore;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushKillScoreTextInfo) == 0x000008, "Wrong alignment on FPushKillScoreTextInfo");
static_assert(sizeof(FPushKillScoreTextInfo) == 0x000020, "Wrong size on FPushKillScoreTextInfo");
static_assert(offsetof(FPushKillScoreTextInfo, MinScore) == 0x000008, "Member 'FPushKillScoreTextInfo::MinScore' has a wrong offset!");
static_assert(offsetof(FPushKillScoreTextInfo, MaxScore) == 0x00000C, "Member 'FPushKillScoreTextInfo::MaxScore' has a wrong offset!");
static_assert(offsetof(FPushKillScoreTextInfo, TextKey) == 0x000010, "Member 'FPushKillScoreTextInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.PushKillMultiScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FPushKillMultiScoreInfo final : public FTableRowBase
{
public:
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreRatio;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushKillMultiScoreInfo) == 0x000008, "Wrong alignment on FPushKillMultiScoreInfo");
static_assert(sizeof(FPushKillMultiScoreInfo) == 0x000020, "Wrong size on FPushKillMultiScoreInfo");
static_assert(offsetof(FPushKillMultiScoreInfo, Count) == 0x000008, "Member 'FPushKillMultiScoreInfo::Count' has a wrong offset!");
static_assert(offsetof(FPushKillMultiScoreInfo, ScoreRatio) == 0x00000C, "Member 'FPushKillMultiScoreInfo::ScoreRatio' has a wrong offset!");
static_assert(offsetof(FPushKillMultiScoreInfo, TextKey) == 0x000010, "Member 'FPushKillMultiScoreInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.PushKillScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FPushKillScoreInfo final : public FTableRowBase
{
public:
	class FString                                 TargetTag;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostTime;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushKillScoreInfo) == 0x000008, "Wrong alignment on FPushKillScoreInfo");
static_assert(sizeof(FPushKillScoreInfo) == 0x000020, "Wrong size on FPushKillScoreInfo");
static_assert(offsetof(FPushKillScoreInfo, TargetTag) == 0x000008, "Member 'FPushKillScoreInfo::TargetTag' has a wrong offset!");
static_assert(offsetof(FPushKillScoreInfo, Score) == 0x000018, "Member 'FPushKillScoreInfo::Score' has a wrong offset!");
static_assert(offsetof(FPushKillScoreInfo, CostTime) == 0x00001C, "Member 'FPushKillScoreInfo::CostTime' has a wrong offset!");

// ScriptStruct Game.RAEmpty
// 0x0001 (0x0001 - 0x0000)
struct FRAEmpty final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRAEmpty) == 0x000001, "Wrong alignment on FRAEmpty");
static_assert(sizeof(FRAEmpty) == 0x000001, "Wrong size on FRAEmpty");

// ScriptStruct Game.RocketGameSubLevelInfo
// 0x0030 (0x0030 - 0x0000)
struct FRocketGameSubLevelInfo final
{
public:
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelWidth;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRocketGameSubLevelInfo) == 0x000008, "Wrong alignment on FRocketGameSubLevelInfo");
static_assert(sizeof(FRocketGameSubLevelInfo) == 0x000030, "Wrong size on FRocketGameSubLevelInfo");
static_assert(offsetof(FRocketGameSubLevelInfo, Level) == 0x000000, "Member 'FRocketGameSubLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FRocketGameSubLevelInfo, LevelWidth) == 0x000028, "Member 'FRocketGameSubLevelInfo::LevelWidth' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapWeight
// 0x0008 (0x0008 - 0x0000)
struct FRocketGameTrapWeight final
{
public:
	int32                                         TrapId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapWeight) == 0x000004, "Wrong alignment on FRocketGameTrapWeight");
static_assert(sizeof(FRocketGameTrapWeight) == 0x000008, "Wrong size on FRocketGameTrapWeight");
static_assert(offsetof(FRocketGameTrapWeight, TrapId) == 0x000000, "Member 'FRocketGameTrapWeight::TrapId' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapWeight, Weight) == 0x000004, "Member 'FRocketGameTrapWeight::Weight' has a wrong offset!");

// ScriptStruct Game.RocketGameTrapDifficulty
// 0x0048 (0x0050 - 0x0008)
struct FRocketGameTrapDifficulty final : public FTableRowBase
{
public:
	int32                                         Difficulty;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRocketGameTrapWeight>          WeightInfo;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SpecialInterval;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRocketGameTrapWeight>          SpecialWeightInfo;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SpecialInterval2;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRocketGameTrapWeight>          SpecialWeightInfo2;                                // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRocketGameTrapDifficulty) == 0x000008, "Wrong alignment on FRocketGameTrapDifficulty");
static_assert(sizeof(FRocketGameTrapDifficulty) == 0x000050, "Wrong size on FRocketGameTrapDifficulty");
static_assert(offsetof(FRocketGameTrapDifficulty, Difficulty) == 0x000008, "Member 'FRocketGameTrapDifficulty::Difficulty' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapDifficulty, WeightInfo) == 0x000010, "Member 'FRocketGameTrapDifficulty::WeightInfo' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapDifficulty, SpecialInterval) == 0x000020, "Member 'FRocketGameTrapDifficulty::SpecialInterval' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapDifficulty, SpecialWeightInfo) == 0x000028, "Member 'FRocketGameTrapDifficulty::SpecialWeightInfo' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapDifficulty, SpecialInterval2) == 0x000038, "Member 'FRocketGameTrapDifficulty::SpecialInterval2' has a wrong offset!");
static_assert(offsetof(FRocketGameTrapDifficulty, SpecialWeightInfo2) == 0x000040, "Member 'FRocketGameTrapDifficulty::SpecialWeightInfo2' has a wrong offset!");

// ScriptStruct Game.RolePropertyEntry
// 0x0024 (0x0030 - 0x000C)
struct FRolePropertyEntry final : public FFastArraySerializerItem
{
public:
	struct FClampAttribute                        PropertyValue;                                     // 0x000C(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRolePropertyEntry) == 0x000004, "Wrong alignment on FRolePropertyEntry");
static_assert(sizeof(FRolePropertyEntry) == 0x000030, "Wrong size on FRolePropertyEntry");
static_assert(offsetof(FRolePropertyEntry, PropertyValue) == 0x00000C, "Member 'FRolePropertyEntry::PropertyValue' has a wrong offset!");

// ScriptStruct Game.RolePropertiesManager
// 0x0010 (0x0118 - 0x0108)
struct FRolePropertiesManager final : public FFastArraySerializer
{
public:
	TArray<struct FRolePropertyEntry>             Props;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRolePropertiesManager) == 0x000008, "Wrong alignment on FRolePropertiesManager");
static_assert(sizeof(FRolePropertiesManager) == 0x000118, "Wrong size on FRolePropertiesManager");
static_assert(offsetof(FRolePropertiesManager, Props) == 0x000108, "Member 'FRolePropertiesManager::Props' has a wrong offset!");

// ScriptStruct Game.SceneActorTranslucentMaterial
// 0x0048 (0x0050 - 0x0008)
struct FSceneActorTranslucentMaterial final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        Ignore;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Opaque;                                            // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Translucent;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneActorTranslucentMaterial) == 0x000008, "Wrong alignment on FSceneActorTranslucentMaterial");
static_assert(sizeof(FSceneActorTranslucentMaterial) == 0x000050, "Wrong size on FSceneActorTranslucentMaterial");
static_assert(offsetof(FSceneActorTranslucentMaterial, Ignore) == 0x000008, "Member 'FSceneActorTranslucentMaterial::Ignore' has a wrong offset!");
static_assert(offsetof(FSceneActorTranslucentMaterial, Opaque) == 0x000020, "Member 'FSceneActorTranslucentMaterial::Opaque' has a wrong offset!");
static_assert(offsetof(FSceneActorTranslucentMaterial, Translucent) == 0x000038, "Member 'FSceneActorTranslucentMaterial::Translucent' has a wrong offset!");

// ScriptStruct Game.SceneActorMaterialCache
// 0x0058 (0x0058 - 0x0000)
struct FSceneActorMaterialCache final
{
public:
	TWeakObjectPtr<class UActorComponent>         Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UMaterialInterface*>        Materials;                                         // 0x0008(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneActorMaterialCache) == 0x000008, "Wrong alignment on FSceneActorMaterialCache");
static_assert(sizeof(FSceneActorMaterialCache) == 0x000058, "Wrong size on FSceneActorMaterialCache");
static_assert(offsetof(FSceneActorMaterialCache, Owner) == 0x000000, "Member 'FSceneActorMaterialCache::Owner' has a wrong offset!");
static_assert(offsetof(FSceneActorMaterialCache, Materials) == 0x000008, "Member 'FSceneActorMaterialCache::Materials' has a wrong offset!");

// ScriptStruct Game.ScoreTextInfo
// 0x0018 (0x0020 - 0x0008)
struct FScoreTextInfo final : public FTableRowBase
{
public:
	int32                                         MinScore;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScore;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreTextInfo) == 0x000008, "Wrong alignment on FScoreTextInfo");
static_assert(sizeof(FScoreTextInfo) == 0x000020, "Wrong size on FScoreTextInfo");
static_assert(offsetof(FScoreTextInfo, MinScore) == 0x000008, "Member 'FScoreTextInfo::MinScore' has a wrong offset!");
static_assert(offsetof(FScoreTextInfo, MaxScore) == 0x00000C, "Member 'FScoreTextInfo::MaxScore' has a wrong offset!");
static_assert(offsetof(FScoreTextInfo, TextKey) == 0x000010, "Member 'FScoreTextInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.MultiScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FMultiScoreInfo final : public FTableRowBase
{
public:
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreRatio;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiScoreInfo) == 0x000008, "Wrong alignment on FMultiScoreInfo");
static_assert(sizeof(FMultiScoreInfo) == 0x000020, "Wrong size on FMultiScoreInfo");
static_assert(offsetof(FMultiScoreInfo, Count) == 0x000008, "Member 'FMultiScoreInfo::Count' has a wrong offset!");
static_assert(offsetof(FMultiScoreInfo, ScoreRatio) == 0x00000C, "Member 'FMultiScoreInfo::ScoreRatio' has a wrong offset!");
static_assert(offsetof(FMultiScoreInfo, TextKey) == 0x000010, "Member 'FMultiScoreInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.TagScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FTagScoreInfo final : public FTableRowBase
{
public:
	class FString                                 TargetTag;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostTime;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTagScoreInfo) == 0x000008, "Wrong alignment on FTagScoreInfo");
static_assert(sizeof(FTagScoreInfo) == 0x000020, "Wrong size on FTagScoreInfo");
static_assert(offsetof(FTagScoreInfo, TargetTag) == 0x000008, "Member 'FTagScoreInfo::TargetTag' has a wrong offset!");
static_assert(offsetof(FTagScoreInfo, Score) == 0x000018, "Member 'FTagScoreInfo::Score' has a wrong offset!");
static_assert(offsetof(FTagScoreInfo, CostTime) == 0x00001C, "Member 'FTagScoreInfo::CostTime' has a wrong offset!");

// ScriptStruct Game.SimpleHierarchicalInstance
// 0x0010 (0x0010 - 0x0000)
struct FSimpleHierarchicalInstance final
{
public:
	TArray<struct FTransform>                     Instance;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleHierarchicalInstance) == 0x000008, "Wrong alignment on FSimpleHierarchicalInstance");
static_assert(sizeof(FSimpleHierarchicalInstance) == 0x000010, "Wrong size on FSimpleHierarchicalInstance");
static_assert(offsetof(FSimpleHierarchicalInstance, Instance) == 0x000000, "Member 'FSimpleHierarchicalInstance::Instance' has a wrong offset!");

// ScriptStruct Game.SimpleDropClientInfo
// 0x0008 (0x0008 - 0x0000)
struct FSimpleDropClientInfo final
{
public:
	class ASimpleDrop*                            Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleDropClientInfo) == 0x000008, "Wrong alignment on FSimpleDropClientInfo");
static_assert(sizeof(FSimpleDropClientInfo) == 0x000008, "Wrong size on FSimpleDropClientInfo");
static_assert(offsetof(FSimpleDropClientInfo, Actor) == 0x000000, "Member 'FSimpleDropClientInfo::Actor' has a wrong offset!");

// ScriptStruct Game.SimpleDropServerInfo
// 0x0040 (0x0040 - 0x0000)
struct FSimpleDropServerInfo final
{
public:
	struct FTransform                             Trans;                                             // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AGameCharacter*                         Picker;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroy;                                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleDropServerInfo) == 0x000010, "Wrong alignment on FSimpleDropServerInfo");
static_assert(sizeof(FSimpleDropServerInfo) == 0x000040, "Wrong size on FSimpleDropServerInfo");
static_assert(offsetof(FSimpleDropServerInfo, Trans) == 0x000000, "Member 'FSimpleDropServerInfo::Trans' has a wrong offset!");
static_assert(offsetof(FSimpleDropServerInfo, Picker) == 0x000030, "Member 'FSimpleDropServerInfo::Picker' has a wrong offset!");
static_assert(offsetof(FSimpleDropServerInfo, bDestroy) == 0x000038, "Member 'FSimpleDropServerInfo::bDestroy' has a wrong offset!");

// ScriptStruct Game.DamageAttenuationInfo
// 0x0028 (0x0028 - 0x0000)
struct FDamageAttenuationInfo final
{
public:
	int32                                         SkillRunTimeID;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponentBase*                  Launcher;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillDamageApplyTimes;                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillEndTime;                                      // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageAttenuationInfo) == 0x000008, "Wrong alignment on FDamageAttenuationInfo");
static_assert(sizeof(FDamageAttenuationInfo) == 0x000028, "Wrong size on FDamageAttenuationInfo");
static_assert(offsetof(FDamageAttenuationInfo, SkillRunTimeID) == 0x000000, "Member 'FDamageAttenuationInfo::SkillRunTimeID' has a wrong offset!");
static_assert(offsetof(FDamageAttenuationInfo, Launcher) == 0x000008, "Member 'FDamageAttenuationInfo::Launcher' has a wrong offset!");
static_assert(offsetof(FDamageAttenuationInfo, SkillDamageApplyTimes) == 0x000010, "Member 'FDamageAttenuationInfo::SkillDamageApplyTimes' has a wrong offset!");
static_assert(offsetof(FDamageAttenuationInfo, SkillEndTime) == 0x000014, "Member 'FDamageAttenuationInfo::SkillEndTime' has a wrong offset!");

// ScriptStruct Game.SkillConditionTarget
// 0x0050 (0x0050 - 0x0000)
struct FSkillConditionTarget final
{
public:
	TArray<class UAbilityComponentBase*>          ConditionAbilitys;                                 // 0x0000(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  ConditionTriggerAbility;                           // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ConditionTriggerPoint;                             // 0x0020(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillConditionTarget) == 0x000010, "Wrong alignment on FSkillConditionTarget");
static_assert(sizeof(FSkillConditionTarget) == 0x000050, "Wrong size on FSkillConditionTarget");
static_assert(offsetof(FSkillConditionTarget, ConditionAbilitys) == 0x000000, "Member 'FSkillConditionTarget::ConditionAbilitys' has a wrong offset!");
static_assert(offsetof(FSkillConditionTarget, ConditionTriggerAbility) == 0x000010, "Member 'FSkillConditionTarget::ConditionTriggerAbility' has a wrong offset!");
static_assert(offsetof(FSkillConditionTarget, ConditionTriggerPoint) == 0x000020, "Member 'FSkillConditionTarget::ConditionTriggerPoint' has a wrong offset!");

// ScriptStruct Game.AnimStateEventInfo
// 0x0018 (0x0018 - 0x0000)
struct FAnimStateEventInfo final
{
public:
	class UCustomAnimNotifyState*                 M_lpCurrentStateEvent;                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStartTriggerTime;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStopTriggerTime;                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HashValue;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimStateEventInfo) == 0x000008, "Wrong alignment on FAnimStateEventInfo");
static_assert(sizeof(FAnimStateEventInfo) == 0x000018, "Wrong size on FAnimStateEventInfo");
static_assert(offsetof(FAnimStateEventInfo, M_lpCurrentStateEvent) == 0x000000, "Member 'FAnimStateEventInfo::M_lpCurrentStateEvent' has a wrong offset!");
static_assert(offsetof(FAnimStateEventInfo, M_fStartTriggerTime) == 0x000008, "Member 'FAnimStateEventInfo::M_fStartTriggerTime' has a wrong offset!");
static_assert(offsetof(FAnimStateEventInfo, M_fStopTriggerTime) == 0x00000C, "Member 'FAnimStateEventInfo::M_fStopTriggerTime' has a wrong offset!");
static_assert(offsetof(FAnimStateEventInfo, HashValue) == 0x000010, "Member 'FAnimStateEventInfo::HashValue' has a wrong offset!");

// ScriptStruct Game.IgnoreByControlProtectionModifierInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FIgnoreByControlProtectionModifierInfo final
{
public:
	class UAbilityComponentBase*                  Causer;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponentBase*                  Target;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIgnoreByControlProtectionModifierInfo) == 0x000010, "Wrong alignment on FIgnoreByControlProtectionModifierInfo");
static_assert(sizeof(FIgnoreByControlProtectionModifierInfo) == 0x000060, "Wrong size on FIgnoreByControlProtectionModifierInfo");
static_assert(offsetof(FIgnoreByControlProtectionModifierInfo, Causer) == 0x000000, "Member 'FIgnoreByControlProtectionModifierInfo::Causer' has a wrong offset!");
static_assert(offsetof(FIgnoreByControlProtectionModifierInfo, Target) == 0x000008, "Member 'FIgnoreByControlProtectionModifierInfo::Target' has a wrong offset!");

// ScriptStruct Game.KeepEffectCountInfo
// 0x0018 (0x0018 - 0x0000)
struct FKeepEffectCountInfo final
{
public:
	class UFXSystemComponent*                     AnchorParticle;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 SourceModifierHashIDs;                             // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeepEffectCountInfo) == 0x000008, "Wrong alignment on FKeepEffectCountInfo");
static_assert(sizeof(FKeepEffectCountInfo) == 0x000018, "Wrong size on FKeepEffectCountInfo");
static_assert(offsetof(FKeepEffectCountInfo, AnchorParticle) == 0x000000, "Member 'FKeepEffectCountInfo::AnchorParticle' has a wrong offset!");
static_assert(offsetof(FKeepEffectCountInfo, SourceModifierHashIDs) == 0x000008, "Member 'FKeepEffectCountInfo::SourceModifierHashIDs' has a wrong offset!");

// ScriptStruct Game.EmitterEffectRay
// 0x0030 (0x0030 - 0x0000)
struct FEmitterEffectRay final
{
public:
	int64                                         HashID;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQueryResult>                   QueryResults;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 Luancher;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayDistance;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLineTrace;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterEffectRay) == 0x000008, "Wrong alignment on FEmitterEffectRay");
static_assert(sizeof(FEmitterEffectRay) == 0x000030, "Wrong size on FEmitterEffectRay");
static_assert(offsetof(FEmitterEffectRay, HashID) == 0x000000, "Member 'FEmitterEffectRay::HashID' has a wrong offset!");
static_assert(offsetof(FEmitterEffectRay, QueryResults) == 0x000008, "Member 'FEmitterEffectRay::QueryResults' has a wrong offset!");
static_assert(offsetof(FEmitterEffectRay, Luancher) == 0x000018, "Member 'FEmitterEffectRay::Luancher' has a wrong offset!");
static_assert(offsetof(FEmitterEffectRay, EmitterID) == 0x000020, "Member 'FEmitterEffectRay::EmitterID' has a wrong offset!");
static_assert(offsetof(FEmitterEffectRay, RayDistance) == 0x000024, "Member 'FEmitterEffectRay::RayDistance' has a wrong offset!");
static_assert(offsetof(FEmitterEffectRay, bLineTrace) == 0x000028, "Member 'FEmitterEffectRay::bLineTrace' has a wrong offset!");

// ScriptStruct Game.EmitterEffect
// 0x0108 (0x0108 - 0x0000)
struct FEmitterEffect final
{
public:
	class UFXSystemComponent*                     RayParticleRef;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, class UFXSystemComponent*> RayHitLoopParticleMap;                             // 0x0010(0x0050)(BlueprintVisible, ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAnchorParticleFollowAnchor;                       // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFXSystemComponent*>             AnchorParticles;                                   // 0x0068(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UWwiseComponent*>                AnchorPointSounds;                                 // 0x0078(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ACustomEffectActor*>             AnchorEffectActor;                                 // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 PostProcessValues;                                 // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 AbnormalStateID;                                   // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class UNiagaraSystem>, struct FCompositeIdArray> CompositeParticles;                                // 0x00B8(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterEffect) == 0x000008, "Wrong alignment on FEmitterEffect");
static_assert(sizeof(FEmitterEffect) == 0x000108, "Wrong size on FEmitterEffect");
static_assert(offsetof(FEmitterEffect, RayParticleRef) == 0x000000, "Member 'FEmitterEffect::RayParticleRef' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, RayHitLoopParticleMap) == 0x000010, "Member 'FEmitterEffect::RayHitLoopParticleMap' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, bAnchorParticleFollowAnchor) == 0x000060, "Member 'FEmitterEffect::bAnchorParticleFollowAnchor' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, AnchorParticles) == 0x000068, "Member 'FEmitterEffect::AnchorParticles' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, AnchorPointSounds) == 0x000078, "Member 'FEmitterEffect::AnchorPointSounds' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, AnchorEffectActor) == 0x000088, "Member 'FEmitterEffect::AnchorEffectActor' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, PostProcessValues) == 0x000098, "Member 'FEmitterEffect::PostProcessValues' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, AbnormalStateID) == 0x0000A8, "Member 'FEmitterEffect::AbnormalStateID' has a wrong offset!");
static_assert(offsetof(FEmitterEffect, CompositeParticles) == 0x0000B8, "Member 'FEmitterEffect::CompositeParticles' has a wrong offset!");

// ScriptStruct Game.CharacterModifier
// 0x0018 (0x0018 - 0x0000)
struct FCharacterModifier final
{
public:
	class AGameCharacter*                         InTarget;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterModifier) == 0x000008, "Wrong alignment on FCharacterModifier");
static_assert(sizeof(FCharacterModifier) == 0x000018, "Wrong size on FCharacterModifier");
static_assert(offsetof(FCharacterModifier, InTarget) == 0x000000, "Member 'FCharacterModifier::InTarget' has a wrong offset!");

// ScriptStruct Game.LieMoveInfo
// 0x0018 (0x0018 - 0x0000)
struct FLieMoveInfo final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitSpeed;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLieMoveInfo) == 0x000004, "Wrong alignment on FLieMoveInfo");
static_assert(sizeof(FLieMoveInfo) == 0x000018, "Wrong size on FLieMoveInfo");
static_assert(offsetof(FLieMoveInfo, Direction) == 0x000000, "Member 'FLieMoveInfo::Direction' has a wrong offset!");
static_assert(offsetof(FLieMoveInfo, InitSpeed) == 0x00000C, "Member 'FLieMoveInfo::InitSpeed' has a wrong offset!");
static_assert(offsetof(FLieMoveInfo, KeepTime) == 0x000010, "Member 'FLieMoveInfo::KeepTime' has a wrong offset!");
static_assert(offsetof(FLieMoveInfo, AnimTime) == 0x000014, "Member 'FLieMoveInfo::AnimTime' has a wrong offset!");

// ScriptStruct Game.RepelMoveInfo
// 0x0048 (0x0048 - 0x0000)
struct FRepelMoveInfo final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RepelEndStage;                                     // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepelFormulaTime;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepelMoveTime;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepelKeepTime;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepelDistance;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceToOrigin;                                     // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseDir;                                       // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSpeed;                                      // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RepelCurve1;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RepelCurve2;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           MetaDataCurve;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepelMoveInfo) == 0x000008, "Wrong alignment on FRepelMoveInfo");
static_assert(sizeof(FRepelMoveInfo) == 0x000048, "Wrong size on FRepelMoveInfo");
static_assert(offsetof(FRepelMoveInfo, Direction) == 0x000000, "Member 'FRepelMoveInfo::Direction' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelEndStage) == 0x00000C, "Member 'FRepelMoveInfo::RepelEndStage' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelFormulaTime) == 0x000010, "Member 'FRepelMoveInfo::RepelFormulaTime' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelMoveTime) == 0x000014, "Member 'FRepelMoveInfo::RepelMoveTime' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelKeepTime) == 0x000018, "Member 'FRepelMoveInfo::RepelKeepTime' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelDistance) == 0x00001C, "Member 'FRepelMoveInfo::RepelDistance' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, bFaceToOrigin) == 0x000020, "Member 'FRepelMoveInfo::bFaceToOrigin' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, bInverseDir) == 0x000021, "Member 'FRepelMoveInfo::bInverseDir' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, InitialSpeed) == 0x000024, "Member 'FRepelMoveInfo::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelCurve1) == 0x000028, "Member 'FRepelMoveInfo::RepelCurve1' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, RepelCurve2) == 0x000030, "Member 'FRepelMoveInfo::RepelCurve2' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, MetaDataCurve) == 0x000038, "Member 'FRepelMoveInfo::MetaDataCurve' has a wrong offset!");
static_assert(offsetof(FRepelMoveInfo, Alpha) == 0x000040, "Member 'FRepelMoveInfo::Alpha' has a wrong offset!");

// ScriptStruct Game.FloatingMove_ControlVelocity
// 0x0010 (0x0010 - 0x0000)
struct FFloatingMove_ControlVelocity final
{
public:
	class UCurveFloat*                            ZVelocityCurve;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZRotatorSpeed;                                     // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatingMove_ControlVelocity) == 0x000008, "Wrong alignment on FFloatingMove_ControlVelocity");
static_assert(sizeof(FFloatingMove_ControlVelocity) == 0x000010, "Wrong size on FFloatingMove_ControlVelocity");
static_assert(offsetof(FFloatingMove_ControlVelocity, ZVelocityCurve) == 0x000000, "Member 'FFloatingMove_ControlVelocity::ZVelocityCurve' has a wrong offset!");
static_assert(offsetof(FFloatingMove_ControlVelocity, ZRotatorSpeed) == 0x000008, "Member 'FFloatingMove_ControlVelocity::ZRotatorSpeed' has a wrong offset!");

// ScriptStruct Game.FloatingMove_VortexWhirlInfo
// 0x002C (0x002C - 0x0000)
struct FFloatingMove_VortexWhirlInfo final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimType;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VortexWhirlKeepTime;                               // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplierToReachOrbitRadius;                 // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplierToReachOrbitHeight;                 // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingDownGravity;                                 // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatingMove_VortexWhirlInfo) == 0x000004, "Wrong alignment on FFloatingMove_VortexWhirlInfo");
static_assert(sizeof(FFloatingMove_VortexWhirlInfo) == 0x00002C, "Wrong size on FFloatingMove_VortexWhirlInfo");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, Direction) == 0x000000, "Member 'FFloatingMove_VortexWhirlInfo::Direction' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, AnimType) == 0x00000C, "Member 'FFloatingMove_VortexWhirlInfo::AnimType' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, VortexWhirlKeepTime) == 0x000010, "Member 'FFloatingMove_VortexWhirlInfo::VortexWhirlKeepTime' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, Radius) == 0x000014, "Member 'FFloatingMove_VortexWhirlInfo::Radius' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, Speed) == 0x000018, "Member 'FFloatingMove_VortexWhirlInfo::Speed' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, SpeedMultiplierToReachOrbitRadius) == 0x00001C, "Member 'FFloatingMove_VortexWhirlInfo::SpeedMultiplierToReachOrbitRadius' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, SpeedMultiplierToReachOrbitHeight) == 0x000020, "Member 'FFloatingMove_VortexWhirlInfo::SpeedMultiplierToReachOrbitHeight' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, Height) == 0x000024, "Member 'FFloatingMove_VortexWhirlInfo::Height' has a wrong offset!");
static_assert(offsetof(FFloatingMove_VortexWhirlInfo, MovingDownGravity) == 0x000028, "Member 'FFloatingMove_VortexWhirlInfo::MovingDownGravity' has a wrong offset!");

// ScriptStruct Game.FloatingMoveInfo
// 0x0040 (0x0040 - 0x0000)
struct FFloatingMoveInfo final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimType;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scaler;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingTime_Pre;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingTime_After;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTime_Verticle;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTime_VerticleHighest;                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTime_Horizental;                                // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceToOrigin;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RisingForlumeTime;                                 // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingHight;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatingHorizentalDis;                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed_Verticle;                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed_Horizental;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatingMoveInfo) == 0x000004, "Wrong alignment on FFloatingMoveInfo");
static_assert(sizeof(FFloatingMoveInfo) == 0x000040, "Wrong size on FFloatingMoveInfo");
static_assert(offsetof(FFloatingMoveInfo, Direction) == 0x000000, "Member 'FFloatingMoveInfo::Direction' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, AnimType) == 0x00000C, "Member 'FFloatingMoveInfo::AnimType' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, Scaler) == 0x000010, "Member 'FFloatingMoveInfo::Scaler' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FloatingTime_Pre) == 0x000014, "Member 'FFloatingMoveInfo::FloatingTime_Pre' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FloatingTime_After) == 0x000018, "Member 'FFloatingMoveInfo::FloatingTime_After' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FlyTime_Verticle) == 0x00001C, "Member 'FFloatingMoveInfo::FlyTime_Verticle' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FlyTime_VerticleHighest) == 0x000020, "Member 'FFloatingMoveInfo::FlyTime_VerticleHighest' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FlyTime_Horizental) == 0x000024, "Member 'FFloatingMoveInfo::FlyTime_Horizental' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, bFaceToOrigin) == 0x000028, "Member 'FFloatingMoveInfo::bFaceToOrigin' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, RisingForlumeTime) == 0x00002C, "Member 'FFloatingMoveInfo::RisingForlumeTime' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FloatingHight) == 0x000030, "Member 'FFloatingMoveInfo::FloatingHight' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, FloatingHorizentalDis) == 0x000034, "Member 'FFloatingMoveInfo::FloatingHorizentalDis' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, InitialSpeed_Verticle) == 0x000038, "Member 'FFloatingMoveInfo::InitialSpeed_Verticle' has a wrong offset!");
static_assert(offsetof(FFloatingMoveInfo, InitialSpeed_Horizental) == 0x00003C, "Member 'FFloatingMoveInfo::InitialSpeed_Horizental' has a wrong offset!");

// ScriptStruct Game.MotionCurveData
// 0x0018 (0x0018 - 0x0000)
struct FMotionCurveData final
{
public:
	class UCurveFloat*                            SlowCurve;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            NormalCurve;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            QuickCurve;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionCurveData) == 0x000008, "Wrong alignment on FMotionCurveData");
static_assert(sizeof(FMotionCurveData) == 0x000018, "Wrong size on FMotionCurveData");
static_assert(offsetof(FMotionCurveData, SlowCurve) == 0x000000, "Member 'FMotionCurveData::SlowCurve' has a wrong offset!");
static_assert(offsetof(FMotionCurveData, NormalCurve) == 0x000008, "Member 'FMotionCurveData::NormalCurve' has a wrong offset!");
static_assert(offsetof(FMotionCurveData, QuickCurve) == 0x000010, "Member 'FMotionCurveData::QuickCurve' has a wrong offset!");

// ScriptStruct Game.RequireModifier
// 0x0010 (0x0010 - 0x0000)
struct FRequireModifier final
{
public:
	TArray<int32>                                 RequireModifiers;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRequireModifier) == 0x000008, "Wrong alignment on FRequireModifier");
static_assert(sizeof(FRequireModifier) == 0x000010, "Wrong size on FRequireModifier");
static_assert(offsetof(FRequireModifier, RequireModifiers) == 0x000000, "Member 'FRequireModifier::RequireModifiers' has a wrong offset!");

// ScriptStruct Game.MultipleProgressBarStyle
// 0x0120 (0x0128 - 0x0008)
struct FMultipleProgressBarStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            BackgroundImage;                                   // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    FillImages;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MarqueeImage;                                      // 0x00A0(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultipleProgressBarStyle) == 0x000008, "Wrong alignment on FMultipleProgressBarStyle");
static_assert(sizeof(FMultipleProgressBarStyle) == 0x000128, "Wrong size on FMultipleProgressBarStyle");
static_assert(offsetof(FMultipleProgressBarStyle, BackgroundImage) == 0x000008, "Member 'FMultipleProgressBarStyle::BackgroundImage' has a wrong offset!");
static_assert(offsetof(FMultipleProgressBarStyle, FillImages) == 0x000090, "Member 'FMultipleProgressBarStyle::FillImages' has a wrong offset!");
static_assert(offsetof(FMultipleProgressBarStyle, MarqueeImage) == 0x0000A0, "Member 'FMultipleProgressBarStyle::MarqueeImage' has a wrong offset!");

// ScriptStruct Game.SneakShowInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSneakShowInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSneakShowInfo) == 0x000008, "Wrong alignment on FSneakShowInfo");
static_assert(sizeof(FSneakShowInfo) == 0x000018, "Wrong size on FSneakShowInfo");

// ScriptStruct Game.SnowEffectParameter
// 0x0038 (0x0038 - 0x0000)
struct FSnowEffectParameter final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Bound;                                             // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnowEffectParameter) == 0x000004, "Wrong alignment on FSnowEffectParameter");
static_assert(sizeof(FSnowEffectParameter) == 0x000038, "Wrong size on FSnowEffectParameter");
static_assert(offsetof(FSnowEffectParameter, Priority) == 0x000000, "Member 'FSnowEffectParameter::Priority' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, Bound) == 0x000004, "Member 'FSnowEffectParameter::Bound' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, Rate) == 0x000010, "Member 'FSnowEffectParameter::Rate' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, Size) == 0x000014, "Member 'FSnowEffectParameter::Size' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, Velocity) == 0x000018, "Member 'FSnowEffectParameter::Velocity' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, VelocityMax) == 0x00001C, "Member 'FSnowEffectParameter::VelocityMax' has a wrong offset!");
static_assert(offsetof(FSnowEffectParameter, VelocityMin) == 0x000028, "Member 'FSnowEffectParameter::VelocityMin' has a wrong offset!");

// ScriptStruct Game.LoginBgInfo
// 0x0078 (0x0078 - 0x0000)
struct FLoginBgInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Picture;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Picture_A;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Spine;                                             // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Spine_A;                                           // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Music;                                             // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OpenAnim;                                          // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StandAnim;                                         // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginBgInfo) == 0x000008, "Wrong alignment on FLoginBgInfo");
static_assert(sizeof(FLoginBgInfo) == 0x000078, "Wrong size on FLoginBgInfo");
static_assert(offsetof(FLoginBgInfo, ID) == 0x000000, "Member 'FLoginBgInfo::ID' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, Picture) == 0x000008, "Member 'FLoginBgInfo::Picture' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, Picture_A) == 0x000018, "Member 'FLoginBgInfo::Picture_A' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, Spine) == 0x000028, "Member 'FLoginBgInfo::Spine' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, Spine_A) == 0x000038, "Member 'FLoginBgInfo::Spine_A' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, Music) == 0x000048, "Member 'FLoginBgInfo::Music' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, OpenAnim) == 0x000058, "Member 'FLoginBgInfo::OpenAnim' has a wrong offset!");
static_assert(offsetof(FLoginBgInfo, StandAnim) == 0x000068, "Member 'FLoginBgInfo::StandAnim' has a wrong offset!");

// ScriptStruct Game.LoginServerInfo
// 0x0028 (0x0028 - 0x0000)
struct FLoginServerInfo final
{
public:
	class FString                                 Host;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginServerInfo) == 0x000008, "Wrong alignment on FLoginServerInfo");
static_assert(sizeof(FLoginServerInfo) == 0x000028, "Wrong size on FLoginServerInfo");
static_assert(offsetof(FLoginServerInfo, Host) == 0x000000, "Member 'FLoginServerInfo::Host' has a wrong offset!");
static_assert(offsetof(FLoginServerInfo, Port) == 0x000010, "Member 'FLoginServerInfo::Port' has a wrong offset!");
static_assert(offsetof(FLoginServerInfo, DisplayName) == 0x000018, "Member 'FLoginServerInfo::DisplayName' has a wrong offset!");

// ScriptStruct Game.LoginServerInfoURL
// 0x0030 (0x0030 - 0x0000)
struct FLoginServerInfoURL final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoginServerInfoURL) == 0x000008, "Wrong alignment on FLoginServerInfoURL");
static_assert(sizeof(FLoginServerInfoURL) == 0x000030, "Wrong size on FLoginServerInfoURL");
static_assert(offsetof(FLoginServerInfoURL, ID) == 0x000000, "Member 'FLoginServerInfoURL::ID' has a wrong offset!");
static_assert(offsetof(FLoginServerInfoURL, Type) == 0x000004, "Member 'FLoginServerInfoURL::Type' has a wrong offset!");
static_assert(offsetof(FLoginServerInfoURL, DisplayName) == 0x000008, "Member 'FLoginServerInfoURL::DisplayName' has a wrong offset!");
static_assert(offsetof(FLoginServerInfoURL, Address) == 0x000018, "Member 'FLoginServerInfoURL::Address' has a wrong offset!");
static_assert(offsetof(FLoginServerInfoURL, Port) == 0x000028, "Member 'FLoginServerInfoURL::Port' has a wrong offset!");

// ScriptStruct Game.TargetMultiScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FTargetMultiScoreInfo final : public FTableRowBase
{
public:
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreRatio;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextKey;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetMultiScoreInfo) == 0x000008, "Wrong alignment on FTargetMultiScoreInfo");
static_assert(sizeof(FTargetMultiScoreInfo) == 0x000020, "Wrong size on FTargetMultiScoreInfo");
static_assert(offsetof(FTargetMultiScoreInfo, Count) == 0x000008, "Member 'FTargetMultiScoreInfo::Count' has a wrong offset!");
static_assert(offsetof(FTargetMultiScoreInfo, ScoreRatio) == 0x00000C, "Member 'FTargetMultiScoreInfo::ScoreRatio' has a wrong offset!");
static_assert(offsetof(FTargetMultiScoreInfo, TextKey) == 0x000010, "Member 'FTargetMultiScoreInfo::TextKey' has a wrong offset!");

// ScriptStruct Game.TargetScoreInfo
// 0x0018 (0x0020 - 0x0008)
struct FTargetScoreInfo final : public FTableRowBase
{
public:
	class FString                                 TargetTag;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostTime;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetScoreInfo) == 0x000008, "Wrong alignment on FTargetScoreInfo");
static_assert(sizeof(FTargetScoreInfo) == 0x000020, "Wrong size on FTargetScoreInfo");
static_assert(offsetof(FTargetScoreInfo, TargetTag) == 0x000008, "Member 'FTargetScoreInfo::TargetTag' has a wrong offset!");
static_assert(offsetof(FTargetScoreInfo, Score) == 0x000018, "Member 'FTargetScoreInfo::Score' has a wrong offset!");
static_assert(offsetof(FTargetScoreInfo, CostTime) == 0x00001C, "Member 'FTargetScoreInfo::CostTime' has a wrong offset!");

// ScriptStruct Game.Action_BuffSaveInfo
// 0x0014 (0x0014 - 0x0000)
struct FAction_BuffSaveInfo final
{
public:
	int32                                         BuffType;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimitValue;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowLimitNum;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAction_BuffSaveInfo) == 0x000004, "Wrong alignment on FAction_BuffSaveInfo");
static_assert(sizeof(FAction_BuffSaveInfo) == 0x000014, "Wrong size on FAction_BuffSaveInfo");
static_assert(offsetof(FAction_BuffSaveInfo, BuffType) == 0x000000, "Member 'FAction_BuffSaveInfo::BuffType' has a wrong offset!");
static_assert(offsetof(FAction_BuffSaveInfo, BuffId) == 0x000004, "Member 'FAction_BuffSaveInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FAction_BuffSaveInfo, LimitValue) == 0x000008, "Member 'FAction_BuffSaveInfo::LimitValue' has a wrong offset!");
static_assert(offsetof(FAction_BuffSaveInfo, NowLimitNum) == 0x000010, "Member 'FAction_BuffSaveInfo::NowLimitNum' has a wrong offset!");

// ScriptStruct Game.Action_BuffInfo
// 0x0008 (0x0008 - 0x0000)
struct FAction_BuffInfo final
{
public:
	int32                                         BuffType;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffId;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAction_BuffInfo) == 0x000004, "Wrong alignment on FAction_BuffInfo");
static_assert(sizeof(FAction_BuffInfo) == 0x000008, "Wrong size on FAction_BuffInfo");
static_assert(offsetof(FAction_BuffInfo, BuffType) == 0x000000, "Member 'FAction_BuffInfo::BuffType' has a wrong offset!");
static_assert(offsetof(FAction_BuffInfo, BuffId) == 0x000004, "Member 'FAction_BuffInfo::BuffId' has a wrong offset!");

// ScriptStruct Game.AsyncSpawnNpcByPoint
// 0x0030 (0x0030 - 0x0000)
struct FAsyncSpawnNpcByPoint final
{
public:
	int32                                         TableID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSummon;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAsyncSpawnNpcByPoint) == 0x000008, "Wrong alignment on FAsyncSpawnNpcByPoint");
static_assert(sizeof(FAsyncSpawnNpcByPoint) == 0x000030, "Wrong size on FAsyncSpawnNpcByPoint");
static_assert(offsetof(FAsyncSpawnNpcByPoint, TableID) == 0x000000, "Member 'FAsyncSpawnNpcByPoint::TableID' has a wrong offset!");
static_assert(offsetof(FAsyncSpawnNpcByPoint, Tag) == 0x000008, "Member 'FAsyncSpawnNpcByPoint::Tag' has a wrong offset!");
static_assert(offsetof(FAsyncSpawnNpcByPoint, Team) == 0x000018, "Member 'FAsyncSpawnNpcByPoint::Team' has a wrong offset!");
static_assert(offsetof(FAsyncSpawnNpcByPoint, bSummon) == 0x000028, "Member 'FAsyncSpawnNpcByPoint::bSummon' has a wrong offset!");

// ScriptStruct Game.TaskActionBindData
// 0x002C (0x002C - 0x0000)
struct FTaskActionBindData final
{
public:
	ELevelTaskEvent                               TargetEvent;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTaskActionInfo                        ActionInfo;                                        // 0x0004(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskActionBindData) == 0x000004, "Wrong alignment on FTaskActionBindData");
static_assert(sizeof(FTaskActionBindData) == 0x00002C, "Wrong size on FTaskActionBindData");
static_assert(offsetof(FTaskActionBindData, TargetEvent) == 0x000000, "Member 'FTaskActionBindData::TargetEvent' has a wrong offset!");
static_assert(offsetof(FTaskActionBindData, ActionInfo) == 0x000004, "Member 'FTaskActionBindData::ActionInfo' has a wrong offset!");

// ScriptStruct Game.TeamSpawnerInfo
// 0x0018 (0x0050 - 0x0038)
struct FTeamSpawnerInfo final : public FSpawnerConfig
{
public:
	struct FSpawnLocRot                           SpawnPoint;                                        // 0x0038(0x0018)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamSpawnerInfo) == 0x000008, "Wrong alignment on FTeamSpawnerInfo");
static_assert(sizeof(FTeamSpawnerInfo) == 0x000050, "Wrong size on FTeamSpawnerInfo");
static_assert(offsetof(FTeamSpawnerInfo, SpawnPoint) == 0x000038, "Member 'FTeamSpawnerInfo::SpawnPoint' has a wrong offset!");

// ScriptStruct Game.TowerRushPlayerScore
// 0x0010 (0x0010 - 0x0000)
struct FTowerRushPlayerScore final
{
public:
	int64                                         RolePID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTowerRushPlayerScore) == 0x000008, "Wrong alignment on FTowerRushPlayerScore");
static_assert(sizeof(FTowerRushPlayerScore) == 0x000010, "Wrong size on FTowerRushPlayerScore");
static_assert(offsetof(FTowerRushPlayerScore, RolePID) == 0x000000, "Member 'FTowerRushPlayerScore::RolePID' has a wrong offset!");
static_assert(offsetof(FTowerRushPlayerScore, Score) == 0x000008, "Member 'FTowerRushPlayerScore::Score' has a wrong offset!");

// ScriptStruct Game.TowerRushSubLevelInfo
// 0x0058 (0x0058 - 0x0000)
struct FTowerRushSubLevelInfo final
{
public:
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LogicLevel;                                        // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelHeight;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTowerRushSubLevelInfo) == 0x000008, "Wrong alignment on FTowerRushSubLevelInfo");
static_assert(sizeof(FTowerRushSubLevelInfo) == 0x000058, "Wrong size on FTowerRushSubLevelInfo");
static_assert(offsetof(FTowerRushSubLevelInfo, Level) == 0x000000, "Member 'FTowerRushSubLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FTowerRushSubLevelInfo, LogicLevel) == 0x000028, "Member 'FTowerRushSubLevelInfo::LogicLevel' has a wrong offset!");
static_assert(offsetof(FTowerRushSubLevelInfo, LevelHeight) == 0x000050, "Member 'FTowerRushSubLevelInfo::LevelHeight' has a wrong offset!");

// ScriptStruct Game.TowerRushSubLevelState
// 0x0060 (0x0060 - 0x0000)
struct FTowerRushSubLevelState final
{
public:
	struct FTowerRushSubLevelInfo                 LevelInfo;                                         // 0x0000(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         CurrentHeight;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentFloor;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTowerRushSubLevelState) == 0x000008, "Wrong alignment on FTowerRushSubLevelState");
static_assert(sizeof(FTowerRushSubLevelState) == 0x000060, "Wrong size on FTowerRushSubLevelState");
static_assert(offsetof(FTowerRushSubLevelState, LevelInfo) == 0x000000, "Member 'FTowerRushSubLevelState::LevelInfo' has a wrong offset!");
static_assert(offsetof(FTowerRushSubLevelState, CurrentHeight) == 0x000058, "Member 'FTowerRushSubLevelState::CurrentHeight' has a wrong offset!");
static_assert(offsetof(FTowerRushSubLevelState, CurrentFloor) == 0x00005C, "Member 'FTowerRushSubLevelState::CurrentFloor' has a wrong offset!");

// ScriptStruct Game.TowerRushMonsterInfo
// 0x0020 (0x0020 - 0x0000)
struct FTowerRushMonsterInfo final
{
public:
	int32                                         MonsterId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETowerRushMonsterType                         Type;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTowerRushMonsterInfo) == 0x000008, "Wrong alignment on FTowerRushMonsterInfo");
static_assert(sizeof(FTowerRushMonsterInfo) == 0x000020, "Wrong size on FTowerRushMonsterInfo");
static_assert(offsetof(FTowerRushMonsterInfo, MonsterId) == 0x000000, "Member 'FTowerRushMonsterInfo::MonsterId' has a wrong offset!");
static_assert(offsetof(FTowerRushMonsterInfo, ColorIndex) == 0x000004, "Member 'FTowerRushMonsterInfo::ColorIndex' has a wrong offset!");
static_assert(offsetof(FTowerRushMonsterInfo, Tag) == 0x000008, "Member 'FTowerRushMonsterInfo::Tag' has a wrong offset!");
static_assert(offsetof(FTowerRushMonsterInfo, Type) == 0x000018, "Member 'FTowerRushMonsterInfo::Type' has a wrong offset!");

// ScriptStruct Game.TurrentSettings
// 0x0108 (0x0108 - 0x0000)
struct FTurrentSettings final
{
public:
	class FString                                 UseTips;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrowTemplateID;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponGrowUpID;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponAppearID;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArmOffset;                                         // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimFov;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchAngle;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchAngle;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FireSocket;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BarrelName;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BarrelAnimPath;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraArmLengthCurvePath;                          // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraSocketOffsetCurvePath;                       // 0x0088(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TmpCameraOffsetCurvePath;                          // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraSocketOffset;                                // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefend;                                           // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResource;                                         // 0x00C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TurretLevel;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TurretBreak;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TurretEvolve;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleValue;                                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETurretAttackType                             AttackType;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurretCriticalDamage;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FixedBullet;                                       // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishOnTurret;                                   // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        EffectPath;                                        // 0x00E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTurrentSettings) == 0x000008, "Wrong alignment on FTurrentSettings");
static_assert(sizeof(FTurrentSettings) == 0x000108, "Wrong size on FTurrentSettings");
static_assert(offsetof(FTurrentSettings, UseTips) == 0x000000, "Member 'FTurrentSettings::UseTips' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, GrowTemplateID) == 0x000010, "Member 'FTurrentSettings::GrowTemplateID' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, AbilityLevel) == 0x000014, "Member 'FTurrentSettings::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, WeaponGrowUpID) == 0x000018, "Member 'FTurrentSettings::WeaponGrowUpID' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, WeaponAppearID) == 0x00001C, "Member 'FTurrentSettings::WeaponAppearID' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, ArmOffset) == 0x000020, "Member 'FTurrentSettings::ArmOffset' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, AimFov) == 0x00002C, "Member 'FTurrentSettings::AimFov' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, MaxPitchAngle) == 0x000030, "Member 'FTurrentSettings::MaxPitchAngle' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, MinPitchAngle) == 0x000034, "Member 'FTurrentSettings::MinPitchAngle' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, FireSocket) == 0x000038, "Member 'FTurrentSettings::FireSocket' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, BarrelName) == 0x000048, "Member 'FTurrentSettings::BarrelName' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, BarrelAnimPath) == 0x000058, "Member 'FTurrentSettings::BarrelAnimPath' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, CameraArmLengthCurvePath) == 0x000070, "Member 'FTurrentSettings::CameraArmLengthCurvePath' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, CameraSocketOffsetCurvePath) == 0x000088, "Member 'FTurrentSettings::CameraSocketOffsetCurvePath' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, TmpCameraOffsetCurvePath) == 0x0000A0, "Member 'FTurrentSettings::TmpCameraOffsetCurvePath' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, CameraSocketOffset) == 0x0000B8, "Member 'FTurrentSettings::CameraSocketOffset' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, bDefend) == 0x0000C4, "Member 'FTurrentSettings::bDefend' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, bResource) == 0x0000C5, "Member 'FTurrentSettings::bResource' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, TurretLevel) == 0x0000C8, "Member 'FTurrentSettings::TurretLevel' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, TurretBreak) == 0x0000CC, "Member 'FTurrentSettings::TurretBreak' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, TurretEvolve) == 0x0000D0, "Member 'FTurrentSettings::TurretEvolve' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, AngleValue) == 0x0000D4, "Member 'FTurrentSettings::AngleValue' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, AttackType) == 0x0000D8, "Member 'FTurrentSettings::AttackType' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, TurretCriticalDamage) == 0x0000DC, "Member 'FTurrentSettings::TurretCriticalDamage' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, FixedBullet) == 0x0000E0, "Member 'FTurrentSettings::FixedBullet' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, bFinishOnTurret) == 0x0000E4, "Member 'FTurrentSettings::bFinishOnTurret' has a wrong offset!");
static_assert(offsetof(FTurrentSettings, EffectPath) == 0x0000E8, "Member 'FTurrentSettings::EffectPath' has a wrong offset!");

// ScriptStruct Game.PreviewModelInfo
// 0x0050 (0x0050 - 0x0000)
struct FPreviewModelInfo final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StartRotation;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LightRotation;                                     // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EUIWidgetAnimType                             AnimType;                                          // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Options;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewModelInfo) == 0x000008, "Wrong alignment on FPreviewModelInfo");
static_assert(sizeof(FPreviewModelInfo) == 0x000050, "Wrong size on FPreviewModelInfo");
static_assert(offsetof(FPreviewModelInfo, Position) == 0x000000, "Member 'FPreviewModelInfo::Position' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, StartRotation) == 0x00000C, "Member 'FPreviewModelInfo::StartRotation' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, TargetRotation) == 0x000018, "Member 'FPreviewModelInfo::TargetRotation' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, Scale) == 0x000024, "Member 'FPreviewModelInfo::Scale' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, LightRotation) == 0x000030, "Member 'FPreviewModelInfo::LightRotation' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, AnimType) == 0x00003C, "Member 'FPreviewModelInfo::AnimType' has a wrong offset!");
static_assert(offsetof(FPreviewModelInfo, Options) == 0x000040, "Member 'FPreviewModelInfo::Options' has a wrong offset!");

// ScriptStruct Game.UICameraInfoItem
// 0x0060 (0x0060 - 0x0000)
struct FUICameraInfoItem final
{
public:
	class FString                                 Describe;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIndex;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MiddlePoints;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIWidgetAnimType                             AnimType;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ModelPos;                                          // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ModelRot;                                          // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LightRot;                                          // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ModelScale;                                        // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUICameraInfoItem) == 0x000008, "Wrong alignment on FUICameraInfoItem");
static_assert(sizeof(FUICameraInfoItem) == 0x000060, "Wrong size on FUICameraInfoItem");
static_assert(offsetof(FUICameraInfoItem, Describe) == 0x000000, "Member 'FUICameraInfoItem::Describe' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, StartIndex) == 0x000010, "Member 'FUICameraInfoItem::StartIndex' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, MiddlePoints) == 0x000018, "Member 'FUICameraInfoItem::MiddlePoints' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, Index) == 0x000028, "Member 'FUICameraInfoItem::Index' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, AnimType) == 0x00002C, "Member 'FUICameraInfoItem::AnimType' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, ModelPos) == 0x000030, "Member 'FUICameraInfoItem::ModelPos' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, ModelRot) == 0x00003C, "Member 'FUICameraInfoItem::ModelRot' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, LightRot) == 0x000048, "Member 'FUICameraInfoItem::LightRot' has a wrong offset!");
static_assert(offsetof(FUICameraInfoItem, ModelScale) == 0x000054, "Member 'FUICameraInfoItem::ModelScale' has a wrong offset!");

// ScriptStruct Game.UICameraInfo
// 0x0078 (0x0080 - 0x0008)
struct FUICameraInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CameraAnimMetaDataInfo;                            // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CacheMetaData;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FUICameraInfoItem> Items;                                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUICameraInfo) == 0x000008, "Wrong alignment on FUICameraInfo");
static_assert(sizeof(FUICameraInfo) == 0x000080, "Wrong size on FUICameraInfo");
static_assert(offsetof(FUICameraInfo, ID) == 0x000008, "Member 'FUICameraInfo::ID' has a wrong offset!");
static_assert(offsetof(FUICameraInfo, CameraAnimMetaDataInfo) == 0x000010, "Member 'FUICameraInfo::CameraAnimMetaDataInfo' has a wrong offset!");
static_assert(offsetof(FUICameraInfo, CacheMetaData) == 0x000028, "Member 'FUICameraInfo::CacheMetaData' has a wrong offset!");
static_assert(offsetof(FUICameraInfo, Items) == 0x000030, "Member 'FUICameraInfo::Items' has a wrong offset!");

// ScriptStruct Game.PlayerEffectSettings
// 0x0038 (0x0038 - 0x0000)
struct FPlayerEffectSettings final
{
public:
	EPostProcessType                              ProcessType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessParams*                     Params;                                            // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessDelayTime;                              // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessAliveTime;                              // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialSlot;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialParameter*>             MaterialParameters;                                // 0x0020(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaterialDelayTime;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerEffectSettings) == 0x000008, "Wrong alignment on FPlayerEffectSettings");
static_assert(sizeof(FPlayerEffectSettings) == 0x000038, "Wrong size on FPlayerEffectSettings");
static_assert(offsetof(FPlayerEffectSettings, ProcessType) == 0x000000, "Member 'FPlayerEffectSettings::ProcessType' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, Params) == 0x000008, "Member 'FPlayerEffectSettings::Params' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, PostProcessDelayTime) == 0x000010, "Member 'FPlayerEffectSettings::PostProcessDelayTime' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, PostProcessAliveTime) == 0x000014, "Member 'FPlayerEffectSettings::PostProcessAliveTime' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, MaterialSlot) == 0x000018, "Member 'FPlayerEffectSettings::MaterialSlot' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, MaterialParameters) == 0x000020, "Member 'FPlayerEffectSettings::MaterialParameters' has a wrong offset!");
static_assert(offsetof(FPlayerEffectSettings, MaterialDelayTime) == 0x000030, "Member 'FPlayerEffectSettings::MaterialDelayTime' has a wrong offset!");

// ScriptStruct Game.UINiagaraConfig
// 0x0088 (0x0090 - 0x0008)
struct FUINiagaraConfig final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Des;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UIName;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterDelay;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        NiagaraAsset;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivePost;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerEffectSettings                  PlayerEffectSettings;                              // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUINiagaraConfig) == 0x000008, "Wrong alignment on FUINiagaraConfig");
static_assert(sizeof(FUINiagaraConfig) == 0x000090, "Wrong size on FUINiagaraConfig");
static_assert(offsetof(FUINiagaraConfig, ID) == 0x000008, "Member 'FUINiagaraConfig::ID' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, Des) == 0x000010, "Member 'FUINiagaraConfig::Des' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, UIName) == 0x000020, "Member 'FUINiagaraConfig::UIName' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, EnterDelay) == 0x000030, "Member 'FUINiagaraConfig::EnterDelay' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, NiagaraAsset) == 0x000038, "Member 'FUINiagaraConfig::NiagaraAsset' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, bActivePost) == 0x000050, "Member 'FUINiagaraConfig::bActivePost' has a wrong offset!");
static_assert(offsetof(FUINiagaraConfig, PlayerEffectSettings) == 0x000058, "Member 'FUINiagaraConfig::PlayerEffectSettings' has a wrong offset!");

// ScriptStruct Game.HPBarTemplate
// 0x00B0 (0x00B8 - 0x0008)
struct FHPBarTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetPath;                                        // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetPivot;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAuxiliaryLineDirection                       AuxiliaryLine;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialRewardPart;                                // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountDown;                                        // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHPBarPriorityRule                            PriorityRule;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysVisible;                                    // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimOrShootVisible;                                // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimComponent;                                     // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillVisible;                                     // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSummonsVisible;                                   // 0x005D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SummonsKeepTime;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeVisible;                                   // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainEffectAccessory;                              // 0x0065(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectAccessoryHPBarID;                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccessoryEffectMain;                              // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnterAimStateVisible;                             // 0x006D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInFightVisible;                                   // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScreenPosCenter;                                  // 0x006F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalPercent;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalPercent;                                 // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayVisibleTime;                                  // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyModifierIcon;                                // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ApplyModifierTag;                                  // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InSightShowDistance;                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockHidden;                                      // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNumLimitHidden;                                   // 0x0095(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNum;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepTimeHidden;                                   // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepTime;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutFightHidden;                                   // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceHidden;                                   // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvisibleHidden;                                  // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayHiddenTime;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveModifierHidden;                             // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHPBarTemplate) == 0x000008, "Wrong alignment on FHPBarTemplate");
static_assert(sizeof(FHPBarTemplate) == 0x0000B8, "Wrong size on FHPBarTemplate");
static_assert(offsetof(FHPBarTemplate, ID) == 0x000008, "Member 'FHPBarTemplate::ID' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, Desc) == 0x000010, "Member 'FHPBarTemplate::Desc' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, WidgetPath) == 0x000020, "Member 'FHPBarTemplate::WidgetPath' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, OffsetPivot) == 0x000048, "Member 'FHPBarTemplate::OffsetPivot' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, AuxiliaryLine) == 0x000050, "Member 'FHPBarTemplate::AuxiliaryLine' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bSpecialRewardPart) == 0x000051, "Member 'FHPBarTemplate::bSpecialRewardPart' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bCountDown) == 0x000052, "Member 'FHPBarTemplate::bCountDown' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, Priority) == 0x000054, "Member 'FHPBarTemplate::Priority' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, PriorityRule) == 0x000058, "Member 'FHPBarTemplate::PriorityRule' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bAlwaysVisible) == 0x000059, "Member 'FHPBarTemplate::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bAimOrShootVisible) == 0x00005A, "Member 'FHPBarTemplate::bAimOrShootVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bAimComponent) == 0x00005B, "Member 'FHPBarTemplate::bAimComponent' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bSkillVisible) == 0x00005C, "Member 'FHPBarTemplate::bSkillVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bSummonsVisible) == 0x00005D, "Member 'FHPBarTemplate::bSummonsVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, SummonsKeepTime) == 0x000060, "Member 'FHPBarTemplate::SummonsKeepTime' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bExplodeVisible) == 0x000064, "Member 'FHPBarTemplate::bExplodeVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bMainEffectAccessory) == 0x000065, "Member 'FHPBarTemplate::bMainEffectAccessory' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, EffectAccessoryHPBarID) == 0x000068, "Member 'FHPBarTemplate::EffectAccessoryHPBarID' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bAccessoryEffectMain) == 0x00006C, "Member 'FHPBarTemplate::bAccessoryEffectMain' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bEnterAimStateVisible) == 0x00006D, "Member 'FHPBarTemplate::bEnterAimStateVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bInFightVisible) == 0x00006E, "Member 'FHPBarTemplate::bInFightVisible' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bScreenPosCenter) == 0x00006F, "Member 'FHPBarTemplate::bScreenPosCenter' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, VerticalPercent) == 0x000070, "Member 'FHPBarTemplate::VerticalPercent' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, HorizontalPercent) == 0x000074, "Member 'FHPBarTemplate::HorizontalPercent' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, DelayVisibleTime) == 0x000078, "Member 'FHPBarTemplate::DelayVisibleTime' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bApplyModifierIcon) == 0x00007C, "Member 'FHPBarTemplate::bApplyModifierIcon' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, ApplyModifierTag) == 0x000080, "Member 'FHPBarTemplate::ApplyModifierTag' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, InSightShowDistance) == 0x000090, "Member 'FHPBarTemplate::InSightShowDistance' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bBlockHidden) == 0x000094, "Member 'FHPBarTemplate::bBlockHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bNumLimitHidden) == 0x000095, "Member 'FHPBarTemplate::bNumLimitHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, MaxNum) == 0x000098, "Member 'FHPBarTemplate::MaxNum' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bKeepTimeHidden) == 0x00009C, "Member 'FHPBarTemplate::bKeepTimeHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, KeepTime) == 0x0000A0, "Member 'FHPBarTemplate::KeepTime' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bOutFightHidden) == 0x0000A4, "Member 'FHPBarTemplate::bOutFightHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bDistanceHidden) == 0x0000A5, "Member 'FHPBarTemplate::bDistanceHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, MaxDistance) == 0x0000A8, "Member 'FHPBarTemplate::MaxDistance' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bInvisibleHidden) == 0x0000AC, "Member 'FHPBarTemplate::bInvisibleHidden' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, DelayHiddenTime) == 0x0000B0, "Member 'FHPBarTemplate::DelayHiddenTime' has a wrong offset!");
static_assert(offsetof(FHPBarTemplate, bRemoveModifierHidden) == 0x0000B4, "Member 'FHPBarTemplate::bRemoveModifierHidden' has a wrong offset!");

// ScriptStruct Game.HPHitRecover
// 0x0010 (0x0010 - 0x0000)
struct FHPHitRecover final
{
public:
	class UCurveFloat*                            HPRecoversCurve;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHPHitRecover) == 0x000008, "Wrong alignment on FHPHitRecover");
static_assert(sizeof(FHPHitRecover) == 0x000010, "Wrong size on FHPHitRecover");
static_assert(offsetof(FHPHitRecover, HPRecoversCurve) == 0x000000, "Member 'FHPHitRecover::HPRecoversCurve' has a wrong offset!");

// ScriptStruct Game.WidgetAnimTrackData
// 0x0050 (0x0050 - 0x0000)
struct FWidgetAnimTrackData final
{
public:
	TMap<class FName, struct FAllAnimTrackData>   Tracks;                                            // 0x0000(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetAnimTrackData) == 0x000008, "Wrong alignment on FWidgetAnimTrackData");
static_assert(sizeof(FWidgetAnimTrackData) == 0x000050, "Wrong size on FWidgetAnimTrackData");
static_assert(offsetof(FWidgetAnimTrackData, Tracks) == 0x000000, "Member 'FWidgetAnimTrackData::Tracks' has a wrong offset!");

// ScriptStruct Game.VATNiagaraData
// 0x0040 (0x0040 - 0x0000)
struct FVATNiagaraData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraDataInterfaceArrayFloat3*       NDIPosition;                                       // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraDataInterfaceArrayQuat*         NDIRotation;                                       // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraDataInterfaceArrayFloat3*       NDIScale;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraDataInterfaceArrayFloat*        NDIParticle;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraDataInterfaceArrayFloat*        NDIDynamicValue;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATNiagaraData) == 0x000008, "Wrong alignment on FVATNiagaraData");
static_assert(sizeof(FVATNiagaraData) == 0x000040, "Wrong size on FVATNiagaraData");
static_assert(offsetof(FVATNiagaraData, NDIPosition) == 0x000018, "Member 'FVATNiagaraData::NDIPosition' has a wrong offset!");
static_assert(offsetof(FVATNiagaraData, NDIRotation) == 0x000020, "Member 'FVATNiagaraData::NDIRotation' has a wrong offset!");
static_assert(offsetof(FVATNiagaraData, NDIScale) == 0x000028, "Member 'FVATNiagaraData::NDIScale' has a wrong offset!");
static_assert(offsetof(FVATNiagaraData, NDIParticle) == 0x000030, "Member 'FVATNiagaraData::NDIParticle' has a wrong offset!");
static_assert(offsetof(FVATNiagaraData, NDIDynamicValue) == 0x000038, "Member 'FVATNiagaraData::NDIDynamicValue' has a wrong offset!");

// ScriptStruct Game.VatAnimation
// 0x0030 (0x0030 - 0x0000)
struct FVatAnimation final
{
public:
	int32                                         StartFrame;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFrame;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVatAnimationNTF*>               NTF;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UVatAnimationStateNTF*>          StateNTF;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVatAnimation) == 0x000008, "Wrong alignment on FVatAnimation");
static_assert(sizeof(FVatAnimation) == 0x000030, "Wrong size on FVatAnimation");
static_assert(offsetof(FVatAnimation, StartFrame) == 0x000000, "Member 'FVatAnimation::StartFrame' has a wrong offset!");
static_assert(offsetof(FVatAnimation, EndFrame) == 0x000004, "Member 'FVatAnimation::EndFrame' has a wrong offset!");
static_assert(offsetof(FVatAnimation, bLoop) == 0x000008, "Member 'FVatAnimation::bLoop' has a wrong offset!");
static_assert(offsetof(FVatAnimation, NTF) == 0x000010, "Member 'FVatAnimation::NTF' has a wrong offset!");
static_assert(offsetof(FVatAnimation, StateNTF) == 0x000020, "Member 'FVatAnimation::StateNTF' has a wrong offset!");

// ScriptStruct Game.VATMaterialParam
// 0x0108 (0x0108 - 0x0000)
struct FVATMaterialParam final
{
public:
	class FString                                 KeyPropName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectId;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    Offset;                                            // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    DefaultScalars;                                    // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLinearColor>      DefaultVectors;                                    // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVATMaterialParam) == 0x000008, "Wrong alignment on FVATMaterialParam");
static_assert(sizeof(FVATMaterialParam) == 0x000108, "Wrong size on FVATMaterialParam");
static_assert(offsetof(FVATMaterialParam, KeyPropName) == 0x000000, "Member 'FVATMaterialParam::KeyPropName' has a wrong offset!");
static_assert(offsetof(FVATMaterialParam, EffectId) == 0x000010, "Member 'FVATMaterialParam::EffectId' has a wrong offset!");
static_assert(offsetof(FVATMaterialParam, Offset) == 0x000018, "Member 'FVATMaterialParam::Offset' has a wrong offset!");
static_assert(offsetof(FVATMaterialParam, DefaultScalars) == 0x000068, "Member 'FVATMaterialParam::DefaultScalars' has a wrong offset!");
static_assert(offsetof(FVATMaterialParam, DefaultVectors) == 0x0000B8, "Member 'FVATMaterialParam::DefaultVectors' has a wrong offset!");

// ScriptStruct Game.VehicleInputRateCurve
// 0x0110 (0x0110 - 0x0000)
struct FVehicleInputRateCurve final
{
public:
	struct FRuntimeFloatCurve                     RiseRateCurve;                                     // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FallRateCurve;                                     // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleInputRateCurve) == 0x000008, "Wrong alignment on FVehicleInputRateCurve");
static_assert(sizeof(FVehicleInputRateCurve) == 0x000110, "Wrong size on FVehicleInputRateCurve");
static_assert(offsetof(FVehicleInputRateCurve, RiseRateCurve) == 0x000000, "Member 'FVehicleInputRateCurve::RiseRateCurve' has a wrong offset!");
static_assert(offsetof(FVehicleInputRateCurve, FallRateCurve) == 0x000088, "Member 'FVehicleInputRateCurve::FallRateCurve' has a wrong offset!");

// ScriptStruct Game.VehicleNitrousRuntimeData
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FVehicleNitrousRuntimeData final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleNitrousRuntimeData) == 0x000008, "Wrong alignment on FVehicleNitrousRuntimeData");
static_assert(sizeof(FVehicleNitrousRuntimeData) == 0x0000A0, "Wrong size on FVehicleNitrousRuntimeData");

// ScriptStruct Game.View_ManifestationCharacter
// 0x0150 (0x0158 - 0x0008)
struct FView_ManifestationCharacter final : public FTableRowBase
{
public:
	struct FViewGirlMain                          FViewGirl;                                         // 0x0008(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FViewGirlMain                          FViewGirlAllAges;                                  // 0x00B0(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_ManifestationCharacter) == 0x000008, "Wrong alignment on FView_ManifestationCharacter");
static_assert(sizeof(FView_ManifestationCharacter) == 0x000158, "Wrong size on FView_ManifestationCharacter");
static_assert(offsetof(FView_ManifestationCharacter, FViewGirl) == 0x000008, "Member 'FView_ManifestationCharacter::FViewGirl' has a wrong offset!");
static_assert(offsetof(FView_ManifestationCharacter, FViewGirlAllAges) == 0x0000B0, "Member 'FView_ManifestationCharacter::FViewGirlAllAges' has a wrong offset!");

// ScriptStruct Game.View_HouseBeach_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_HouseBeach_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_ManifestationCharacter> View_HouseBeach;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_HouseBeach_DataTable) == 0x000008, "Wrong alignment on FView_HouseBeach_DataTable");
static_assert(sizeof(FView_HouseBeach_DataTable) == 0x000058, "Wrong size on FView_HouseBeach_DataTable");
static_assert(offsetof(FView_HouseBeach_DataTable, View_HouseBeach) == 0x000008, "Member 'FView_HouseBeach_DataTable::View_HouseBeach' has a wrong offset!");

// ScriptStruct Game.View_HousePhoto_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_HousePhoto_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_ManifestationCharacter> View_HousePhoto;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_HousePhoto_DataTable) == 0x000008, "Wrong alignment on FView_HousePhoto_DataTable");
static_assert(sizeof(FView_HousePhoto_DataTable) == 0x000058, "Wrong size on FView_HousePhoto_DataTable");
static_assert(offsetof(FView_HousePhoto_DataTable, View_HousePhoto) == 0x000008, "Member 'FView_HousePhoto_DataTable::View_HousePhoto' has a wrong offset!");

// ScriptStruct Game.View_Boss
// 0x0078 (0x0080 - 0x0008)
struct FView_Boss final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UViewLightData>          BossLight;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewOtherLightData>     BossOtherLight;                                    // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewEnvironmentData>    BossEnv;                                           // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Boss) == 0x000008, "Wrong alignment on FView_Boss");
static_assert(sizeof(FView_Boss) == 0x000080, "Wrong size on FView_Boss");
static_assert(offsetof(FView_Boss, BossLight) == 0x000008, "Member 'FView_Boss::BossLight' has a wrong offset!");
static_assert(offsetof(FView_Boss, BossOtherLight) == 0x000030, "Member 'FView_Boss::BossOtherLight' has a wrong offset!");
static_assert(offsetof(FView_Boss, BossEnv) == 0x000058, "Member 'FView_Boss::BossEnv' has a wrong offset!");

// ScriptStruct Game.View_Boss_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_Boss_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_Boss>        View_Boss;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Boss_DataTable) == 0x000008, "Wrong alignment on FView_Boss_DataTable");
static_assert(sizeof(FView_Boss_DataTable) == 0x000058, "Wrong size on FView_Boss_DataTable");
static_assert(offsetof(FView_Boss_DataTable, View_Boss) == 0x000008, "Member 'FView_Boss_DataTable::View_Boss' has a wrong offset!");

// ScriptStruct Game.View_Weapon
// 0x0078 (0x0080 - 0x0008)
struct FView_Weapon final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UViewLightData>          EnvironmentLight;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewOtherLightData>     EnvOtherLight;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UViewEnvironmentData>    EnvironmentEnv;                                    // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Weapon) == 0x000008, "Wrong alignment on FView_Weapon");
static_assert(sizeof(FView_Weapon) == 0x000080, "Wrong size on FView_Weapon");
static_assert(offsetof(FView_Weapon, EnvironmentLight) == 0x000008, "Member 'FView_Weapon::EnvironmentLight' has a wrong offset!");
static_assert(offsetof(FView_Weapon, EnvOtherLight) == 0x000030, "Member 'FView_Weapon::EnvOtherLight' has a wrong offset!");
static_assert(offsetof(FView_Weapon, EnvironmentEnv) == 0x000058, "Member 'FView_Weapon::EnvironmentEnv' has a wrong offset!");

// ScriptStruct Game.View_Weapon_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_Weapon_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_Weapon>      View_Weapon;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Weapon_DataTable) == 0x000008, "Wrong alignment on FView_Weapon_DataTable");
static_assert(sizeof(FView_Weapon_DataTable) == 0x000058, "Wrong size on FView_Weapon_DataTable");
static_assert(offsetof(FView_Weapon_DataTable, View_Weapon) == 0x000008, "Member 'FView_Weapon_DataTable::View_Weapon' has a wrong offset!");

// ScriptStruct Game.View_Manifestation_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_Manifestation_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_ManifestationCharacter> View_ManifestationCharacter;                       // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Manifestation_DataTable) == 0x000008, "Wrong alignment on FView_Manifestation_DataTable");
static_assert(sizeof(FView_Manifestation_DataTable) == 0x000058, "Wrong size on FView_Manifestation_DataTable");
static_assert(offsetof(FView_Manifestation_DataTable, View_ManifestationCharacter) == 0x000008, "Member 'FView_Manifestation_DataTable::View_ManifestationCharacter' has a wrong offset!");

// ScriptStruct Game.View_Character_DataTable
// 0x0050 (0x0058 - 0x0008)
struct FView_Character_DataTable final : public FTableRowBase
{
public:
	TMap<class FString, struct FView_Character>   View_Character;                                    // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Character_DataTable) == 0x000008, "Wrong alignment on FView_Character_DataTable");
static_assert(sizeof(FView_Character_DataTable) == 0x000058, "Wrong size on FView_Character_DataTable");
static_assert(offsetof(FView_Character_DataTable, View_Character) == 0x000008, "Member 'FView_Character_DataTable::View_Character' has a wrong offset!");

// ScriptStruct Game.View_Niagara_Str
// 0x0028 (0x0030 - 0x0008)
struct FView_Niagara_Str final : public FTableRowBase
{
public:
	float                                         View_Niagara_Size;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               View_Niagara_Rotate;                               // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         View_Niagara_XCount;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                View_Niagara_Dimension;                            // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         View_Niagara_YCount;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         View_Niagara_ZCount;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Niagara_Str) == 0x000008, "Wrong alignment on FView_Niagara_Str");
static_assert(sizeof(FView_Niagara_Str) == 0x000030, "Wrong size on FView_Niagara_Str");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_Size) == 0x000008, "Member 'FView_Niagara_Str::View_Niagara_Size' has a wrong offset!");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_Rotate) == 0x00000C, "Member 'FView_Niagara_Str::View_Niagara_Rotate' has a wrong offset!");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_XCount) == 0x000018, "Member 'FView_Niagara_Str::View_Niagara_XCount' has a wrong offset!");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_Dimension) == 0x00001C, "Member 'FView_Niagara_Str::View_Niagara_Dimension' has a wrong offset!");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_YCount) == 0x000028, "Member 'FView_Niagara_Str::View_Niagara_YCount' has a wrong offset!");
static_assert(offsetof(FView_Niagara_Str, View_Niagara_ZCount) == 0x00002C, "Member 'FView_Niagara_Str::View_Niagara_ZCount' has a wrong offset!");

// ScriptStruct Game.View_Environment_Str
// 0x0060 (0x0068 - 0x0008)
struct FView_Environment_Str final : public FTableRowBase
{
public:
	TMap<class FName, struct FTransform>          View_Environment_Parameter;                        // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         View_EnvMesh_Line_Radius;                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_EnvMesh_Line_Tile;                            // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_EnvMesh_Line_Rotate;                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_EnvMesh_Line_OffsetV;                         // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Environment_Str) == 0x000008, "Wrong alignment on FView_Environment_Str");
static_assert(sizeof(FView_Environment_Str) == 0x000068, "Wrong size on FView_Environment_Str");
static_assert(offsetof(FView_Environment_Str, View_Environment_Parameter) == 0x000008, "Member 'FView_Environment_Str::View_Environment_Parameter' has a wrong offset!");
static_assert(offsetof(FView_Environment_Str, View_EnvMesh_Line_Radius) == 0x000058, "Member 'FView_Environment_Str::View_EnvMesh_Line_Radius' has a wrong offset!");
static_assert(offsetof(FView_Environment_Str, View_EnvMesh_Line_Tile) == 0x00005C, "Member 'FView_Environment_Str::View_EnvMesh_Line_Tile' has a wrong offset!");
static_assert(offsetof(FView_Environment_Str, View_EnvMesh_Line_Rotate) == 0x000060, "Member 'FView_Environment_Str::View_EnvMesh_Line_Rotate' has a wrong offset!");
static_assert(offsetof(FView_Environment_Str, View_EnvMesh_Line_OffsetV) == 0x000064, "Member 'FView_Environment_Str::View_EnvMesh_Line_OffsetV' has a wrong offset!");

// ScriptStruct Game.View_Character_SecondaryMat
// 0x00A0 (0x00A8 - 0x0008)
struct FView_Character_SecondaryMat final : public FTableRowBase
{
public:
	TMap<class FString, TSoftObjectPtr<class UMaterialInstance>> ViewCharacterSecData;                              // 0x0008(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, TSoftObjectPtr<class UMaterialInstance>> View_Character_SecMAT;                             // 0x0058(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Character_SecondaryMat) == 0x000008, "Wrong alignment on FView_Character_SecondaryMat");
static_assert(sizeof(FView_Character_SecondaryMat) == 0x0000A8, "Wrong size on FView_Character_SecondaryMat");
static_assert(offsetof(FView_Character_SecondaryMat, ViewCharacterSecData) == 0x000008, "Member 'FView_Character_SecondaryMat::ViewCharacterSecData' has a wrong offset!");
static_assert(offsetof(FView_Character_SecondaryMat, View_Character_SecMAT) == 0x000058, "Member 'FView_Character_SecondaryMat::View_Character_SecMAT' has a wrong offset!");

// ScriptStruct Game.View_Character_Main
// 0x0130 (0x0138 - 0x0008)
struct FView_Character_Main final : public FTableRowBase
{
public:
	class FString                                 ViewCharacterMaterialSlotName;                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         View_Character_MaterialIndex;                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      View_Character_floatParameter;                     // 0x0020(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        View_Character_ColorParameter;                     // 0x0070(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UTexture2D>> View_Character_TexParameter;                       // 0x00C0(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       View_Character_Mat;                                // 0x0110(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_Character_Main) == 0x000008, "Wrong alignment on FView_Character_Main");
static_assert(sizeof(FView_Character_Main) == 0x000138, "Wrong size on FView_Character_Main");
static_assert(offsetof(FView_Character_Main, ViewCharacterMaterialSlotName) == 0x000008, "Member 'FView_Character_Main::ViewCharacterMaterialSlotName' has a wrong offset!");
static_assert(offsetof(FView_Character_Main, View_Character_MaterialIndex) == 0x000018, "Member 'FView_Character_Main::View_Character_MaterialIndex' has a wrong offset!");
static_assert(offsetof(FView_Character_Main, View_Character_floatParameter) == 0x000020, "Member 'FView_Character_Main::View_Character_floatParameter' has a wrong offset!");
static_assert(offsetof(FView_Character_Main, View_Character_ColorParameter) == 0x000070, "Member 'FView_Character_Main::View_Character_ColorParameter' has a wrong offset!");
static_assert(offsetof(FView_Character_Main, View_Character_TexParameter) == 0x0000C0, "Member 'FView_Character_Main::View_Character_TexParameter' has a wrong offset!");
static_assert(offsetof(FView_Character_Main, View_Character_Mat) == 0x000110, "Member 'FView_Character_Main::View_Character_Mat' has a wrong offset!");

// ScriptStruct Game.View_DirectionalLight
// 0x0048 (0x0050 - 0x0008)
struct FView_DirectionalLight final : public FTableRowBase
{
public:
	struct FVector                                View_DirLight_Location;                            // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               View_DirLight_Rotation;                            // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           View_DirLight_LightColor;                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_ShadowResolutionScale;               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_Distance;                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_BoundScale;                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_ShadowBias;                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_ShadowSlopeBias;              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         View_DirLight_Shadow_NumDynamicShadowCascades;     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_DistributionExponent;         // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         View_DirLight_Shadow_DistanceFadeoutFraction;      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FView_DirectionalLight) == 0x000008, "Wrong alignment on FView_DirectionalLight");
static_assert(sizeof(FView_DirectionalLight) == 0x000050, "Wrong size on FView_DirectionalLight");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Location) == 0x000008, "Member 'FView_DirectionalLight::View_DirLight_Location' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Rotation) == 0x000014, "Member 'FView_DirectionalLight::View_DirLight_Rotation' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_LightColor) == 0x000020, "Member 'FView_DirectionalLight::View_DirLight_LightColor' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_ShadowResolutionScale) == 0x000030, "Member 'FView_DirectionalLight::View_DirLight_ShadowResolutionScale' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_Distance) == 0x000034, "Member 'FView_DirectionalLight::View_DirLight_Shadow_Distance' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_BoundScale) == 0x000038, "Member 'FView_DirectionalLight::View_DirLight_Shadow_BoundScale' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_ShadowBias) == 0x00003C, "Member 'FView_DirectionalLight::View_DirLight_Shadow_ShadowBias' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_ShadowSlopeBias) == 0x000040, "Member 'FView_DirectionalLight::View_DirLight_Shadow_ShadowSlopeBias' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_NumDynamicShadowCascades) == 0x000044, "Member 'FView_DirectionalLight::View_DirLight_Shadow_NumDynamicShadowCascades' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_DistributionExponent) == 0x000048, "Member 'FView_DirectionalLight::View_DirLight_Shadow_DistributionExponent' has a wrong offset!");
static_assert(offsetof(FView_DirectionalLight, View_DirLight_Shadow_DistanceFadeoutFraction) == 0x00004C, "Member 'FView_DirectionalLight::View_DirLight_Shadow_DistanceFadeoutFraction' has a wrong offset!");

// ScriptStruct Game.VoiceItemCollection
// 0x0018 (0x0018 - 0x0000)
struct FVoiceItemCollection final
{
public:
	TArray<struct FVoiceItem>                     Items;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TotalWeight;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoiceItemCollection) == 0x000008, "Wrong alignment on FVoiceItemCollection");
static_assert(sizeof(FVoiceItemCollection) == 0x000018, "Wrong size on FVoiceItemCollection");
static_assert(offsetof(FVoiceItemCollection, Items) == 0x000000, "Member 'FVoiceItemCollection::Items' has a wrong offset!");
static_assert(offsetof(FVoiceItemCollection, TotalWeight) == 0x000010, "Member 'FVoiceItemCollection::TotalWeight' has a wrong offset!");

// ScriptStruct Game.VoiceInfo
// 0x0060 (0x0060 - 0x0000)
struct FVoiceInfo final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInterrupt : 1;                                    // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CD;                                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FVoiceItemCollection>      WwiseEvents;                                       // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoiceInfo) == 0x000008, "Wrong alignment on FVoiceInfo");
static_assert(sizeof(FVoiceInfo) == 0x000060, "Wrong size on FVoiceInfo");
static_assert(offsetof(FVoiceInfo, Rate) == 0x000000, "Member 'FVoiceInfo::Rate' has a wrong offset!");
static_assert(offsetof(FVoiceInfo, Priority) == 0x000004, "Member 'FVoiceInfo::Priority' has a wrong offset!");
static_assert(offsetof(FVoiceInfo, CD) == 0x00000C, "Member 'FVoiceInfo::CD' has a wrong offset!");
static_assert(offsetof(FVoiceInfo, WwiseEvents) == 0x000010, "Member 'FVoiceInfo::WwiseEvents' has a wrong offset!");

// ScriptStruct Game.WPBabyMode
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x08) FWPBabyMode final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  CurTarget;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugMoveDelta;                                   // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0xF];                                       // 0x00A9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWPBabyMode) == 0x000008, "Wrong alignment on FWPBabyMode");
static_assert(sizeof(FWPBabyMode) == 0x0000B8, "Wrong size on FWPBabyMode");
static_assert(offsetof(FWPBabyMode, CurTarget) == 0x000078, "Member 'FWPBabyMode::CurTarget' has a wrong offset!");
static_assert(offsetof(FWPBabyMode, bDebugMoveDelta) == 0x0000A8, "Member 'FWPBabyMode::bDebugMoveDelta' has a wrong offset!");

// ScriptStruct Game.WPAbilityLastForceFeedbackInfo
// 0x0020 (0x0020 - 0x0000)
struct FWPAbilityLastForceFeedbackInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEAbilityForceFeedbackType                   Type;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColdDownTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWPAbilityLastForceFeedbackInfo) == 0x000004, "Wrong alignment on FWPAbilityLastForceFeedbackInfo");
static_assert(sizeof(FWPAbilityLastForceFeedbackInfo) == 0x000020, "Wrong size on FWPAbilityLastForceFeedbackInfo");
static_assert(offsetof(FWPAbilityLastForceFeedbackInfo, ID) == 0x000000, "Member 'FWPAbilityLastForceFeedbackInfo::ID' has a wrong offset!");
static_assert(offsetof(FWPAbilityLastForceFeedbackInfo, Type) == 0x000004, "Member 'FWPAbilityLastForceFeedbackInfo::Type' has a wrong offset!");
static_assert(offsetof(FWPAbilityLastForceFeedbackInfo, ColdDownTime) == 0x000008, "Member 'FWPAbilityLastForceFeedbackInfo::ColdDownTime' has a wrong offset!");
static_assert(offsetof(FWPAbilityLastForceFeedbackInfo, BlendOutTime) == 0x00000C, "Member 'FWPAbilityLastForceFeedbackInfo::BlendOutTime' has a wrong offset!");

// ScriptStruct Game.WPPostParamEffectTimer
// 0x0020 (0x0020 - 0x0000)
struct FWPPostParamEffectTimer final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostId;                                            // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWPPostParamEffectTimer) == 0x000008, "Wrong alignment on FWPPostParamEffectTimer");
static_assert(sizeof(FWPPostParamEffectTimer) == 0x000020, "Wrong size on FWPPostParamEffectTimer");
static_assert(offsetof(FWPPostParamEffectTimer, Name) == 0x000000, "Member 'FWPPostParamEffectTimer::Name' has a wrong offset!");
static_assert(offsetof(FWPPostParamEffectTimer, PostId) == 0x000010, "Member 'FWPPostParamEffectTimer::PostId' has a wrong offset!");
static_assert(offsetof(FWPPostParamEffectTimer, Duration) == 0x000014, "Member 'FWPPostParamEffectTimer::Duration' has a wrong offset!");
static_assert(offsetof(FWPPostParamEffectTimer, Timer) == 0x000018, "Member 'FWPPostParamEffectTimer::Timer' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DarkZone

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DarkZone_structs.hpp"
#include "GameTask_structs.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class DarkZone.DarkZoneActorInterface
// 0x0000 (0x0028 - 0x0028)
class IDarkZoneActorInterface final : public IInterface
{
public:
	void InitActor(int32 InActorId, int32 State, const TArray<float>& CustomParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneActorInterface">();
	}
	static class IDarkZoneActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDarkZoneActorInterface>();
	}
};
static_assert(alignof(IDarkZoneActorInterface) == 0x000008, "Wrong alignment on IDarkZoneActorInterface");
static_assert(sizeof(IDarkZoneActorInterface) == 0x000028, "Wrong size on IDarkZoneActorInterface");

// Class DarkZone.DarkZoneFogActor
// 0x0018 (0x0240 - 0x0228)
class ADarkZoneFogActor final : public AActor
{
public:
	int32                                         Index_0;                                           // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Explain;                                           // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneFogActor">();
	}
	static class ADarkZoneFogActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneFogActor>();
	}
};
static_assert(alignof(ADarkZoneFogActor) == 0x000008, "Wrong alignment on ADarkZoneFogActor");
static_assert(sizeof(ADarkZoneFogActor) == 0x000240, "Wrong size on ADarkZoneFogActor");
static_assert(offsetof(ADarkZoneFogActor, Index_0) == 0x000228, "Member 'ADarkZoneFogActor::Index_0' has a wrong offset!");
static_assert(offsetof(ADarkZoneFogActor, Explain) == 0x000230, "Member 'ADarkZoneFogActor::Explain' has a wrong offset!");

// Class DarkZone.DarkZoneFogSwitchActor
// 0x0038 (0x0260 - 0x0228)
class ADarkZoneFogSwitchActor final : public AActor
{
public:
	class UDarkZoneSystem*                        System;                                            // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSwitchTime;                                   // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x2C];                                     // 0x0234(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveCustomFog(int32 InIndex);
	void Switch(int32 A, int32 B, float InProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneFogSwitchActor">();
	}
	static class ADarkZoneFogSwitchActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneFogSwitchActor>();
	}
};
static_assert(alignof(ADarkZoneFogSwitchActor) == 0x000008, "Wrong alignment on ADarkZoneFogSwitchActor");
static_assert(sizeof(ADarkZoneFogSwitchActor) == 0x000260, "Wrong size on ADarkZoneFogSwitchActor");
static_assert(offsetof(ADarkZoneFogSwitchActor, System) == 0x000228, "Member 'ADarkZoneFogSwitchActor::System' has a wrong offset!");
static_assert(offsetof(ADarkZoneFogSwitchActor, TotalSwitchTime) == 0x000230, "Member 'ADarkZoneFogSwitchActor::TotalSwitchTime' has a wrong offset!");

// Class DarkZone.DarkZoneGeneralTriggerRegion
// 0x0030 (0x0258 - 0x0228)
class ADarkZoneGeneralTriggerRegion final : public AActor
{
public:
	class FString                                 Type;                                              // 0x0228(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegionId;                                          // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FogLevel;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FogLayer;                                          // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDarkZoneRegionExportButton            Export;                                            // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ShowRegion;                                        // 0x0249(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ShowFogLevel;                                      // 0x024A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B[0xD];                                      // 0x024B(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEntryRegion();
	void OnExitRegion();

	TArray<class FString> GetList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneGeneralTriggerRegion">();
	}
	static class ADarkZoneGeneralTriggerRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneGeneralTriggerRegion>();
	}
};
static_assert(alignof(ADarkZoneGeneralTriggerRegion) == 0x000008, "Wrong alignment on ADarkZoneGeneralTriggerRegion");
static_assert(sizeof(ADarkZoneGeneralTriggerRegion) == 0x000258, "Wrong size on ADarkZoneGeneralTriggerRegion");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, Type) == 0x000228, "Member 'ADarkZoneGeneralTriggerRegion::Type' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, RegionId) == 0x000238, "Member 'ADarkZoneGeneralTriggerRegion::RegionId' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, FogLevel) == 0x00023C, "Member 'ADarkZoneGeneralTriggerRegion::FogLevel' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, FogLayer) == 0x000240, "Member 'ADarkZoneGeneralTriggerRegion::FogLayer' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, Export) == 0x000248, "Member 'ADarkZoneGeneralTriggerRegion::Export' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, ShowRegion) == 0x000249, "Member 'ADarkZoneGeneralTriggerRegion::ShowRegion' has a wrong offset!");
static_assert(offsetof(ADarkZoneGeneralTriggerRegion, ShowFogLevel) == 0x00024A, "Member 'ADarkZoneGeneralTriggerRegion::ShowFogLevel' has a wrong offset!");

// Class DarkZone.DarkZoneMapPointMgr
// 0x00F8 (0x0320 - 0x0228)
class ADarkZoneMapPointMgr final : public AActor
{
public:
	uint8                                         Pad_228[0xA0];                                     // 0x0228(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, TWeakObjectPtr<class AActor>>     AllSpawnActor;                                     // 0x02C8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetSpawnActor(int32 ActorId);
	void OnDestroyActor(int32 ActorId);
	class AActor* TrySpawnActor(int32 ActorId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneMapPointMgr">();
	}
	static class ADarkZoneMapPointMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneMapPointMgr>();
	}
};
static_assert(alignof(ADarkZoneMapPointMgr) == 0x000008, "Wrong alignment on ADarkZoneMapPointMgr");
static_assert(sizeof(ADarkZoneMapPointMgr) == 0x000320, "Wrong size on ADarkZoneMapPointMgr");
static_assert(offsetof(ADarkZoneMapPointMgr, AllSpawnActor) == 0x0002C8, "Member 'ADarkZoneMapPointMgr::AllSpawnActor' has a wrong offset!");

// Class DarkZone.DarkZoneNavLinkProxy
// 0x0028 (0x02A0 - 0x0278)
class ADarkZoneNavLinkProxy final : public ANavLinkProxy
{
public:
	TArray<struct FVector>                        TargetArray;                                       // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsClosed;                                          // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interval;                                          // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoFill();
	void Clear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneNavLinkProxy">();
	}
	static class ADarkZoneNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneNavLinkProxy>();
	}
};
static_assert(alignof(ADarkZoneNavLinkProxy) == 0x000008, "Wrong alignment on ADarkZoneNavLinkProxy");
static_assert(sizeof(ADarkZoneNavLinkProxy) == 0x0002A0, "Wrong size on ADarkZoneNavLinkProxy");
static_assert(offsetof(ADarkZoneNavLinkProxy, TargetArray) == 0x000278, "Member 'ADarkZoneNavLinkProxy::TargetArray' has a wrong offset!");
static_assert(offsetof(ADarkZoneNavLinkProxy, IsClosed) == 0x000288, "Member 'ADarkZoneNavLinkProxy::IsClosed' has a wrong offset!");
static_assert(offsetof(ADarkZoneNavLinkProxy, Interval) == 0x00028C, "Member 'ADarkZoneNavLinkProxy::Interval' has a wrong offset!");

// Class DarkZone.DarkZonePatrolArea
// 0x0010 (0x0238 - 0x0228)
class ADarkZonePatrolArea final : public AActor
{
public:
	class UCapsuleComponent*                      Capsule;                                           // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IdleTimeRange;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetRandomPos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZonePatrolArea">();
	}
	static class ADarkZonePatrolArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZonePatrolArea>();
	}
};
static_assert(alignof(ADarkZonePatrolArea) == 0x000008, "Wrong alignment on ADarkZonePatrolArea");
static_assert(sizeof(ADarkZonePatrolArea) == 0x000238, "Wrong size on ADarkZonePatrolArea");
static_assert(offsetof(ADarkZonePatrolArea, Capsule) == 0x000228, "Member 'ADarkZonePatrolArea::Capsule' has a wrong offset!");
static_assert(offsetof(ADarkZonePatrolArea, IdleTimeRange) == 0x000230, "Member 'ADarkZonePatrolArea::IdleTimeRange' has a wrong offset!");

// Class DarkZone.DarkZoneMapPoint
// 0x0038 (0x0260 - 0x0228)
class ADarkZoneMapPoint final : public AActor
{
public:
	int32                                         Type;                                              // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CustomParam;                                       // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDarkZonePointTypeComboBox             TypeComboBox;                                      // 0x0240(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDarkZonePointInteractionComboBox      InteractionComboBox;                               // 0x0244(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDarkZonePointExportButton             Export;                                            // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnActor;                                        // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADarkZoneMapPointMgr*                   Mgr;                                               // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneMapPoint">();
	}
	static class ADarkZoneMapPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneMapPoint>();
	}
};
static_assert(alignof(ADarkZoneMapPoint) == 0x000008, "Wrong alignment on ADarkZoneMapPoint");
static_assert(sizeof(ADarkZoneMapPoint) == 0x000260, "Wrong size on ADarkZoneMapPoint");
static_assert(offsetof(ADarkZoneMapPoint, Type) == 0x000228, "Member 'ADarkZoneMapPoint::Type' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, ID) == 0x00022C, "Member 'ADarkZoneMapPoint::ID' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, CustomParam) == 0x000230, "Member 'ADarkZoneMapPoint::CustomParam' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, TypeComboBox) == 0x000240, "Member 'ADarkZoneMapPoint::TypeComboBox' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, InteractionComboBox) == 0x000244, "Member 'ADarkZoneMapPoint::InteractionComboBox' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, Export) == 0x000248, "Member 'ADarkZoneMapPoint::Export' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, SpawnActor) == 0x000250, "Member 'ADarkZoneMapPoint::SpawnActor' has a wrong offset!");
static_assert(offsetof(ADarkZoneMapPoint, Mgr) == 0x000258, "Member 'ADarkZoneMapPoint::Mgr' has a wrong offset!");

// Class DarkZone.DarkZoneNpcPoint
// 0x0038 (0x0260 - 0x0228)
class ADarkZoneNpcPoint final : public AActor
{
public:
	struct FDarkZoneNpcPointExportButton          Export;                                            // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DropGroup;                                         // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x28];                                     // 0x0238(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneNpcPoint">();
	}
	static class ADarkZoneNpcPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneNpcPoint>();
	}
};
static_assert(alignof(ADarkZoneNpcPoint) == 0x000008, "Wrong alignment on ADarkZoneNpcPoint");
static_assert(sizeof(ADarkZoneNpcPoint) == 0x000260, "Wrong size on ADarkZoneNpcPoint");
static_assert(offsetof(ADarkZoneNpcPoint, Export) == 0x000228, "Member 'ADarkZoneNpcPoint::Export' has a wrong offset!");
static_assert(offsetof(ADarkZoneNpcPoint, DropGroup) == 0x00022C, "Member 'ADarkZoneNpcPoint::DropGroup' has a wrong offset!");
static_assert(offsetof(ADarkZoneNpcPoint, ArrowComponent) == 0x000230, "Member 'ADarkZoneNpcPoint::ArrowComponent' has a wrong offset!");

// Class DarkZone.DarkZoneRegionMgr
// 0x0028 (0x0250 - 0x0228)
class ADarkZoneRegionMgr final : public AActor
{
public:
	uint8                                         Pad_228[0x28];                                     // 0x0228(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneRegionMgr">();
	}
	static class ADarkZoneRegionMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneRegionMgr>();
	}
};
static_assert(alignof(ADarkZoneRegionMgr) == 0x000008, "Wrong alignment on ADarkZoneRegionMgr");
static_assert(sizeof(ADarkZoneRegionMgr) == 0x000250, "Wrong size on ADarkZoneRegionMgr");

// Class DarkZone.DarkZoneSettingSystem
// 0x0150 (0x0180 - 0x0030)
class UDarkZoneSettingSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x150];                                     // 0x0030(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneSettingSystem">();
	}
	static class UDarkZoneSettingSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkZoneSettingSystem>();
	}
};
static_assert(alignof(UDarkZoneSettingSystem) == 0x000008, "Wrong alignment on UDarkZoneSettingSystem");
static_assert(sizeof(UDarkZoneSettingSystem) == 0x000180, "Wrong size on UDarkZoneSettingSystem");

// Class DarkZone.DarkZoneSpecialLogic
// 0x0020 (0x0248 - 0x0228)
class ADarkZoneSpecialLogic final : public AActor
{
public:
	uint8                                         Pad_228[0x20];                                     // 0x0228(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddGZ(int32 Val);
	int32 GetGZ();
	int32 GetGZLevel();
	int32 GetGZMax();
	int32 GetGZSpeed();
	void SetGZ(const int32 Val);
	void SetGZLevelAndSpeed(const int32 Level, const int32 Speed);
	void SetGZMax(const int32 Val);
	void SetGZRate(const float Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneSpecialLogic">();
	}
	static class ADarkZoneSpecialLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneSpecialLogic>();
	}
};
static_assert(alignof(ADarkZoneSpecialLogic) == 0x000008, "Wrong alignment on ADarkZoneSpecialLogic");
static_assert(sizeof(ADarkZoneSpecialLogic) == 0x000248, "Wrong size on ADarkZoneSpecialLogic");

// Class DarkZone.DarkZoneSystem
// 0x0120 (0x0150 - 0x0030)
class UDarkZoneSystem final : public UWorldSubsystem
{
public:
	TSet<TWeakObjectPtr<class AActor>>            WaitDestroyActorList;                              // 0x0030(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x88];                                      // 0x0080(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	EDarkZoneType                                 PlayType;                                          // 0x0108(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADarkZoneTaskMgr*                       TaskMgr;                                           // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDarkZoneSettingSystem*                 Setting;                                           // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADarkZoneMapPointMgr*                   MapPointMgr;                                       // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADarkZoneRegionMgr*                     RegionMgr;                                         // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADarkZoneFogSwitchActor*                FogSwitch;                                         // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpecialLogic;                                      // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanFreeRush();
	void SetFreeRush(const bool CanFree);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneSystem">();
	}
	static class UDarkZoneSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkZoneSystem>();
	}
};
static_assert(alignof(UDarkZoneSystem) == 0x000008, "Wrong alignment on UDarkZoneSystem");
static_assert(sizeof(UDarkZoneSystem) == 0x000150, "Wrong size on UDarkZoneSystem");
static_assert(offsetof(UDarkZoneSystem, WaitDestroyActorList) == 0x000030, "Member 'UDarkZoneSystem::WaitDestroyActorList' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, PlayType) == 0x000108, "Member 'UDarkZoneSystem::PlayType' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, TaskMgr) == 0x000110, "Member 'UDarkZoneSystem::TaskMgr' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, Setting) == 0x000118, "Member 'UDarkZoneSystem::Setting' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, MapPointMgr) == 0x000120, "Member 'UDarkZoneSystem::MapPointMgr' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, RegionMgr) == 0x000128, "Member 'UDarkZoneSystem::RegionMgr' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, FogSwitch) == 0x000130, "Member 'UDarkZoneSystem::FogSwitch' has a wrong offset!");
static_assert(offsetof(UDarkZoneSystem, SpecialLogic) == 0x000138, "Member 'UDarkZoneSystem::SpecialLogic' has a wrong offset!");

// Class DarkZone.DarkZoneTaskMgr
// 0x0118 (0x0340 - 0x0228)
class ADarkZoneTaskMgr final : public AActor
{
public:
	TDelegate<void(int32 RegionId, int32 TaskId)> NotifyTaskComplete;                                // 0x0228(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 RegionId, int32 TaskId, ELevelFailedReason Reason)> NotifyTaskFailed;                                  // 0x0238(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 RegionId, bool IsAuto)>  NotifyEntryRegion;                                 // 0x0248(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Reason)>                 NotifyMainTaskFailed;                              // 0x0258(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 RegionId)>               NotifyExitEntryRegion;                             // 0x0268(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 RegionId)>               NotifyExitRegion;                                  // 0x0278(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 RegionId)>               NotifyEntryActiveRegion;                           // 0x0288(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 OldId, int32 NewId)>     NotifyFogChanged;                                  // 0x0298(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          DontFlushLevelStreaming;                           // 0x02A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ManualRemoveStreamingLevel;                        // 0x02A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInited;                                          // 0x02AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x95];                                     // 0x02AB(0x0095)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginTask(int32 RegionId, int32 TaskId, const class FString& TaskPath, const class FString& LevelStreamingPath);
	bool CheckRegionHasTask(int32 InRegionId);
	TArray<int32> GetCurrentRegionList();
	int32 GetCurrentTaskCount();
	int32 GetCurrentTaskId(int32 InRegionId);
	int32 GetNpcLevel();
	float GetTaskDuration(int32 InRegionId);
	void NotifyChildLevelHidden();
	void NotifyChildLevelVisible();
	void NotifyTaskBegin(class AGameTaskActor* InTaskActor);
	void OnTaskFailedMain(class AGameTaskActor* InTaskActor);
	void OnTaskFailedSimple(class AGameTaskActor* InTaskActor);
	void OnTaskFinishSimple(class AGameTaskActor* InTaskActor);
	void SetMainTaskActor(class AGameTaskActor* InTaskActor);
	void StopAllTask(bool IsUnloadLevel);
	void StopRegionTask(int32 InRegionId, bool IsUnloadLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneTaskMgr">();
	}
	static class ADarkZoneTaskMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneTaskMgr>();
	}
};
static_assert(alignof(ADarkZoneTaskMgr) == 0x000008, "Wrong alignment on ADarkZoneTaskMgr");
static_assert(sizeof(ADarkZoneTaskMgr) == 0x000340, "Wrong size on ADarkZoneTaskMgr");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyTaskComplete) == 0x000228, "Member 'ADarkZoneTaskMgr::NotifyTaskComplete' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyTaskFailed) == 0x000238, "Member 'ADarkZoneTaskMgr::NotifyTaskFailed' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyEntryRegion) == 0x000248, "Member 'ADarkZoneTaskMgr::NotifyEntryRegion' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyMainTaskFailed) == 0x000258, "Member 'ADarkZoneTaskMgr::NotifyMainTaskFailed' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyExitEntryRegion) == 0x000268, "Member 'ADarkZoneTaskMgr::NotifyExitEntryRegion' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyExitRegion) == 0x000278, "Member 'ADarkZoneTaskMgr::NotifyExitRegion' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyEntryActiveRegion) == 0x000288, "Member 'ADarkZoneTaskMgr::NotifyEntryActiveRegion' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, NotifyFogChanged) == 0x000298, "Member 'ADarkZoneTaskMgr::NotifyFogChanged' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, DontFlushLevelStreaming) == 0x0002A8, "Member 'ADarkZoneTaskMgr::DontFlushLevelStreaming' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, ManualRemoveStreamingLevel) == 0x0002A9, "Member 'ADarkZoneTaskMgr::ManualRemoveStreamingLevel' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskMgr, IsInited) == 0x0002AA, "Member 'ADarkZoneTaskMgr::IsInited' has a wrong offset!");

// Class DarkZone.DarkZoneTaskRegion
// 0x0018 (0x0240 - 0x0228)
class ADarkZoneTaskRegion : public AActor
{
public:
	int32                                         RegionId;                                          // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDarkZoneRegionExportButton            Export;                                            // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDarkZoneRegionPreviewButton           Preview;                                           // 0x0230(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0xC];                                      // 0x0234(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneTaskRegion">();
	}
	static class ADarkZoneTaskRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneTaskRegion>();
	}
};
static_assert(alignof(ADarkZoneTaskRegion) == 0x000008, "Wrong alignment on ADarkZoneTaskRegion");
static_assert(sizeof(ADarkZoneTaskRegion) == 0x000240, "Wrong size on ADarkZoneTaskRegion");
static_assert(offsetof(ADarkZoneTaskRegion, RegionId) == 0x000228, "Member 'ADarkZoneTaskRegion::RegionId' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskRegion, Export) == 0x00022C, "Member 'ADarkZoneTaskRegion::Export' has a wrong offset!");
static_assert(offsetof(ADarkZoneTaskRegion, Preview) == 0x000230, "Member 'ADarkZoneTaskRegion::Preview' has a wrong offset!");

// Class DarkZone.DarkZoneTaskRegionEntry
// 0x0000 (0x0240 - 0x0240)
class ADarkZoneTaskRegionEntry final : public ADarkZoneTaskRegion
{
public:
	void OnEntryRegion();
	void OnExitRegion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneTaskRegionEntry">();
	}
	static class ADarkZoneTaskRegionEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneTaskRegionEntry>();
	}
};
static_assert(alignof(ADarkZoneTaskRegionEntry) == 0x000008, "Wrong alignment on ADarkZoneTaskRegionEntry");
static_assert(sizeof(ADarkZoneTaskRegionEntry) == 0x000240, "Wrong size on ADarkZoneTaskRegionEntry");

// Class DarkZone.DarkZoneTaskRegionActive
// 0x0000 (0x0240 - 0x0240)
class ADarkZoneTaskRegionActive final : public ADarkZoneTaskRegion
{
public:
	void OnEntryRegion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneTaskRegionActive">();
	}
	static class ADarkZoneTaskRegionActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneTaskRegionActive>();
	}
};
static_assert(alignof(ADarkZoneTaskRegionActive) == 0x000008, "Wrong alignment on ADarkZoneTaskRegionActive");
static_assert(sizeof(ADarkZoneTaskRegionActive) == 0x000240, "Wrong size on ADarkZoneTaskRegionActive");

// Class DarkZone.DarkZoneTaskRegionExit
// 0x0000 (0x0240 - 0x0240)
class ADarkZoneTaskRegionExit final : public ADarkZoneTaskRegion
{
public:
	void OnEntryRegion();
	void OnExitRegion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkZoneTaskRegionExit">();
	}
	static class ADarkZoneTaskRegionExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarkZoneTaskRegionExit>();
	}
};
static_assert(alignof(ADarkZoneTaskRegionExit) == 0x000008, "Wrong alignment on ADarkZoneTaskRegionExit");
static_assert(sizeof(ADarkZoneTaskRegionExit) == 0x000240, "Wrong size on ADarkZoneTaskRegionExit");

// Class DarkZone.SlopeNavLinkProxy
// 0x0008 (0x0280 - 0x0278)
class ASlopeNavLinkProxy final : public ANavLinkProxy
{
public:
	float                                         Interval;                                          // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoFill();
	void Clear();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlopeNavLinkProxy">();
	}
	static class ASlopeNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlopeNavLinkProxy>();
	}
};
static_assert(alignof(ASlopeNavLinkProxy) == 0x000008, "Wrong alignment on ASlopeNavLinkProxy");
static_assert(sizeof(ASlopeNavLinkProxy) == 0x000280, "Wrong size on ASlopeNavLinkProxy");
static_assert(offsetof(ASlopeNavLinkProxy, Interval) == 0x000278, "Member 'ASlopeNavLinkProxy::Interval' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SeasunAnimGraph

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SeasunAnimGraph_structs.hpp"


namespace SDK
{

// Class SeasunAnimGraph.CurveSequenceAssetBase
// 0x0010 (0x0040 - 0x0030)
class UCurveSequenceAssetBase : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLooping;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequenceAssetBase">();
	}
	static class UCurveSequenceAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSequenceAssetBase>();
	}
};
static_assert(alignof(UCurveSequenceAssetBase) == 0x000008, "Wrong alignment on UCurveSequenceAssetBase");
static_assert(sizeof(UCurveSequenceAssetBase) == 0x000040, "Wrong size on UCurveSequenceAssetBase");
static_assert(offsetof(UCurveSequenceAssetBase, bIsLooping) == 0x000038, "Member 'UCurveSequenceAssetBase::bIsLooping' has a wrong offset!");

// Class SeasunAnimGraph.CurveSequenceAsset
// 0x00A8 (0x00E8 - 0x0040)
class UCurveSequenceAsset final : public UCurveSequenceAssetBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0048(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendOut;                                          // 0x0078(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CoolDownTime;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurveSequenceSlot                            SlotType;                                          // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTranslation_X;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslation_Y;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslation_Z;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle_Pitch;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle_Yaw;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle_Roll;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomRotationOffsetMultiplier;                    // 0x00C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCurveSequenceEffectorSetup>    EffectorSetups;                                    // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequenceAsset">();
	}
	static class UCurveSequenceAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSequenceAsset>();
	}
};
static_assert(alignof(UCurveSequenceAsset) == 0x000008, "Wrong alignment on UCurveSequenceAsset");
static_assert(sizeof(UCurveSequenceAsset) == 0x0000E8, "Wrong size on UCurveSequenceAsset");
static_assert(offsetof(UCurveSequenceAsset, BlendIn) == 0x000048, "Member 'UCurveSequenceAsset::BlendIn' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, BlendOut) == 0x000078, "Member 'UCurveSequenceAsset::BlendOut' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, CoolDownTime) == 0x0000A8, "Member 'UCurveSequenceAsset::CoolDownTime' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, SlotType) == 0x0000AC, "Member 'UCurveSequenceAsset::SlotType' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxTranslation_X) == 0x0000B0, "Member 'UCurveSequenceAsset::MaxTranslation_X' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxTranslation_Y) == 0x0000B4, "Member 'UCurveSequenceAsset::MaxTranslation_Y' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxTranslation_Z) == 0x0000B8, "Member 'UCurveSequenceAsset::MaxTranslation_Z' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxAngle_Pitch) == 0x0000BC, "Member 'UCurveSequenceAsset::MaxAngle_Pitch' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxAngle_Yaw) == 0x0000C0, "Member 'UCurveSequenceAsset::MaxAngle_Yaw' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, MaxAngle_Roll) == 0x0000C4, "Member 'UCurveSequenceAsset::MaxAngle_Roll' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, RandomRotationOffsetMultiplier) == 0x0000C8, "Member 'UCurveSequenceAsset::RandomRotationOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UCurveSequenceAsset, EffectorSetups) == 0x0000D8, "Member 'UCurveSequenceAsset::EffectorSetups' has a wrong offset!");

// Class SeasunAnimGraph.CurveSequence_RecoilAnimation
// 0x05C0 (0x0600 - 0x0040)
class UCurveSequence_RecoilAnimation final : public UCurveSequenceAssetBase
{
public:
	struct FRuntimeFloatCurve                     GunPitch;                                          // 0x0040(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     GunTranslation;                                    // 0x00C8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     BodyPitch;                                         // 0x0150(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     BodyTranslation;                                   // 0x01D8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RightElbowRoll;                                    // 0x0260(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RightElbowTranslation;                             // 0x02E8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                RandomRotationOffsetMultiplier;                    // 0x0370(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderAffectedByGun_Rotation;                    // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElbowAffectedByGun_Rotation;                       // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderAffectedByGun_Translation;                 // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch_Gun;                                      // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw_Gun;                                        // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRoll_Gun;                                       // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslation_Gun;                                // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch_Body;                                     // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslation_Body;                               // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRoll_RightElbow;                                // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslation__RightElbow;                        // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LeftClavicleAlphaCurve;                            // 0x03A8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LeftClavicleMaxAlphaCurve;                         // 0x0430(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                MaxLeftClavicleRandomRotation;                     // 0x04B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinLeftClavicleRandomRotation;                     // 0x04C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RightClavicleAlphaCurve;                           // 0x04D0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RightClavicleMaxAlphaCurve;                        // 0x0558(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                MaxRightClavicleRandomRotation;                    // 0x05E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinRightClavicleRandomRotation;                    // 0x05EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValidTime;                                  // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequence_RecoilAnimation">();
	}
	static class UCurveSequence_RecoilAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSequence_RecoilAnimation>();
	}
};
static_assert(alignof(UCurveSequence_RecoilAnimation) == 0x000008, "Wrong alignment on UCurveSequence_RecoilAnimation");
static_assert(sizeof(UCurveSequence_RecoilAnimation) == 0x000600, "Wrong size on UCurveSequence_RecoilAnimation");
static_assert(offsetof(UCurveSequence_RecoilAnimation, GunPitch) == 0x000040, "Member 'UCurveSequence_RecoilAnimation::GunPitch' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, GunTranslation) == 0x0000C8, "Member 'UCurveSequence_RecoilAnimation::GunTranslation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, BodyPitch) == 0x000150, "Member 'UCurveSequence_RecoilAnimation::BodyPitch' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, BodyTranslation) == 0x0001D8, "Member 'UCurveSequence_RecoilAnimation::BodyTranslation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, RightElbowRoll) == 0x000260, "Member 'UCurveSequence_RecoilAnimation::RightElbowRoll' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, RightElbowTranslation) == 0x0002E8, "Member 'UCurveSequence_RecoilAnimation::RightElbowTranslation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, RandomRotationOffsetMultiplier) == 0x000370, "Member 'UCurveSequence_RecoilAnimation::RandomRotationOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, ShoulderAffectedByGun_Rotation) == 0x00037C, "Member 'UCurveSequence_RecoilAnimation::ShoulderAffectedByGun_Rotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, ElbowAffectedByGun_Rotation) == 0x000380, "Member 'UCurveSequence_RecoilAnimation::ElbowAffectedByGun_Rotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, ShoulderAffectedByGun_Translation) == 0x000384, "Member 'UCurveSequence_RecoilAnimation::ShoulderAffectedByGun_Translation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxPitch_Gun) == 0x000388, "Member 'UCurveSequence_RecoilAnimation::MaxPitch_Gun' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxYaw_Gun) == 0x00038C, "Member 'UCurveSequence_RecoilAnimation::MaxYaw_Gun' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxRoll_Gun) == 0x000390, "Member 'UCurveSequence_RecoilAnimation::MaxRoll_Gun' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxTranslation_Gun) == 0x000394, "Member 'UCurveSequence_RecoilAnimation::MaxTranslation_Gun' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxPitch_Body) == 0x000398, "Member 'UCurveSequence_RecoilAnimation::MaxPitch_Body' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxTranslation_Body) == 0x00039C, "Member 'UCurveSequence_RecoilAnimation::MaxTranslation_Body' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxRoll_RightElbow) == 0x0003A0, "Member 'UCurveSequence_RecoilAnimation::MaxRoll_RightElbow' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxTranslation__RightElbow) == 0x0003A4, "Member 'UCurveSequence_RecoilAnimation::MaxTranslation__RightElbow' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, LeftClavicleAlphaCurve) == 0x0003A8, "Member 'UCurveSequence_RecoilAnimation::LeftClavicleAlphaCurve' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, LeftClavicleMaxAlphaCurve) == 0x000430, "Member 'UCurveSequence_RecoilAnimation::LeftClavicleMaxAlphaCurve' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxLeftClavicleRandomRotation) == 0x0004B8, "Member 'UCurveSequence_RecoilAnimation::MaxLeftClavicleRandomRotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MinLeftClavicleRandomRotation) == 0x0004C4, "Member 'UCurveSequence_RecoilAnimation::MinLeftClavicleRandomRotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, RightClavicleAlphaCurve) == 0x0004D0, "Member 'UCurveSequence_RecoilAnimation::RightClavicleAlphaCurve' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, RightClavicleMaxAlphaCurve) == 0x000558, "Member 'UCurveSequence_RecoilAnimation::RightClavicleMaxAlphaCurve' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MaxRightClavicleRandomRotation) == 0x0005E0, "Member 'UCurveSequence_RecoilAnimation::MaxRightClavicleRandomRotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, MinRightClavicleRandomRotation) == 0x0005EC, "Member 'UCurveSequence_RecoilAnimation::MinRightClavicleRandomRotation' has a wrong offset!");
static_assert(offsetof(UCurveSequence_RecoilAnimation, DefaultValidTime) == 0x0005F8, "Member 'UCurveSequence_RecoilAnimation::DefaultValidTime' has a wrong offset!");

// Class SeasunAnimGraph.CurveSequence_PhysicalRecoilAnimation
// 0x01A8 (0x01E8 - 0x0040)
class UCurveSequence_PhysicalRecoilAnimation final : public UCurveSequenceAssetBase
{
public:
	struct FRuntimeFloatCurve                     PhysicsAlpha_Hair;                                 // 0x0040(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PhysicsAlpha_Cloth;                                // 0x00C8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PhysicsAlpha_Hat;                                  // 0x0150(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxValue_Hair;                                     // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue_Cloth;                                    // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue_Hat;                                      // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequence_PhysicalRecoilAnimation">();
	}
	static class UCurveSequence_PhysicalRecoilAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSequence_PhysicalRecoilAnimation>();
	}
};
static_assert(alignof(UCurveSequence_PhysicalRecoilAnimation) == 0x000008, "Wrong alignment on UCurveSequence_PhysicalRecoilAnimation");
static_assert(sizeof(UCurveSequence_PhysicalRecoilAnimation) == 0x0001E8, "Wrong size on UCurveSequence_PhysicalRecoilAnimation");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, PhysicsAlpha_Hair) == 0x000040, "Member 'UCurveSequence_PhysicalRecoilAnimation::PhysicsAlpha_Hair' has a wrong offset!");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, PhysicsAlpha_Cloth) == 0x0000C8, "Member 'UCurveSequence_PhysicalRecoilAnimation::PhysicsAlpha_Cloth' has a wrong offset!");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, PhysicsAlpha_Hat) == 0x000150, "Member 'UCurveSequence_PhysicalRecoilAnimation::PhysicsAlpha_Hat' has a wrong offset!");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, MaxValue_Hair) == 0x0001D8, "Member 'UCurveSequence_PhysicalRecoilAnimation::MaxValue_Hair' has a wrong offset!");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, MaxValue_Cloth) == 0x0001DC, "Member 'UCurveSequence_PhysicalRecoilAnimation::MaxValue_Cloth' has a wrong offset!");
static_assert(offsetof(UCurveSequence_PhysicalRecoilAnimation, MaxValue_Hat) == 0x0001E0, "Member 'UCurveSequence_PhysicalRecoilAnimation::MaxValue_Hat' has a wrong offset!");

// Class SeasunAnimGraph.CurveSequenceControllerAnimInstance
// 0x0160 (0x0420 - 0x02C0)
class UCurveSequenceControllerAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCurveSequenceBlendingOut;                        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurveSequenceStarted;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurveSequenceEnded;                              // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllCurveSequenceInstancesEnded;                  // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x50];                                     // 0x0308(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bQueueCurveSequenceEvents : 1;                     // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	ECustomPhysicCalcMode                         CustomPhysicMode;                                  // 0x0359(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECustomPhysicState                            CustomPhysicState;                                 // 0x035A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35B[0x5];                                      // 0x035B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHitSystem                         AnimHitSystem;                                     // 0x0360(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x0400(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 FootBones;                                         // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void ApplyStandardDirectionProcess(class UCurveSequenceAsset* Curve, const struct FHitResult& Hit);
	float CurveSequence_Play(TScriptInterface<class ICurveSequenceInterface> CurveSequenceToPlay, float InPlayRate, float InTimeToStartCurveSequenceAt);
	void CurveSequence_Stop(float InBlendOutTime, const TScriptInterface<class ICurveSequenceInterface> CurveSequence);
	ECustomPhysicCalcMode GetCustomPhysicMode();
	ECustomPhysicState GetCustomPhysicState();
	void SetCustomPhysicMode(ECustomPhysicCalcMode InState);
	void SetCustomPhysicState(ECustomPhysicState InState);

	float CurveSequence_GetPosition(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const;
	bool CurveSequence_IsActive(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const;
	bool CurveSequence_IsPlaying(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const;
	bool HasCurveEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequenceControllerAnimInstance">();
	}
	static class UCurveSequenceControllerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveSequenceControllerAnimInstance>();
	}
};
static_assert(alignof(UCurveSequenceControllerAnimInstance) == 0x000010, "Wrong alignment on UCurveSequenceControllerAnimInstance");
static_assert(sizeof(UCurveSequenceControllerAnimInstance) == 0x000420, "Wrong size on UCurveSequenceControllerAnimInstance");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, OnCurveSequenceBlendingOut) == 0x0002C8, "Member 'UCurveSequenceControllerAnimInstance::OnCurveSequenceBlendingOut' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, OnCurveSequenceStarted) == 0x0002D8, "Member 'UCurveSequenceControllerAnimInstance::OnCurveSequenceStarted' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, OnCurveSequenceEnded) == 0x0002E8, "Member 'UCurveSequenceControllerAnimInstance::OnCurveSequenceEnded' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, OnAllCurveSequenceInstancesEnded) == 0x0002F8, "Member 'UCurveSequenceControllerAnimInstance::OnAllCurveSequenceInstancesEnded' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, CustomPhysicMode) == 0x000359, "Member 'UCurveSequenceControllerAnimInstance::CustomPhysicMode' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, CustomPhysicState) == 0x00035A, "Member 'UCurveSequenceControllerAnimInstance::CustomPhysicState' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, AnimHitSystem) == 0x000360, "Member 'UCurveSequenceControllerAnimInstance::AnimHitSystem' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, PelvisBone) == 0x000400, "Member 'UCurveSequenceControllerAnimInstance::PelvisBone' has a wrong offset!");
static_assert(offsetof(UCurveSequenceControllerAnimInstance, FootBones) == 0x000410, "Member 'UCurveSequenceControllerAnimInstance::FootBones' has a wrong offset!");

// Class SeasunAnimGraph.CurveSequenceInterface
// 0x0000 (0x0028 - 0x0028)
class ICurveSequenceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequenceInterface">();
	}
	static class ICurveSequenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICurveSequenceInterface>();
	}
};
static_assert(alignof(ICurveSequenceInterface) == 0x000008, "Wrong alignment on ICurveSequenceInterface");
static_assert(sizeof(ICurveSequenceInterface) == 0x000028, "Wrong size on ICurveSequenceInterface");

// Class SeasunAnimGraph.CurveSequenceTestActor
// 0x0010 (0x0238 - 0x0228)
class ACurveSequenceTestActor final : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitReactData*                          HitReactData;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSequenceTestActor">();
	}
	static class ACurveSequenceTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurveSequenceTestActor>();
	}
};
static_assert(alignof(ACurveSequenceTestActor) == 0x000008, "Wrong alignment on ACurveSequenceTestActor");
static_assert(sizeof(ACurveSequenceTestActor) == 0x000238, "Wrong size on ACurveSequenceTestActor");
static_assert(offsetof(ACurveSequenceTestActor, Mesh) == 0x000228, "Member 'ACurveSequenceTestActor::Mesh' has a wrong offset!");
static_assert(offsetof(ACurveSequenceTestActor, HitReactData) == 0x000230, "Member 'ACurveSequenceTestActor::HitReactData' has a wrong offset!");

// Class SeasunAnimGraph.GrounderInterface
// 0x0000 (0x0028 - 0x0028)
class IGrounderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrounderInterface">();
	}
	static class IGrounderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGrounderInterface>();
	}
};
static_assert(alignof(IGrounderInterface) == 0x000008, "Wrong alignment on IGrounderInterface");
static_assert(sizeof(IGrounderInterface) == 0x000028, "Wrong size on IGrounderInterface");

// Class SeasunAnimGraph.HitReactCondition
// 0x0000 (0x0028 - 0x0028)
class UHitReactCondition : public UObject
{
public:
	bool K2_Accepts(const struct FHitResult& Hit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactCondition">();
	}
	static class UHitReactCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactCondition>();
	}
};
static_assert(alignof(UHitReactCondition) == 0x000008, "Wrong alignment on UHitReactCondition");
static_assert(sizeof(UHitReactCondition) == 0x000028, "Wrong size on UHitReactCondition");

// Class SeasunAnimGraph.HitReactCondition_TurnDirection
// 0x0008 (0x0030 - 0x0028)
class UHitReactCondition_TurnDirection final : public UHitReactCondition
{
public:
	bool                                          bShouldTurnRight;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactCondition_TurnDirection">();
	}
	static class UHitReactCondition_TurnDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactCondition_TurnDirection>();
	}
};
static_assert(alignof(UHitReactCondition_TurnDirection) == 0x000008, "Wrong alignment on UHitReactCondition_TurnDirection");
static_assert(sizeof(UHitReactCondition_TurnDirection) == 0x000030, "Wrong size on UHitReactCondition_TurnDirection");
static_assert(offsetof(UHitReactCondition_TurnDirection, bShouldTurnRight) == 0x000028, "Member 'UHitReactCondition_TurnDirection::bShouldTurnRight' has a wrong offset!");

// Class SeasunAnimGraph.HitReactData
// 0x0020 (0x0050 - 0x0030)
class UHitReactData final : public UDataAsset
{
public:
	TArray<struct FHitReactCurveSequenceContainerMap> HitReactSequencesContainer;                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHitReactCurveSequenceContainer> HitReactSequences;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool GetCaclHitDirectionFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const;
	class UCurveSequenceAsset* GetCurveSequenceFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const;
	TArray<class UCurveSequenceAsset*> GetCurveSequencesFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactData">();
	}
	static class UHitReactData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactData>();
	}
};
static_assert(alignof(UHitReactData) == 0x000008, "Wrong alignment on UHitReactData");
static_assert(sizeof(UHitReactData) == 0x000050, "Wrong size on UHitReactData");
static_assert(offsetof(UHitReactData, HitReactSequencesContainer) == 0x000030, "Member 'UHitReactData::HitReactSequencesContainer' has a wrong offset!");
static_assert(offsetof(UHitReactData, HitReactSequences) == 0x000040, "Member 'UHitReactData::HitReactSequences' has a wrong offset!");

// Class SeasunAnimGraph.AbnormalReactData
// 0x0050 (0x0080 - 0x0030)
class UAbnormalReactData final : public UDataAsset
{
public:
	TMap<uint8, class UCurveSequenceAsset*>       AbnormalReactContainer;                            // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	class UCurveSequenceAsset* GetCurveSequenceFromAbnormalState(uint8 InState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalReactData">();
	}
	static class UAbnormalReactData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalReactData>();
	}
};
static_assert(alignof(UAbnormalReactData) == 0x000008, "Wrong alignment on UAbnormalReactData");
static_assert(sizeof(UAbnormalReactData) == 0x000080, "Wrong size on UAbnormalReactData");
static_assert(offsetof(UAbnormalReactData, AbnormalReactContainer) == 0x000030, "Member 'UAbnormalReactData::AbnormalReactContainer' has a wrong offset!");

// Class SeasunAnimGraph.AttributeAbnormalReactData
// 0x0050 (0x0080 - 0x0030)
class UAttributeAbnormalReactData final : public UDataAsset
{
public:
	TMap<uint8, class UCurveSequenceAsset*>       AttributeAbnormalReactContainer;                   // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	class UCurveSequenceAsset* GetCurveSequenceFromAttributeAbnormalState(uint8 InState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeAbnormalReactData">();
	}
	static class UAttributeAbnormalReactData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeAbnormalReactData>();
	}
};
static_assert(alignof(UAttributeAbnormalReactData) == 0x000008, "Wrong alignment on UAttributeAbnormalReactData");
static_assert(sizeof(UAttributeAbnormalReactData) == 0x000080, "Wrong size on UAttributeAbnormalReactData");
static_assert(offsetof(UAttributeAbnormalReactData, AttributeAbnormalReactContainer) == 0x000030, "Member 'UAttributeAbnormalReactData::AttributeAbnormalReactContainer' has a wrong offset!");

// Class SeasunAnimGraph.HitReactPhysicalData
// 0x0158 (0x0188 - 0x0030)
class UHitReactPhysicalData final : public UDataAsset
{
public:
	struct FHitPhyConfig                          DefaultHitReaction;                                // 0x0030(0x00F8)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FHitPhyConfig>       HitConfigs;                                        // 0x0128(0x0050)(Edit, NativeAccessSpecifierPublic)
	class FName                                   PhyAnimProfile;                                    // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstrainProfile;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactPhysicalData">();
	}
	static class UHitReactPhysicalData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactPhysicalData>();
	}
};
static_assert(alignof(UHitReactPhysicalData) == 0x000008, "Wrong alignment on UHitReactPhysicalData");
static_assert(sizeof(UHitReactPhysicalData) == 0x000188, "Wrong size on UHitReactPhysicalData");
static_assert(offsetof(UHitReactPhysicalData, DefaultHitReaction) == 0x000030, "Member 'UHitReactPhysicalData::DefaultHitReaction' has a wrong offset!");
static_assert(offsetof(UHitReactPhysicalData, HitConfigs) == 0x000128, "Member 'UHitReactPhysicalData::HitConfigs' has a wrong offset!");
static_assert(offsetof(UHitReactPhysicalData, PhyAnimProfile) == 0x000178, "Member 'UHitReactPhysicalData::PhyAnimProfile' has a wrong offset!");
static_assert(offsetof(UHitReactPhysicalData, ConstrainProfile) == 0x000180, "Member 'UHitReactPhysicalData::ConstrainProfile' has a wrong offset!");

// Class SeasunAnimGraph.PhysAnimLibrary
// 0x0000 (0x0028 - 0x0028)
class UPhysAnimLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetBodyNameByIndex(const class USkeletalMeshComponent* Mesh, int32 Index_0, class FName* BodyName);
	static void ResetBoneSimulationInfo(class USkeletalMeshComponent* Mesh);
	static void SetBodySimulateWeightByIndex(class USkeletalMeshComponent* Mesh, int32 BodyIndex, float Weight);
	static void SetBodySimulationWeight(class USkeletalMeshComponent* Mesh, const class FName& BoneName, float Weight);
	static void SetBoneSimulationInfo(class USkeletalMeshComponent* Mesh, const struct FHitBoneSimulationInfo& SimulationInfo, struct FPhysAnimCharState* CharPhysState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysAnimLibrary">();
	}
	static class UPhysAnimLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysAnimLibrary>();
	}
};
static_assert(alignof(UPhysAnimLibrary) == 0x000008, "Wrong alignment on UPhysAnimLibrary");
static_assert(sizeof(UPhysAnimLibrary) == 0x000028, "Wrong size on UPhysAnimLibrary");

// Class SeasunAnimGraph.CachedBoneTransform
// 0x0050 (0x0078 - 0x0028)
class UCachedBoneTransform final : public UAssetUserData
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CachedBoneTransform">();
	}
	static class UCachedBoneTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCachedBoneTransform>();
	}
};
static_assert(alignof(UCachedBoneTransform) == 0x000008, "Wrong alignment on UCachedBoneTransform");
static_assert(sizeof(UCachedBoneTransform) == 0x000078, "Wrong size on UCachedBoneTransform");

// Class SeasunAnimGraph.KawaiiPhysicsLimitsDataAsset
// 0x0030 (0x0060 - 0x0030)
class UKawaiiPhysicsLimitsDataAsset final : public UDataAsset
{
public:
	TArray<struct FSphericalLimit>                SphericalLimits;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCapsuleLimit>                  CapsuleLimits;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlanarLimit>                   PlanarLimits;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KawaiiPhysicsLimitsDataAsset">();
	}
	static class UKawaiiPhysicsLimitsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKawaiiPhysicsLimitsDataAsset>();
	}
};
static_assert(alignof(UKawaiiPhysicsLimitsDataAsset) == 0x000008, "Wrong alignment on UKawaiiPhysicsLimitsDataAsset");
static_assert(sizeof(UKawaiiPhysicsLimitsDataAsset) == 0x000060, "Wrong size on UKawaiiPhysicsLimitsDataAsset");
static_assert(offsetof(UKawaiiPhysicsLimitsDataAsset, SphericalLimits) == 0x000030, "Member 'UKawaiiPhysicsLimitsDataAsset::SphericalLimits' has a wrong offset!");
static_assert(offsetof(UKawaiiPhysicsLimitsDataAsset, CapsuleLimits) == 0x000040, "Member 'UKawaiiPhysicsLimitsDataAsset::CapsuleLimits' has a wrong offset!");
static_assert(offsetof(UKawaiiPhysicsLimitsDataAsset, PlanarLimits) == 0x000050, "Member 'UKawaiiPhysicsLimitsDataAsset::PlanarLimits' has a wrong offset!");

// Class SeasunAnimGraph.CachedKawaiiPhysicsSettings
// 0x0018 (0x0048 - 0x0030)
class UCachedKawaiiPhysicsSettings final : public UDataAsset
{
public:
	class USkeleton*                              TargetSkeleton;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCachedKawaiiPhysicsSetting>    ExternalKawaiiPhysicSettingContainer;              // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CachedKawaiiPhysicsSettings">();
	}
	static class UCachedKawaiiPhysicsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCachedKawaiiPhysicsSettings>();
	}
};
static_assert(alignof(UCachedKawaiiPhysicsSettings) == 0x000008, "Wrong alignment on UCachedKawaiiPhysicsSettings");
static_assert(sizeof(UCachedKawaiiPhysicsSettings) == 0x000048, "Wrong size on UCachedKawaiiPhysicsSettings");
static_assert(offsetof(UCachedKawaiiPhysicsSettings, TargetSkeleton) == 0x000030, "Member 'UCachedKawaiiPhysicsSettings::TargetSkeleton' has a wrong offset!");
static_assert(offsetof(UCachedKawaiiPhysicsSettings, ExternalKawaiiPhysicSettingContainer) == 0x000038, "Member 'UCachedKawaiiPhysicsSettings::ExternalKawaiiPhysicSettingContainer' has a wrong offset!");

// Class SeasunAnimGraph.SeasunAnimFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USeasunAnimFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float AngleBetweenVectors(const struct FVector& V1, const struct FVector& V2);
	static void ApplyRecoilForce(const struct FAnimRecoilSystem& InRecoilSystem, const struct FRecoilStrength& InStrength);
	static void CalculateAimRotation(class UAnimInstance* AnimInstance, float AimYaw, float AimPitch, float DeltaSeconds, const struct FVector& FacingDirection, float RotationInterpSpeed, float MaxAngle, float* OutPitch, float* OutYaw, class FName ViewLocationSocketName);
	static float CalculateDirection(const struct FVector& Vector, const struct FRotator& BaseRotation);
	static bool GetLerpedTimeByCurveValueFromAnimMontage(const class UAnimMontage* AnimMontage, const class FName& SectionName, const class FName& CurveName, float CurveValue, float* OutTime, bool bUnsigned);
	static bool GetLerpedTimeByCurveValueFromAnimSequence(const class UAnimSequenceBase* AnimSequence, const class FName& CurveName, float CurveValue, float* OutTime, bool bUnsigned);
	static struct FTransform GetSavedBoneTransform(class UAnimInstance* AnimInstance, const class FName& GroupName, const class FName& BoneName);
	static bool HasSavedBoneTransform(class UAnimInstance* AnimInstance, const class FName& GroupName, const class FName& BoneName);
	static class UAnimMontage* PlayLoopSlotAnimationAsDynamicMontage(class UAnimInstance* AnimInstance, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartLoopTime, float EndLoopTime, float BlendInTime, float BlendOutTime, float InPlayRate, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static void UpdateRecoilSystem(const struct FAnimRecoilSystem& InRecoilSystem, float InDeltaSeconds, struct FVector* OutGunTransition, struct FRotator* OutGunRotation, float* OutPelvisOffset, float* OutSpineRotationAngle, float* OutRightShoulderRotationAngle, float* OutLeftShoulderRotationAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasunAnimFunctionLibrary">();
	}
	static class USeasunAnimFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasunAnimFunctionLibrary>();
	}
};
static_assert(alignof(USeasunAnimFunctionLibrary) == 0x000008, "Wrong alignment on USeasunAnimFunctionLibrary");
static_assert(sizeof(USeasunAnimFunctionLibrary) == 0x000028, "Wrong size on USeasunAnimFunctionLibrary");

}


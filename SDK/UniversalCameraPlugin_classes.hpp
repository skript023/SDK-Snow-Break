#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UniversalCameraPlugin

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UniversalCameraPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class UniversalCameraPlugin.AsyncNode
// 0x0120 (0x0150 - 0x0030)
class UAsyncNode final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x100];                                     // 0x0030(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReachedDestination;                              // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAborted;                                         // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncNode* CameraTravel(class AUniversalCamera* UniversalCamera, const struct FTargetSettings& TargetSettings, const struct FTargetVector& LocationSettings, const struct FOffsetSettings& OffsetSettings, const struct FTargetFloat& YawSettings, const struct FTargetFloat& PitchSettings, const struct FTargetFloat& RollSettings, const struct FTargetFloat& ZoomSettings, class UCurveFloat* Curve, const struct FTravelSpeedSettings& SpeedSettings, bool LockAllMovement, bool IgnoreLag, bool IgnoreRestrictions);
	static struct FTargetVector UseActorLocation();
	static struct FTargetFloat UseActorValue();
	static struct FTargetVector UseCustomLocation(const struct FVector& Location);
	static struct FTargetFloat UseCustomValue(const float Value);
	static struct FTravelSpeedSettings UseDuration(const float Duration);
	static struct FTargetVector UseSceneComponentLocation();
	static struct FTargetFloat UseSceneComponentValue();
	static struct FTargetVector UseSocketLocation();
	static struct FOffsetSettings UseSocketOffset(const struct FVector& SocketOffset);
	static struct FTargetFloat UseSocketValue();
	static struct FTravelSpeedSettings UseSpeed(const float Speed);
	static struct FTargetVector UseSpline(class USplineComponent* SplineComponent);
	static struct FOffsetSettings UseTargetOffset(const struct FVector& TargetOffset);

	void OnTaskResult__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncNode">();
	}
	static class UAsyncNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncNode>();
	}
};
static_assert(alignof(UAsyncNode) == 0x000008, "Wrong alignment on UAsyncNode");
static_assert(sizeof(UAsyncNode) == 0x000150, "Wrong size on UAsyncNode");
static_assert(offsetof(UAsyncNode, OnReachedDestination) == 0x000130, "Member 'UAsyncNode::OnReachedDestination' has a wrong offset!");
static_assert(offsetof(UAsyncNode, OnAborted) == 0x000140, "Member 'UAsyncNode::OnAborted' has a wrong offset!");

// Class UniversalCameraPlugin.PlaceholderCamera
// 0x0010 (0x0238 - 0x0228)
class APlaceholderCamera final : public AActor
{
public:
	class USpringArmComponent*                    SpringArmComponent;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FPlaceholderCameraInfos GetInfos();
	float GetZoom();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceholderCamera">();
	}
	static class APlaceholderCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlaceholderCamera>();
	}
};
static_assert(alignof(APlaceholderCamera) == 0x000008, "Wrong alignment on APlaceholderCamera");
static_assert(sizeof(APlaceholderCamera) == 0x000238, "Wrong size on APlaceholderCamera");
static_assert(offsetof(APlaceholderCamera, SpringArmComponent) == 0x000228, "Member 'APlaceholderCamera::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(APlaceholderCamera, CameraComponent) == 0x000230, "Member 'APlaceholderCamera::CameraComponent' has a wrong offset!");

// Class UniversalCameraPlugin.UniversalCamera
// 0x0308 (0x0590 - 0x0288)
class AUniversalCamera : public APawn
{
public:
	FMulticastInlineDelegateProperty_             OnDesiredLocationChanged;                          // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDesiredSocketOffsetChanged;                      // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDesiredTargetOffsetChanged;                      // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDesiredRotationChanged;                          // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDesiredRotationOffsetChanged;                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDesiredZoomChanged;                              // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredLocation;                                   // 0x02F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredSocketOffset;                               // 0x02FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredTargetOffset;                               // 0x0308(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DesiredRotation;                                   // 0x0314(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               DesiredRotationOffset;                             // 0x0320(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DesiredZoom;                                       // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncNode*                             CurrentTravelTask;                                 // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTraveling;                                       // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnabledFeatures;                                   // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          OverrideStartingLocation;                          // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartingLocation;                                  // 0x036C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideStartingTargetOffset;                      // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartingTargetOffset;                              // 0x037C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideStartingSocketOffset;                      // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartingSocketOffset;                              // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideStartingYaw;                               // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingYaw;                                       // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideStartingPitch;                             // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingPitch;                                     // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideStartingZoom;                              // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartingZoom;                                      // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementSpeed;                                     // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAlternativeForwardVector;                       // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAlternativeRightVector;                         // 0x03B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAlternativeUpVector;                            // 0x03B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B7[0x1];                                      // 0x03B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetSpeed;                                       // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeed;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreTimeDilation;                                // 0x03C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C5[0x7];                                      // 0x03C5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ApplyMovementScaling;                              // 0x03CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyOffsetScaling;                                // 0x03CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyMoveUpScaling;                                // 0x03CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseZoomLevel;                                      // 0x03CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumMovementSpeed;                              // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumMovementSpeed;                              // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScalingDistanceReference;                          // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundLevel;                                       // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScalingTraceToGround;                              // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ScalingTraceChannels;                              // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	bool                                          UseZoomScaling;                                    // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumZoomSpeed;                                  // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumZoomSpeed;                                  // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomReference;                                     // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyOriginCollisions;                             // 0x0408(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyTargetOffsetCollisions;                       // 0x0409(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplySocketOffsetCollisions;                       // 0x040A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OriginCollisionsChannel;                           // 0x040B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginCollisionsProbeSize;                         // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SpringArmCollisionsChannel;                        // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringArmCollisionsProbeSize;                      // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     TerrainHeightAdaptationChannels;                   // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	float                                         OriginDistanceFromGround;                          // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZProbeRadius;                                      // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanGoBelowSurfaces;                                // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysSeeOrigin;                                   // 0x0431(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x2];                                      // 0x0432(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibilityProbeRadius;                             // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DistanceAdaptation;                                // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceBypassValue;                               // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeScrollingSensitivity;                          // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeScrollingSpeedMultiplier;                      // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEdgeScrollingStrength;                          // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NormalizeEdgeScrollingDirection;                   // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEdgeScrollMode                               EdgeScrollMode;                                    // 0x044A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEdgeScrolling;                                   // 0x044B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreciseMouseDragMode                         PreciseMouseDragMode;                              // 0x044C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44D[0x3];                                      // 0x044D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreciseMouseDragPoint;                             // 0x0450(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreciseMouseDragNormal;                            // 0x045C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             PreciseMouseDragCollisionChannel;                  // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreciseMouseDragTraceComplex;                      // 0x0469(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreciseMouseDragIgnoreMovementLag;                 // 0x046A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPreciseMouseDragging;                            // 0x046B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreciseMouseDragOrigin;                            // 0x046C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSlidingMaxSpeed;                             // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSlidingMaxRatio;                             // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScreenSlidingInvertXAxis;                          // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScreenSlidingInvertYAxis;                          // 0x0481(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenSlidingType                            ScreenSlidingType;                                 // 0x0482(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsScreenSliding;                                   // 0x0483(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_484[0xC];                                      // 0x0484(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetSettings_WithTemplates          FollowTargetSettings;                              // 0x0490(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstrainVector2                      FollowedAxis;                                      // 0x04B8(0x0003)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BB[0x3];                                      // 0x04BB(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFollowingAnyActor;                              // 0x04BE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowTargetIgnoreRestrictions;                   // 0x04BF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldResetOffsetIfFailed;                        // 0x04C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementLagSpeed;                                  // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLagSpeed;                                    // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightLagSpeed;                                    // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLagSpeed;                                  // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomLagSpeed;                                      // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocationConstrainType                        LocationConstrainType;                             // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x3];                                      // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SphereOrigin;                                      // 0x04DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainVector                       ConstrainLocationMinimum;                          // 0x04EC(0x0003)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EF[0x1];                                      // 0x04EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinimumLocation;                                   // 0x04F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainVector                       ConstrainLocationMaximum;                          // 0x04FC(0x0003)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FF[0x1];                                      // 0x04FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MaximumLocation;                                   // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainLocationToShape;                          // 0x050C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      ConstrainDots;                                     // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	EConstrainType                                OffsetConstrainType;                               // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetMaxDistance;                                 // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainVector                       ConstrainOffsetMinimum;                            // 0x0528(0x0003)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_52B[0x1];                                      // 0x052B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinimumOffset;                                     // 0x052C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainVector                       ConstrainOffsetMaximum;                            // 0x0538(0x0003)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_53B[0x1];                                      // 0x053B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MaximumOffset;                                     // 0x053C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainYaw;                                      // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumYaw;                                        // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumYaw;                                        // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReverseYawRestriction;                             // 0x0554(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainPitch;                                    // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_556[0x2];                                      // 0x0556(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumPitch;                                      // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumPitch;                                      // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReversePitchRestriction;                           // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainRoll;                                     // 0x0561(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_562[0x2];                                      // 0x0562(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumRoll;                                       // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumRoll;                                       // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReverseRollRestriction;                            // 0x056C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainZoomMinimum;                              // 0x056D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56E[0x2];                                      // 0x056E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumZoom;                                       // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainZoomMaximum;                              // 0x0574(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumZoom;                                       // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugSpheres;                                  // 0x057C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugPrintDesiredPosition;                         // 0x057D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationLimitMode                            RotationLimitMode;                                 // 0x057E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57F[0x1];                                      // 0x057F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRotationRadiusAngle;                            // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0xC];                                      // 0x0584(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<struct FVector2D> GetActorsLocation2D(const TArray<class AActor*>& Actors);
	static struct FVector GetAlternativeForwardVector(const struct FRotator& Rotation);
	static struct FVector GetAlternativeRightVector(const struct FRotator& Rotation);
	static struct FVector GetAlternativeUpVector(const struct FRotator& Rotation);
	static struct FVector GetImpactPointUnderCursor(class APlayerController* PlayerController, ECollisionChannel TraceChannel, bool TraceComplex, bool* DidHit);
	static struct FVector2D GetMousePositionRatio(class APlayerController* PlayerController, struct FVector2D* RawPosition);
	static struct FTargetSettings_WithTemplates UseActor(class AActor* Actor);
	static struct FTargetSettings_WithTemplates UseSceneComponent(class USceneComponent* SceneComponent);
	static struct FTargetSettings_WithTemplates UseSocket(class UMeshComponent* MeshComponent, class FName Socket);

	void AbortTravelTask();
	bool AreFeaturesEnabled(int32 FeaturesToTest);
	void DisableFeatures(int32 FeaturesToDisable);
	void EdgeScrollingTick(float RightAxis, float ForwardAxis, float RightMultiplier, float ForwardMultiplier, bool bTargetOffset, bool bSocketOffset);
	void EdgeScrollingTick_Internal();
	void EnableFeatures(int32 FeaturesToEnable);
	void EndTravelTask(const bool Abort);
	void FollowTarget(const struct FTargetSettings_WithTemplates& TargetSettings, const struct FConstrainVector2& FollowAxis, const struct FBoolRotation& FollowRotations, bool IgnoreRestrictions, bool ResetOffsetIfPrematurelyEnded);
	void FollowTargetTick();
	bool GetActorFocusLocation(class AActor* Actor, struct FVector* Location, float* IdealZoom);
	class UCameraComponent* GetCameraComponent();
	struct FVector GetClampedLocation(const struct FVector& Location);
	struct FVector GetClampedOffset(const struct FVector& Offset);
	float GetClampedPitch(float Pitch);
	float GetClampedRoll(float Roll);
	float GetClampedYaw(float Yaw);
	float GetClampedZoom(float Zoom);
	struct FVector GetCorrectedDestinationFromOriginCollisions(const struct FVector& Location, const struct FVector& Destination, bool* DidHit);
	struct FVector GetCorrectedDestinationFromRestrictions(const struct FVector& Destination);
	float GetMovementScaling();
	struct FUniversalCameraPositionSaveFormat GetPositionSaveFormat();
	TArray<uint8> GetSettingsSaveFormat();
	float GetTerrainHeightAdaptationValue(bool* IsValid);
	float GetZoomInScaling();
	bool IsFollowingAnyActor();
	float Lag_GetTickDesiredHeight(float DeltaTime);
	struct FVector Lag_GetTickDesiredLocation(float DeltaTime);
	struct FRotator Lag_GetTickDesiredRotation(float DeltaTime);
	struct FVector Lag_GetTickDesiredSocketOffset(float DeltaTime);
	struct FVector Lag_GetTickDesiredTargetOffset(float DeltaTime);
	float Lag_GetTickDesiredZoom(float DeltaTime);
	void LoadPositionSaveFormat(const struct FUniversalCameraPositionSaveFormat& PositionSaveFormat);
	void LoadSettingsSaveFormat(const TArray<uint8>& SettingsSaveFormat);
	void Move(float ForwardAxis, float RightAxis, float UpAxis, float Multiplier, bool NormalizeDirection, bool MoveTargetOffset, bool MoveSocketOffset);
	void MoveForward(float AxisValue, float Multiplier, bool MoveTargetOffset, bool MoveSocketOffset);
	void MoveRight(float AxisValue, float Multiplier, bool MoveTargetOffset, bool MoveSocketOffset);
	void MoveUp(float AxisValue, float Multiplier, bool MoveTargetOffset, bool MoveSocketOffset);
	void OnBeginEdgeScrolling();
	void OnBeginMouseDrag();
	void OnBeginScreenSliding(const struct FVector2D& OriginPosition);
	void OnEndEdgeScrolling();
	void OnEndMouseDrag();
	void OnEndScreenSliding();
	void OnStoppedFollowing(EStopFollowingReason Reason);
	void OnUpdateEdgeScrolling(ESimplifiedMovementDirection SimplifiedDirection, const struct FVector2D& MovementDirection);
	void OnUpdateMouseDrag(const struct FVector& Direction);
	void OnUpdateScreenSliding(const struct FVector2D& Direction);
	void QuickLoadPosition(const class FString& SlotName, const int32 UserIndex);
	void QuickLoadSettings(const class FString& SlotName, const int32 UserIndex);
	void QuickSavePosition(const struct FUniversalCameraPositionSaveFormat& PositionSaveFormat, const class FString& SlotName, const int32 UserIndex);
	void QuickSaveSettings(const TArray<uint8>& SettingsSaveFormat, const class FString& SlotName, const int32 UserIndex);
	void ResetRotationOffset();
	void ResetSocketOffset();
	void ResetTargetOffset();
	void Rotate(float YawAxis, float PitchAxis, float RollAxis, float Multiplier, bool RotateOffset);
	void RotatePitch(float AxisValue, float Multiplier, bool RotateOffset);
	void RotatePitchAroundPivot(const struct FVector& Pivot, float AxisValue, float Multiplier, bool LockZAxis);
	void RotateRoll(float AxisValue, float Multiplier, bool RotateOffset);
	void RotateYaw(float AxisValue, float Multiplier, bool RotateOffset);
	void RotateYawAroundPivot(const struct FVector& Pivot, float AxisValue, float Multiplier);
	void SetConstrainDots(const TArray<struct FVector2D>& Dots);
	void SetDesiredAxisClampLimit();
	void SetDesiredCircleLimit(float RotationRadiusAngle);
	void SetDesiredFOV(float NewFOV);
	void SetDesiredLocation(const struct FVector& NewLocation, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredMovementSpeed(float NewMovementSpeed);
	void SetDesiredPitch(float NewPitch, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredPitchLimit(bool bConstrainPitch, float MinPitch, float MaxPitch, bool bReversePitchRestriction);
	void SetDesiredPitchOffset(float NewPitchOffset);
	void SetDesiredPosition(const struct FVector& NewLocation, const struct FVector& NewTargetOffset, const struct FVector& NewSocketOffset, float NewYaw, float NewPitch, float NewRoll, float NewZoom, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredRoll(float NewRoll, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredRollLimit(bool bConstrainRoll, float MinRoll, float MaxRoll, bool bReverseRollRestriction);
	void SetDesiredRollOffset(float NewRollOffset);
	void SetDesiredRotateSpeed(float NewRotateSpeed);
	void SetDesiredRotation(const struct FRotator& NewRotation, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredRotationForCircularLimit(const struct FRotator& NewRotation);
	void SetDesiredRotationLimitMode(ERotationLimitMode LimitMode);
	void SetDesiredRotationOffset(const struct FRotator& NewRotationOffset);
	void SetDesiredSocketOffset(const struct FVector& NewSocketOffset, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredTargetOffset(const struct FVector& NewTargetOffset, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredYaw(float NewYaw, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredYawLimit(bool bConstrainYaw, float MinYaw, float MaxYaw, bool bReverseYawRestriction);
	void SetDesiredYawOffset(float NewYawOffset);
	void SetDesiredZoom(float NewZoom, bool IgnoreLag, bool IgnoreRestrictions);
	void SetDesiredZoomLimit(bool bConstrainZoomMin, float MinZoom, bool bConstrainZoomMax, float MaxZoom);
	void StartTraveling_Internal(class UAsyncNode* AsyncNode);
	void StopFollowing(bool bResetOffset);
	void ToggleConstrainDots(bool ConstrainWithDots);
	void TogglePreciseMouseDrag(bool Activate);
	void ToggleScreenSliding(bool Activate);
	void TravelTaskTick(float DeltaTime);
	void ZoomAtCursor(float AxisValue, ECollisionChannel CollisionChannel, bool* DidHit, float Multiplier, bool LockZoomLevel);
	void ZoomAtLocation(float AxisValue, const struct FVector& Location, float Multiplier, bool LockZoomLevel);
	void ZoomIn(float AxisValue, float Multiplier);

	struct FTransform CalculateRequiredPawnTransformForCameraTarget(const struct FTransform& TargetCameraWorldTransform) const;
	struct FVector GetDesiredCameraWorldLocation() const;
	struct FRotator GetDesiredRotationWithOffset() const;
	struct FVector GetDesiredSocketOffsetWorldLocation() const;
	struct FVector GetDesiredTargetOffsetWorldLocation() const;
	struct FVector GetSocketOffsetWorldLocation() const;
	struct FVector GetTargetOffsetWorldLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniversalCamera">();
	}
	static class AUniversalCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUniversalCamera>();
	}
};
static_assert(alignof(AUniversalCamera) == 0x000008, "Wrong alignment on AUniversalCamera");
static_assert(sizeof(AUniversalCamera) == 0x000590, "Wrong size on AUniversalCamera");
static_assert(offsetof(AUniversalCamera, OnDesiredLocationChanged) == 0x000288, "Member 'AUniversalCamera::OnDesiredLocationChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OnDesiredSocketOffsetChanged) == 0x000298, "Member 'AUniversalCamera::OnDesiredSocketOffsetChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OnDesiredTargetOffsetChanged) == 0x0002A8, "Member 'AUniversalCamera::OnDesiredTargetOffsetChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OnDesiredRotationChanged) == 0x0002B8, "Member 'AUniversalCamera::OnDesiredRotationChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OnDesiredRotationOffsetChanged) == 0x0002C8, "Member 'AUniversalCamera::OnDesiredRotationOffsetChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OnDesiredZoomChanged) == 0x0002D8, "Member 'AUniversalCamera::OnDesiredZoomChanged' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, SpringArmComponent) == 0x0002E8, "Member 'AUniversalCamera::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredLocation) == 0x0002F0, "Member 'AUniversalCamera::DesiredLocation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredSocketOffset) == 0x0002FC, "Member 'AUniversalCamera::DesiredSocketOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredTargetOffset) == 0x000308, "Member 'AUniversalCamera::DesiredTargetOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredRotation) == 0x000314, "Member 'AUniversalCamera::DesiredRotation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredRotationOffset) == 0x000320, "Member 'AUniversalCamera::DesiredRotationOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DesiredZoom) == 0x00032C, "Member 'AUniversalCamera::DesiredZoom' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, CurrentTravelTask) == 0x000350, "Member 'AUniversalCamera::CurrentTravelTask' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, IsTraveling) == 0x000358, "Member 'AUniversalCamera::IsTraveling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, EnabledFeatures) == 0x00035C, "Member 'AUniversalCamera::EnabledFeatures' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingLocation) == 0x000368, "Member 'AUniversalCamera::OverrideStartingLocation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingLocation) == 0x00036C, "Member 'AUniversalCamera::StartingLocation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingTargetOffset) == 0x000378, "Member 'AUniversalCamera::OverrideStartingTargetOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingTargetOffset) == 0x00037C, "Member 'AUniversalCamera::StartingTargetOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingSocketOffset) == 0x000388, "Member 'AUniversalCamera::OverrideStartingSocketOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingSocketOffset) == 0x00038C, "Member 'AUniversalCamera::StartingSocketOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingYaw) == 0x000398, "Member 'AUniversalCamera::OverrideStartingYaw' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingYaw) == 0x00039C, "Member 'AUniversalCamera::StartingYaw' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingPitch) == 0x0003A0, "Member 'AUniversalCamera::OverrideStartingPitch' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingPitch) == 0x0003A4, "Member 'AUniversalCamera::StartingPitch' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OverrideStartingZoom) == 0x0003A8, "Member 'AUniversalCamera::OverrideStartingZoom' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, StartingZoom) == 0x0003AC, "Member 'AUniversalCamera::StartingZoom' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MovementSpeed) == 0x0003B0, "Member 'AUniversalCamera::MovementSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseAlternativeForwardVector) == 0x0003B4, "Member 'AUniversalCamera::UseAlternativeForwardVector' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseAlternativeRightVector) == 0x0003B5, "Member 'AUniversalCamera::UseAlternativeRightVector' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseAlternativeUpVector) == 0x0003B6, "Member 'AUniversalCamera::UseAlternativeUpVector' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OffsetSpeed) == 0x0003B8, "Member 'AUniversalCamera::OffsetSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, RotateSpeed) == 0x0003BC, "Member 'AUniversalCamera::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ZoomSpeed) == 0x0003C0, "Member 'AUniversalCamera::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, IgnoreTimeDilation) == 0x0003C4, "Member 'AUniversalCamera::IgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplyMovementScaling) == 0x0003CC, "Member 'AUniversalCamera::ApplyMovementScaling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplyOffsetScaling) == 0x0003CD, "Member 'AUniversalCamera::ApplyOffsetScaling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplyMoveUpScaling) == 0x0003CE, "Member 'AUniversalCamera::ApplyMoveUpScaling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseZoomLevel) == 0x0003CF, "Member 'AUniversalCamera::UseZoomLevel' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumMovementSpeed) == 0x0003D0, "Member 'AUniversalCamera::MinimumMovementSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumMovementSpeed) == 0x0003D4, "Member 'AUniversalCamera::MaximumMovementSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScalingDistanceReference) == 0x0003D8, "Member 'AUniversalCamera::ScalingDistanceReference' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, GroundLevel) == 0x0003DC, "Member 'AUniversalCamera::GroundLevel' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScalingTraceToGround) == 0x0003E0, "Member 'AUniversalCamera::ScalingTraceToGround' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScalingTraceChannels) == 0x0003E8, "Member 'AUniversalCamera::ScalingTraceChannels' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseZoomScaling) == 0x0003F8, "Member 'AUniversalCamera::UseZoomScaling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumZoomSpeed) == 0x0003FC, "Member 'AUniversalCamera::MinimumZoomSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumZoomSpeed) == 0x000400, "Member 'AUniversalCamera::MaximumZoomSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ZoomReference) == 0x000404, "Member 'AUniversalCamera::ZoomReference' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplyOriginCollisions) == 0x000408, "Member 'AUniversalCamera::ApplyOriginCollisions' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplyTargetOffsetCollisions) == 0x000409, "Member 'AUniversalCamera::ApplyTargetOffsetCollisions' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ApplySocketOffsetCollisions) == 0x00040A, "Member 'AUniversalCamera::ApplySocketOffsetCollisions' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OriginCollisionsChannel) == 0x00040B, "Member 'AUniversalCamera::OriginCollisionsChannel' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OriginCollisionsProbeSize) == 0x00040C, "Member 'AUniversalCamera::OriginCollisionsProbeSize' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, SpringArmCollisionsChannel) == 0x000410, "Member 'AUniversalCamera::SpringArmCollisionsChannel' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, SpringArmCollisionsProbeSize) == 0x000414, "Member 'AUniversalCamera::SpringArmCollisionsProbeSize' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, TerrainHeightAdaptationChannels) == 0x000418, "Member 'AUniversalCamera::TerrainHeightAdaptationChannels' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OriginDistanceFromGround) == 0x000428, "Member 'AUniversalCamera::OriginDistanceFromGround' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ZProbeRadius) == 0x00042C, "Member 'AUniversalCamera::ZProbeRadius' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, CanGoBelowSurfaces) == 0x000430, "Member 'AUniversalCamera::CanGoBelowSurfaces' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, AlwaysSeeOrigin) == 0x000431, "Member 'AUniversalCamera::AlwaysSeeOrigin' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, VisibilityProbeRadius) == 0x000434, "Member 'AUniversalCamera::VisibilityProbeRadius' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DistanceAdaptation) == 0x000438, "Member 'AUniversalCamera::DistanceAdaptation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DistanceBypassValue) == 0x00043C, "Member 'AUniversalCamera::DistanceBypassValue' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, EdgeScrollingSensitivity) == 0x000440, "Member 'AUniversalCamera::EdgeScrollingSensitivity' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, EdgeScrollingSpeedMultiplier) == 0x000444, "Member 'AUniversalCamera::EdgeScrollingSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, UseEdgeScrollingStrength) == 0x000448, "Member 'AUniversalCamera::UseEdgeScrollingStrength' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, NormalizeEdgeScrollingDirection) == 0x000449, "Member 'AUniversalCamera::NormalizeEdgeScrollingDirection' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, EdgeScrollMode) == 0x00044A, "Member 'AUniversalCamera::EdgeScrollMode' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, IsEdgeScrolling) == 0x00044B, "Member 'AUniversalCamera::IsEdgeScrolling' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragMode) == 0x00044C, "Member 'AUniversalCamera::PreciseMouseDragMode' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragPoint) == 0x000450, "Member 'AUniversalCamera::PreciseMouseDragPoint' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragNormal) == 0x00045C, "Member 'AUniversalCamera::PreciseMouseDragNormal' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragCollisionChannel) == 0x000468, "Member 'AUniversalCamera::PreciseMouseDragCollisionChannel' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragTraceComplex) == 0x000469, "Member 'AUniversalCamera::PreciseMouseDragTraceComplex' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragIgnoreMovementLag) == 0x00046A, "Member 'AUniversalCamera::PreciseMouseDragIgnoreMovementLag' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, IsPreciseMouseDragging) == 0x00046B, "Member 'AUniversalCamera::IsPreciseMouseDragging' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, PreciseMouseDragOrigin) == 0x00046C, "Member 'AUniversalCamera::PreciseMouseDragOrigin' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScreenSlidingMaxSpeed) == 0x000478, "Member 'AUniversalCamera::ScreenSlidingMaxSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScreenSlidingMaxRatio) == 0x00047C, "Member 'AUniversalCamera::ScreenSlidingMaxRatio' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScreenSlidingInvertXAxis) == 0x000480, "Member 'AUniversalCamera::ScreenSlidingInvertXAxis' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScreenSlidingInvertYAxis) == 0x000481, "Member 'AUniversalCamera::ScreenSlidingInvertYAxis' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ScreenSlidingType) == 0x000482, "Member 'AUniversalCamera::ScreenSlidingType' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, IsScreenSliding) == 0x000483, "Member 'AUniversalCamera::IsScreenSliding' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, FollowTargetSettings) == 0x000490, "Member 'AUniversalCamera::FollowTargetSettings' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, FollowedAxis) == 0x0004B8, "Member 'AUniversalCamera::FollowedAxis' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, bIsFollowingAnyActor) == 0x0004BE, "Member 'AUniversalCamera::bIsFollowingAnyActor' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, bFollowTargetIgnoreRestrictions) == 0x0004BF, "Member 'AUniversalCamera::bFollowTargetIgnoreRestrictions' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, bShouldResetOffsetIfFailed) == 0x0004C0, "Member 'AUniversalCamera::bShouldResetOffsetIfFailed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MovementLagSpeed) == 0x0004C4, "Member 'AUniversalCamera::MovementLagSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OffsetLagSpeed) == 0x0004C8, "Member 'AUniversalCamera::OffsetLagSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, HeightLagSpeed) == 0x0004CC, "Member 'AUniversalCamera::HeightLagSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, RotationLagSpeed) == 0x0004D0, "Member 'AUniversalCamera::RotationLagSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ZoomLagSpeed) == 0x0004D4, "Member 'AUniversalCamera::ZoomLagSpeed' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, LocationConstrainType) == 0x0004D8, "Member 'AUniversalCamera::LocationConstrainType' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, SphereOrigin) == 0x0004DC, "Member 'AUniversalCamera::SphereOrigin' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, SphereRadius) == 0x0004E8, "Member 'AUniversalCamera::SphereRadius' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainLocationMinimum) == 0x0004EC, "Member 'AUniversalCamera::ConstrainLocationMinimum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumLocation) == 0x0004F0, "Member 'AUniversalCamera::MinimumLocation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainLocationMaximum) == 0x0004FC, "Member 'AUniversalCamera::ConstrainLocationMaximum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumLocation) == 0x000500, "Member 'AUniversalCamera::MaximumLocation' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainLocationToShape) == 0x00050C, "Member 'AUniversalCamera::ConstrainLocationToShape' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainDots) == 0x000510, "Member 'AUniversalCamera::ConstrainDots' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OffsetConstrainType) == 0x000520, "Member 'AUniversalCamera::OffsetConstrainType' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, OffsetMaxDistance) == 0x000524, "Member 'AUniversalCamera::OffsetMaxDistance' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainOffsetMinimum) == 0x000528, "Member 'AUniversalCamera::ConstrainOffsetMinimum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumOffset) == 0x00052C, "Member 'AUniversalCamera::MinimumOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainOffsetMaximum) == 0x000538, "Member 'AUniversalCamera::ConstrainOffsetMaximum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumOffset) == 0x00053C, "Member 'AUniversalCamera::MaximumOffset' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainYaw) == 0x000548, "Member 'AUniversalCamera::ConstrainYaw' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumYaw) == 0x00054C, "Member 'AUniversalCamera::MinimumYaw' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumYaw) == 0x000550, "Member 'AUniversalCamera::MaximumYaw' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ReverseYawRestriction) == 0x000554, "Member 'AUniversalCamera::ReverseYawRestriction' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainPitch) == 0x000555, "Member 'AUniversalCamera::ConstrainPitch' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumPitch) == 0x000558, "Member 'AUniversalCamera::MinimumPitch' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumPitch) == 0x00055C, "Member 'AUniversalCamera::MaximumPitch' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ReversePitchRestriction) == 0x000560, "Member 'AUniversalCamera::ReversePitchRestriction' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainRoll) == 0x000561, "Member 'AUniversalCamera::ConstrainRoll' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumRoll) == 0x000564, "Member 'AUniversalCamera::MinimumRoll' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumRoll) == 0x000568, "Member 'AUniversalCamera::MaximumRoll' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ReverseRollRestriction) == 0x00056C, "Member 'AUniversalCamera::ReverseRollRestriction' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainZoomMinimum) == 0x00056D, "Member 'AUniversalCamera::ConstrainZoomMinimum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MinimumZoom) == 0x000570, "Member 'AUniversalCamera::MinimumZoom' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, ConstrainZoomMaximum) == 0x000574, "Member 'AUniversalCamera::ConstrainZoomMaximum' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaximumZoom) == 0x000578, "Member 'AUniversalCamera::MaximumZoom' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DrawDebugSpheres) == 0x00057C, "Member 'AUniversalCamera::DrawDebugSpheres' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, DebugPrintDesiredPosition) == 0x00057D, "Member 'AUniversalCamera::DebugPrintDesiredPosition' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, RotationLimitMode) == 0x00057E, "Member 'AUniversalCamera::RotationLimitMode' has a wrong offset!");
static_assert(offsetof(AUniversalCamera, MaxRotationRadiusAngle) == 0x000580, "Member 'AUniversalCamera::MaxRotationRadiusAngle' has a wrong offset!");

// Class UniversalCameraPlugin.UniversalCameraDataAsset
// 0x0050 (0x0080 - 0x0030)
class UUniversalCameraDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FUniversalCameraInfo> UniversalCameraDate;                               // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniversalCameraDataAsset">();
	}
	static class UUniversalCameraDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniversalCameraDataAsset>();
	}
};
static_assert(alignof(UUniversalCameraDataAsset) == 0x000008, "Wrong alignment on UUniversalCameraDataAsset");
static_assert(sizeof(UUniversalCameraDataAsset) == 0x000080, "Wrong size on UUniversalCameraDataAsset");
static_assert(offsetof(UUniversalCameraDataAsset, UniversalCameraDate) == 0x000030, "Member 'UUniversalCameraDataAsset::UniversalCameraDate' has a wrong offset!");

// Class UniversalCameraPlugin.UniversalCameraActor
// 0x0020 (0x05B0 - 0x0590)
class AUniversalCameraActor final : public AUniversalCamera
{
public:
	class UCameraComponent*                       CameraComp;                                        // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniversalCameraDataAsset*              UniversalCameraData;                               // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            CurrentCameraTransitionParams;                     // 0x05A0(0x0010)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	struct FUniversalCameraInfo SetUniversalCameraMode(class FName ModeName, bool bTryAlignTargetCamera);
	void TryAlignTargetCamera();
	void UpdateUniversalCamera(const struct FUniversalCameraInfo& UniversalCameraInfo);

	bool GetUniversalCameraInfo(class FName Name_0, struct FUniversalCameraInfo* Info) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniversalCameraActor">();
	}
	static class AUniversalCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUniversalCameraActor>();
	}
};
static_assert(alignof(AUniversalCameraActor) == 0x000008, "Wrong alignment on AUniversalCameraActor");
static_assert(sizeof(AUniversalCameraActor) == 0x0005B0, "Wrong size on AUniversalCameraActor");
static_assert(offsetof(AUniversalCameraActor, CameraComp) == 0x000590, "Member 'AUniversalCameraActor::CameraComp' has a wrong offset!");
static_assert(offsetof(AUniversalCameraActor, UniversalCameraData) == 0x000598, "Member 'AUniversalCameraActor::UniversalCameraData' has a wrong offset!");
static_assert(offsetof(AUniversalCameraActor, CurrentCameraTransitionParams) == 0x0005A0, "Member 'AUniversalCameraActor::CurrentCameraTransitionParams' has a wrong offset!");

// Class UniversalCameraPlugin.UniversalCameraSaveGame
// 0x0060 (0x0088 - 0x0028)
class UUniversalCameraSaveGame final : public USaveGame
{
public:
	struct FUniversalCameraPositionSaveFormat     SavedPosition;                                     // 0x0028(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsValidSavePosition;                              // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 SavedSettings;                                     // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsValidSaveSettings;                              // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniversalCameraSaveGame">();
	}
	static class UUniversalCameraSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniversalCameraSaveGame>();
	}
};
static_assert(alignof(UUniversalCameraSaveGame) == 0x000008, "Wrong alignment on UUniversalCameraSaveGame");
static_assert(sizeof(UUniversalCameraSaveGame) == 0x000088, "Wrong size on UUniversalCameraSaveGame");
static_assert(offsetof(UUniversalCameraSaveGame, SavedPosition) == 0x000028, "Member 'UUniversalCameraSaveGame::SavedPosition' has a wrong offset!");
static_assert(offsetof(UUniversalCameraSaveGame, bIsValidSavePosition) == 0x000068, "Member 'UUniversalCameraSaveGame::bIsValidSavePosition' has a wrong offset!");
static_assert(offsetof(UUniversalCameraSaveGame, SavedSettings) == 0x000070, "Member 'UUniversalCameraSaveGame::SavedSettings' has a wrong offset!");
static_assert(offsetof(UUniversalCameraSaveGame, bIsValidSaveSettings) == 0x000080, "Member 'UUniversalCameraSaveGame::bIsValidSaveSettings' has a wrong offset!");

}


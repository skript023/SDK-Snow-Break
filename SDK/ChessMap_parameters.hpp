#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ChessMap

#include "Basic.hpp"

#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function ChessMap.ChessBase.GetClassName
// 0x0010 (0x0010 - 0x0000)
struct ChessBase_GetClassName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChessBase_GetClassName) == 0x000008, "Wrong alignment on ChessBase_GetClassName");
static_assert(sizeof(ChessBase_GetClassName) == 0x000010, "Wrong size on ChessBase_GetClassName");
static_assert(offsetof(ChessBase_GetClassName, ReturnValue) == 0x000000, "Member 'ChessBase_GetClassName::ReturnValue' has a wrong offset!");

// Function ChessMap.ChessBase.GetTplId
// 0x0004 (0x0004 - 0x0000)
struct ChessBase_GetTplId final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChessBase_GetTplId) == 0x000004, "Wrong alignment on ChessBase_GetTplId");
static_assert(sizeof(ChessBase_GetTplId) == 0x000004, "Wrong size on ChessBase_GetTplId");
static_assert(offsetof(ChessBase_GetTplId, ReturnValue) == 0x000000, "Member 'ChessBase_GetTplId::ReturnValue' has a wrong offset!");

// Function ChessMap.ChessBase.HasTag
// 0x000C (0x000C - 0x0000)
struct ChessBase_HasTag final
{
public:
	class FName                                   InTagName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessBase_HasTag) == 0x000004, "Wrong alignment on ChessBase_HasTag");
static_assert(sizeof(ChessBase_HasTag) == 0x00000C, "Wrong size on ChessBase_HasTag");
static_assert(offsetof(ChessBase_HasTag, InTagName) == 0x000000, "Member 'ChessBase_HasTag::InTagName' has a wrong offset!");
static_assert(offsetof(ChessBase_HasTag, ReturnValue) == 0x000008, "Member 'ChessBase_HasTag::ReturnValue' has a wrong offset!");

// Function ChessMap.ChessBullet.OnOverlapBegin
// 0x00B0 (0x00B0 - 0x0000)
struct ChessBullet_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x008C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessBullet_OnOverlapBegin) == 0x000008, "Wrong alignment on ChessBullet_OnOverlapBegin");
static_assert(sizeof(ChessBullet_OnOverlapBegin) == 0x0000B0, "Wrong size on ChessBullet_OnOverlapBegin");
static_assert(offsetof(ChessBullet_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'ChessBullet_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapBegin, OtherActor) == 0x000008, "Member 'ChessBullet_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapBegin, OtherComp) == 0x000010, "Member 'ChessBullet_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'ChessBullet_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'ChessBullet_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapBegin, SweepResult) == 0x000020, "Member 'ChessBullet_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function ChessMap.ChessBullet.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct ChessBullet_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessBullet_OnOverlapEnd) == 0x000008, "Wrong alignment on ChessBullet_OnOverlapEnd");
static_assert(sizeof(ChessBullet_OnOverlapEnd) == 0x000020, "Wrong size on ChessBullet_OnOverlapEnd");
static_assert(offsetof(ChessBullet_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'ChessBullet_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapEnd, OtherActor) == 0x000008, "Member 'ChessBullet_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapEnd, OtherComp) == 0x000010, "Member 'ChessBullet_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(ChessBullet_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'ChessBullet_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function ChessMap.ChessGround.CheckObject
// 0x0018 (0x0018 - 0x0000)
struct ChessGround_CheckObject final
{
public:
	class FString                                 ClassName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessGround_CheckObject) == 0x000008, "Wrong alignment on ChessGround_CheckObject");
static_assert(sizeof(ChessGround_CheckObject) == 0x000018, "Wrong size on ChessGround_CheckObject");
static_assert(offsetof(ChessGround_CheckObject, ClassName) == 0x000000, "Member 'ChessGround_CheckObject::ClassName' has a wrong offset!");
static_assert(offsetof(ChessGround_CheckObject, ReturnValue) == 0x000010, "Member 'ChessGround_CheckObject::ReturnValue' has a wrong offset!");

// Function ChessMap.ChessFlowNpcBase.OnOverlapBegin
// 0x00B0 (0x00B0 - 0x0000)
struct ChessFlowNpcBase_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x008C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessFlowNpcBase_OnOverlapBegin) == 0x000008, "Wrong alignment on ChessFlowNpcBase_OnOverlapBegin");
static_assert(sizeof(ChessFlowNpcBase_OnOverlapBegin) == 0x0000B0, "Wrong size on ChessFlowNpcBase_OnOverlapBegin");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'ChessFlowNpcBase_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, OtherActor) == 0x000008, "Member 'ChessFlowNpcBase_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, OtherComp) == 0x000010, "Member 'ChessFlowNpcBase_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'ChessFlowNpcBase_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'ChessFlowNpcBase_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapBegin, SweepResult) == 0x000020, "Member 'ChessFlowNpcBase_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function ChessMap.ChessFlowNpcBase.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct ChessFlowNpcBase_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChessFlowNpcBase_OnOverlapEnd) == 0x000008, "Wrong alignment on ChessFlowNpcBase_OnOverlapEnd");
static_assert(sizeof(ChessFlowNpcBase_OnOverlapEnd) == 0x000020, "Wrong size on ChessFlowNpcBase_OnOverlapEnd");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'ChessFlowNpcBase_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapEnd, OtherActor) == 0x000008, "Member 'ChessFlowNpcBase_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapEnd, OtherComp) == 0x000010, "Member 'ChessFlowNpcBase_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(ChessFlowNpcBase_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'ChessFlowNpcBase_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

}


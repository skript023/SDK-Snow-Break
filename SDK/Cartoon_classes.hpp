#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Cartoon

#include "Basic.hpp"

#include "UMG_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Cartoon_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class Cartoon.CartoonSpineRTActor
// 0x0080 (0x02A8 - 0x0228)
class ACartoonSpineRTActor final : public AActor
{
public:
	struct FSoftObjectPath                        CurveDataPath;                                     // 0x0228(0x0018)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        CurveColorDataPath;                                // 0x0240(0x0018)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           CurrentCurveData;                                  // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           CurrentCurveColorData;                             // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CurrentMaterial;                                   // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USpineSkeletonAnimationComponent*       SpineAnimationComponent;                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpineSkeletonRendererComponent*        SpineRenderComponent;                              // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget2D;                                    // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonSpineRTActor">();
	}
	static class ACartoonSpineRTActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACartoonSpineRTActor>();
	}
};
static_assert(alignof(ACartoonSpineRTActor) == 0x000008, "Wrong alignment on ACartoonSpineRTActor");
static_assert(sizeof(ACartoonSpineRTActor) == 0x0002A8, "Wrong size on ACartoonSpineRTActor");
static_assert(offsetof(ACartoonSpineRTActor, CurveDataPath) == 0x000228, "Member 'ACartoonSpineRTActor::CurveDataPath' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, CurveColorDataPath) == 0x000240, "Member 'ACartoonSpineRTActor::CurveColorDataPath' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, CurrentCurveData) == 0x000258, "Member 'ACartoonSpineRTActor::CurrentCurveData' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, CurrentCurveColorData) == 0x000260, "Member 'ACartoonSpineRTActor::CurrentCurveColorData' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, SceneCaptureComponent) == 0x000268, "Member 'ACartoonSpineRTActor::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, CurrentMaterial) == 0x000270, "Member 'ACartoonSpineRTActor::CurrentMaterial' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, SpineAnimationComponent) == 0x000288, "Member 'ACartoonSpineRTActor::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, SpineRenderComponent) == 0x000290, "Member 'ACartoonSpineRTActor::SpineRenderComponent' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, RenderTarget2D) == 0x000298, "Member 'ACartoonSpineRTActor::RenderTarget2D' has a wrong offset!");
static_assert(offsetof(ACartoonSpineRTActor, Index_0) == 0x0002A0, "Member 'ACartoonSpineRTActor::Index_0' has a wrong offset!");

// Class Cartoon.CartoonActionWidget
// 0x0058 (0x02D8 - 0x0280)
class UCartoonActionWidget : public UUserWidget
{
public:
	uint8                                         Pad_280[0x50];                                     // 0x0280(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UCartoonWidget>          UIWidget;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetParam(const class FString& InKey, const class FString& InDefault);
	bool LuaImpl_IsComplete();
	void LuaImpl_OnBegin(const class FString& ActionName);
	void LuaImpl_OnEnd();
	void LuaImpl_OnTick(float InTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonActionWidget">();
	}
	static class UCartoonActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonActionWidget>();
	}
};
static_assert(alignof(UCartoonActionWidget) == 0x000008, "Wrong alignment on UCartoonActionWidget");
static_assert(sizeof(UCartoonActionWidget) == 0x0002D8, "Wrong size on UCartoonActionWidget");
static_assert(offsetof(UCartoonActionWidget, UIWidget) == 0x0002D0, "Member 'UCartoonActionWidget::UIWidget' has a wrong offset!");

// Class Cartoon.CameraShakeActionWidget
// 0x0050 (0x0328 - 0x02D8)
class UCameraShakeActionWidget final : public UCartoonActionWidget
{
public:
	struct FVOscillator                           ShakeSetting;                                      // 0x02D8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMaterialInstanceDynamic> ShakeMaterial;                                     // 0x02FC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0304(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0308(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x1C];                                     // 0x030C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginShake(class UMaterialInstanceDynamic* InMaterial, class FName InKey);
	void EndShake();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraShakeActionWidget">();
	}
	static class UCameraShakeActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraShakeActionWidget>();
	}
};
static_assert(alignof(UCameraShakeActionWidget) == 0x000008, "Wrong alignment on UCameraShakeActionWidget");
static_assert(sizeof(UCameraShakeActionWidget) == 0x000328, "Wrong size on UCameraShakeActionWidget");
static_assert(offsetof(UCameraShakeActionWidget, ShakeSetting) == 0x0002D8, "Member 'UCameraShakeActionWidget::ShakeSetting' has a wrong offset!");
static_assert(offsetof(UCameraShakeActionWidget, ShakeMaterial) == 0x0002FC, "Member 'UCameraShakeActionWidget::ShakeMaterial' has a wrong offset!");
static_assert(offsetof(UCameraShakeActionWidget, ShakeScale) == 0x000304, "Member 'UCameraShakeActionWidget::ShakeScale' has a wrong offset!");
static_assert(offsetof(UCameraShakeActionWidget, BlendWeight) == 0x000308, "Member 'UCameraShakeActionWidget::BlendWeight' has a wrong offset!");

// Class Cartoon.CartoonAnchor
// 0x0000 (0x0228 - 0x0228)
class ACartoonAnchor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonAnchor">();
	}
	static class ACartoonAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACartoonAnchor>();
	}
};
static_assert(alignof(ACartoonAnchor) == 0x000008, "Wrong alignment on ACartoonAnchor");
static_assert(sizeof(ACartoonAnchor) == 0x000228, "Wrong size on ACartoonAnchor");

// Class Cartoon.CartoonBGImage
// 0x0010 (0x0240 - 0x0230)
class UCartoonBGImage final : public UImage
{
public:
	TWeakObjectPtr<class UCartoonWidget>          UIWidget;                                          // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPath(const class FString& InPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonBGImage">();
	}
	static class UCartoonBGImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonBGImage>();
	}
};
static_assert(alignof(UCartoonBGImage) == 0x000008, "Wrong alignment on UCartoonBGImage");
static_assert(sizeof(UCartoonBGImage) == 0x000240, "Wrong size on UCartoonBGImage");
static_assert(offsetof(UCartoonBGImage, UIWidget) == 0x000230, "Member 'UCartoonBGImage::UIWidget' has a wrong offset!");

// Class Cartoon.CartoonCameraAnimSystem
// 0x02F0 (0x0320 - 0x0030)
class alignas(0x10) UCartoonCameraAnimSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           CameraActor;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CameraAnchor;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   CurrentCameraPlayer;                               // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ULevelSequencePlayer*, class ALevelSequenceActor*> CacheCameraSequencePlayer;                         // 0x00A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class ULevelSequencePlayer*>      CacheId2CameraPlayer;                              // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x50];                                     // 0x0148(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetCache;                                       // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x180];                                    // 0x01A0(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToAnimStartPos(int32 InAnimId, float InSmoothTime);
	bool Play(int32 InAnimId, float InSmoothTime);
	void Reset(float InSmoothTime);

	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonCameraAnimSystem">();
	}
	static class UCartoonCameraAnimSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonCameraAnimSystem>();
	}
};
static_assert(alignof(UCartoonCameraAnimSystem) == 0x000010, "Wrong alignment on UCartoonCameraAnimSystem");
static_assert(sizeof(UCartoonCameraAnimSystem) == 0x000320, "Wrong size on UCartoonCameraAnimSystem");
static_assert(offsetof(UCartoonCameraAnimSystem, CameraActor) == 0x000040, "Member 'UCartoonCameraAnimSystem::CameraActor' has a wrong offset!");
static_assert(offsetof(UCartoonCameraAnimSystem, CameraAnchor) == 0x000048, "Member 'UCartoonCameraAnimSystem::CameraAnchor' has a wrong offset!");
static_assert(offsetof(UCartoonCameraAnimSystem, CurrentCameraPlayer) == 0x000050, "Member 'UCartoonCameraAnimSystem::CurrentCameraPlayer' has a wrong offset!");
static_assert(offsetof(UCartoonCameraAnimSystem, CacheCameraSequencePlayer) == 0x0000A8, "Member 'UCartoonCameraAnimSystem::CacheCameraSequencePlayer' has a wrong offset!");
static_assert(offsetof(UCartoonCameraAnimSystem, CacheId2CameraPlayer) == 0x0000F8, "Member 'UCartoonCameraAnimSystem::CacheId2CameraPlayer' has a wrong offset!");
static_assert(offsetof(UCartoonCameraAnimSystem, TargetCache) == 0x000198, "Member 'UCartoonCameraAnimSystem::TargetCache' has a wrong offset!");

// Class Cartoon.CartoonRuntime
// 0x0848 (0x0A70 - 0x0228)
class ACartoonRuntime final : public AActor
{
public:
	class UCartoonSettingSystem*                  Setting;                                           // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FObjectManager                         ObjectManager;                                     // 0x0230(0x0170)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ACameraActor*                           CameraActor;                                       // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BeginTransform;                                    // 0x03B0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ACameraActor*                           LevelSequenceCameraActor;                          // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCartoonWidget>          UI;                                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CacheViewTarget;                                   // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CacheShowMouseCursor;                              // 0x0400(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasLevelSequence;                                  // 0x0401(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebugMode;                                       // 0x0402(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden;                                          // 0x0403(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CameraAnchor;                                      // 0x0408(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AllAnchor;                                         // 0x0410(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class ULevelSequencePlayer*, class ALevelSequenceActor*> CacheCameraSequencePlayer;                         // 0x0420(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, class ULevelSequencePlayer*>      CacheId2CameraPlayer;                              // 0x0470(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, class ULevelSequencePlayer*> CacheId2CameraPlayer2;                             // 0x04C0(0x0050)(Transient, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   CurrentCameraPlayer;                               // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AllSelectedBranches;                               // 0x0518(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0538(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x528];                                    // 0x0548(0x0528)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasTag(const class FName& InName);
	bool IsFix();
	void NotifyLevelSequencePlayEnd();
	void OnBtnClickSkip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonRuntime">();
	}
	static class ACartoonRuntime* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACartoonRuntime>();
	}
};
static_assert(alignof(ACartoonRuntime) == 0x000010, "Wrong alignment on ACartoonRuntime");
static_assert(sizeof(ACartoonRuntime) == 0x000A70, "Wrong size on ACartoonRuntime");
static_assert(offsetof(ACartoonRuntime, Setting) == 0x000228, "Member 'ACartoonRuntime::Setting' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, ObjectManager) == 0x000230, "Member 'ACartoonRuntime::ObjectManager' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CameraActor) == 0x0003A0, "Member 'ACartoonRuntime::CameraActor' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, BeginTransform) == 0x0003B0, "Member 'ACartoonRuntime::BeginTransform' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, LevelSequenceCameraActor) == 0x0003E0, "Member 'ACartoonRuntime::LevelSequenceCameraActor' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, UI) == 0x0003E8, "Member 'ACartoonRuntime::UI' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, PlayerController) == 0x0003F0, "Member 'ACartoonRuntime::PlayerController' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CacheViewTarget) == 0x0003F8, "Member 'ACartoonRuntime::CacheViewTarget' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CacheShowMouseCursor) == 0x000400, "Member 'ACartoonRuntime::CacheShowMouseCursor' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, HasLevelSequence) == 0x000401, "Member 'ACartoonRuntime::HasLevelSequence' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, IsDebugMode) == 0x000402, "Member 'ACartoonRuntime::IsDebugMode' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, IsHidden) == 0x000403, "Member 'ACartoonRuntime::IsHidden' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CameraAnchor) == 0x000408, "Member 'ACartoonRuntime::CameraAnchor' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, AllAnchor) == 0x000410, "Member 'ACartoonRuntime::AllAnchor' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CacheCameraSequencePlayer) == 0x000420, "Member 'ACartoonRuntime::CacheCameraSequencePlayer' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CacheId2CameraPlayer) == 0x000470, "Member 'ACartoonRuntime::CacheId2CameraPlayer' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CacheId2CameraPlayer2) == 0x0004C0, "Member 'ACartoonRuntime::CacheId2CameraPlayer2' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, CurrentCameraPlayer) == 0x000510, "Member 'ACartoonRuntime::CurrentCameraPlayer' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, AllSelectedBranches) == 0x000518, "Member 'ACartoonRuntime::AllSelectedBranches' has a wrong offset!");
static_assert(offsetof(ACartoonRuntime, PlayerName) == 0x000538, "Member 'ACartoonRuntime::PlayerName' has a wrong offset!");

// Class Cartoon.CartoonSettingSystem
// 0x0658 (0x0688 - 0x0030)
class UCartoonSettingSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x658];                                     // 0x0030(0x0658)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetImagePath(const class FString& InName, bool IsFix);
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonSettingSystem">();
	}
	static class UCartoonSettingSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonSettingSystem>();
	}
};
static_assert(alignof(UCartoonSettingSystem) == 0x000008, "Wrong alignment on UCartoonSettingSystem");
static_assert(sizeof(UCartoonSettingSystem) == 0x000688, "Wrong size on UCartoonSettingSystem");

// Class Cartoon.CartoonSpineImage
// 0x0018 (0x0248 - 0x0230)
class UCartoonSpineImage final : public UImage
{
public:
	class USpineSkeletonAnimationComponent*       SpineAnimationComponent;                           // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpineSkeletonRendererComponent*        SpineRenderComponent;                              // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACartoonSpineRTActor*                   PlotSceneActor;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonSpineImage">();
	}
	static class UCartoonSpineImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonSpineImage>();
	}
};
static_assert(alignof(UCartoonSpineImage) == 0x000008, "Wrong alignment on UCartoonSpineImage");
static_assert(sizeof(UCartoonSpineImage) == 0x000248, "Wrong size on UCartoonSpineImage");
static_assert(offsetof(UCartoonSpineImage, SpineAnimationComponent) == 0x000230, "Member 'UCartoonSpineImage::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(UCartoonSpineImage, SpineRenderComponent) == 0x000238, "Member 'UCartoonSpineImage::SpineRenderComponent' has a wrong offset!");
static_assert(offsetof(UCartoonSpineImage, PlotSceneActor) == 0x000240, "Member 'UCartoonSpineImage::PlotSceneActor' has a wrong offset!");

// Class Cartoon.CartoonSpineWidget
// 0x0090 (0x0310 - 0x0280)
class UCartoonSpineWidget final : public UUserWidget
{
public:
	class UCartoonSpineImage*                     RoleSpineEffectImage;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UMaterialInstanceDynamic*>  EffectMats;                                        // 0x0290(0x0050)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCartoonWidget>          CartoonWidget;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString LuaImpl_CheckResourceAmend(const class FString& InPath);
	class FString LuaImpl_GetEffecMaterialPathByType(int32 InType);
	void OnEffectAnimationCompleteHandler(class UObject* InDispatcher, class UTrackEntry* InEntry);
	void SetSpineImageAlpha(const float Alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonSpineWidget">();
	}
	static class UCartoonSpineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonSpineWidget>();
	}
};
static_assert(alignof(UCartoonSpineWidget) == 0x000008, "Wrong alignment on UCartoonSpineWidget");
static_assert(sizeof(UCartoonSpineWidget) == 0x000310, "Wrong size on UCartoonSpineWidget");
static_assert(offsetof(UCartoonSpineWidget, RoleSpineEffectImage) == 0x000280, "Member 'UCartoonSpineWidget::RoleSpineEffectImage' has a wrong offset!");
static_assert(offsetof(UCartoonSpineWidget, EffectMats) == 0x000290, "Member 'UCartoonSpineWidget::EffectMats' has a wrong offset!");
static_assert(offsetof(UCartoonSpineWidget, CartoonWidget) == 0x0002E0, "Member 'UCartoonSpineWidget::CartoonWidget' has a wrong offset!");

// Class Cartoon.CartoonWidget
// 0x00F8 (0x0378 - 0x0280)
class UCartoonWidget : public UUserWidget
{
public:
	class UImage*                                 DefaultScreenImage;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Speaker;                                           // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelMsg;                                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelLayer1;                                       // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelOptions;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelFullScreen;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Pool_Images;                                       // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Btn_hide;                                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                DialogueText;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImgFullScreen;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ScrollFullText;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                FullScreenText;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalApplicationScale;                            // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkip;                                            // 0x02E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoPlay;                                        // 0x02E5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWindowMinized;                                   // 0x02E6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E7[0x1];                                      // 0x02E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UWidget*, class UWidget*>          WarpWidgets;                                       // 0x02E8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        ImageWidgetPool;                                   // 0x0338(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsTextAnimComplete;                               // 0x0348(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACartoonRuntime*                        Runtime;                                           // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCartoonBGImage>         BGImage;                                           // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChoiceIndex;                                       // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowSkipUI;                                      // 0x0364(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x7];                                      // 0x0365(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CartoonType;                                       // 0x036C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCartoonActionWidget* AllocActionWidget(const class FString& InActionName);
	class UCartoonSpineWidget* AllocRichmanSpine(int32 InPosType);
	class UCartoonSpineWidget* AllocSpineWidget();
	bool CheckCondition(const class FString& InContent);
	bool CheckIsAutoPlay();
	void FreeActionWidget(class UCartoonActionWidget* InWidget);
	void FreeSpineWidget(class UCartoonSpineWidget* InWidget);
	struct FVector2D GetBackgroundImageSize();
	void LuaCloseCameraEffect(int32 InType, float InTime);
	void LuaImpl_NotifyChoiceEnd(int32 ChoiceIndex_0);
	void LuaImpl_NotifySkipEnabeld(bool InValue);
	bool LuaImpl_UpdateBGSize(class UImage* InImage, class UTexture2D* InTexture);
	void LuaOpenCameraEffect(int32 InType, int32 InLayer, int32 InOffset, float InTime);
	void NotifyTextAnimBegin(class UWidget* InWidget);
	void NotifyTextAnimEnd(class UWidget* InWidget, bool InForce);
	void OnBtnClickSkip();
	void OnChoices(const TArray<struct FCartoonChoiceData>& InOptions);
	void OnClick();
	void OnLuaInit();
	void OnLuaPlayEnd();
	void OnLuaReset();
	void OnTextInfoChange(class UWidget* InWidget, const class FText& InText);
	void RegisterWrapWidget(class UWidget* InSrc, class UWidget* InWrap);
	void SetParallaxBlur(float InDistance);

	const struct FVector2D GetBackgroundSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartoonWidget">();
	}
	static class UCartoonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartoonWidget>();
	}
};
static_assert(alignof(UCartoonWidget) == 0x000008, "Wrong alignment on UCartoonWidget");
static_assert(sizeof(UCartoonWidget) == 0x000378, "Wrong size on UCartoonWidget");
static_assert(offsetof(UCartoonWidget, DefaultScreenImage) == 0x000280, "Member 'UCartoonWidget::DefaultScreenImage' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, Speaker) == 0x000288, "Member 'UCartoonWidget::Speaker' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, PanelMsg) == 0x000290, "Member 'UCartoonWidget::PanelMsg' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, PanelLayer1) == 0x000298, "Member 'UCartoonWidget::PanelLayer1' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, PanelOptions) == 0x0002A0, "Member 'UCartoonWidget::PanelOptions' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, PanelFullScreen) == 0x0002A8, "Member 'UCartoonWidget::PanelFullScreen' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, Pool_Images) == 0x0002B0, "Member 'UCartoonWidget::Pool_Images' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, Btn_hide) == 0x0002B8, "Member 'UCartoonWidget::Btn_hide' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, DialogueText) == 0x0002C0, "Member 'UCartoonWidget::DialogueText' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, ImgFullScreen) == 0x0002C8, "Member 'UCartoonWidget::ImgFullScreen' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, ScrollFullText) == 0x0002D0, "Member 'UCartoonWidget::ScrollFullText' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, FullScreenText) == 0x0002D8, "Member 'UCartoonWidget::FullScreenText' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, GlobalApplicationScale) == 0x0002E0, "Member 'UCartoonWidget::GlobalApplicationScale' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, IsSkip) == 0x0002E4, "Member 'UCartoonWidget::IsSkip' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, IsAutoPlay) == 0x0002E5, "Member 'UCartoonWidget::IsAutoPlay' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, IsWindowMinized) == 0x0002E6, "Member 'UCartoonWidget::IsWindowMinized' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, WarpWidgets) == 0x0002E8, "Member 'UCartoonWidget::WarpWidgets' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, ImageWidgetPool) == 0x000338, "Member 'UCartoonWidget::ImageWidgetPool' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, bIsTextAnimComplete) == 0x000348, "Member 'UCartoonWidget::bIsTextAnimComplete' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, Runtime) == 0x000350, "Member 'UCartoonWidget::Runtime' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, BGImage) == 0x000358, "Member 'UCartoonWidget::BGImage' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, ChoiceIndex) == 0x000360, "Member 'UCartoonWidget::ChoiceIndex' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, IsShowSkipUI) == 0x000364, "Member 'UCartoonWidget::IsShowSkipUI' has a wrong offset!");
static_assert(offsetof(UCartoonWidget, CartoonType) == 0x00036C, "Member 'UCartoonWidget::CartoonType' has a wrong offset!");

}


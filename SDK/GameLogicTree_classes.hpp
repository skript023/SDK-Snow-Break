#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameLogicTree

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameLogicTree_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GameLogicTree.GameLogic_DataHandler
// 0x0038 (0x0060 - 0x0028)
class UGameLogic_DataHandler : public UObject
{
public:
	class ULogicTree_BlackBoard*                  TargetBlackBoard;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HandlerTag;                                        // 0x0030(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetKey;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExecuteInterval;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameLogicTreeEntity*                   OwnEntity;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         OwnerNode;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLogic_DataHandler">();
	}
	static class UGameLogic_DataHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLogic_DataHandler>();
	}
};
static_assert(alignof(UGameLogic_DataHandler) == 0x000008, "Wrong alignment on UGameLogic_DataHandler");
static_assert(sizeof(UGameLogic_DataHandler) == 0x000060, "Wrong size on UGameLogic_DataHandler");
static_assert(offsetof(UGameLogic_DataHandler, TargetBlackBoard) == 0x000028, "Member 'UGameLogic_DataHandler::TargetBlackBoard' has a wrong offset!");
static_assert(offsetof(UGameLogic_DataHandler, HandlerTag) == 0x000030, "Member 'UGameLogic_DataHandler::HandlerTag' has a wrong offset!");
static_assert(offsetof(UGameLogic_DataHandler, TargetKey) == 0x000038, "Member 'UGameLogic_DataHandler::TargetKey' has a wrong offset!");
static_assert(offsetof(UGameLogic_DataHandler, ExecuteInterval) == 0x000040, "Member 'UGameLogic_DataHandler::ExecuteInterval' has a wrong offset!");
static_assert(offsetof(UGameLogic_DataHandler, OwnEntity) == 0x000050, "Member 'UGameLogic_DataHandler::OwnEntity' has a wrong offset!");
static_assert(offsetof(UGameLogic_DataHandler, OwnerNode) == 0x000058, "Member 'UGameLogic_DataHandler::OwnerNode' has a wrong offset!");

// Class GameLogicTree.LT_DataHandler_AccumulateTime
// 0x0048 (0x00A8 - 0x0060)
class ULT_DataHandler_AccumulateTime final : public UGameLogic_DataHandler
{
public:
	struct FLogicTree_DataAccessor                Timeout;                                           // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeNode*                         CacheNode;                                         // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DataHandler_AccumulateTime">();
	}
	static class ULT_DataHandler_AccumulateTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DataHandler_AccumulateTime>();
	}
};
static_assert(alignof(ULT_DataHandler_AccumulateTime) == 0x000008, "Wrong alignment on ULT_DataHandler_AccumulateTime");
static_assert(sizeof(ULT_DataHandler_AccumulateTime) == 0x0000A8, "Wrong size on ULT_DataHandler_AccumulateTime");
static_assert(offsetof(ULT_DataHandler_AccumulateTime, Timeout) == 0x000060, "Member 'ULT_DataHandler_AccumulateTime::Timeout' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_AccumulateTime, CacheNode) == 0x0000A0, "Member 'ULT_DataHandler_AccumulateTime::CacheNode' has a wrong offset!");

// Class GameLogicTree.LogicTree_Decorator
// 0x0010 (0x0038 - 0x0028)
class ULogicTree_Decorator : public UObject
{
public:
	uint8                                         Pad_28[0x2];                                       // 0x0028(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ELogicTreeDecoratorAbortType                  AbortType;                                         // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInverse;                                         // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanBreakChild;                                     // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeNode*                         OwnerNode;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ReCheckAndBreakChild();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Decorator">();
	}
	static class ULogicTree_Decorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Decorator>();
	}
};
static_assert(alignof(ULogicTree_Decorator) == 0x000008, "Wrong alignment on ULogicTree_Decorator");
static_assert(sizeof(ULogicTree_Decorator) == 0x000038, "Wrong size on ULogicTree_Decorator");
static_assert(offsetof(ULogicTree_Decorator, AbortType) == 0x00002A, "Member 'ULogicTree_Decorator::AbortType' has a wrong offset!");
static_assert(offsetof(ULogicTree_Decorator, IsInverse) == 0x00002B, "Member 'ULogicTree_Decorator::IsInverse' has a wrong offset!");
static_assert(offsetof(ULogicTree_Decorator, CanBreakChild) == 0x00002C, "Member 'ULogicTree_Decorator::CanBreakChild' has a wrong offset!");
static_assert(offsetof(ULogicTree_Decorator, OwnerNode) == 0x000030, "Member 'ULogicTree_Decorator::OwnerNode' has a wrong offset!");

// Class GameLogicTree.LogicTree_Decorator_BP
// 0x0000 (0x0038 - 0x0038)
class ULogicTree_Decorator_BP final : public ULogicTree_Decorator
{
public:
	bool CheckCondition_BP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Decorator_BP">();
	}
	static class ULogicTree_Decorator_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Decorator_BP>();
	}
};
static_assert(alignof(ULogicTree_Decorator_BP) == 0x000008, "Wrong alignment on ULogicTree_Decorator_BP");
static_assert(sizeof(ULogicTree_Decorator_BP) == 0x000038, "Wrong size on ULogicTree_Decorator_BP");

// Class GameLogicTree.LogicTreeNode
// 0x0078 (0x00A0 - 0x0028)
class ULogicTreeNode : public UObject
{
public:
	class UGameLogicTreeEntity*                   OwnEntity;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNodeExecuteHelper>         ExecuteHelperClass;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameLogic_NodeBlackBoardOwner                BlackBoardOwner;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_BlackBoard*                  NodeBlackBoard;                                    // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         Parent;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexInParent;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameLogicTreeRoot*                     Root;                                              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_BlackBoard*                  ExecuteParentBBCache;                              // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULogicTree_Decorator*>           Decorators;                                        // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameLogic_DataHandler*>         Services;                                          // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x5];                                       // 0x0090(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	ELogicTree_NodeExecuteNet                     ExecuteNetMode;                                    // 0x0095(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_BlackBoard*                  RuntimeBlackBoard;                                 // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTreeNode">();
	}
	static class ULogicTreeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTreeNode>();
	}
};
static_assert(alignof(ULogicTreeNode) == 0x000008, "Wrong alignment on ULogicTreeNode");
static_assert(sizeof(ULogicTreeNode) == 0x0000A0, "Wrong size on ULogicTreeNode");
static_assert(offsetof(ULogicTreeNode, OwnEntity) == 0x000028, "Member 'ULogicTreeNode::OwnEntity' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, ExecuteHelperClass) == 0x000030, "Member 'ULogicTreeNode::ExecuteHelperClass' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, BlackBoardOwner) == 0x000038, "Member 'ULogicTreeNode::BlackBoardOwner' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, NodeBlackBoard) == 0x000040, "Member 'ULogicTreeNode::NodeBlackBoard' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, Parent) == 0x000048, "Member 'ULogicTreeNode::Parent' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, IndexInParent) == 0x000050, "Member 'ULogicTreeNode::IndexInParent' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, Root) == 0x000058, "Member 'ULogicTreeNode::Root' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, ExecuteParentBBCache) == 0x000060, "Member 'ULogicTreeNode::ExecuteParentBBCache' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, Decorators) == 0x000068, "Member 'ULogicTreeNode::Decorators' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, Services) == 0x000080, "Member 'ULogicTreeNode::Services' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, ExecuteNetMode) == 0x000095, "Member 'ULogicTreeNode::ExecuteNetMode' has a wrong offset!");
static_assert(offsetof(ULogicTreeNode, RuntimeBlackBoard) == 0x000098, "Member 'ULogicTreeNode::RuntimeBlackBoard' has a wrong offset!");

// Class GameLogicTree.LogicTree_CompositeNode
// 0x0018 (0x00B8 - 0x00A0)
class ULogicTree_CompositeNode : public ULogicTreeNode
{
public:
	TArray<class ULogicTreeNode*>                 Children;                                          // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_CompositeNode">();
	}
	static class ULogicTree_CompositeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_CompositeNode>();
	}
};
static_assert(alignof(ULogicTree_CompositeNode) == 0x000008, "Wrong alignment on ULogicTree_CompositeNode");
static_assert(sizeof(ULogicTree_CompositeNode) == 0x0000B8, "Wrong size on ULogicTree_CompositeNode");
static_assert(offsetof(ULogicTree_CompositeNode, Children) == 0x0000A0, "Member 'ULogicTree_CompositeNode::Children' has a wrong offset!");

// Class GameLogicTree.LogicTree_SelectorNode
// 0x0008 (0x00C0 - 0x00B8)
class ULogicTree_SelectorNode final : public ULogicTree_CompositeNode
{
public:
	class ULogicTreeNode*                         JumpTickNode;                                      // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SelectorNode">();
	}
	static class ULogicTree_SelectorNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SelectorNode>();
	}
};
static_assert(alignof(ULogicTree_SelectorNode) == 0x000008, "Wrong alignment on ULogicTree_SelectorNode");
static_assert(sizeof(ULogicTree_SelectorNode) == 0x0000C0, "Wrong size on ULogicTree_SelectorNode");
static_assert(offsetof(ULogicTree_SelectorNode, JumpTickNode) == 0x0000B8, "Member 'ULogicTree_SelectorNode::JumpTickNode' has a wrong offset!");

// Class GameLogicTree.LogicTree_DataFormula
// 0x0018 (0x0040 - 0x0028)
class ULogicTree_DataFormula : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_DataFormula">();
	}
	static class ULogicTree_DataFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_DataFormula>();
	}
};
static_assert(alignof(ULogicTree_DataFormula) == 0x000008, "Wrong alignment on ULogicTree_DataFormula");
static_assert(sizeof(ULogicTree_DataFormula) == 0x000040, "Wrong size on ULogicTree_DataFormula");

// Class GameLogicTree.LogicTree_ActionBase
// 0x0008 (0x0030 - 0x0028)
class ULogicTree_ActionBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_ActionBase">();
	}
	static class ULogicTree_ActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_ActionBase>();
	}
};
static_assert(alignof(ULogicTree_ActionBase) == 0x000008, "Wrong alignment on ULogicTree_ActionBase");
static_assert(sizeof(ULogicTree_ActionBase) == 0x000030, "Wrong size on ULogicTree_ActionBase");

// Class GameLogicTree.LogicTree_DestroyAction
// 0x0040 (0x0070 - 0x0030)
class ULogicTree_DestroyAction final : public ULogicTree_ActionBase
{
public:
	class FName                                   Key;                                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_DestroyAction">();
	}
	static class ULogicTree_DestroyAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_DestroyAction>();
	}
};
static_assert(alignof(ULogicTree_DestroyAction) == 0x000008, "Wrong alignment on ULogicTree_DestroyAction");
static_assert(sizeof(ULogicTree_DestroyAction) == 0x000070, "Wrong size on ULogicTree_DestroyAction");
static_assert(offsetof(ULogicTree_DestroyAction, Key) == 0x000030, "Member 'ULogicTree_DestroyAction::Key' has a wrong offset!");
static_assert(offsetof(ULogicTree_DestroyAction, DataAccessor) == 0x000038, "Member 'ULogicTree_DestroyAction::DataAccessor' has a wrong offset!");

// Class GameLogicTree.LogicTree_TaskNode
// 0x0000 (0x00A0 - 0x00A0)
class ULogicTree_TaskNode : public ULogicTreeNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_TaskNode">();
	}
	static class ULogicTree_TaskNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_TaskNode>();
	}
};
static_assert(alignof(ULogicTree_TaskNode) == 0x000008, "Wrong alignment on ULogicTree_TaskNode");
static_assert(sizeof(ULogicTree_TaskNode) == 0x0000A0, "Wrong size on ULogicTree_TaskNode");

// Class GameLogicTree.LogicTree_EntityDataCom
// 0x0408 (0x04B8 - 0x00B0)
class ULogicTree_EntityDataCom final : public UActorComponent
{
public:
	struct FLogicTree_EntityDataContainer         ReplicatedData;                                    // 0x00B0(0x0168)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x1B8];                                    // 0x0218(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ReplicatedTags;                                    // 0x03D0(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x70];                                     // 0x03F0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeMessageBus*                   MsgBus;                                            // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosLagRecordTime;                                  // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PosLagOffset;                                      // 0x046C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x40];                                     // 0x0478(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddData(class FName Name_0, float BaseValue, bool bReplicated);
	void AddTag(const struct FGameplayTag& Tag, int32 Count);
	float GetBaseData(class FName Name_0);
	float GetCurData(class FName Name_0);
	bool IsPosInLagAABB(const struct FVector& InCheckPos);
	void OnRep_Data();
	void OnRep_ReplicatedTags();
	void RegisterTagChangeCallback(const struct FGameplayTag& Tag, const TDelegate<void(const struct FGameplayTag& Tag, bool IsContain)>& Callback);
	void RemoveTag(const struct FGameplayTag& Tag, int32 Count);
	void SetBaseData(class FName Name_0, float NewValue);
	void SetCurrentData(class FName Name_0, float NewValue);
	void UnregisterTagChangeCallback(const struct FGameplayTag& Tag, class UObject* BoundObject, class FName FunctionName);

	bool GetData(class FName Name_0, float* OutBase, float* OutCurrent) const;
	bool HasTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_EntityDataCom">();
	}
	static class ULogicTree_EntityDataCom* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_EntityDataCom>();
	}
};
static_assert(alignof(ULogicTree_EntityDataCom) == 0x000008, "Wrong alignment on ULogicTree_EntityDataCom");
static_assert(sizeof(ULogicTree_EntityDataCom) == 0x0004B8, "Wrong size on ULogicTree_EntityDataCom");
static_assert(offsetof(ULogicTree_EntityDataCom, ReplicatedData) == 0x0000B0, "Member 'ULogicTree_EntityDataCom::ReplicatedData' has a wrong offset!");
static_assert(offsetof(ULogicTree_EntityDataCom, ReplicatedTags) == 0x0003D0, "Member 'ULogicTree_EntityDataCom::ReplicatedTags' has a wrong offset!");
static_assert(offsetof(ULogicTree_EntityDataCom, MsgBus) == 0x000460, "Member 'ULogicTree_EntityDataCom::MsgBus' has a wrong offset!");
static_assert(offsetof(ULogicTree_EntityDataCom, PosLagRecordTime) == 0x000468, "Member 'ULogicTree_EntityDataCom::PosLagRecordTime' has a wrong offset!");
static_assert(offsetof(ULogicTree_EntityDataCom, PosLagOffset) == 0x00046C, "Member 'ULogicTree_EntityDataCom::PosLagOffset' has a wrong offset!");

// Class GameLogicTree.LogicTree_LogicHandleCom
// 0x0418 (0x04C8 - 0x00B0)
class ULogicTree_LogicHandleCom : public UActorComponent
{
public:
	struct FLogicTree_LogicHandleContainer        ReplicatedHandles;                                 // 0x00B0(0x0180)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x1D8];                                    // 0x0230(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UGameLogicTreeEntity*>      Entities;                                          // 0x0408(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x70];                                     // 0x0458(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_NotifyExecuteFail(int32 LogicId, int32 PredictionId);
	void Client_NotifyStopFail(int32 LogicId, int32 PredictionId);
	void MulticastExecuteLogic(int32 LogicId, int32 PredictionId);
	void MulticastExecuteNode_FromServer(int32 LogicId, int32 NodeId, const struct FLogicTree_NodeExecutionData& InData);
	void MulticastStopLogic(int32 LogicId, int32 PredictionId);
	void OnRep_ReplicatedHandles();
	void Server_TryStopLogic(int32 LogicId, int32 PredictionId);
	void TryExecuteLogic(int32 LogicId, int32 PredictionId);
	void TryExecuteLogic_FromClient(int32 LogicId);
	void TryStopLogic_FromClient(int32 LogicId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_LogicHandleCom">();
	}
	static class ULogicTree_LogicHandleCom* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_LogicHandleCom>();
	}
};
static_assert(alignof(ULogicTree_LogicHandleCom) == 0x000008, "Wrong alignment on ULogicTree_LogicHandleCom");
static_assert(sizeof(ULogicTree_LogicHandleCom) == 0x0004C8, "Wrong size on ULogicTree_LogicHandleCom");
static_assert(offsetof(ULogicTree_LogicHandleCom, ReplicatedHandles) == 0x0000B0, "Member 'ULogicTree_LogicHandleCom::ReplicatedHandles' has a wrong offset!");
static_assert(offsetof(ULogicTree_LogicHandleCom, Entities) == 0x000408, "Member 'ULogicTree_LogicHandleCom::Entities' has a wrong offset!");

// Class GameLogicTree.LogicTree_CustomContext
// 0x0000 (0x0028 - 0x0028)
class ULogicTree_CustomContext final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_CustomContext">();
	}
	static class ULogicTree_CustomContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_CustomContext>();
	}
};
static_assert(alignof(ULogicTree_CustomContext) == 0x000008, "Wrong alignment on ULogicTree_CustomContext");
static_assert(sizeof(ULogicTree_CustomContext) == 0x000028, "Wrong size on ULogicTree_CustomContext");

// Class GameLogicTree.LogicTree_SpawnAction
// 0x0048 (0x0078 - 0x0030)
class ULogicTree_SpawnAction : public ULogicTree_ActionBase
{
public:
	bool                                          bAttached;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControlByEntity;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0040(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SpawnAction">();
	}
	static class ULogicTree_SpawnAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SpawnAction>();
	}
};
static_assert(alignof(ULogicTree_SpawnAction) == 0x000008, "Wrong alignment on ULogicTree_SpawnAction");
static_assert(sizeof(ULogicTree_SpawnAction) == 0x000078, "Wrong size on ULogicTree_SpawnAction");
static_assert(offsetof(ULogicTree_SpawnAction, bAttached) == 0x000030, "Member 'ULogicTree_SpawnAction::bAttached' has a wrong offset!");
static_assert(offsetof(ULogicTree_SpawnAction, AttachSocket) == 0x000034, "Member 'ULogicTree_SpawnAction::AttachSocket' has a wrong offset!");
static_assert(offsetof(ULogicTree_SpawnAction, ControlByEntity) == 0x00003C, "Member 'ULogicTree_SpawnAction::ControlByEntity' has a wrong offset!");
static_assert(offsetof(ULogicTree_SpawnAction, DataAccessor) == 0x000040, "Member 'ULogicTree_SpawnAction::DataAccessor' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CheckOwnerTag
// 0x0018 (0x0050 - 0x0038)
class ULT_Decorator_CheckOwnerTag final : public ULogicTree_Decorator
{
public:
	struct FGameplayTag                           CheckTag;                                          // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_EntityDataCom*               OwnerDataComCache;                                 // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnTagChange(const struct FGameplayTag& Tag, bool IsContain);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CheckOwnerTag">();
	}
	static class ULT_Decorator_CheckOwnerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CheckOwnerTag>();
	}
};
static_assert(alignof(ULT_Decorator_CheckOwnerTag) == 0x000008, "Wrong alignment on ULT_Decorator_CheckOwnerTag");
static_assert(sizeof(ULT_Decorator_CheckOwnerTag) == 0x000050, "Wrong size on ULT_Decorator_CheckOwnerTag");
static_assert(offsetof(ULT_Decorator_CheckOwnerTag, CheckTag) == 0x000038, "Member 'ULT_Decorator_CheckOwnerTag::CheckTag' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckOwnerTag, OwnerDataComCache) == 0x000048, "Member 'ULT_Decorator_CheckOwnerTag::OwnerDataComCache' has a wrong offset!");

// Class GameLogicTree.GameLogicTree_EntityMgr
// 0x00B0 (0x00E0 - 0x0030)
class UGameLogicTree_EntityMgr final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, int32>                    ActorLookUp;                                       // 0x0038(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class ULogicTree_EntityDataCom*>  DataComLookUp;                                     // 0x0088(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckActorHasTagByStr(class AActor* TargetActor, class FName InTagStr);
	static class UGameLogicTree_EntityMgr* Get(const class UObject* WorldContextObject);
	static float GetLTDataDataAccessorFloatData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode);
	static int32 GetLTDataDataAccessorIntData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode);
	static class UObject* GetLTDataDataAccessorObjData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode);
	static struct FVector GetLTDataDataAccessorVectorData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode);
	static void SetLTDataDataAccessorFloatData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, float InValue);
	static void SetLTDataDataAccessorIntData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, int32 InValue);
	static void SetLTDataDataAccessorObjData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, class UObject* InValue);
	static void SetLTDataDataAccessorVectorData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, const struct FVector& InValue);
	static void Static_AddTagToActor(class AActor* TargetActor, struct FGameplayTag* InTag);
	static void Static_RemoveActorTag(class AActor* TargetActor, struct FGameplayTag* InTag);
	static void Static_SendLogicTreeMsgToActor(class AActor* TargetActor, struct FLogicTree_MsgContext& Msg);

	void AddTagToActor(class AActor* TargetActor, struct FGameplayTag* InTag);
	class UGameLogicTreeEntity* GetLogicByStrPath(const class FString& InPath);
	struct FLogicTree_LogicHandle InstallLogicTreeEntity(class AActor* OwnerActor, int32 InId, TSubclassOf<class ULogicTree_LogicHandleCom> InHandleComClass, bool bReplicate, bool DefaultActive, bool ExecuteImmediately);
	struct FLogicTree_LogicHandle InstallLogicTreeEntityByObjPath(class AActor* OwnerActor, const struct FSoftObjectPath& InPath, bool bReplicate, bool DefaultActive, bool ExecuteImmediately);
	void RemoveActorTag(class AActor* TargetActor, struct FGameplayTag* InTag);
	void SendLogicTreeMsgToActor(class AActor* TargetActor, struct FLogicTree_MsgContext& Msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLogicTree_EntityMgr">();
	}
	static class UGameLogicTree_EntityMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLogicTree_EntityMgr>();
	}
};
static_assert(alignof(UGameLogicTree_EntityMgr) == 0x000008, "Wrong alignment on UGameLogicTree_EntityMgr");
static_assert(sizeof(UGameLogicTree_EntityMgr) == 0x0000E0, "Wrong size on UGameLogicTree_EntityMgr");
static_assert(offsetof(UGameLogicTree_EntityMgr, ActorLookUp) == 0x000038, "Member 'UGameLogicTree_EntityMgr::ActorLookUp' has a wrong offset!");
static_assert(offsetof(UGameLogicTree_EntityMgr, DataComLookUp) == 0x000088, "Member 'UGameLogicTree_EntityMgr::DataComLookUp' has a wrong offset!");

// Class GameLogicTree.GameLogicTreeEntity
// 0x00A8 (0x00D0 - 0x0028)
class UGameLogicTreeEntity final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_BlackBoard*                  Blackboard;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinish;                                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UGameLogic_DataHandler*>         ParallelHandlers;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGameLogic_DataHandler*>         OrderedHandlers;                                   // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_LogicHandleCom*              OwnHandleCom;                                      // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameLogicTree_EntityMgr*               OwnMgr;                                            // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnActor;                                          // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsRunning;                                         // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameLogicTreeRoot*                     MainRoot;                                          // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGameLogicTreeRoot*>             SubRoots;                                          // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ULogicTreeMessageBus*                   MessageBus;                                        // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAuthority;                                      // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStandalone;                                      // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocalControl;                                    // 0x00CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateDataHandlersByTag(const struct FGameplayTag& InTag);
	void DeActivateDataHandlersByTag(const struct FGameplayTag& InTag);
	void FinishLogic();
	void OnLogicEnd();
	void RequestExecute();

	class ULogicTreeMessageBus* GetMessageBus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLogicTreeEntity">();
	}
	static class UGameLogicTreeEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLogicTreeEntity>();
	}
};
static_assert(alignof(UGameLogicTreeEntity) == 0x000008, "Wrong alignment on UGameLogicTreeEntity");
static_assert(sizeof(UGameLogicTreeEntity) == 0x0000D0, "Wrong size on UGameLogicTreeEntity");
static_assert(offsetof(UGameLogicTreeEntity, Blackboard) == 0x000040, "Member 'UGameLogicTreeEntity::Blackboard' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, OnFinish) == 0x000048, "Member 'UGameLogicTreeEntity::OnFinish' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, ParallelHandlers) == 0x000058, "Member 'UGameLogicTreeEntity::ParallelHandlers' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, OrderedHandlers) == 0x000068, "Member 'UGameLogicTreeEntity::OrderedHandlers' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, Owner) == 0x000078, "Member 'UGameLogicTreeEntity::Owner' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, OwnHandleCom) == 0x000080, "Member 'UGameLogicTreeEntity::OwnHandleCom' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, OwnMgr) == 0x000088, "Member 'UGameLogicTreeEntity::OwnMgr' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, OwnActor) == 0x000090, "Member 'UGameLogicTreeEntity::OwnActor' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, IsRunning) == 0x0000A0, "Member 'UGameLogicTreeEntity::IsRunning' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, MainRoot) == 0x0000A8, "Member 'UGameLogicTreeEntity::MainRoot' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, SubRoots) == 0x0000B0, "Member 'UGameLogicTreeEntity::SubRoots' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, MessageBus) == 0x0000C0, "Member 'UGameLogicTreeEntity::MessageBus' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, HasAuthority) == 0x0000C8, "Member 'UGameLogicTreeEntity::HasAuthority' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, IsStandalone) == 0x0000C9, "Member 'UGameLogicTreeEntity::IsStandalone' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeEntity, IsLocalControl) == 0x0000CA, "Member 'UGameLogicTreeEntity::IsLocalControl' has a wrong offset!");

// Class GameLogicTree.GameLogicTreeRoot
// 0x0020 (0x00C0 - 0x00A0)
class UGameLogicTreeRoot final : public ULogicTreeNode
{
public:
	bool                                          RunOnBegin;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TreeName;                                          // 0x00A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_CompositeNode*               RootCompositeNode;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_CompositeNode*               Child;                                             // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameLogicTreeRoot">();
	}
	static class UGameLogicTreeRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameLogicTreeRoot>();
	}
};
static_assert(alignof(UGameLogicTreeRoot) == 0x000008, "Wrong alignment on UGameLogicTreeRoot");
static_assert(sizeof(UGameLogicTreeRoot) == 0x0000C0, "Wrong size on UGameLogicTreeRoot");
static_assert(offsetof(UGameLogicTreeRoot, RunOnBegin) == 0x0000A0, "Member 'UGameLogicTreeRoot::RunOnBegin' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeRoot, TreeName) == 0x0000A4, "Member 'UGameLogicTreeRoot::TreeName' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeRoot, RootCompositeNode) == 0x0000B0, "Member 'UGameLogicTreeRoot::RootCompositeNode' has a wrong offset!");
static_assert(offsetof(UGameLogicTreeRoot, Child) == 0x0000B8, "Member 'UGameLogicTreeRoot::Child' has a wrong offset!");

// Class GameLogicTree.LogicTree_AddBuffAction
// 0x0018 (0x0048 - 0x0030)
class ULogicTree_AddBuffAction final : public ULogicTree_ActionBase
{
public:
	struct FSoftObjectPath                        BuffPath;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_AddBuffAction">();
	}
	static class ULogicTree_AddBuffAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_AddBuffAction>();
	}
};
static_assert(alignof(ULogicTree_AddBuffAction) == 0x000008, "Wrong alignment on ULogicTree_AddBuffAction");
static_assert(sizeof(ULogicTree_AddBuffAction) == 0x000048, "Wrong size on ULogicTree_AddBuffAction");
static_assert(offsetof(ULogicTree_AddBuffAction, BuffPath) == 0x000030, "Member 'ULogicTree_AddBuffAction::BuffPath' has a wrong offset!");

// Class GameLogicTree.LogicTree_BindActionToEvent
// 0x0010 (0x00B0 - 0x00A0)
class ULogicTree_BindActionToEvent final : public ULogicTree_TaskNode
{
public:
	TArray<struct FLogicTreeActionBindData>       ActionDatas;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_BindActionToEvent">();
	}
	static class ULogicTree_BindActionToEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_BindActionToEvent>();
	}
};
static_assert(alignof(ULogicTree_BindActionToEvent) == 0x000008, "Wrong alignment on ULogicTree_BindActionToEvent");
static_assert(sizeof(ULogicTree_BindActionToEvent) == 0x0000B0, "Wrong size on ULogicTree_BindActionToEvent");
static_assert(offsetof(ULogicTree_BindActionToEvent, ActionDatas) == 0x0000A0, "Member 'ULogicTree_BindActionToEvent::ActionDatas' has a wrong offset!");

// Class GameLogicTree.LogicTree_BlackBoard
// 0x00A0 (0x00C8 - 0x0028)
class ULogicTree_BlackBoard final : public UObject
{
public:
	TMap<class FName, struct FLogicTreeBBValue>   ValueMap;                                          // 0x0028(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FLogicTree_BBContext> ContextObjectMap;                                  // 0x0078(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_BlackBoard">();
	}
	static class ULogicTree_BlackBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_BlackBoard>();
	}
};
static_assert(alignof(ULogicTree_BlackBoard) == 0x000008, "Wrong alignment on ULogicTree_BlackBoard");
static_assert(sizeof(ULogicTree_BlackBoard) == 0x0000C8, "Wrong size on ULogicTree_BlackBoard");
static_assert(offsetof(ULogicTree_BlackBoard, ValueMap) == 0x000028, "Member 'ULogicTree_BlackBoard::ValueMap' has a wrong offset!");
static_assert(offsetof(ULogicTree_BlackBoard, ContextObjectMap) == 0x000078, "Member 'ULogicTree_BlackBoard::ContextObjectMap' has a wrong offset!");

// Class GameLogicTree.LogicTree_ChangeAttrAction
// 0x00F0 (0x0120 - 0x0030)
class ULogicTree_ChangeAttrAction final : public ULogicTree_ActionBase
{
public:
	struct FGameLogicTree_AttributeAccessor       Data1;                                             // 0x0030(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameLogicTree_AttributeAccessor       Data2;                                             // 0x0080(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGameLogicTreeAction                          Action;                                            // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                ResDataAccessor;                                   // 0x00D8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESetAttributeType                             SetAttrType;                                       // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetByCacheVal;                                  // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CacheChangeVal;                                    // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidCacheChangeVal;                               // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyExecuteAtAuthority;                            // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCacheValidChangeValToBB;                          // 0x011D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_ChangeAttrAction">();
	}
	static class ULogicTree_ChangeAttrAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_ChangeAttrAction>();
	}
};
static_assert(alignof(ULogicTree_ChangeAttrAction) == 0x000008, "Wrong alignment on ULogicTree_ChangeAttrAction");
static_assert(sizeof(ULogicTree_ChangeAttrAction) == 0x000120, "Wrong size on ULogicTree_ChangeAttrAction");
static_assert(offsetof(ULogicTree_ChangeAttrAction, Data1) == 0x000030, "Member 'ULogicTree_ChangeAttrAction::Data1' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, Data2) == 0x000080, "Member 'ULogicTree_ChangeAttrAction::Data2' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, Action) == 0x0000D0, "Member 'ULogicTree_ChangeAttrAction::Action' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, ResDataAccessor) == 0x0000D8, "Member 'ULogicTree_ChangeAttrAction::ResDataAccessor' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, SetAttrType) == 0x000110, "Member 'ULogicTree_ChangeAttrAction::SetAttrType' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, bResetByCacheVal) == 0x000111, "Member 'ULogicTree_ChangeAttrAction::bResetByCacheVal' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, CacheChangeVal) == 0x000114, "Member 'ULogicTree_ChangeAttrAction::CacheChangeVal' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, ValidCacheChangeVal) == 0x000118, "Member 'ULogicTree_ChangeAttrAction::ValidCacheChangeVal' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, OnlyExecuteAtAuthority) == 0x00011C, "Member 'ULogicTree_ChangeAttrAction::OnlyExecuteAtAuthority' has a wrong offset!");
static_assert(offsetof(ULogicTree_ChangeAttrAction, bCacheValidChangeValToBB) == 0x00011D, "Member 'ULogicTree_ChangeAttrAction::bCacheValidChangeValToBB' has a wrong offset!");

// Class GameLogicTree.LogicTree_ChangeAttributeNode
// 0x0010 (0x00B0 - 0x00A0)
class ULogicTree_ChangeAttributeNode final : public ULogicTree_TaskNode
{
public:
	class ULogicTree_ChangeAttrAction*            Action;                                            // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_ChangeAttributeNode">();
	}
	static class ULogicTree_ChangeAttributeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_ChangeAttributeNode>();
	}
};
static_assert(alignof(ULogicTree_ChangeAttributeNode) == 0x000008, "Wrong alignment on ULogicTree_ChangeAttributeNode");
static_assert(sizeof(ULogicTree_ChangeAttributeNode) == 0x0000B0, "Wrong size on ULogicTree_ChangeAttributeNode");
static_assert(offsetof(ULogicTree_ChangeAttributeNode, Action) == 0x0000A0, "Member 'ULogicTree_ChangeAttributeNode::Action' has a wrong offset!");

// Class GameLogicTree.LogicTree_DoAction
// 0x0010 (0x00B0 - 0x00A0)
class ULogicTree_DoAction final : public ULogicTree_TaskNode
{
public:
	class ULogicTree_ActionBase*                  Action;                                            // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsOneExecute;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_DoAction">();
	}
	static class ULogicTree_DoAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_DoAction>();
	}
};
static_assert(alignof(ULogicTree_DoAction) == 0x000008, "Wrong alignment on ULogicTree_DoAction");
static_assert(sizeof(ULogicTree_DoAction) == 0x0000B0, "Wrong size on ULogicTree_DoAction");
static_assert(offsetof(ULogicTree_DoAction, Action) == 0x0000A0, "Member 'ULogicTree_DoAction::Action' has a wrong offset!");
static_assert(offsetof(ULogicTree_DoAction, IsOneExecute) == 0x0000A8, "Member 'ULogicTree_DoAction::IsOneExecute' has a wrong offset!");

// Class GameLogicTree.LogicTree_DoActionList
// 0x0018 (0x00B8 - 0x00A0)
class ULogicTree_DoActionList final : public ULogicTree_TaskNode
{
public:
	TArray<class ULogicTree_ActionBase*>          Actions;                                           // 0x00A0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          IsOneExecute;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_DoActionList">();
	}
	static class ULogicTree_DoActionList* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_DoActionList>();
	}
};
static_assert(alignof(ULogicTree_DoActionList) == 0x000008, "Wrong alignment on ULogicTree_DoActionList");
static_assert(sizeof(ULogicTree_DoActionList) == 0x0000B8, "Wrong size on ULogicTree_DoActionList");
static_assert(offsetof(ULogicTree_DoActionList, Actions) == 0x0000A0, "Member 'ULogicTree_DoActionList::Actions' has a wrong offset!");
static_assert(offsetof(ULogicTree_DoActionList, IsOneExecute) == 0x0000B0, "Member 'ULogicTree_DoActionList::IsOneExecute' has a wrong offset!");

// Class GameLogicTree.LogicTreeMessageBus
// 0x00F8 (0x0120 - 0x0028)
class ULogicTreeMessageBus final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FLogicTree_MsgContext> CachedMessages;                                    // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, FMulticastInlineDelegateProperty_> DynamicDelegates;                                  // 0x00D0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTreeMessageBus">();
	}
	static class ULogicTreeMessageBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTreeMessageBus>();
	}
};
static_assert(alignof(ULogicTreeMessageBus) == 0x000008, "Wrong alignment on ULogicTreeMessageBus");
static_assert(sizeof(ULogicTreeMessageBus) == 0x000120, "Wrong size on ULogicTreeMessageBus");
static_assert(offsetof(ULogicTreeMessageBus, CachedMessages) == 0x000080, "Member 'ULogicTreeMessageBus::CachedMessages' has a wrong offset!");
static_assert(offsetof(ULogicTreeMessageBus, DynamicDelegates) == 0x0000D0, "Member 'ULogicTreeMessageBus::DynamicDelegates' has a wrong offset!");

// Class GameLogicTree.LogicTree_PlayWwiseAction
// 0x0050 (0x0080 - 0x0030)
class ULogicTree_PlayWwiseAction final : public ULogicTree_ActionBase
{
public:
	class FString                                 WwiseKey;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is2DAudio;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedCacheWwiseCom;                                 // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                WwiseDataAccessor;                                 // 0x0048(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_PlayWwiseAction">();
	}
	static class ULogicTree_PlayWwiseAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_PlayWwiseAction>();
	}
};
static_assert(alignof(ULogicTree_PlayWwiseAction) == 0x000008, "Wrong alignment on ULogicTree_PlayWwiseAction");
static_assert(sizeof(ULogicTree_PlayWwiseAction) == 0x000080, "Wrong size on ULogicTree_PlayWwiseAction");
static_assert(offsetof(ULogicTree_PlayWwiseAction, WwiseKey) == 0x000030, "Member 'ULogicTree_PlayWwiseAction::WwiseKey' has a wrong offset!");
static_assert(offsetof(ULogicTree_PlayWwiseAction, Is2DAudio) == 0x000040, "Member 'ULogicTree_PlayWwiseAction::Is2DAudio' has a wrong offset!");
static_assert(offsetof(ULogicTree_PlayWwiseAction, NeedCacheWwiseCom) == 0x000041, "Member 'ULogicTree_PlayWwiseAction::NeedCacheWwiseCom' has a wrong offset!");
static_assert(offsetof(ULogicTree_PlayWwiseAction, WwiseDataAccessor) == 0x000048, "Member 'ULogicTree_PlayWwiseAction::WwiseDataAccessor' has a wrong offset!");

// Class GameLogicTree.LogicTree_SequenceNode
// 0x0008 (0x00C0 - 0x00B8)
class ULogicTree_SequenceNode final : public ULogicTree_CompositeNode
{
public:
	class ULogicTreeNode*                         JumpTickNode;                                      // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SequenceNode">();
	}
	static class ULogicTree_SequenceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SequenceNode>();
	}
};
static_assert(alignof(ULogicTree_SequenceNode) == 0x000008, "Wrong alignment on ULogicTree_SequenceNode");
static_assert(sizeof(ULogicTree_SequenceNode) == 0x0000C0, "Wrong size on ULogicTree_SequenceNode");
static_assert(offsetof(ULogicTree_SequenceNode, JumpTickNode) == 0x0000B8, "Member 'ULogicTree_SequenceNode::JumpTickNode' has a wrong offset!");

// Class GameLogicTree.LogicTree_SimpleParallel
// 0x0000 (0x00B8 - 0x00B8)
class ULogicTree_SimpleParallel final : public ULogicTree_CompositeNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SimpleParallel">();
	}
	static class ULogicTree_SimpleParallel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SimpleParallel>();
	}
};
static_assert(alignof(ULogicTree_SimpleParallel) == 0x000008, "Wrong alignment on ULogicTree_SimpleParallel");
static_assert(sizeof(ULogicTree_SimpleParallel) == 0x0000B8, "Wrong size on ULogicTree_SimpleParallel");

// Class GameLogicTree.LogicTree_SpawnActorAction
// 0x0008 (0x0080 - 0x0078)
class ULogicTree_SpawnActorAction final : public ULogicTree_SpawnAction
{
public:
	TSubclassOf<class AActor>                     TargetClass;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SpawnActorAction">();
	}
	static class ULogicTree_SpawnActorAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SpawnActorAction>();
	}
};
static_assert(alignof(ULogicTree_SpawnActorAction) == 0x000008, "Wrong alignment on ULogicTree_SpawnActorAction");
static_assert(sizeof(ULogicTree_SpawnActorAction) == 0x000080, "Wrong size on ULogicTree_SpawnActorAction");
static_assert(offsetof(ULogicTree_SpawnActorAction, TargetClass) == 0x000078, "Member 'ULogicTree_SpawnActorAction::TargetClass' has a wrong offset!");

// Class GameLogicTree.LogicTree_StopWwiseAction
// 0x0038 (0x0068 - 0x0030)
class ULogicTree_StopWwiseAction final : public ULogicTree_ActionBase
{
public:
	struct FLogicTree_DataAccessor                WwiseDataAccessor;                                 // 0x0030(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_StopWwiseAction">();
	}
	static class ULogicTree_StopWwiseAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_StopWwiseAction>();
	}
};
static_assert(alignof(ULogicTree_StopWwiseAction) == 0x000008, "Wrong alignment on ULogicTree_StopWwiseAction");
static_assert(sizeof(ULogicTree_StopWwiseAction) == 0x000068, "Wrong size on ULogicTree_StopWwiseAction");
static_assert(offsetof(ULogicTree_StopWwiseAction, WwiseDataAccessor) == 0x000030, "Member 'ULogicTree_StopWwiseAction::WwiseDataAccessor' has a wrong offset!");

// Class GameLogicTree.LogicTree_TaskNode_BP
// 0x0000 (0x00A0 - 0x00A0)
class ULogicTree_TaskNode_BP final : public ULogicTree_TaskNode
{
public:
	ELogicTreeNodeStatus ExecuteBP(class ULogicTree_BlackBoard* TargetBlackBoard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_TaskNode_BP">();
	}
	static class ULogicTree_TaskNode_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_TaskNode_BP>();
	}
};
static_assert(alignof(ULogicTree_TaskNode_BP) == 0x000008, "Wrong alignment on ULogicTree_TaskNode_BP");
static_assert(sizeof(ULogicTree_TaskNode_BP) == 0x0000A0, "Wrong size on ULogicTree_TaskNode_BP");

// Class GameLogicTree.LogicTree_WaitTask
// 0x0048 (0x00E8 - 0x00A0)
class ULogicTree_WaitTask final : public ULogicTree_TaskNode
{
public:
	bool                                          IsUseCustomVal;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_WaitTask">();
	}
	static class ULogicTree_WaitTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_WaitTask>();
	}
};
static_assert(alignof(ULogicTree_WaitTask) == 0x000008, "Wrong alignment on ULogicTree_WaitTask");
static_assert(sizeof(ULogicTree_WaitTask) == 0x0000E8, "Wrong size on ULogicTree_WaitTask");
static_assert(offsetof(ULogicTree_WaitTask, IsUseCustomVal) == 0x0000A0, "Member 'ULogicTree_WaitTask::IsUseCustomVal' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaitTask, WaitTime) == 0x0000A4, "Member 'ULogicTree_WaitTask::WaitTime' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaitTask, DataAccessor) == 0x0000A8, "Member 'ULogicTree_WaitTask::DataAccessor' has a wrong offset!");

// Class GameLogicTree.NodeExecuteHelper
// 0x0000 (0x0028 - 0x0028)
class UNodeExecuteHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeExecuteHelper">();
	}
	static class UNodeExecuteHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNodeExecuteHelper>();
	}
};
static_assert(alignof(UNodeExecuteHelper) == 0x000008, "Wrong alignment on UNodeExecuteHelper");
static_assert(sizeof(UNodeExecuteHelper) == 0x000028, "Wrong size on UNodeExecuteHelper");

// Class GameLogicTree.LT_Decorator_CheckContextArrayContainsObj
// 0x0070 (0x00A8 - 0x0038)
class ULT_Decorator_CheckContextArrayContainsObj final : public ULogicTree_Decorator
{
public:
	struct FLogicTree_DataAccessor                CheckObj;                                          // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                CheckContext;                                      // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CheckContextArrayContainsObj">();
	}
	static class ULT_Decorator_CheckContextArrayContainsObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CheckContextArrayContainsObj>();
	}
};
static_assert(alignof(ULT_Decorator_CheckContextArrayContainsObj) == 0x000008, "Wrong alignment on ULT_Decorator_CheckContextArrayContainsObj");
static_assert(sizeof(ULT_Decorator_CheckContextArrayContainsObj) == 0x0000A8, "Wrong size on ULT_Decorator_CheckContextArrayContainsObj");
static_assert(offsetof(ULT_Decorator_CheckContextArrayContainsObj, CheckObj) == 0x000038, "Member 'ULT_Decorator_CheckContextArrayContainsObj::CheckObj' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextArrayContainsObj, CheckContext) == 0x000070, "Member 'ULT_Decorator_CheckContextArrayContainsObj::CheckContext' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CheckContextObjAngleWithOwner
// 0x0040 (0x0078 - 0x0038)
class ULT_Decorator_CheckContextObjAngleWithOwner final : public ULogicTree_Decorator
{
public:
	float                                         AngleMin;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleMax;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                TargetActor;                                       // 0x0040(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CheckContextObjAngleWithOwner">();
	}
	static class ULT_Decorator_CheckContextObjAngleWithOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CheckContextObjAngleWithOwner>();
	}
};
static_assert(alignof(ULT_Decorator_CheckContextObjAngleWithOwner) == 0x000008, "Wrong alignment on ULT_Decorator_CheckContextObjAngleWithOwner");
static_assert(sizeof(ULT_Decorator_CheckContextObjAngleWithOwner) == 0x000078, "Wrong size on ULT_Decorator_CheckContextObjAngleWithOwner");
static_assert(offsetof(ULT_Decorator_CheckContextObjAngleWithOwner, AngleMin) == 0x000038, "Member 'ULT_Decorator_CheckContextObjAngleWithOwner::AngleMin' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjAngleWithOwner, AngleMax) == 0x00003C, "Member 'ULT_Decorator_CheckContextObjAngleWithOwner::AngleMax' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjAngleWithOwner, TargetActor) == 0x000040, "Member 'ULT_Decorator_CheckContextObjAngleWithOwner::TargetActor' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CheckContextObjDisSqWithOwner
// 0x0078 (0x00B0 - 0x0038)
class ULT_Decorator_CheckContextObjDisSqWithOwner final : public ULogicTree_Decorator
{
public:
	struct FLogicTree_DataAccessor                TargetActor;                                       // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                CheckDisSq;                                        // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELTDecorator_CompareOperation                 CheckOperation;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CheckContextObjDisSqWithOwner">();
	}
	static class ULT_Decorator_CheckContextObjDisSqWithOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CheckContextObjDisSqWithOwner>();
	}
};
static_assert(alignof(ULT_Decorator_CheckContextObjDisSqWithOwner) == 0x000008, "Wrong alignment on ULT_Decorator_CheckContextObjDisSqWithOwner");
static_assert(sizeof(ULT_Decorator_CheckContextObjDisSqWithOwner) == 0x0000B0, "Wrong size on ULT_Decorator_CheckContextObjDisSqWithOwner");
static_assert(offsetof(ULT_Decorator_CheckContextObjDisSqWithOwner, TargetActor) == 0x000038, "Member 'ULT_Decorator_CheckContextObjDisSqWithOwner::TargetActor' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjDisSqWithOwner, CheckDisSq) == 0x000070, "Member 'ULT_Decorator_CheckContextObjDisSqWithOwner::CheckDisSq' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjDisSqWithOwner, CheckOperation) == 0x0000A8, "Member 'ULT_Decorator_CheckContextObjDisSqWithOwner::CheckOperation' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CheckContextObjHeightOffsetWithOwner
// 0x0040 (0x0078 - 0x0038)
class ULT_Decorator_CheckContextObjHeightOffsetWithOwner final : public ULogicTree_Decorator
{
public:
	float                                         HeightOffsetMin;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetMax;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                TargetActor;                                       // 0x0040(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CheckContextObjHeightOffsetWithOwner">();
	}
	static class ULT_Decorator_CheckContextObjHeightOffsetWithOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CheckContextObjHeightOffsetWithOwner>();
	}
};
static_assert(alignof(ULT_Decorator_CheckContextObjHeightOffsetWithOwner) == 0x000008, "Wrong alignment on ULT_Decorator_CheckContextObjHeightOffsetWithOwner");
static_assert(sizeof(ULT_Decorator_CheckContextObjHeightOffsetWithOwner) == 0x000078, "Wrong size on ULT_Decorator_CheckContextObjHeightOffsetWithOwner");
static_assert(offsetof(ULT_Decorator_CheckContextObjHeightOffsetWithOwner, HeightOffsetMin) == 0x000038, "Member 'ULT_Decorator_CheckContextObjHeightOffsetWithOwner::HeightOffsetMin' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjHeightOffsetWithOwner, HeightOffsetMax) == 0x00003C, "Member 'ULT_Decorator_CheckContextObjHeightOffsetWithOwner::HeightOffsetMax' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CheckContextObjHeightOffsetWithOwner, TargetActor) == 0x000040, "Member 'ULT_Decorator_CheckContextObjHeightOffsetWithOwner::TargetActor' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CompareFloatData
// 0x0078 (0x00B0 - 0x0038)
class ULT_Decorator_CompareFloatData final : public ULogicTree_Decorator
{
public:
	struct FLogicTree_DataAccessor                DataA;                                             // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                DataB;                                             // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELTDecorator_CompareOperation                 Operation;                                         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CompareFloatData">();
	}
	static class ULT_Decorator_CompareFloatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CompareFloatData>();
	}
};
static_assert(alignof(ULT_Decorator_CompareFloatData) == 0x000008, "Wrong alignment on ULT_Decorator_CompareFloatData");
static_assert(sizeof(ULT_Decorator_CompareFloatData) == 0x0000B0, "Wrong size on ULT_Decorator_CompareFloatData");
static_assert(offsetof(ULT_Decorator_CompareFloatData, DataA) == 0x000038, "Member 'ULT_Decorator_CompareFloatData::DataA' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CompareFloatData, DataB) == 0x000070, "Member 'ULT_Decorator_CompareFloatData::DataB' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CompareFloatData, Operation) == 0x0000A8, "Member 'ULT_Decorator_CompareFloatData::Operation' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_CompareIntData
// 0x0078 (0x00B0 - 0x0038)
class ULT_Decorator_CompareIntData final : public ULogicTree_Decorator
{
public:
	struct FLogicTree_DataAccessor                DataA;                                             // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                DataB;                                             // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELTDecorator_CompareOperation                 Operation;                                         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_CompareIntData">();
	}
	static class ULT_Decorator_CompareIntData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_CompareIntData>();
	}
};
static_assert(alignof(ULT_Decorator_CompareIntData) == 0x000008, "Wrong alignment on ULT_Decorator_CompareIntData");
static_assert(sizeof(ULT_Decorator_CompareIntData) == 0x0000B0, "Wrong size on ULT_Decorator_CompareIntData");
static_assert(offsetof(ULT_Decorator_CompareIntData, DataA) == 0x000038, "Member 'ULT_Decorator_CompareIntData::DataA' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CompareIntData, DataB) == 0x000070, "Member 'ULT_Decorator_CompareIntData::DataB' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_CompareIntData, Operation) == 0x0000A8, "Member 'ULT_Decorator_CompareIntData::Operation' has a wrong offset!");

// Class GameLogicTree.LT_Decorator_TriggerOnMsg
// 0x0050 (0x0108 - 0x00B8)
class ULT_Decorator_TriggerOnMsg final : public ULogicTree_CompositeNode
{
public:
	struct FGameplayTag                           TriggerMsgTag;                                     // 0x00B8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanFinish;                                         // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanReExecuteRunningChild;                          // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeedChildFinishNum;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CacheContext;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCacheByValue;                                     // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckByData;                                      // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLogicTree_MsgConditionCheck>   CheckDataInt;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeNode*                         CacheChild;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveLogicMsg(const struct FLogicTree_MsgContext& Msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_TriggerOnMsg">();
	}
	static class ULT_Decorator_TriggerOnMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_TriggerOnMsg>();
	}
};
static_assert(alignof(ULT_Decorator_TriggerOnMsg) == 0x000008, "Wrong alignment on ULT_Decorator_TriggerOnMsg");
static_assert(sizeof(ULT_Decorator_TriggerOnMsg) == 0x000108, "Wrong size on ULT_Decorator_TriggerOnMsg");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, TriggerMsgTag) == 0x0000B8, "Member 'ULT_Decorator_TriggerOnMsg::TriggerMsgTag' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, CanFinish) == 0x0000C0, "Member 'ULT_Decorator_TriggerOnMsg::CanFinish' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, CanReExecuteRunningChild) == 0x0000C1, "Member 'ULT_Decorator_TriggerOnMsg::CanReExecuteRunningChild' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, NeedChildFinishNum) == 0x0000C4, "Member 'ULT_Decorator_TriggerOnMsg::NeedChildFinishNum' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, CacheContext) == 0x0000C8, "Member 'ULT_Decorator_TriggerOnMsg::CacheContext' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, bCacheByValue) == 0x0000C9, "Member 'ULT_Decorator_TriggerOnMsg::bCacheByValue' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, bCheckByData) == 0x0000CA, "Member 'ULT_Decorator_TriggerOnMsg::bCheckByData' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, CheckDataInt) == 0x0000D0, "Member 'ULT_Decorator_TriggerOnMsg::CheckDataInt' has a wrong offset!");
static_assert(offsetof(ULT_Decorator_TriggerOnMsg, CacheChild) == 0x0000F0, "Member 'ULT_Decorator_TriggerOnMsg::CacheChild' has a wrong offset!");

// Class GameLogicTree.LT_DecoratorNode_Loop
// 0x0010 (0x00C8 - 0x00B8)
class ULT_DecoratorNode_Loop final : public ULogicTree_CompositeNode
{
public:
	int32                                         LoopNum;                                           // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeNode*                         CacheChild;                                        // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DecoratorNode_Loop">();
	}
	static class ULT_DecoratorNode_Loop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DecoratorNode_Loop>();
	}
};
static_assert(alignof(ULT_DecoratorNode_Loop) == 0x000008, "Wrong alignment on ULT_DecoratorNode_Loop");
static_assert(sizeof(ULT_DecoratorNode_Loop) == 0x0000C8, "Wrong size on ULT_DecoratorNode_Loop");
static_assert(offsetof(ULT_DecoratorNode_Loop, LoopNum) == 0x0000B8, "Member 'ULT_DecoratorNode_Loop::LoopNum' has a wrong offset!");
static_assert(offsetof(ULT_DecoratorNode_Loop, CacheChild) == 0x0000C0, "Member 'ULT_DecoratorNode_Loop::CacheChild' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_AddObjToContextArray
// 0x0070 (0x0110 - 0x00A0)
class ULT_TaskNode_AddObjToContextArray final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                ObjToAdd;                                          // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                TargetArray;                                       // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_AddObjToContextArray">();
	}
	static class ULT_TaskNode_AddObjToContextArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_AddObjToContextArray>();
	}
};
static_assert(alignof(ULT_TaskNode_AddObjToContextArray) == 0x000008, "Wrong alignment on ULT_TaskNode_AddObjToContextArray");
static_assert(sizeof(ULT_TaskNode_AddObjToContextArray) == 0x000110, "Wrong size on ULT_TaskNode_AddObjToContextArray");
static_assert(offsetof(ULT_TaskNode_AddObjToContextArray, ObjToAdd) == 0x0000A0, "Member 'ULT_TaskNode_AddObjToContextArray::ObjToAdd' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_AddObjToContextArray, TargetArray) == 0x0000D8, "Member 'ULT_TaskNode_AddObjToContextArray::TargetArray' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_AddOrRemoveOwnerTag
// 0x0010 (0x00B0 - 0x00A0)
class ULT_TaskNode_AddOrRemoveOwnerTag final : public ULogicTree_TaskNode
{
public:
	bool                                          IsAdd;                                             // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TargetTag;                                         // 0x00A4(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_AddOrRemoveOwnerTag">();
	}
	static class ULT_TaskNode_AddOrRemoveOwnerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_AddOrRemoveOwnerTag>();
	}
};
static_assert(alignof(ULT_TaskNode_AddOrRemoveOwnerTag) == 0x000008, "Wrong alignment on ULT_TaskNode_AddOrRemoveOwnerTag");
static_assert(sizeof(ULT_TaskNode_AddOrRemoveOwnerTag) == 0x0000B0, "Wrong size on ULT_TaskNode_AddOrRemoveOwnerTag");
static_assert(offsetof(ULT_TaskNode_AddOrRemoveOwnerTag, IsAdd) == 0x0000A0, "Member 'ULT_TaskNode_AddOrRemoveOwnerTag::IsAdd' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_AddOrRemoveOwnerTag, TargetTag) == 0x0000A4, "Member 'ULT_TaskNode_AddOrRemoveOwnerTag::TargetTag' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_BindActionToMsg
// 0x0060 (0x0100 - 0x00A0)
class ULT_TaskNode_BindActionToMsg final : public ULogicTree_TaskNode
{
public:
	TArray<struct FLogicTree_BindActionToMsg>     BindMsgs;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_BindActionToMsg">();
	}
	static class ULT_TaskNode_BindActionToMsg* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_BindActionToMsg>();
	}
};
static_assert(alignof(ULT_TaskNode_BindActionToMsg) == 0x000008, "Wrong alignment on ULT_TaskNode_BindActionToMsg");
static_assert(sizeof(ULT_TaskNode_BindActionToMsg) == 0x000100, "Wrong size on ULT_TaskNode_BindActionToMsg");
static_assert(offsetof(ULT_TaskNode_BindActionToMsg, BindMsgs) == 0x0000A0, "Member 'ULT_TaskNode_BindActionToMsg::BindMsgs' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_ChangeBoolData
// 0x0040 (0x00E0 - 0x00A0)
class ULT_TaskNode_ChangeBoolData final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                TargetData;                                        // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          TargetValue;                                       // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_ChangeBoolData">();
	}
	static class ULT_TaskNode_ChangeBoolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_ChangeBoolData>();
	}
};
static_assert(alignof(ULT_TaskNode_ChangeBoolData) == 0x000008, "Wrong alignment on ULT_TaskNode_ChangeBoolData");
static_assert(sizeof(ULT_TaskNode_ChangeBoolData) == 0x0000E0, "Wrong size on ULT_TaskNode_ChangeBoolData");
static_assert(offsetof(ULT_TaskNode_ChangeBoolData, TargetData) == 0x0000A0, "Member 'ULT_TaskNode_ChangeBoolData::TargetData' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_ChangeBoolData, TargetValue) == 0x0000D8, "Member 'ULT_TaskNode_ChangeBoolData::TargetValue' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_ChangeFloatData
// 0x0040 (0x00E0 - 0x00A0)
class ULT_TaskNode_ChangeFloatData final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                TargetData;                                        // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         TargetValue;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_ChangeFloatData">();
	}
	static class ULT_TaskNode_ChangeFloatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_ChangeFloatData>();
	}
};
static_assert(alignof(ULT_TaskNode_ChangeFloatData) == 0x000008, "Wrong alignment on ULT_TaskNode_ChangeFloatData");
static_assert(sizeof(ULT_TaskNode_ChangeFloatData) == 0x0000E0, "Wrong size on ULT_TaskNode_ChangeFloatData");
static_assert(offsetof(ULT_TaskNode_ChangeFloatData, TargetData) == 0x0000A0, "Member 'ULT_TaskNode_ChangeFloatData::TargetData' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_ChangeFloatData, TargetValue) == 0x0000D8, "Member 'ULT_TaskNode_ChangeFloatData::TargetValue' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_AddOwnerFloatData
// 0x0010 (0x00B0 - 0x00A0)
class ULT_TaskNode_AddOwnerFloatData final : public ULogicTree_TaskNode
{
public:
	class FName                                   TargetName;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetValue;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReplicate;                                        // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_AddOwnerFloatData">();
	}
	static class ULT_TaskNode_AddOwnerFloatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_AddOwnerFloatData>();
	}
};
static_assert(alignof(ULT_TaskNode_AddOwnerFloatData) == 0x000008, "Wrong alignment on ULT_TaskNode_AddOwnerFloatData");
static_assert(sizeof(ULT_TaskNode_AddOwnerFloatData) == 0x0000B0, "Wrong size on ULT_TaskNode_AddOwnerFloatData");
static_assert(offsetof(ULT_TaskNode_AddOwnerFloatData, TargetName) == 0x0000A0, "Member 'ULT_TaskNode_AddOwnerFloatData::TargetName' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_AddOwnerFloatData, TargetValue) == 0x0000A8, "Member 'ULT_TaskNode_AddOwnerFloatData::TargetValue' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_AddOwnerFloatData, bReplicate) == 0x0000AC, "Member 'ULT_TaskNode_AddOwnerFloatData::bReplicate' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_ClearContext
// 0x0008 (0x00A8 - 0x00A0)
class ULT_TaskNode_ClearContext final : public ULogicTree_TaskNode
{
public:
	class FName                                   ContextName;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_ClearContext">();
	}
	static class ULT_TaskNode_ClearContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_ClearContext>();
	}
};
static_assert(alignof(ULT_TaskNode_ClearContext) == 0x000008, "Wrong alignment on ULT_TaskNode_ClearContext");
static_assert(sizeof(ULT_TaskNode_ClearContext) == 0x0000A8, "Wrong size on ULT_TaskNode_ClearContext");
static_assert(offsetof(ULT_TaskNode_ClearContext, ContextName) == 0x0000A0, "Member 'ULT_TaskNode_ClearContext::ContextName' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_FinishLogic
// 0x0000 (0x00A0 - 0x00A0)
class ULT_TaskNode_FinishLogic final : public ULogicTree_TaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_FinishLogic">();
	}
	static class ULT_TaskNode_FinishLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_FinishLogic>();
	}
};
static_assert(alignof(ULT_TaskNode_FinishLogic) == 0x000008, "Wrong alignment on ULT_TaskNode_FinishLogic");
static_assert(sizeof(ULT_TaskNode_FinishLogic) == 0x0000A0, "Wrong size on ULT_TaskNode_FinishLogic");

// Class GameLogicTree.LT_TaskNode_OwnerPlayMontage
// 0x0040 (0x00E0 - 0x00A0)
class ULT_TaskNode_OwnerPlayMontage final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                TargetMontage;                                     // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageCache;                                      // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_OwnerPlayMontage">();
	}
	static class ULT_TaskNode_OwnerPlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_OwnerPlayMontage>();
	}
};
static_assert(alignof(ULT_TaskNode_OwnerPlayMontage) == 0x000008, "Wrong alignment on ULT_TaskNode_OwnerPlayMontage");
static_assert(sizeof(ULT_TaskNode_OwnerPlayMontage) == 0x0000E0, "Wrong size on ULT_TaskNode_OwnerPlayMontage");
static_assert(offsetof(ULT_TaskNode_OwnerPlayMontage, TargetMontage) == 0x0000A0, "Member 'ULT_TaskNode_OwnerPlayMontage::TargetMontage' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_OwnerPlayMontage, MontageCache) == 0x0000D8, "Member 'ULT_TaskNode_OwnerPlayMontage::MontageCache' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_RandomInt
// 0x00A8 (0x0148 - 0x00A0)
class ULT_TaskNode_RandomInt final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                RandMin;                                           // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                RandMax;                                           // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                OutRes;                                            // 0x0110(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_RandomInt">();
	}
	static class ULT_TaskNode_RandomInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_RandomInt>();
	}
};
static_assert(alignof(ULT_TaskNode_RandomInt) == 0x000008, "Wrong alignment on ULT_TaskNode_RandomInt");
static_assert(sizeof(ULT_TaskNode_RandomInt) == 0x000148, "Wrong size on ULT_TaskNode_RandomInt");
static_assert(offsetof(ULT_TaskNode_RandomInt, RandMin) == 0x0000A0, "Member 'ULT_TaskNode_RandomInt::RandMin' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_RandomInt, RandMax) == 0x0000D8, "Member 'ULT_TaskNode_RandomInt::RandMax' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_RandomInt, OutRes) == 0x000110, "Member 'ULT_TaskNode_RandomInt::OutRes' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_SendMsgToActor
// 0x0098 (0x0138 - 0x00A0)
class ULT_TaskNode_SendMsgToActor final : public ULogicTree_TaskNode
{
public:
	bool                                          SendToOwner;                                       // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                TargetActor;                                       // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_MsgContext                  TargetMsg;                                         // 0x00E0(0x0058)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_SendMsgToActor">();
	}
	static class ULT_TaskNode_SendMsgToActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_SendMsgToActor>();
	}
};
static_assert(alignof(ULT_TaskNode_SendMsgToActor) == 0x000008, "Wrong alignment on ULT_TaskNode_SendMsgToActor");
static_assert(sizeof(ULT_TaskNode_SendMsgToActor) == 0x000138, "Wrong size on ULT_TaskNode_SendMsgToActor");
static_assert(offsetof(ULT_TaskNode_SendMsgToActor, SendToOwner) == 0x0000A0, "Member 'ULT_TaskNode_SendMsgToActor::SendToOwner' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_SendMsgToActor, TargetActor) == 0x0000A8, "Member 'ULT_TaskNode_SendMsgToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_SendMsgToActor, TargetMsg) == 0x0000E0, "Member 'ULT_TaskNode_SendMsgToActor::TargetMsg' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_SetContextObj
// 0x0070 (0x0110 - 0x00A0)
class ULT_TaskNode_SetContextObj final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                Origin;                                            // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                SetTarget;                                         // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_SetContextObj">();
	}
	static class ULT_TaskNode_SetContextObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_SetContextObj>();
	}
};
static_assert(alignof(ULT_TaskNode_SetContextObj) == 0x000008, "Wrong alignment on ULT_TaskNode_SetContextObj");
static_assert(sizeof(ULT_TaskNode_SetContextObj) == 0x000110, "Wrong size on ULT_TaskNode_SetContextObj");
static_assert(offsetof(ULT_TaskNode_SetContextObj, Origin) == 0x0000A0, "Member 'ULT_TaskNode_SetContextObj::Origin' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_SetContextObj, SetTarget) == 0x0000D8, "Member 'ULT_TaskNode_SetContextObj::SetTarget' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_SwitchDataHandlers
// 0x0010 (0x00B0 - 0x00A0)
class ULT_TaskNode_SwitchDataHandlers final : public ULogicTree_TaskNode
{
public:
	bool                                          StateToSwitch;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TargetTag;                                         // 0x00A4(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_SwitchDataHandlers">();
	}
	static class ULT_TaskNode_SwitchDataHandlers* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_SwitchDataHandlers>();
	}
};
static_assert(alignof(ULT_TaskNode_SwitchDataHandlers) == 0x000008, "Wrong alignment on ULT_TaskNode_SwitchDataHandlers");
static_assert(sizeof(ULT_TaskNode_SwitchDataHandlers) == 0x0000B0, "Wrong size on ULT_TaskNode_SwitchDataHandlers");
static_assert(offsetof(ULT_TaskNode_SwitchDataHandlers, StateToSwitch) == 0x0000A0, "Member 'ULT_TaskNode_SwitchDataHandlers::StateToSwitch' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_SwitchDataHandlers, TargetTag) == 0x0000A4, "Member 'ULT_TaskNode_SwitchDataHandlers::TargetTag' has a wrong offset!");

// Class GameLogicTree.LT_TaskNode_WaitDataComRep
// 0x0018 (0x00B8 - 0x00A0)
class ULT_TaskNode_WaitDataComRep final : public ULogicTree_TaskNode
{
public:
	float                                         CheckInternal;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnActorCache;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_TaskNode_WaitDataComRep">();
	}
	static class ULT_TaskNode_WaitDataComRep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_TaskNode_WaitDataComRep>();
	}
};
static_assert(alignof(ULT_TaskNode_WaitDataComRep) == 0x000008, "Wrong alignment on ULT_TaskNode_WaitDataComRep");
static_assert(sizeof(ULT_TaskNode_WaitDataComRep) == 0x0000B8, "Wrong size on ULT_TaskNode_WaitDataComRep");
static_assert(offsetof(ULT_TaskNode_WaitDataComRep, CheckInternal) == 0x0000A0, "Member 'ULT_TaskNode_WaitDataComRep::CheckInternal' has a wrong offset!");
static_assert(offsetof(ULT_TaskNode_WaitDataComRep, OwnActorCache) == 0x0000A8, "Member 'ULT_TaskNode_WaitDataComRep::OwnActorCache' has a wrong offset!");

// Class GameLogicTree.MyDataHandler
// 0x0000 (0x0060 - 0x0060)
class UMyDataHandler final : public UGameLogic_DataHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyDataHandler">();
	}
	static class UMyDataHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyDataHandler>();
	}
};
static_assert(alignof(UMyDataHandler) == 0x000008, "Wrong alignment on UMyDataHandler");
static_assert(sizeof(UMyDataHandler) == 0x000060, "Wrong size on UMyDataHandler");

// Class GameLogicTree.MyDataHandler2
// 0x0000 (0x0060 - 0x0060)
class UMyDataHandler2 final : public UGameLogic_DataHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyDataHandler2">();
	}
	static class UMyDataHandler2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyDataHandler2>();
	}
};
static_assert(alignof(UMyDataHandler2) == 0x000008, "Wrong alignment on UMyDataHandler2");
static_assert(sizeof(UMyDataHandler2) == 0x000060, "Wrong size on UMyDataHandler2");

// Class GameLogicTree.MyDataHandler3
// 0x0000 (0x0060 - 0x0060)
class UMyDataHandler3 final : public UGameLogic_DataHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyDataHandler3">();
	}
	static class UMyDataHandler3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyDataHandler3>();
	}
};
static_assert(alignof(UMyDataHandler3) == 0x000008, "Wrong alignment on UMyDataHandler3");
static_assert(sizeof(UMyDataHandler3) == 0x000060, "Wrong size on UMyDataHandler3");

// Class GameLogicTree.TestLogicTreeNode
// 0x0008 (0x00A8 - 0x00A0)
class UTestLogicTreeNode final : public ULogicTreeNode
{
public:
	int32                                         TestIntValue;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLogicTreeNode">();
	}
	static class UTestLogicTreeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestLogicTreeNode>();
	}
};
static_assert(alignof(UTestLogicTreeNode) == 0x000008, "Wrong alignment on UTestLogicTreeNode");
static_assert(sizeof(UTestLogicTreeNode) == 0x0000A8, "Wrong size on UTestLogicTreeNode");
static_assert(offsetof(UTestLogicTreeNode, TestIntValue) == 0x0000A0, "Member 'UTestLogicTreeNode::TestIntValue' has a wrong offset!");

}


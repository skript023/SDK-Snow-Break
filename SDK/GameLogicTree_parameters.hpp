#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameLogicTree

#include "Basic.hpp"

#include "GameLogicTree_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function GameLogicTree.LogicTree_Decorator_BP.CheckCondition_BP
// 0x0001 (0x0001 - 0x0000)
struct LogicTree_Decorator_BP_CheckCondition_BP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_Decorator_BP_CheckCondition_BP) == 0x000001, "Wrong alignment on LogicTree_Decorator_BP_CheckCondition_BP");
static_assert(sizeof(LogicTree_Decorator_BP_CheckCondition_BP) == 0x000001, "Wrong size on LogicTree_Decorator_BP_CheckCondition_BP");
static_assert(offsetof(LogicTree_Decorator_BP_CheckCondition_BP, ReturnValue) == 0x000000, "Member 'LogicTree_Decorator_BP_CheckCondition_BP::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.AddData
// 0x0010 (0x0010 - 0x0000)
struct LogicTree_EntityDataCom_AddData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseValue;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicated;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LogicTree_EntityDataCom_AddData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_AddData");
static_assert(sizeof(LogicTree_EntityDataCom_AddData) == 0x000010, "Wrong size on LogicTree_EntityDataCom_AddData");
static_assert(offsetof(LogicTree_EntityDataCom_AddData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_AddData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_AddData, BaseValue) == 0x000008, "Member 'LogicTree_EntityDataCom_AddData::BaseValue' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_AddData, bReplicated) == 0x00000C, "Member 'LogicTree_EntityDataCom_AddData::bReplicated' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.AddTag
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_AddTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_AddTag) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_AddTag");
static_assert(sizeof(LogicTree_EntityDataCom_AddTag) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_AddTag");
static_assert(offsetof(LogicTree_EntityDataCom_AddTag, Tag) == 0x000000, "Member 'LogicTree_EntityDataCom_AddTag::Tag' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_AddTag, Count) == 0x000008, "Member 'LogicTree_EntityDataCom_AddTag::Count' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.GetBaseData
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_GetBaseData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_GetBaseData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_GetBaseData");
static_assert(sizeof(LogicTree_EntityDataCom_GetBaseData) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_GetBaseData");
static_assert(offsetof(LogicTree_EntityDataCom_GetBaseData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_GetBaseData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_GetBaseData, ReturnValue) == 0x000008, "Member 'LogicTree_EntityDataCom_GetBaseData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.GetCurData
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_GetCurData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_GetCurData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_GetCurData");
static_assert(sizeof(LogicTree_EntityDataCom_GetCurData) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_GetCurData");
static_assert(offsetof(LogicTree_EntityDataCom_GetCurData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_GetCurData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_GetCurData, ReturnValue) == 0x000008, "Member 'LogicTree_EntityDataCom_GetCurData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.IsPosInLagAABB
// 0x0010 (0x0010 - 0x0000)
struct LogicTree_EntityDataCom_IsPosInLagAABB final
{
public:
	struct FVector                                InCheckPos;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LogicTree_EntityDataCom_IsPosInLagAABB) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_IsPosInLagAABB");
static_assert(sizeof(LogicTree_EntityDataCom_IsPosInLagAABB) == 0x000010, "Wrong size on LogicTree_EntityDataCom_IsPosInLagAABB");
static_assert(offsetof(LogicTree_EntityDataCom_IsPosInLagAABB, InCheckPos) == 0x000000, "Member 'LogicTree_EntityDataCom_IsPosInLagAABB::InCheckPos' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_IsPosInLagAABB, ReturnValue) == 0x00000C, "Member 'LogicTree_EntityDataCom_IsPosInLagAABB::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.RegisterTagChangeCallback
// 0x0018 (0x0018 - 0x0000)
struct LogicTree_EntityDataCom_RegisterTagChangeCallback final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& Tag, bool IsContain)> Callback;                                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_RegisterTagChangeCallback) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_RegisterTagChangeCallback");
static_assert(sizeof(LogicTree_EntityDataCom_RegisterTagChangeCallback) == 0x000018, "Wrong size on LogicTree_EntityDataCom_RegisterTagChangeCallback");
static_assert(offsetof(LogicTree_EntityDataCom_RegisterTagChangeCallback, Tag) == 0x000000, "Member 'LogicTree_EntityDataCom_RegisterTagChangeCallback::Tag' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_RegisterTagChangeCallback, Callback) == 0x000008, "Member 'LogicTree_EntityDataCom_RegisterTagChangeCallback::Callback' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.RemoveTag
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_RemoveTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_RemoveTag) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_RemoveTag");
static_assert(sizeof(LogicTree_EntityDataCom_RemoveTag) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_RemoveTag");
static_assert(offsetof(LogicTree_EntityDataCom_RemoveTag, Tag) == 0x000000, "Member 'LogicTree_EntityDataCom_RemoveTag::Tag' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_RemoveTag, Count) == 0x000008, "Member 'LogicTree_EntityDataCom_RemoveTag::Count' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.SetBaseData
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_SetBaseData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_SetBaseData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_SetBaseData");
static_assert(sizeof(LogicTree_EntityDataCom_SetBaseData) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_SetBaseData");
static_assert(offsetof(LogicTree_EntityDataCom_SetBaseData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_SetBaseData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_SetBaseData, NewValue) == 0x000008, "Member 'LogicTree_EntityDataCom_SetBaseData::NewValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.SetCurrentData
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_SetCurrentData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_SetCurrentData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_SetCurrentData");
static_assert(sizeof(LogicTree_EntityDataCom_SetCurrentData) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_SetCurrentData");
static_assert(offsetof(LogicTree_EntityDataCom_SetCurrentData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_SetCurrentData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_SetCurrentData, NewValue) == 0x000008, "Member 'LogicTree_EntityDataCom_SetCurrentData::NewValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.UnregisterTagChangeCallback
// 0x0018 (0x0018 - 0x0000)
struct LogicTree_EntityDataCom_UnregisterTagChangeCallback final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                BoundObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_EntityDataCom_UnregisterTagChangeCallback) == 0x000008, "Wrong alignment on LogicTree_EntityDataCom_UnregisterTagChangeCallback");
static_assert(sizeof(LogicTree_EntityDataCom_UnregisterTagChangeCallback) == 0x000018, "Wrong size on LogicTree_EntityDataCom_UnregisterTagChangeCallback");
static_assert(offsetof(LogicTree_EntityDataCom_UnregisterTagChangeCallback, Tag) == 0x000000, "Member 'LogicTree_EntityDataCom_UnregisterTagChangeCallback::Tag' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_UnregisterTagChangeCallback, BoundObject) == 0x000008, "Member 'LogicTree_EntityDataCom_UnregisterTagChangeCallback::BoundObject' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_UnregisterTagChangeCallback, FunctionName) == 0x000010, "Member 'LogicTree_EntityDataCom_UnregisterTagChangeCallback::FunctionName' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.GetData
// 0x0014 (0x0014 - 0x0000)
struct LogicTree_EntityDataCom_GetData final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutBase;                                           // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCurrent;                                        // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LogicTree_EntityDataCom_GetData) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_GetData");
static_assert(sizeof(LogicTree_EntityDataCom_GetData) == 0x000014, "Wrong size on LogicTree_EntityDataCom_GetData");
static_assert(offsetof(LogicTree_EntityDataCom_GetData, Name_0) == 0x000000, "Member 'LogicTree_EntityDataCom_GetData::Name_0' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_GetData, OutBase) == 0x000008, "Member 'LogicTree_EntityDataCom_GetData::OutBase' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_GetData, OutCurrent) == 0x00000C, "Member 'LogicTree_EntityDataCom_GetData::OutCurrent' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_GetData, ReturnValue) == 0x000010, "Member 'LogicTree_EntityDataCom_GetData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_EntityDataCom.HasTag
// 0x000C (0x000C - 0x0000)
struct LogicTree_EntityDataCom_HasTag final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LogicTree_EntityDataCom_HasTag) == 0x000004, "Wrong alignment on LogicTree_EntityDataCom_HasTag");
static_assert(sizeof(LogicTree_EntityDataCom_HasTag) == 0x00000C, "Wrong size on LogicTree_EntityDataCom_HasTag");
static_assert(offsetof(LogicTree_EntityDataCom_HasTag, Tag) == 0x000000, "Member 'LogicTree_EntityDataCom_HasTag::Tag' has a wrong offset!");
static_assert(offsetof(LogicTree_EntityDataCom_HasTag, ReturnValue) == 0x000008, "Member 'LogicTree_EntityDataCom_HasTag::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.Client_NotifyExecuteFail
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_Client_NotifyExecuteFail final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_Client_NotifyExecuteFail) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_Client_NotifyExecuteFail");
static_assert(sizeof(LogicTree_LogicHandleCom_Client_NotifyExecuteFail) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_Client_NotifyExecuteFail");
static_assert(offsetof(LogicTree_LogicHandleCom_Client_NotifyExecuteFail, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_Client_NotifyExecuteFail::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_Client_NotifyExecuteFail, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_Client_NotifyExecuteFail::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.Client_NotifyStopFail
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_Client_NotifyStopFail final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_Client_NotifyStopFail) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_Client_NotifyStopFail");
static_assert(sizeof(LogicTree_LogicHandleCom_Client_NotifyStopFail) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_Client_NotifyStopFail");
static_assert(offsetof(LogicTree_LogicHandleCom_Client_NotifyStopFail, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_Client_NotifyStopFail::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_Client_NotifyStopFail, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_Client_NotifyStopFail::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastExecuteLogic
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_MulticastExecuteLogic final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_MulticastExecuteLogic) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_MulticastExecuteLogic");
static_assert(sizeof(LogicTree_LogicHandleCom_MulticastExecuteLogic) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_MulticastExecuteLogic");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastExecuteLogic, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_MulticastExecuteLogic::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastExecuteLogic, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_MulticastExecuteLogic::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastExecuteNode_FromServer
// 0x0040 (0x0040 - 0x0000)
struct LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeId;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_NodeExecutionData           InData;                                            // 0x0008(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer) == 0x000008, "Wrong alignment on LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer");
static_assert(sizeof(LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer) == 0x000040, "Wrong size on LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer, NodeId) == 0x000004, "Member 'LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer::NodeId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer, InData) == 0x000008, "Member 'LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer::InData' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastStopLogic
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_MulticastStopLogic final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_MulticastStopLogic) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_MulticastStopLogic");
static_assert(sizeof(LogicTree_LogicHandleCom_MulticastStopLogic) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_MulticastStopLogic");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastStopLogic, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_MulticastStopLogic::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_MulticastStopLogic, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_MulticastStopLogic::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.Server_TryStopLogic
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_Server_TryStopLogic final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_Server_TryStopLogic) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_Server_TryStopLogic");
static_assert(sizeof(LogicTree_LogicHandleCom_Server_TryStopLogic) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_Server_TryStopLogic");
static_assert(offsetof(LogicTree_LogicHandleCom_Server_TryStopLogic, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_Server_TryStopLogic::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_Server_TryStopLogic, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_Server_TryStopLogic::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.TryExecuteLogic
// 0x0008 (0x0008 - 0x0000)
struct LogicTree_LogicHandleCom_TryExecuteLogic final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionId;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_TryExecuteLogic) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_TryExecuteLogic");
static_assert(sizeof(LogicTree_LogicHandleCom_TryExecuteLogic) == 0x000008, "Wrong size on LogicTree_LogicHandleCom_TryExecuteLogic");
static_assert(offsetof(LogicTree_LogicHandleCom_TryExecuteLogic, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_TryExecuteLogic::LogicId' has a wrong offset!");
static_assert(offsetof(LogicTree_LogicHandleCom_TryExecuteLogic, PredictionId) == 0x000004, "Member 'LogicTree_LogicHandleCom_TryExecuteLogic::PredictionId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.TryExecuteLogic_FromClient
// 0x0004 (0x0004 - 0x0000)
struct LogicTree_LogicHandleCom_TryExecuteLogic_FromClient final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_TryExecuteLogic_FromClient) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_TryExecuteLogic_FromClient");
static_assert(sizeof(LogicTree_LogicHandleCom_TryExecuteLogic_FromClient) == 0x000004, "Wrong size on LogicTree_LogicHandleCom_TryExecuteLogic_FromClient");
static_assert(offsetof(LogicTree_LogicHandleCom_TryExecuteLogic_FromClient, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_TryExecuteLogic_FromClient::LogicId' has a wrong offset!");

// Function GameLogicTree.LogicTree_LogicHandleCom.TryStopLogic_FromClient
// 0x0004 (0x0004 - 0x0000)
struct LogicTree_LogicHandleCom_TryStopLogic_FromClient final
{
public:
	int32                                         LogicId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LogicTree_LogicHandleCom_TryStopLogic_FromClient) == 0x000004, "Wrong alignment on LogicTree_LogicHandleCom_TryStopLogic_FromClient");
static_assert(sizeof(LogicTree_LogicHandleCom_TryStopLogic_FromClient) == 0x000004, "Wrong size on LogicTree_LogicHandleCom_TryStopLogic_FromClient");
static_assert(offsetof(LogicTree_LogicHandleCom_TryStopLogic_FromClient, LogicId) == 0x000000, "Member 'LogicTree_LogicHandleCom_TryStopLogic_FromClient::LogicId' has a wrong offset!");

// Function GameLogicTree.LT_Decorator_CheckOwnerTag.OnTagChange
// 0x000C (0x000C - 0x0000)
struct LT_Decorator_CheckOwnerTag_OnTagChange final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsContain;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LT_Decorator_CheckOwnerTag_OnTagChange) == 0x000004, "Wrong alignment on LT_Decorator_CheckOwnerTag_OnTagChange");
static_assert(sizeof(LT_Decorator_CheckOwnerTag_OnTagChange) == 0x00000C, "Wrong size on LT_Decorator_CheckOwnerTag_OnTagChange");
static_assert(offsetof(LT_Decorator_CheckOwnerTag_OnTagChange, Tag) == 0x000000, "Member 'LT_Decorator_CheckOwnerTag_OnTagChange::Tag' has a wrong offset!");
static_assert(offsetof(LT_Decorator_CheckOwnerTag_OnTagChange, IsContain) == 0x000008, "Member 'LT_Decorator_CheckOwnerTag_OnTagChange::IsContain' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.CheckActorHasTagByStr
// 0x0018 (0x0018 - 0x0000)
struct GameLogicTree_EntityMgr_CheckActorHasTagByStr final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InTagStr;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_CheckActorHasTagByStr) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_CheckActorHasTagByStr");
static_assert(sizeof(GameLogicTree_EntityMgr_CheckActorHasTagByStr) == 0x000018, "Wrong size on GameLogicTree_EntityMgr_CheckActorHasTagByStr");
static_assert(offsetof(GameLogicTree_EntityMgr_CheckActorHasTagByStr, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_CheckActorHasTagByStr::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_CheckActorHasTagByStr, InTagStr) == 0x000008, "Member 'GameLogicTree_EntityMgr_CheckActorHasTagByStr::InTagStr' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_CheckActorHasTagByStr, ReturnValue) == 0x000010, "Member 'GameLogicTree_EntityMgr_CheckActorHasTagByStr::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.Get
// 0x0010 (0x0010 - 0x0000)
struct GameLogicTree_EntityMgr_Get final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameLogicTree_EntityMgr*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_Get) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_Get");
static_assert(sizeof(GameLogicTree_EntityMgr_Get) == 0x000010, "Wrong size on GameLogicTree_EntityMgr_Get");
static_assert(offsetof(GameLogicTree_EntityMgr_Get, WorldContextObject) == 0x000000, "Member 'GameLogicTree_EntityMgr_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_Get, ReturnValue) == 0x000008, "Member 'GameLogicTree_EntityMgr_Get::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorFloatData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData");
static_assert(sizeof(GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData, ReturnValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorIntData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData");
static_assert(sizeof(GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData, ReturnValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorObjData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData");
static_assert(sizeof(GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData, ReturnValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorVectorData
// 0x0050 (0x0050 - 0x0000)
struct GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0040(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData");
static_assert(sizeof(GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData) == 0x000050, "Wrong size on GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData, ReturnValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorFloatData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData");
static_assert(sizeof(GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData, InValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData::InValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorIntData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData");
static_assert(sizeof(GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData, InValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData::InValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorObjData
// 0x0048 (0x0048 - 0x0000)
struct GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InValue;                                           // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData");
static_assert(sizeof(GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData) == 0x000048, "Wrong size on GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData, InValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData::InValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorVectorData
// 0x0050 (0x0050 - 0x0000)
struct GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData final
{
public:
	struct FLogicTree_DataAccessor                InAccessor;                                        // 0x0000(0x0038)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULogicTreeNode*                         FromNode;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InValue;                                           // 0x0040(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData");
static_assert(sizeof(GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData) == 0x000050, "Wrong size on GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData, InAccessor) == 0x000000, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData::InAccessor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData, FromNode) == 0x000038, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData::FromNode' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData, InValue) == 0x000040, "Member 'GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData::InValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.Static_AddTagToActor
// 0x0010 (0x0010 - 0x0000)
struct GameLogicTree_EntityMgr_Static_AddTagToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InTag;                                             // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_Static_AddTagToActor) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_Static_AddTagToActor");
static_assert(sizeof(GameLogicTree_EntityMgr_Static_AddTagToActor) == 0x000010, "Wrong size on GameLogicTree_EntityMgr_Static_AddTagToActor");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_AddTagToActor, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_Static_AddTagToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_AddTagToActor, InTag) == 0x000008, "Member 'GameLogicTree_EntityMgr_Static_AddTagToActor::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.Static_RemoveActorTag
// 0x0010 (0x0010 - 0x0000)
struct GameLogicTree_EntityMgr_Static_RemoveActorTag final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InTag;                                             // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_Static_RemoveActorTag) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_Static_RemoveActorTag");
static_assert(sizeof(GameLogicTree_EntityMgr_Static_RemoveActorTag) == 0x000010, "Wrong size on GameLogicTree_EntityMgr_Static_RemoveActorTag");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_RemoveActorTag, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_Static_RemoveActorTag::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_RemoveActorTag, InTag) == 0x000008, "Member 'GameLogicTree_EntityMgr_Static_RemoveActorTag::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.Static_SendLogicTreeMsgToActor
// 0x0060 (0x0060 - 0x0000)
struct GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_MsgContext                  Msg;                                               // 0x0008(0x0058)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor");
static_assert(sizeof(GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor) == 0x000060, "Wrong size on GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor, Msg) == 0x000008, "Member 'GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor::Msg' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.AddTagToActor
// 0x0010 (0x0010 - 0x0000)
struct GameLogicTree_EntityMgr_AddTagToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InTag;                                             // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_AddTagToActor) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_AddTagToActor");
static_assert(sizeof(GameLogicTree_EntityMgr_AddTagToActor) == 0x000010, "Wrong size on GameLogicTree_EntityMgr_AddTagToActor");
static_assert(offsetof(GameLogicTree_EntityMgr_AddTagToActor, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_AddTagToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_AddTagToActor, InTag) == 0x000008, "Member 'GameLogicTree_EntityMgr_AddTagToActor::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.GetLogicByStrPath
// 0x0018 (0x0018 - 0x0000)
struct GameLogicTree_EntityMgr_GetLogicByStrPath final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameLogicTreeEntity*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_GetLogicByStrPath) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_GetLogicByStrPath");
static_assert(sizeof(GameLogicTree_EntityMgr_GetLogicByStrPath) == 0x000018, "Wrong size on GameLogicTree_EntityMgr_GetLogicByStrPath");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLogicByStrPath, InPath) == 0x000000, "Member 'GameLogicTree_EntityMgr_GetLogicByStrPath::InPath' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_GetLogicByStrPath, ReturnValue) == 0x000010, "Member 'GameLogicTree_EntityMgr_GetLogicByStrPath::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.InstallLogicTreeEntity
// 0x0028 (0x0028 - 0x0000)
struct GameLogicTree_EntityMgr_InstallLogicTreeEntity final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InId;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULogicTree_LogicHandleCom>  InHandleComClass;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicate;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultActive;                                     // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExecuteImmediately;                                // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_LogicHandle                 ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_InstallLogicTreeEntity) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_InstallLogicTreeEntity");
static_assert(sizeof(GameLogicTree_EntityMgr_InstallLogicTreeEntity) == 0x000028, "Wrong size on GameLogicTree_EntityMgr_InstallLogicTreeEntity");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, OwnerActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::OwnerActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, InId) == 0x000008, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::InId' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, InHandleComClass) == 0x000010, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::InHandleComClass' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, bReplicate) == 0x000018, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::bReplicate' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, DefaultActive) == 0x000019, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::DefaultActive' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, ExecuteImmediately) == 0x00001A, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::ExecuteImmediately' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntity, ReturnValue) == 0x00001C, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntity::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.InstallLogicTreeEntityByObjPath
// 0x0030 (0x0030 - 0x0000)
struct GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        InPath;                                            // 0x0008(0x0018)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicate;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultActive;                                     // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExecuteImmediately;                                // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_LogicHandle                 ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath");
static_assert(sizeof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath) == 0x000030, "Wrong size on GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, OwnerActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::OwnerActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, InPath) == 0x000008, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::InPath' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, bReplicate) == 0x000020, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::bReplicate' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, DefaultActive) == 0x000021, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::DefaultActive' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, ExecuteImmediately) == 0x000022, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::ExecuteImmediately' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath, ReturnValue) == 0x000024, "Member 'GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath::ReturnValue' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.RemoveActorTag
// 0x0010 (0x0010 - 0x0000)
struct GameLogicTree_EntityMgr_RemoveActorTag final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InTag;                                             // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_RemoveActorTag) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_RemoveActorTag");
static_assert(sizeof(GameLogicTree_EntityMgr_RemoveActorTag) == 0x000010, "Wrong size on GameLogicTree_EntityMgr_RemoveActorTag");
static_assert(offsetof(GameLogicTree_EntityMgr_RemoveActorTag, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_RemoveActorTag::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_RemoveActorTag, InTag) == 0x000008, "Member 'GameLogicTree_EntityMgr_RemoveActorTag::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTree_EntityMgr.SendLogicTreeMsgToActor
// 0x0060 (0x0060 - 0x0000)
struct GameLogicTree_EntityMgr_SendLogicTreeMsgToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_MsgContext                  Msg;                                               // 0x0008(0x0058)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTree_EntityMgr_SendLogicTreeMsgToActor) == 0x000008, "Wrong alignment on GameLogicTree_EntityMgr_SendLogicTreeMsgToActor");
static_assert(sizeof(GameLogicTree_EntityMgr_SendLogicTreeMsgToActor) == 0x000060, "Wrong size on GameLogicTree_EntityMgr_SendLogicTreeMsgToActor");
static_assert(offsetof(GameLogicTree_EntityMgr_SendLogicTreeMsgToActor, TargetActor) == 0x000000, "Member 'GameLogicTree_EntityMgr_SendLogicTreeMsgToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GameLogicTree_EntityMgr_SendLogicTreeMsgToActor, Msg) == 0x000008, "Member 'GameLogicTree_EntityMgr_SendLogicTreeMsgToActor::Msg' has a wrong offset!");

// Function GameLogicTree.GameLogicTreeEntity.ActivateDataHandlersByTag
// 0x0008 (0x0008 - 0x0000)
struct GameLogicTreeEntity_ActivateDataHandlersByTag final
{
public:
	struct FGameplayTag                           InTag;                                             // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTreeEntity_ActivateDataHandlersByTag) == 0x000004, "Wrong alignment on GameLogicTreeEntity_ActivateDataHandlersByTag");
static_assert(sizeof(GameLogicTreeEntity_ActivateDataHandlersByTag) == 0x000008, "Wrong size on GameLogicTreeEntity_ActivateDataHandlersByTag");
static_assert(offsetof(GameLogicTreeEntity_ActivateDataHandlersByTag, InTag) == 0x000000, "Member 'GameLogicTreeEntity_ActivateDataHandlersByTag::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTreeEntity.DeActivateDataHandlersByTag
// 0x0008 (0x0008 - 0x0000)
struct GameLogicTreeEntity_DeActivateDataHandlersByTag final
{
public:
	struct FGameplayTag                           InTag;                                             // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTreeEntity_DeActivateDataHandlersByTag) == 0x000004, "Wrong alignment on GameLogicTreeEntity_DeActivateDataHandlersByTag");
static_assert(sizeof(GameLogicTreeEntity_DeActivateDataHandlersByTag) == 0x000008, "Wrong size on GameLogicTreeEntity_DeActivateDataHandlersByTag");
static_assert(offsetof(GameLogicTreeEntity_DeActivateDataHandlersByTag, InTag) == 0x000000, "Member 'GameLogicTreeEntity_DeActivateDataHandlersByTag::InTag' has a wrong offset!");

// Function GameLogicTree.GameLogicTreeEntity.GetMessageBus
// 0x0008 (0x0008 - 0x0000)
struct GameLogicTreeEntity_GetMessageBus final
{
public:
	class ULogicTreeMessageBus*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameLogicTreeEntity_GetMessageBus) == 0x000008, "Wrong alignment on GameLogicTreeEntity_GetMessageBus");
static_assert(sizeof(GameLogicTreeEntity_GetMessageBus) == 0x000008, "Wrong size on GameLogicTreeEntity_GetMessageBus");
static_assert(offsetof(GameLogicTreeEntity_GetMessageBus, ReturnValue) == 0x000000, "Member 'GameLogicTreeEntity_GetMessageBus::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LogicTree_TaskNode_BP.ExecuteBP
// 0x0010 (0x0010 - 0x0000)
struct LogicTree_TaskNode_BP_ExecuteBP final
{
public:
	class ULogicTree_BlackBoard*                  TargetBlackBoard;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELogicTreeNodeStatus                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LogicTree_TaskNode_BP_ExecuteBP) == 0x000008, "Wrong alignment on LogicTree_TaskNode_BP_ExecuteBP");
static_assert(sizeof(LogicTree_TaskNode_BP_ExecuteBP) == 0x000010, "Wrong size on LogicTree_TaskNode_BP_ExecuteBP");
static_assert(offsetof(LogicTree_TaskNode_BP_ExecuteBP, TargetBlackBoard) == 0x000000, "Member 'LogicTree_TaskNode_BP_ExecuteBP::TargetBlackBoard' has a wrong offset!");
static_assert(offsetof(LogicTree_TaskNode_BP_ExecuteBP, ReturnValue) == 0x000008, "Member 'LogicTree_TaskNode_BP_ExecuteBP::ReturnValue' has a wrong offset!");

// Function GameLogicTree.LT_Decorator_TriggerOnMsg.OnReceiveLogicMsg
// 0x0058 (0x0058 - 0x0000)
struct LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg final
{
public:
	struct FLogicTree_MsgContext                  Msg;                                               // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg) == 0x000008, "Wrong alignment on LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg");
static_assert(sizeof(LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg) == 0x000058, "Wrong size on LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg");
static_assert(offsetof(LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg, Msg) == 0x000000, "Member 'LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg::Msg' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterInteractionV3

#include "Basic.hpp"

#include "DeveloperSettings_classes.hpp"
#include "CharacterInteractionV3_structs.hpp"
#include "SeasunAnimGraph_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "CameraBlueprint_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsControl_classes.hpp"


namespace SDK
{

// Class CharacterInteractionV3.ActorOperateAct
// 0x0118 (0x0140 - 0x0028)
class UActorOperateAct : public UObject
{
public:
	struct FInteractionVoiceConfig                VoiceConfig;                                       // 0x0028(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInteractionV3OperateWwise             OperateWwiseData;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 ActorOperateActName;                               // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FacialAnim;                                        // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BlendInAndOut;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FacialAnimMontage;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlush;                                          // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceEyeLookAtCamera;                             // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EyesLookAtPosition;                                // 0x00CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInteractionV3PhysProfileModifier      ProfileModifier;                                   // 0x00D4(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPhysicsBlendOut;                                  // 0x0134(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllPerformerPhysicsBlendOut;                      // 0x0135(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideKawaiiBlendOut;                           // 0x0136(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_137[0x1];                                      // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            OverrideDisableKawaiiBlendCurve;                   // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPause(class AInteractionSkeletalActorV3* Actor);
	void OnRestart(class AInteractionSkeletalActorV3* Actor);
	void OnResume(class AInteractionSkeletalActorV3* Actor);
	void OnStart(class AInteractionSkeletalActorV3* Actor);
	void OnStartBlendOut(class AInteractionSkeletalActorV3* Actor);
	void OnStop(class AInteractionSkeletalActorV3* Actor);
	void OnUpdate(class UInteractionV3InputControl* InputControl, class AInteractionSkeletalActorV3* Actor, float DeltaSeconds);
	void ProcessStartAct(class AInteractionSkeletalActorV3* Actor);

	class UInteractionV3InputControl* GetInputControl() const;
	class UScenarioOperate* GetScenarioOperate() const;
	bool IsCompleteAndBlendOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorOperateAct">();
	}
	static class UActorOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorOperateAct>();
	}
};
static_assert(alignof(UActorOperateAct) == 0x000008, "Wrong alignment on UActorOperateAct");
static_assert(sizeof(UActorOperateAct) == 0x000140, "Wrong size on UActorOperateAct");
static_assert(offsetof(UActorOperateAct, VoiceConfig) == 0x000028, "Member 'UActorOperateAct::VoiceConfig' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, OperateWwiseData) == 0x000070, "Member 'UActorOperateAct::OperateWwiseData' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, ActorOperateActName) == 0x000080, "Member 'UActorOperateAct::ActorOperateActName' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, FacialAnim) == 0x000090, "Member 'UActorOperateAct::FacialAnim' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, BlendInAndOut) == 0x0000B8, "Member 'UActorOperateAct::BlendInAndOut' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, FacialAnimMontage) == 0x0000C0, "Member 'UActorOperateAct::FacialAnimMontage' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, bIsBlush) == 0x0000C8, "Member 'UActorOperateAct::bIsBlush' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, bForceEyeLookAtCamera) == 0x0000C9, "Member 'UActorOperateAct::bForceEyeLookAtCamera' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, EyesLookAtPosition) == 0x0000CC, "Member 'UActorOperateAct::EyesLookAtPosition' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, ProfileModifier) == 0x0000D4, "Member 'UActorOperateAct::ProfileModifier' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, bPhysicsBlendOut) == 0x000134, "Member 'UActorOperateAct::bPhysicsBlendOut' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, bAllPerformerPhysicsBlendOut) == 0x000135, "Member 'UActorOperateAct::bAllPerformerPhysicsBlendOut' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, bOverrideKawaiiBlendOut) == 0x000136, "Member 'UActorOperateAct::bOverrideKawaiiBlendOut' has a wrong offset!");
static_assert(offsetof(UActorOperateAct, OverrideDisableKawaiiBlendCurve) == 0x000138, "Member 'UActorOperateAct::OverrideDisableKawaiiBlendCurve' has a wrong offset!");

// Class CharacterInteractionV3.BlendSpaceOperateAct
// 0x0030 (0x0170 - 0x0140)
class UBlendSpaceOperateAct final : public UActorOperateAct
{
public:
	TSoftObjectPtr<class UBlendSpace>             BlendSpace;                                        // 0x0140(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionV3BlendSpaceSlot                  SlotType;                                          // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendSpaceOperateAct">();
	}
	static class UBlendSpaceOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendSpaceOperateAct>();
	}
};
static_assert(alignof(UBlendSpaceOperateAct) == 0x000008, "Wrong alignment on UBlendSpaceOperateAct");
static_assert(sizeof(UBlendSpaceOperateAct) == 0x000170, "Wrong size on UBlendSpaceOperateAct");
static_assert(offsetof(UBlendSpaceOperateAct, BlendSpace) == 0x000140, "Member 'UBlendSpaceOperateAct::BlendSpace' has a wrong offset!");
static_assert(offsetof(UBlendSpaceOperateAct, SlotType) == 0x000168, "Member 'UBlendSpaceOperateAct::SlotType' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3FaceAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class UInteractionV3FaceAnimInstance final : public UAnimInstance
{
public:
	struct FVector2D                              MouseFollowEyeOffset;                              // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleAnim;                                          // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            EyeBlend;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LastFrameMontage;                                  // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ConfessionMontage;                                 // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBlendSpace* GetEyeBlend();
	void PlayConfessionAnim(class UAnimSequence* InConfessionAnim, float InBlendInTime, float InBlendOutTime);
	void PlayLastFrameAnim(class UAnimSequence* InLastFrameAnim);
	void SetEyeBlend(class UBlendSpace* NewBlend);
	void SetFaceIdleAnim(class UAnimSequence* InAnimSequence);
	void SetMouseFollowEyeOffset(const struct FVector2D& InMouseFollowEyeOffset);
	void StopConfessionAnim();
	void StopLastFrameAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3FaceAnimInstance">();
	}
	static class UInteractionV3FaceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3FaceAnimInstance>();
	}
};
static_assert(alignof(UInteractionV3FaceAnimInstance) == 0x000010, "Wrong alignment on UInteractionV3FaceAnimInstance");
static_assert(sizeof(UInteractionV3FaceAnimInstance) == 0x0002E0, "Wrong size on UInteractionV3FaceAnimInstance");
static_assert(offsetof(UInteractionV3FaceAnimInstance, MouseFollowEyeOffset) == 0x0002B8, "Member 'UInteractionV3FaceAnimInstance::MouseFollowEyeOffset' has a wrong offset!");
static_assert(offsetof(UInteractionV3FaceAnimInstance, IdleAnim) == 0x0002C0, "Member 'UInteractionV3FaceAnimInstance::IdleAnim' has a wrong offset!");
static_assert(offsetof(UInteractionV3FaceAnimInstance, EyeBlend) == 0x0002C8, "Member 'UInteractionV3FaceAnimInstance::EyeBlend' has a wrong offset!");
static_assert(offsetof(UInteractionV3FaceAnimInstance, LastFrameMontage) == 0x0002D0, "Member 'UInteractionV3FaceAnimInstance::LastFrameMontage' has a wrong offset!");
static_assert(offsetof(UInteractionV3FaceAnimInstance, ConfessionMontage) == 0x0002D8, "Member 'UInteractionV3FaceAnimInstance::ConfessionMontage' has a wrong offset!");

// Class CharacterInteractionV3.SequenceEvaluatorOperateAct
// 0x0078 (0x01B8 - 0x0140)
class USequenceEvaluatorOperateAct final : public UActorOperateAct
{
public:
	TSoftObjectPtr<class UAnimSequence>           InteractionAnim;                                   // 0x0140(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           BreathAdditiveAnim;                                // 0x0168(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControlFacialAnim;                                // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           InteractionMontage;                                // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           BreathAdditiveMontage;                             // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimNotifyEvent>               ActiveFacialAnimNotifyState;                       // 0x01A8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceEvaluatorOperateAct">();
	}
	static class USequenceEvaluatorOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequenceEvaluatorOperateAct>();
	}
};
static_assert(alignof(USequenceEvaluatorOperateAct) == 0x000008, "Wrong alignment on USequenceEvaluatorOperateAct");
static_assert(sizeof(USequenceEvaluatorOperateAct) == 0x0001B8, "Wrong size on USequenceEvaluatorOperateAct");
static_assert(offsetof(USequenceEvaluatorOperateAct, InteractionAnim) == 0x000140, "Member 'USequenceEvaluatorOperateAct::InteractionAnim' has a wrong offset!");
static_assert(offsetof(USequenceEvaluatorOperateAct, BreathAdditiveAnim) == 0x000168, "Member 'USequenceEvaluatorOperateAct::BreathAdditiveAnim' has a wrong offset!");
static_assert(offsetof(USequenceEvaluatorOperateAct, bControlFacialAnim) == 0x000190, "Member 'USequenceEvaluatorOperateAct::bControlFacialAnim' has a wrong offset!");
static_assert(offsetof(USequenceEvaluatorOperateAct, InteractionMontage) == 0x000198, "Member 'USequenceEvaluatorOperateAct::InteractionMontage' has a wrong offset!");
static_assert(offsetof(USequenceEvaluatorOperateAct, BreathAdditiveMontage) == 0x0001A0, "Member 'USequenceEvaluatorOperateAct::BreathAdditiveMontage' has a wrong offset!");
static_assert(offsetof(USequenceEvaluatorOperateAct, ActiveFacialAnimNotifyState) == 0x0001A8, "Member 'USequenceEvaluatorOperateAct::ActiveFacialAnimNotifyState' has a wrong offset!");

// Class CharacterInteractionV3.LoopSequenceOperateAct
// 0x0038 (0x0178 - 0x0140)
class ULoopSequenceOperateAct final : public UActorOperateAct
{
public:
	TSoftObjectPtr<class UAnimSequence>           InteractionAnim;                                   // 0x0140(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLoopTime;                                     // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndLoopTime;                                       // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractionMontage;                                // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoopSequenceOperateAct">();
	}
	static class ULoopSequenceOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoopSequenceOperateAct>();
	}
};
static_assert(alignof(ULoopSequenceOperateAct) == 0x000008, "Wrong alignment on ULoopSequenceOperateAct");
static_assert(sizeof(ULoopSequenceOperateAct) == 0x000178, "Wrong size on ULoopSequenceOperateAct");
static_assert(offsetof(ULoopSequenceOperateAct, InteractionAnim) == 0x000140, "Member 'ULoopSequenceOperateAct::InteractionAnim' has a wrong offset!");
static_assert(offsetof(ULoopSequenceOperateAct, StartLoopTime) == 0x000168, "Member 'ULoopSequenceOperateAct::StartLoopTime' has a wrong offset!");
static_assert(offsetof(ULoopSequenceOperateAct, EndLoopTime) == 0x00016C, "Member 'ULoopSequenceOperateAct::EndLoopTime' has a wrong offset!");
static_assert(offsetof(ULoopSequenceOperateAct, InteractionMontage) == 0x000170, "Member 'ULoopSequenceOperateAct::InteractionMontage' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3Event
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3Event : public UObject
{
public:
	void DoAction();

	bool CanTrigger() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Event">();
	}
	static class UInteractionV3Event* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Event>();
	}
};
static_assert(alignof(UInteractionV3Event) == 0x000008, "Wrong alignment on UInteractionV3Event");
static_assert(sizeof(UInteractionV3Event) == 0x000028, "Wrong size on UInteractionV3Event");

// Class CharacterInteractionV3.OperateStandardCompelteEvent
// 0x0028 (0x0050 - 0x0028)
class UOperateStandardCompelteEvent final : public UInteractionV3Event
{
public:
	bool                                          bForceCameraBlend;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShowElementName;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndState;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OperateStandardCompelteEvent">();
	}
	static class UOperateStandardCompelteEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOperateStandardCompelteEvent>();
	}
};
static_assert(alignof(UOperateStandardCompelteEvent) == 0x000008, "Wrong alignment on UOperateStandardCompelteEvent");
static_assert(sizeof(UOperateStandardCompelteEvent) == 0x000050, "Wrong size on UOperateStandardCompelteEvent");
static_assert(offsetof(UOperateStandardCompelteEvent, bForceCameraBlend) == 0x000028, "Member 'UOperateStandardCompelteEvent::bForceCameraBlend' has a wrong offset!");
static_assert(offsetof(UOperateStandardCompelteEvent, ShowElementName) == 0x000030, "Member 'UOperateStandardCompelteEvent::ShowElementName' has a wrong offset!");
static_assert(offsetof(UOperateStandardCompelteEvent, EndState) == 0x000040, "Member 'UOperateStandardCompelteEvent::EndState' has a wrong offset!");

// Class CharacterInteractionV3.IKRefPoseFixOperateAct
// 0x0020 (0x0160 - 0x0140)
class UIKRefPoseFixOperateAct : public UActorOperateAct
{
public:
	struct FIKRefPoseFixData                      RefPoseFixData;                                    // 0x0140(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRefPoseFixOperateAct">();
	}
	static class UIKRefPoseFixOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRefPoseFixOperateAct>();
	}
};
static_assert(alignof(UIKRefPoseFixOperateAct) == 0x000008, "Wrong alignment on UIKRefPoseFixOperateAct");
static_assert(sizeof(UIKRefPoseFixOperateAct) == 0x000160, "Wrong size on UIKRefPoseFixOperateAct");
static_assert(offsetof(UIKRefPoseFixOperateAct, RefPoseFixData) == 0x000140, "Member 'UIKRefPoseFixOperateAct::RefPoseFixData' has a wrong offset!");

// Class CharacterInteractionV3.HeadModifyOperateAct
// 0x0058 (0x01B8 - 0x0160)
class UHeadModifyOperateAct final : public UIKRefPoseFixOperateAct
{
public:
	bool                                          UseYawChange;                                      // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeSpineWeight                    RuntimeSpineDatas;                                 // 0x0168(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadModifyOperateAct">();
	}
	static class UHeadModifyOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadModifyOperateAct>();
	}
};
static_assert(alignof(UHeadModifyOperateAct) == 0x000008, "Wrong alignment on UHeadModifyOperateAct");
static_assert(sizeof(UHeadModifyOperateAct) == 0x0001B8, "Wrong size on UHeadModifyOperateAct");
static_assert(offsetof(UHeadModifyOperateAct, UseYawChange) == 0x000160, "Member 'UHeadModifyOperateAct::UseYawChange' has a wrong offset!");
static_assert(offsetof(UHeadModifyOperateAct, RuntimeSpineDatas) == 0x000168, "Member 'UHeadModifyOperateAct::RuntimeSpineDatas' has a wrong offset!");

// Class CharacterInteractionV3.IKMaintainWorldSpaceRelativeOperateAct
// 0x0010 (0x0170 - 0x0160)
class UIKMaintainWorldSpaceRelativeOperateAct final : public UIKRefPoseFixOperateAct
{
public:
	struct FIKMaintainWorldSpaceRelativeData      MaintainRelativeData;                              // 0x0160(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKMaintainWorldSpaceRelativeOperateAct">();
	}
	static class UIKMaintainWorldSpaceRelativeOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKMaintainWorldSpaceRelativeOperateAct>();
	}
};
static_assert(alignof(UIKMaintainWorldSpaceRelativeOperateAct) == 0x000008, "Wrong alignment on UIKMaintainWorldSpaceRelativeOperateAct");
static_assert(sizeof(UIKMaintainWorldSpaceRelativeOperateAct) == 0x000170, "Wrong size on UIKMaintainWorldSpaceRelativeOperateAct");
static_assert(offsetof(UIKMaintainWorldSpaceRelativeOperateAct, MaintainRelativeData) == 0x000160, "Member 'UIKMaintainWorldSpaceRelativeOperateAct::MaintainRelativeData' has a wrong offset!");

// Class CharacterInteractionV3.IKWorldSpaceOffsetOperateAct
// 0x0020 (0x0180 - 0x0160)
class UIKWorldSpaceOffsetOperateAct final : public UIKRefPoseFixOperateAct
{
public:
	struct FIKWorldSpaceOffsetData                WorldSpaceOffsetData;                              // 0x0160(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKWorldSpaceOffsetOperateAct">();
	}
	static class UIKWorldSpaceOffsetOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKWorldSpaceOffsetOperateAct>();
	}
};
static_assert(alignof(UIKWorldSpaceOffsetOperateAct) == 0x000008, "Wrong alignment on UIKWorldSpaceOffsetOperateAct");
static_assert(sizeof(UIKWorldSpaceOffsetOperateAct) == 0x000180, "Wrong size on UIKWorldSpaceOffsetOperateAct");
static_assert(offsetof(UIKWorldSpaceOffsetOperateAct, WorldSpaceOffsetData) == 0x000160, "Member 'UIKWorldSpaceOffsetOperateAct::WorldSpaceOffsetData' has a wrong offset!");

// Class CharacterInteractionV3.CreateMaintainWorldSpaceRelativeControlEvent
// 0x0038 (0x0060 - 0x0028)
class UCreateMaintainWorldSpaceRelativeControlEvent final : public UInteractionV3Event
{
public:
	class FName                                   ControlName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetName;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentActorName;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentBoneName;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildActorName;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildBoneName;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChildAnimNode;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateMaintainWorldSpaceRelativeControlEvent">();
	}
	static class UCreateMaintainWorldSpaceRelativeControlEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateMaintainWorldSpaceRelativeControlEvent>();
	}
};
static_assert(alignof(UCreateMaintainWorldSpaceRelativeControlEvent) == 0x000008, "Wrong alignment on UCreateMaintainWorldSpaceRelativeControlEvent");
static_assert(sizeof(UCreateMaintainWorldSpaceRelativeControlEvent) == 0x000060, "Wrong size on UCreateMaintainWorldSpaceRelativeControlEvent");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, ControlName) == 0x000028, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::ControlName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, SetName) == 0x000030, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::SetName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, ParentActorName) == 0x000038, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::ParentActorName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, ParentBoneName) == 0x000040, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::ParentBoneName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, ChildActorName) == 0x000048, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::ChildActorName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, ChildBoneName) == 0x000050, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::ChildBoneName' has a wrong offset!");
static_assert(offsetof(UCreateMaintainWorldSpaceRelativeControlEvent, bIsChildAnimNode) == 0x000058, "Member 'UCreateMaintainWorldSpaceRelativeControlEvent::bIsChildAnimNode' has a wrong offset!");

// Class CharacterInteractionV3.EyesFollowOperateAct
// 0x0010 (0x0150 - 0x0140)
class UEyesFollowOperateAct final : public UActorOperateAct
{
public:
	struct FVector2D                              HeadRotationScale;                                 // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterpHead;                                       // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadInterpSpeed;                                   // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EyesFollowOperateAct">();
	}
	static class UEyesFollowOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEyesFollowOperateAct>();
	}
};
static_assert(alignof(UEyesFollowOperateAct) == 0x000008, "Wrong alignment on UEyesFollowOperateAct");
static_assert(sizeof(UEyesFollowOperateAct) == 0x000150, "Wrong size on UEyesFollowOperateAct");
static_assert(offsetof(UEyesFollowOperateAct, HeadRotationScale) == 0x000140, "Member 'UEyesFollowOperateAct::HeadRotationScale' has a wrong offset!");
static_assert(offsetof(UEyesFollowOperateAct, bInterpHead) == 0x000148, "Member 'UEyesFollowOperateAct::bInterpHead' has a wrong offset!");
static_assert(offsetof(UEyesFollowOperateAct, HeadInterpSpeed) == 0x00014C, "Member 'UEyesFollowOperateAct::HeadInterpSpeed' has a wrong offset!");

// Class CharacterInteractionV3.PhysicalOffsetOperateAct
// 0x0048 (0x0188 - 0x0140)
class UPhysicalOffsetOperateAct final : public UActorOperateAct
{
public:
	bool                                          bDragFixedBone;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultDragBoneName;                               // 0x0144(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultDragLocationBoneName;                       // 0x014C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DragScale;                                         // 0x0154(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DragStartLocation;                                 // 0x0160(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurDragBone;                                       // 0x016C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAnimNodePhysicsControl;                        // 0x0174(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearStiffness;                                   // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinearDamping;                                     // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularStiffness;                                  // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngularDamping;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalOffsetOperateAct">();
	}
	static class UPhysicalOffsetOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalOffsetOperateAct>();
	}
};
static_assert(alignof(UPhysicalOffsetOperateAct) == 0x000008, "Wrong alignment on UPhysicalOffsetOperateAct");
static_assert(sizeof(UPhysicalOffsetOperateAct) == 0x000188, "Wrong size on UPhysicalOffsetOperateAct");
static_assert(offsetof(UPhysicalOffsetOperateAct, bDragFixedBone) == 0x000140, "Member 'UPhysicalOffsetOperateAct::bDragFixedBone' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, DefaultDragBoneName) == 0x000144, "Member 'UPhysicalOffsetOperateAct::DefaultDragBoneName' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, DefaultDragLocationBoneName) == 0x00014C, "Member 'UPhysicalOffsetOperateAct::DefaultDragLocationBoneName' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, DragScale) == 0x000154, "Member 'UPhysicalOffsetOperateAct::DragScale' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, DragStartLocation) == 0x000160, "Member 'UPhysicalOffsetOperateAct::DragStartLocation' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, CurDragBone) == 0x00016C, "Member 'UPhysicalOffsetOperateAct::CurDragBone' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, bUseAnimNodePhysicsControl) == 0x000174, "Member 'UPhysicalOffsetOperateAct::bUseAnimNodePhysicsControl' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, LinearStiffness) == 0x000178, "Member 'UPhysicalOffsetOperateAct::LinearStiffness' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, LinearDamping) == 0x00017C, "Member 'UPhysicalOffsetOperateAct::LinearDamping' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, AngularStiffness) == 0x000180, "Member 'UPhysicalOffsetOperateAct::AngularStiffness' has a wrong offset!");
static_assert(offsetof(UPhysicalOffsetOperateAct, AngularDamping) == 0x000184, "Member 'UPhysicalOffsetOperateAct::AngularDamping' has a wrong offset!");

// Class CharacterInteractionV3.InteractionMouseHoverInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractionMouseHoverInterface final : public IInterface
{
public:
	void OnMouseHover(const TArray<class FName>& BoneNames, const class UCurveFloat* CurveScale, const struct FVector2D& SlideVector, const struct FVector2D& SlideStartPos, const struct FVector2D& SlidEndPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionMouseHoverInterface">();
	}
	static class IInteractionMouseHoverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionMouseHoverInterface>();
	}
};
static_assert(alignof(IInteractionMouseHoverInterface) == 0x000008, "Wrong alignment on IInteractionMouseHoverInterface");
static_assert(sizeof(IInteractionMouseHoverInterface) == 0x000028, "Wrong size on IInteractionMouseHoverInterface");

// Class CharacterInteractionV3.InteractionCameraInstanceBase
// 0x0020 (0x03C0 - 0x03A0)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractionCameraInstanceBase : public UCameraInstance
{
public:
	bool                                          bActiveBlendOut;                                   // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceBlendOut;                                    // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockBlendOutChange;                               // 0x03A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            CameraTransitionParams;                            // 0x03A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCameraInstanceBase">();
	}
	static class UInteractionCameraInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCameraInstanceBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractionCameraInstanceBase) == 0x000010, "Wrong alignment on UInteractionCameraInstanceBase");
static_assert(sizeof(UInteractionCameraInstanceBase) == 0x0003C0, "Wrong size on UInteractionCameraInstanceBase");
static_assert(offsetof(UInteractionCameraInstanceBase, bActiveBlendOut) == 0x0003A0, "Member 'UInteractionCameraInstanceBase::bActiveBlendOut' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstanceBase, bForceBlendOut) == 0x0003A1, "Member 'UInteractionCameraInstanceBase::bForceBlendOut' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstanceBase, bLockBlendOutChange) == 0x0003A2, "Member 'UInteractionCameraInstanceBase::bLockBlendOutChange' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstanceBase, CameraTransitionParams) == 0x0003A4, "Member 'UInteractionCameraInstanceBase::CameraTransitionParams' has a wrong offset!");

// Class CharacterInteractionV3.InteractionCameraInstance
// 0x02C0 (0x0680 - 0x03C0)
class UInteractionCameraInstance final : public UInteractionCameraInstanceBase
{
public:
	int32                                         MaxInputSubStep;                                   // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSubStepInputDist;                               // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStandbyCameraConfig                   StandbyCameraConfig;                               // 0x03C0(0x00F0)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FInteractionCameraModifierInfo         StandbyModifierInfo;                               // 0x04B0(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x40];                                     // 0x04D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStandbyCameraConfig                   OperateCameraConfig;                               // 0x0518(0x00F0)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FInteractionCameraModifierInfo         OperateModifierInfo;                               // 0x0608(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x44];                                     // 0x0630(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowCameraMove;                                  // 0x0674(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOperateCamera;                                  // 0x0675(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_676[0xA];                                      // 0x0676(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInput(const struct FVector2D& Value);
	void SetOperateConfig(class FName ID);
	void SetStandbyConfig(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCameraInstance">();
	}
	static class UInteractionCameraInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCameraInstance>();
	}
};
static_assert(alignof(UInteractionCameraInstance) == 0x000010, "Wrong alignment on UInteractionCameraInstance");
static_assert(sizeof(UInteractionCameraInstance) == 0x000680, "Wrong size on UInteractionCameraInstance");
static_assert(offsetof(UInteractionCameraInstance, MaxInputSubStep) == 0x0003B8, "Member 'UInteractionCameraInstance::MaxInputSubStep' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, MaxSubStepInputDist) == 0x0003BC, "Member 'UInteractionCameraInstance::MaxSubStepInputDist' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, StandbyCameraConfig) == 0x0003C0, "Member 'UInteractionCameraInstance::StandbyCameraConfig' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, StandbyModifierInfo) == 0x0004B0, "Member 'UInteractionCameraInstance::StandbyModifierInfo' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, OperateCameraConfig) == 0x000518, "Member 'UInteractionCameraInstance::OperateCameraConfig' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, OperateModifierInfo) == 0x000608, "Member 'UInteractionCameraInstance::OperateModifierInfo' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, bAllowCameraMove) == 0x000674, "Member 'UInteractionCameraInstance::bAllowCameraMove' has a wrong offset!");
static_assert(offsetof(UInteractionCameraInstance, bIsOperateCamera) == 0x000675, "Member 'UInteractionCameraInstance::bIsOperateCamera' has a wrong offset!");

// Class CharacterInteractionV3.MouseHoverOperateAct
// 0x0020 (0x0160 - 0x0140)
class UMouseHoverOperateAct final : public UActorOperateAct
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveTorqueScale;                                  // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SampleInterval;                                    // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseHoverOperateAct">();
	}
	static class UMouseHoverOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseHoverOperateAct>();
	}
};
static_assert(alignof(UMouseHoverOperateAct) == 0x000008, "Wrong alignment on UMouseHoverOperateAct");
static_assert(sizeof(UMouseHoverOperateAct) == 0x000160, "Wrong size on UMouseHoverOperateAct");
static_assert(offsetof(UMouseHoverOperateAct, BoneNames) == 0x000140, "Member 'UMouseHoverOperateAct::BoneNames' has a wrong offset!");
static_assert(offsetof(UMouseHoverOperateAct, CurveTorqueScale) == 0x000150, "Member 'UMouseHoverOperateAct::CurveTorqueScale' has a wrong offset!");
static_assert(offsetof(UMouseHoverOperateAct, SampleInterval) == 0x000158, "Member 'UMouseHoverOperateAct::SampleInterval' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3DragInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractionV3DragInterface final : public IInterface
{
public:
	void EndDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation);
	void StartDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation);
	void UpdateDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3DragInterface">();
	}
	static class IInteractionV3DragInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionV3DragInterface>();
	}
};
static_assert(alignof(IInteractionV3DragInterface) == 0x000008, "Wrong alignment on IInteractionV3DragInterface");
static_assert(sizeof(IInteractionV3DragInterface) == 0x000028, "Wrong size on IInteractionV3DragInterface");

// Class CharacterInteractionV3.ScenarioLittleGameBase
// 0x0008 (0x0030 - 0x0028)
class UScenarioLittleGameBase : public UObject
{
public:
	bool                                          bInitialize;                                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Exit();
	void Initialize();
	void OnExit();
	void OnInitialize();
	void OnStart();
	void OnUpdate(float DeltaSeconds);
	void Start();
	void Update(float DeltaSeconds);

	class UInteractionInputComponent* GetInteractionInputComponent() const;
	class UScenarioStateNode_LittleGame* GetStateNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioLittleGameBase">();
	}
	static class UScenarioLittleGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioLittleGameBase>();
	}
};
static_assert(alignof(UScenarioLittleGameBase) == 0x000008, "Wrong alignment on UScenarioLittleGameBase");
static_assert(sizeof(UScenarioLittleGameBase) == 0x000030, "Wrong size on UScenarioLittleGameBase");
static_assert(offsetof(UScenarioLittleGameBase, bInitialize) == 0x000028, "Member 'UScenarioLittleGameBase::bInitialize' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStandardLittleGame
// 0x0038 (0x0068 - 0x0030)
class UScenarioStandardLittleGame : public UScenarioLittleGameBase
{
public:
	TSoftClassPtr<class UClass>                   LittleGameWidget;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScenarioLittleGameUIState                    UIState;                                           // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AUniversalCameraActor*                  UniversalCharacter;                                // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GameInput(const struct FLittleGameInputEvent& InputEvent);
	void MouseClick(const struct FLittleGameInputEvent& InputEvent);
	void MousePress(const struct FLittleGameInputEvent& InputEvent);
	void MouseRelease(const struct FLittleGameInputEvent& InputEvent);
	void OnGameInput(const struct FLittleGameInputEvent& InputEvent);
	void OnInitCameraSequenceFinished();
	void OnLookAround(float InValue);
	void OnLookUp(float InValue);
	void OnMouseClick(const struct FLittleGameInputEvent& InputEvent);
	void OnMousePress(const struct FLittleGameInputEvent& InputEvent);
	void OnMouseRelease(const struct FLittleGameInputEvent& InputEvent);
	void OnMoveForward(float InValue);
	void OnMoveRight(float InValue);
	void PlayShowElement(const class FString& ElementName, const class FString& NextState, bool bEndLastShowElement);
	void PlayShowElementList(const TArray<class FString>& InElements, const class FString& NextState, bool bEndLastShowElement);
	void SetUIState(EScenarioLittleGameUIState NewState);

	void DisableInput() const;
	void EnableInput() const;
	struct FSoftClassPath GetCustomGameUI() const;
	struct FVector2D GetMousePos() const;
	EScenarioLittleGameUIState GetUIState() const;
	bool IsBlockInput() const;
	bool IsCustomGameUI() const;
	int32 ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback) const;
	void ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback) const;
	void PlayShowElementByCallback(const class FString& ElementName, const class FString& NextState, TDelegate<void()> ShowElementPlayFinish, bool bEndLastShowElement) const;
	void PlayShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> ShowElementPlayFinish, bool bEndLastShowElement) const;
	void SetInputModeGameAndUI(EMouseLockMode MouseLockMode) const;
	void SetInputModeGameOnly() const;
	void SetInputModeUIOnly() const;
	void StopAllListenForKeyAction() const;
	void StopAllListeningForHandle() const;
	void StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType) const;
	void StopListeningForHandle(int32 InHandle) const;
	void StopListeningForInputAction(class FName ActionName, EInputEvent EventType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStandardLittleGame">();
	}
	static class UScenarioStandardLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStandardLittleGame>();
	}
};
static_assert(alignof(UScenarioStandardLittleGame) == 0x000008, "Wrong alignment on UScenarioStandardLittleGame");
static_assert(sizeof(UScenarioStandardLittleGame) == 0x000068, "Wrong size on UScenarioStandardLittleGame");
static_assert(offsetof(UScenarioStandardLittleGame, LittleGameWidget) == 0x000030, "Member 'UScenarioStandardLittleGame::LittleGameWidget' has a wrong offset!");
static_assert(offsetof(UScenarioStandardLittleGame, UIState) == 0x000058, "Member 'UScenarioStandardLittleGame::UIState' has a wrong offset!");
static_assert(offsetof(UScenarioStandardLittleGame, UniversalCharacter) == 0x000060, "Member 'UScenarioStandardLittleGame::UniversalCharacter' has a wrong offset!");

// Class CharacterInteractionV3.FennyShowerLittleGame
// 0x0010 (0x0078 - 0x0068)
class UFennyShowerLittleGame final : public UScenarioStandardLittleGame
{
public:
	TArray<struct FFennyShowerStandbyCfg>         StandbyCfgs;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GetCameraAdditivePitchAndYaw(float* OutPitch, float* OutYaw) const;
	bool GetCanActiveCamera() const;
	void PlayStandBy(const int32 Idx) const;
	void SetCanActiveCamera(const bool bCan) const;
	void SetStandByInfo(const int32 Idx) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FennyShowerLittleGame">();
	}
	static class UFennyShowerLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFennyShowerLittleGame>();
	}
};
static_assert(alignof(UFennyShowerLittleGame) == 0x000008, "Wrong alignment on UFennyShowerLittleGame");
static_assert(sizeof(UFennyShowerLittleGame) == 0x000078, "Wrong size on UFennyShowerLittleGame");
static_assert(offsetof(UFennyShowerLittleGame, StandbyCfgs) == 0x000068, "Member 'UFennyShowerLittleGame::StandbyCfgs' has a wrong offset!");

// Class CharacterInteractionV3.DragPropWorldSpaceOffsetOperateAct
// 0x0070 (0x01B0 - 0x0140)
class UDragPropWorldSpaceOffsetOperateAct final : public UActorOperateAct
{
public:
	bool                                          bSpringInterp;                                     // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ErrorTolerance;                                    // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DragSocketName;                                    // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DragLocation;                                      // 0x0158(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DeltaLocation;                                     // 0x0164(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0170(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreTargetLocation;                                 // 0x017C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InterpTarget;                                      // 0x0188(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DragDistance;                                      // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVectorSpringState                     SpringState;                                       // 0x0198(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragPropWorldSpaceOffsetOperateAct">();
	}
	static class UDragPropWorldSpaceOffsetOperateAct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragPropWorldSpaceOffsetOperateAct>();
	}
};
static_assert(alignof(UDragPropWorldSpaceOffsetOperateAct) == 0x000008, "Wrong alignment on UDragPropWorldSpaceOffsetOperateAct");
static_assert(sizeof(UDragPropWorldSpaceOffsetOperateAct) == 0x0001B0, "Wrong size on UDragPropWorldSpaceOffsetOperateAct");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, bSpringInterp) == 0x000140, "Member 'UDragPropWorldSpaceOffsetOperateAct::bSpringInterp' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, ErrorTolerance) == 0x000144, "Member 'UDragPropWorldSpaceOffsetOperateAct::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, Stiffness) == 0x000148, "Member 'UDragPropWorldSpaceOffsetOperateAct::Stiffness' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, CriticalDamping) == 0x00014C, "Member 'UDragPropWorldSpaceOffsetOperateAct::CriticalDamping' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, DragSocketName) == 0x000150, "Member 'UDragPropWorldSpaceOffsetOperateAct::DragSocketName' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, DragLocation) == 0x000158, "Member 'UDragPropWorldSpaceOffsetOperateAct::DragLocation' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, DeltaLocation) == 0x000164, "Member 'UDragPropWorldSpaceOffsetOperateAct::DeltaLocation' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, TargetLocation) == 0x000170, "Member 'UDragPropWorldSpaceOffsetOperateAct::TargetLocation' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, PreTargetLocation) == 0x00017C, "Member 'UDragPropWorldSpaceOffsetOperateAct::PreTargetLocation' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, InterpTarget) == 0x000188, "Member 'UDragPropWorldSpaceOffsetOperateAct::InterpTarget' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, DragDistance) == 0x000194, "Member 'UDragPropWorldSpaceOffsetOperateAct::DragDistance' has a wrong offset!");
static_assert(offsetof(UDragPropWorldSpaceOffsetOperateAct, SpringState) == 0x000198, "Member 'UDragPropWorldSpaceOffsetOperateAct::SpringState' has a wrong offset!");

// Class CharacterInteractionV3.AnimNotifyState_SubtitleStatus
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_SubtitleStatus final : public UAnimNotifyState
{
public:
	class FString                                 SubtitleKey;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SubtitleStatus">();
	}
	static class UAnimNotifyState_SubtitleStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SubtitleStatus>();
	}
};
static_assert(alignof(UAnimNotifyState_SubtitleStatus) == 0x000008, "Wrong alignment on UAnimNotifyState_SubtitleStatus");
static_assert(sizeof(UAnimNotifyState_SubtitleStatus) == 0x000040, "Wrong size on UAnimNotifyState_SubtitleStatus");
static_assert(offsetof(UAnimNotifyState_SubtitleStatus, SubtitleKey) == 0x000030, "Member 'UAnimNotifyState_SubtitleStatus::SubtitleKey' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3Unit
// 0x0008 (0x0030 - 0x0028)
class UShowElementV3Unit : public UObject
{
public:
	TSubclassOf<class UShowElementV3UnitPlayer>   PlayerType;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3Unit">();
	}
	static class UShowElementV3Unit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3Unit>();
	}
};
static_assert(alignof(UShowElementV3Unit) == 0x000008, "Wrong alignment on UShowElementV3Unit");
static_assert(sizeof(UShowElementV3Unit) == 0x000030, "Wrong size on UShowElementV3Unit");
static_assert(offsetof(UShowElementV3Unit, PlayerType) == 0x000028, "Member 'UShowElementV3Unit::PlayerType' has a wrong offset!");

// Class CharacterInteractionV3.FacialAnimUnit
// 0x0018 (0x0048 - 0x0030)
class UFacialAnimUnit final : public UShowElementV3Unit
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoBlendOut;                               // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FacialAnimUnit">();
	}
	static class UFacialAnimUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFacialAnimUnit>();
	}
};
static_assert(alignof(UFacialAnimUnit) == 0x000008, "Wrong alignment on UFacialAnimUnit");
static_assert(sizeof(UFacialAnimUnit) == 0x000048, "Wrong size on UFacialAnimUnit");
static_assert(offsetof(UFacialAnimUnit, Sequence) == 0x000030, "Member 'UFacialAnimUnit::Sequence' has a wrong offset!");
static_assert(offsetof(UFacialAnimUnit, BlendInTime) == 0x000038, "Member 'UFacialAnimUnit::BlendInTime' has a wrong offset!");
static_assert(offsetof(UFacialAnimUnit, BlendOutTime) == 0x00003C, "Member 'UFacialAnimUnit::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UFacialAnimUnit, BlendOutTriggerTime) == 0x000040, "Member 'UFacialAnimUnit::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(UFacialAnimUnit, bEnableAutoBlendOut) == 0x000044, "Member 'UFacialAnimUnit::bEnableAutoBlendOut' has a wrong offset!");

// Class CharacterInteractionV3.InteractionCameraActor
// 0x0608 (0x0830 - 0x0228)
class alignas(0x10) AInteractionCameraActor final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraInstance>            CameraBlueprintCalss;                              // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x5F8];                                    // 0x0238(0x05F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AInteractionCameraActor* GetCameraActor();

	void ActiveCamera();
	void SetOperateConfig(class FName ID);
	void SetStandbyConfig(class FName ID);
	void ToggleDebugCameraModifierInfo();

	const struct FMinimalViewInfo GetDefaultViewInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCameraActor">();
	}
	static class AInteractionCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionCameraActor>();
	}
};
static_assert(alignof(AInteractionCameraActor) == 0x000010, "Wrong alignment on AInteractionCameraActor");
static_assert(sizeof(AInteractionCameraActor) == 0x000830, "Wrong size on AInteractionCameraActor");
static_assert(offsetof(AInteractionCameraActor, CameraBlueprintCalss) == 0x000230, "Member 'AInteractionCameraActor::CameraBlueprintCalss' has a wrong offset!");

// Class CharacterInteractionV3.CallActorFunctionEvent
// 0x0010 (0x0038 - 0x0028)
class UCallActorFunctionEvent final : public UInteractionV3Event
{
public:
	class FName                                   ActorName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallActorFunctionEvent">();
	}
	static class UCallActorFunctionEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallActorFunctionEvent>();
	}
};
static_assert(alignof(UCallActorFunctionEvent) == 0x000008, "Wrong alignment on UCallActorFunctionEvent");
static_assert(sizeof(UCallActorFunctionEvent) == 0x000038, "Wrong size on UCallActorFunctionEvent");
static_assert(offsetof(UCallActorFunctionEvent, ActorName) == 0x000028, "Member 'UCallActorFunctionEvent::ActorName' has a wrong offset!");
static_assert(offsetof(UCallActorFunctionEvent, FunctionName) == 0x000030, "Member 'UCallActorFunctionEvent::FunctionName' has a wrong offset!");

// Class CharacterInteractionV3.FennyGunFireLittleGame
// 0x0018 (0x0080 - 0x0068)
class UFennyGunFireLittleGame final : public UScenarioStandardLittleGame
{
public:
	TArray<struct FFennyVoiceTipCfg>              VoiceTipCfgs;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              FirstRoundDelayTime;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const struct FFennyVoiceTipCfg GetVoiceTipCfg(int32 InId);
	int32 RandomVoice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FennyGunFireLittleGame">();
	}
	static class UFennyGunFireLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFennyGunFireLittleGame>();
	}
};
static_assert(alignof(UFennyGunFireLittleGame) == 0x000008, "Wrong alignment on UFennyGunFireLittleGame");
static_assert(sizeof(UFennyGunFireLittleGame) == 0x000080, "Wrong size on UFennyGunFireLittleGame");
static_assert(offsetof(UFennyGunFireLittleGame, VoiceTipCfgs) == 0x000068, "Member 'UFennyGunFireLittleGame::VoiceTipCfgs' has a wrong offset!");
static_assert(offsetof(UFennyGunFireLittleGame, FirstRoundDelayTime) == 0x000078, "Member 'UFennyGunFireLittleGame::FirstRoundDelayTime' has a wrong offset!");

// Class CharacterInteractionV3.HolyLightV3Component
// 0x0058 (0x0108 - 0x00B0)
class UHolyLightV3Component final : public UActorComponent
{
public:
	TMap<class FName, struct FInteractionV3HolyLightRuntimeDataArray> HolyLightRuntimeData;                              // 0x00B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HolyLightV3Component">();
	}
	static class UHolyLightV3Component* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHolyLightV3Component>();
	}
};
static_assert(alignof(UHolyLightV3Component) == 0x000008, "Wrong alignment on UHolyLightV3Component");
static_assert(sizeof(UHolyLightV3Component) == 0x000108, "Wrong size on UHolyLightV3Component");
static_assert(offsetof(UHolyLightV3Component, HolyLightRuntimeData) == 0x0000B0, "Member 'UHolyLightV3Component::HolyLightRuntimeData' has a wrong offset!");

// Class CharacterInteractionV3.InteractionActorV3
// 0x0170 (0x0398 - 0x0228)
class AInteractionActorV3 : public AActor
{
public:
	class FName                                   ActorName;                                         // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UShowElementV3UnitPlayerConfigAsset> SEUintPlayConfig;                                  // 0x0230(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UShowElementV3Unit>, class UShowElementV3UnitPlayer*> PlayerMapByType;                                   // 0x0258(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UShowElementV3UnitPlayer>, class UShowElementV3UnitPlayer*> PlayerMapByClass;                                  // 0x02A8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UShowElementV3Unit*, class UShowElementV3UnitPlayer*> ElementUnitPlayerContext;                          // 0x02F8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, TDelegate<void()>>        OperateDelegateMap;                                // 0x0348(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void BindOperateActEvent(const class FString& ActorOperateActName, const TDelegate<void(const class FString& ActorOperateActName, float DeltaSeconds, class UActorOperateAct* ActorOperateAct, EInteractionV3OperateEventType EventType)>& Delegate);
	void OnOperateEnd(const class FString& ActorOperateActName, class UActorOperateAct* ActorOperateAct);
	void OnOperateStart(const class FString& ActorOperateActName, class UActorOperateAct* ActorOperateAct);
	void OnOperateUpdate(const class FString& ActorOperateActName, float DeltaSeconds, class UActorOperateAct* ActorOperateAct);
	void PlayWeightedVoice(const struct FInteractionVoiceConfig& Config);
	void PlayWeightedVoiceWithAnimInstance(class UAnimInstance* AnimInstance, const struct FInteractionVoiceConfig& Config);
	void ReInitPhysics();
	void ResetActor();
	void ResetActorPhysics();
	void StopVoice(int32 TransitionMS, bool bInvokeCallback);
	void UnbindOperateActEvent(const class FString& ActorOperateActName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionActorV3">();
	}
	static class AInteractionActorV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionActorV3>();
	}
};
static_assert(alignof(AInteractionActorV3) == 0x000008, "Wrong alignment on AInteractionActorV3");
static_assert(sizeof(AInteractionActorV3) == 0x000398, "Wrong size on AInteractionActorV3");
static_assert(offsetof(AInteractionActorV3, ActorName) == 0x000228, "Member 'AInteractionActorV3::ActorName' has a wrong offset!");
static_assert(offsetof(AInteractionActorV3, SEUintPlayConfig) == 0x000230, "Member 'AInteractionActorV3::SEUintPlayConfig' has a wrong offset!");
static_assert(offsetof(AInteractionActorV3, PlayerMapByType) == 0x000258, "Member 'AInteractionActorV3::PlayerMapByType' has a wrong offset!");
static_assert(offsetof(AInteractionActorV3, PlayerMapByClass) == 0x0002A8, "Member 'AInteractionActorV3::PlayerMapByClass' has a wrong offset!");
static_assert(offsetof(AInteractionActorV3, ElementUnitPlayerContext) == 0x0002F8, "Member 'AInteractionActorV3::ElementUnitPlayerContext' has a wrong offset!");
static_assert(offsetof(AInteractionActorV3, OperateDelegateMap) == 0x000348, "Member 'AInteractionActorV3::OperateDelegateMap' has a wrong offset!");

// Class CharacterInteractionV3.InteractionArchivementComponentV3
// 0x0040 (0x00F0 - 0x00B0)
class UInteractionArchivementComponentV3 final : public UActorComponent
{
public:
	TArray<struct FInteractionArchivementInfoV3>  Archivements;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 CompleteConditions;                                // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 CompleteArchivements;                              // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 PlayedArchivements;                                // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void PlayArchivement(int32 InId);
	void SetArchievementPlayed(int32 InId);
	void SetArchivementComplete(int32 InId);
	void SetConditionComplete(int32 InId);
	void SetConditionCompleteAdnRefresh(int32 InId);

	bool CanPlay(int32 InId) const;
	bool IsArchivementComplete(int32 InId) const;
	bool IsArchivementPlayed(int32 InId) const;
	bool IsConditionComplete(int32 InId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionArchivementComponentV3">();
	}
	static class UInteractionArchivementComponentV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionArchivementComponentV3>();
	}
};
static_assert(alignof(UInteractionArchivementComponentV3) == 0x000008, "Wrong alignment on UInteractionArchivementComponentV3");
static_assert(sizeof(UInteractionArchivementComponentV3) == 0x0000F0, "Wrong size on UInteractionArchivementComponentV3");
static_assert(offsetof(UInteractionArchivementComponentV3, Archivements) == 0x0000B0, "Member 'UInteractionArchivementComponentV3::Archivements' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponentV3, CompleteConditions) == 0x0000C0, "Member 'UInteractionArchivementComponentV3::CompleteConditions' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponentV3, CompleteArchivements) == 0x0000D0, "Member 'UInteractionArchivementComponentV3::CompleteArchivements' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponentV3, PlayedArchivements) == 0x0000E0, "Member 'UInteractionArchivementComponentV3::PlayedArchivements' has a wrong offset!");

// Class CharacterInteractionV3.InteractionSkeletalActorV3
// 0x0028 (0x03C0 - 0x0398)
class AInteractionSkeletalActorV3 : public AInteractionActorV3
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGamePhysicsControlComponent*       BodyPhysicsControlComponent;                       // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGamePhysicsControlComponent*       BodyAnimNodePhysicsControlComponent;               // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsHandleComponent*                PhysicsHandleComponent;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UInteractionV3CharacterAnimInstance* GetInteractionCharacterAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSkeletalActorV3">();
	}
	static class AInteractionSkeletalActorV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionSkeletalActorV3>();
	}
};
static_assert(alignof(AInteractionSkeletalActorV3) == 0x000008, "Wrong alignment on AInteractionSkeletalActorV3");
static_assert(sizeof(AInteractionSkeletalActorV3) == 0x0003C0, "Wrong size on AInteractionSkeletalActorV3");
static_assert(offsetof(AInteractionSkeletalActorV3, SkeletalMeshComponent) == 0x0003A0, "Member 'AInteractionSkeletalActorV3::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AInteractionSkeletalActorV3, BodyPhysicsControlComponent) == 0x0003A8, "Member 'AInteractionSkeletalActorV3::BodyPhysicsControlComponent' has a wrong offset!");
static_assert(offsetof(AInteractionSkeletalActorV3, BodyAnimNodePhysicsControlComponent) == 0x0003B0, "Member 'AInteractionSkeletalActorV3::BodyAnimNodePhysicsControlComponent' has a wrong offset!");
static_assert(offsetof(AInteractionSkeletalActorV3, PhysicsHandleComponent) == 0x0003B8, "Member 'AInteractionSkeletalActorV3::PhysicsHandleComponent' has a wrong offset!");

// Class CharacterInteractionV3.InteractionCharacterV3
// 0x0090 (0x0450 - 0x03C0)
class AInteractionCharacterV3 : public AInteractionSkeletalActorV3
{
public:
	bool                                          bForceEyeLookAtCamera;                             // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EyesLookAtPosition;                                // 0x03C4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionLookAtBoneData             EyeLookAtBoneInfo;                                 // 0x03CC(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              OperatingCurrentHeadRotScale;                      // 0x03DC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OperatingTargetHeadRotScale;                       // 0x03E4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OperatingHeadRotInterpSpeed;                       // 0x03EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurrentDisableKawaiiBlendCurve;                    // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 FaceComponent;                                     // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 LeftShoeComponent;                                 // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 RightShoeComponent;                                // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOVRLipSyncPlaybackActorComponent*      LipSyncComponent;                                  // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGamePhysicsControlComponent*       FacePhysicsControlComponent;                       // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShutDownKawaii;                                   // 0x0420(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KawaiiAlpha;                                       // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KawaiiBlendDuration;                               // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KawaiiShutdownSpeed;                               // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableKawaiiBlendCurve;                         // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EnableKawaiiBlendCurve;                            // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DisableKawaiiBlendCurve;                           // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x4];                                      // 0x0448(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KawaiBlendSpeedScale;                              // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InteractionStartBlush();
	void InteractionStopBlush();
	void OnLipSyncDataReady();
	void SetKawaiiBlendScale(float KawaiiBlendScaleValue);
	void StartKawaiiBlend();

	class UInteractionV3FaceAnimInstance* GetInteractionCharacterFaceAnimInstance() const;
	float GetKawaiiAlphaValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCharacterV3">();
	}
	static class AInteractionCharacterV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionCharacterV3>();
	}
};
static_assert(alignof(AInteractionCharacterV3) == 0x000008, "Wrong alignment on AInteractionCharacterV3");
static_assert(sizeof(AInteractionCharacterV3) == 0x000450, "Wrong size on AInteractionCharacterV3");
static_assert(offsetof(AInteractionCharacterV3, bForceEyeLookAtCamera) == 0x0003C0, "Member 'AInteractionCharacterV3::bForceEyeLookAtCamera' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, EyesLookAtPosition) == 0x0003C4, "Member 'AInteractionCharacterV3::EyesLookAtPosition' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, EyeLookAtBoneInfo) == 0x0003CC, "Member 'AInteractionCharacterV3::EyeLookAtBoneInfo' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, OperatingCurrentHeadRotScale) == 0x0003DC, "Member 'AInteractionCharacterV3::OperatingCurrentHeadRotScale' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, OperatingTargetHeadRotScale) == 0x0003E4, "Member 'AInteractionCharacterV3::OperatingTargetHeadRotScale' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, OperatingHeadRotInterpSpeed) == 0x0003EC, "Member 'AInteractionCharacterV3::OperatingHeadRotInterpSpeed' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, CurrentDisableKawaiiBlendCurve) == 0x0003F0, "Member 'AInteractionCharacterV3::CurrentDisableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, FaceComponent) == 0x0003F8, "Member 'AInteractionCharacterV3::FaceComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, LeftShoeComponent) == 0x000400, "Member 'AInteractionCharacterV3::LeftShoeComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, RightShoeComponent) == 0x000408, "Member 'AInteractionCharacterV3::RightShoeComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, LipSyncComponent) == 0x000410, "Member 'AInteractionCharacterV3::LipSyncComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, FacePhysicsControlComponent) == 0x000418, "Member 'AInteractionCharacterV3::FacePhysicsControlComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, bShutDownKawaii) == 0x000420, "Member 'AInteractionCharacterV3::bShutDownKawaii' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, KawaiiAlpha) == 0x000424, "Member 'AInteractionCharacterV3::KawaiiAlpha' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, KawaiiBlendDuration) == 0x000428, "Member 'AInteractionCharacterV3::KawaiiBlendDuration' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, KawaiiShutdownSpeed) == 0x00042C, "Member 'AInteractionCharacterV3::KawaiiShutdownSpeed' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, bIsEnableKawaiiBlendCurve) == 0x000430, "Member 'AInteractionCharacterV3::bIsEnableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, EnableKawaiiBlendCurve) == 0x000438, "Member 'AInteractionCharacterV3::EnableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, DisableKawaiiBlendCurve) == 0x000440, "Member 'AInteractionCharacterV3::DisableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(AInteractionCharacterV3, KawaiBlendSpeedScale) == 0x00044C, "Member 'AInteractionCharacterV3::KawaiBlendSpeedScale' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3InputCollision
// 0x0020 (0x0048 - 0x0028)
class UInteractionV3InputCollision : public UObject
{
public:
	int32                                         AllAgeLevel;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MouseResourceID;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TipWidget;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OperateName;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsInCollision(const struct FVector2D& CheckPos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3InputCollision">();
	}
	static class UInteractionV3InputCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3InputCollision>();
	}
};
static_assert(alignof(UInteractionV3InputCollision) == 0x000008, "Wrong alignment on UInteractionV3InputCollision");
static_assert(sizeof(UInteractionV3InputCollision) == 0x000048, "Wrong size on UInteractionV3InputCollision");
static_assert(offsetof(UInteractionV3InputCollision, AllAgeLevel) == 0x000028, "Member 'UInteractionV3InputCollision::AllAgeLevel' has a wrong offset!");
static_assert(offsetof(UInteractionV3InputCollision, MouseResourceID) == 0x00002C, "Member 'UInteractionV3InputCollision::MouseResourceID' has a wrong offset!");
static_assert(offsetof(UInteractionV3InputCollision, TipWidget) == 0x000030, "Member 'UInteractionV3InputCollision::TipWidget' has a wrong offset!");
static_assert(offsetof(UInteractionV3InputCollision, OperateName) == 0x000038, "Member 'UInteractionV3InputCollision::OperateName' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3AutoTriggerInput
// 0x0000 (0x0048 - 0x0048)
class UInteractionV3AutoTriggerInput final : public UInteractionV3InputCollision
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3AutoTriggerInput">();
	}
	static class UInteractionV3AutoTriggerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3AutoTriggerInput>();
	}
};
static_assert(alignof(UInteractionV3AutoTriggerInput) == 0x000008, "Wrong alignment on UInteractionV3AutoTriggerInput");
static_assert(sizeof(UInteractionV3AutoTriggerInput) == 0x000048, "Wrong size on UInteractionV3AutoTriggerInput");

// Class CharacterInteractionV3.InteractionV3SpartialInputCollision
// 0x0040 (0x0088 - 0x0048)
class UInteractionV3SpartialInputCollision : public UInteractionV3InputCollision
{
public:
	class FName                                   CharacterName;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpatialOffset;                                     // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraPitchRange;                                  // 0x0064(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraYawRange;                                    // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraArrowUI;                                     // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UShapeComponent>         ShapeComponent;                                    // 0x007C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInCameraRange;                                    // 0x0084(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisable;                                          // 0x0085(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3SpartialInputCollision">();
	}
	static class UInteractionV3SpartialInputCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3SpartialInputCollision>();
	}
};
static_assert(alignof(UInteractionV3SpartialInputCollision) == 0x000008, "Wrong alignment on UInteractionV3SpartialInputCollision");
static_assert(sizeof(UInteractionV3SpartialInputCollision) == 0x000088, "Wrong size on UInteractionV3SpartialInputCollision");
static_assert(offsetof(UInteractionV3SpartialInputCollision, CharacterName) == 0x000048, "Member 'UInteractionV3SpartialInputCollision::CharacterName' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, BoneName) == 0x000050, "Member 'UInteractionV3SpartialInputCollision::BoneName' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, SpatialOffset) == 0x000058, "Member 'UInteractionV3SpartialInputCollision::SpatialOffset' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, CameraPitchRange) == 0x000064, "Member 'UInteractionV3SpartialInputCollision::CameraPitchRange' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, CameraYawRange) == 0x00006C, "Member 'UInteractionV3SpartialInputCollision::CameraYawRange' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, CameraArrowUI) == 0x000074, "Member 'UInteractionV3SpartialInputCollision::CameraArrowUI' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, ShapeComponent) == 0x00007C, "Member 'UInteractionV3SpartialInputCollision::ShapeComponent' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, bInCameraRange) == 0x000084, "Member 'UInteractionV3SpartialInputCollision::bInCameraRange' has a wrong offset!");
static_assert(offsetof(UInteractionV3SpartialInputCollision, bDisable) == 0x000085, "Member 'UInteractionV3SpartialInputCollision::bDisable' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3SphereCollisionInput
// 0x0008 (0x0090 - 0x0088)
class UInteractionV3SphereCollisionInput final : public UInteractionV3SpartialInputCollision
{
public:
	float                                         Radius;                                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3SphereCollisionInput">();
	}
	static class UInteractionV3SphereCollisionInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3SphereCollisionInput>();
	}
};
static_assert(alignof(UInteractionV3SphereCollisionInput) == 0x000008, "Wrong alignment on UInteractionV3SphereCollisionInput");
static_assert(sizeof(UInteractionV3SphereCollisionInput) == 0x000090, "Wrong size on UInteractionV3SphereCollisionInput");
static_assert(offsetof(UInteractionV3SphereCollisionInput, Radius) == 0x000088, "Member 'UInteractionV3SphereCollisionInput::Radius' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3CapsuleCollisionInput
// 0x0020 (0x00A8 - 0x0088)
class UInteractionV3CapsuleCollisionInput final : public UInteractionV3SpartialInputCollision
{
public:
	bool                                          bAlignToPhysicsBody;                               // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CollisionCapsule;                                  // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3CapsuleCollisionInput">();
	}
	static class UInteractionV3CapsuleCollisionInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3CapsuleCollisionInput>();
	}
};
static_assert(alignof(UInteractionV3CapsuleCollisionInput) == 0x000008, "Wrong alignment on UInteractionV3CapsuleCollisionInput");
static_assert(sizeof(UInteractionV3CapsuleCollisionInput) == 0x0000A8, "Wrong size on UInteractionV3CapsuleCollisionInput");
static_assert(offsetof(UInteractionV3CapsuleCollisionInput, bAlignToPhysicsBody) == 0x000088, "Member 'UInteractionV3CapsuleCollisionInput::bAlignToPhysicsBody' has a wrong offset!");
static_assert(offsetof(UInteractionV3CapsuleCollisionInput, Radius) == 0x00008C, "Member 'UInteractionV3CapsuleCollisionInput::Radius' has a wrong offset!");
static_assert(offsetof(UInteractionV3CapsuleCollisionInput, Length) == 0x000090, "Member 'UInteractionV3CapsuleCollisionInput::Length' has a wrong offset!");
static_assert(offsetof(UInteractionV3CapsuleCollisionInput, CollisionCapsule) == 0x000098, "Member 'UInteractionV3CapsuleCollisionInput::CollisionCapsule' has a wrong offset!");

// Class CharacterInteractionV3.InteractionDirectorV3
// 0x0180 (0x03A8 - 0x0228)
class AInteractionDirectorV3 final : public AActor
{
public:
	class FString                                 LastScenarioName;                                  // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScenarioStateComponent*                ScenarioStateComponent;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionInputComponent*             InteractionInputComponent;                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionArchivementComponentV3*     InteractionArchivementComponent;                   // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHolyLightV3Component*                  HolyLightComponent;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInteractionV3InputCollision*>   InputCollisions;                                   // 0x0258(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class AInteractionActorV3*> Performers;                                        // 0x0268(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0xF0];                                     // 0x02B8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AInteractionDirectorV3* GetInstance();
	static class AInteractionDirectorV3* GetInteractionDirector(const class UObject* WorldContextObject);

	void ClearPerformers();
	class AInteractionActorV3* CreateInteractionActorFromName(const class FName& ActorName);
	void CreateInteractionActorInScenario(const class FName& ScenarioName);
	void EndScenarioShowElement(const class FName& ShowElementName);
	bool EnterScenario(const class FString& ScenarioName);
	void OnEnterScenario(const class FString& ScenarioName);
	TArray<struct FShowElementsAnim> PlayScenarioShowElement(const class FName& ShowElementName);
	void QuitScenarioShowElement(const class FName& ShowElementName);
	void RemoveInteractionActor(const class FName& Name_0);
	void RemoveInteractionActorInScenario(const class FName& ScenarioName);
	void ResetActors();
	void ShowActorsComponents(const class FString& ScName, bool bReset);
	void ToggleDebugOperateCollision();

	class UScenarioStateNode* GetActiveStateNode() const;
	TArray<class AInteractionActorV3*> GetAllInteractionActor() const;
	class UInteractionArchivementComponentV3* GetArchivementComponent() const;
	struct FVector2D GetDeltaPressedMousePosition() const;
	class UHolyLightV3Component* GetHolyLightComponent() const;
	class AInteractionActorV3* GetInteractionActor(const class FName& ActorName) const;
	struct FVector2D GetMouseDownPosition() const;
	struct FVector2D GetMousePosition() const;
	struct FVector2D GetNonOperateDeltaPressedMousePosition() const;
	float GetScenarioShowElementDurationTime(const class FName& ShowElementName) const;
	class UInteractionV3InputCollision* GetSelectedCollision() const;
	bool IsMouseInScreen() const;
	bool IsMousePressed() const;
	bool TransitionState(const class FString& InScenarioStateName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDirectorV3">();
	}
	static class AInteractionDirectorV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionDirectorV3>();
	}
};
static_assert(alignof(AInteractionDirectorV3) == 0x000008, "Wrong alignment on AInteractionDirectorV3");
static_assert(sizeof(AInteractionDirectorV3) == 0x0003A8, "Wrong size on AInteractionDirectorV3");
static_assert(offsetof(AInteractionDirectorV3, LastScenarioName) == 0x000228, "Member 'AInteractionDirectorV3::LastScenarioName' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, ScenarioStateComponent) == 0x000238, "Member 'AInteractionDirectorV3::ScenarioStateComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, InteractionInputComponent) == 0x000240, "Member 'AInteractionDirectorV3::InteractionInputComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, InteractionArchivementComponent) == 0x000248, "Member 'AInteractionDirectorV3::InteractionArchivementComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, HolyLightComponent) == 0x000250, "Member 'AInteractionDirectorV3::HolyLightComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, InputCollisions) == 0x000258, "Member 'AInteractionDirectorV3::InputCollisions' has a wrong offset!");
static_assert(offsetof(AInteractionDirectorV3, Performers) == 0x000268, "Member 'AInteractionDirectorV3::Performers' has a wrong offset!");

// Class CharacterInteractionV3.InteractionFPSCameraActor
// 0x0618 (0x0840 - 0x0228)
class AInteractionFPSCameraActor final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraInstance>            CameraBlueprintCalss;                              // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveCamera;                                     // 0x0238(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       DefaultViewInfo;                                   // 0x0240(0x05F0)(Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  LastViewTarget;                                    // 0x0830(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AInteractionFPSCameraActor* GetInteractorFPSCameraActor();
	static bool IsActiveFPSModel();

	void ActiveCamera();
	void DisableCamera();

	void AddInput(const struct FVector2D& InValue) const;
	bool IsActiveCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionFPSCameraActor">();
	}
	static class AInteractionFPSCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionFPSCameraActor>();
	}
};
static_assert(alignof(AInteractionFPSCameraActor) == 0x000010, "Wrong alignment on AInteractionFPSCameraActor");
static_assert(sizeof(AInteractionFPSCameraActor) == 0x000840, "Wrong size on AInteractionFPSCameraActor");
static_assert(offsetof(AInteractionFPSCameraActor, CameraBlueprintCalss) == 0x000230, "Member 'AInteractionFPSCameraActor::CameraBlueprintCalss' has a wrong offset!");
static_assert(offsetof(AInteractionFPSCameraActor, bActiveCamera) == 0x000238, "Member 'AInteractionFPSCameraActor::bActiveCamera' has a wrong offset!");
static_assert(offsetof(AInteractionFPSCameraActor, DefaultViewInfo) == 0x000240, "Member 'AInteractionFPSCameraActor::DefaultViewInfo' has a wrong offset!");
static_assert(offsetof(AInteractionFPSCameraActor, LastViewTarget) == 0x000830, "Member 'AInteractionFPSCameraActor::LastViewTarget' has a wrong offset!");

// Class CharacterInteractionV3.InteractionFPSCameraInstance
// 0x0060 (0x0420 - 0x03C0)
class UInteractionFPSCameraInstance final : public UInteractionCameraInstanceBase
{
public:
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               CameraRange;                                       // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraSpeed;                                       // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLerpSpeed;                                   // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileCameraLerpSpeed;                             // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionCameraModifierInfo         FPSModifierInfo;                                   // 0x03DC(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              RotationInput;                                     // 0x0404(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotator;                                     // 0x040C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInput(const struct FVector2D& Value);
	void ResetData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionFPSCameraInstance">();
	}
	static class UInteractionFPSCameraInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionFPSCameraInstance>();
	}
};
static_assert(alignof(UInteractionFPSCameraInstance) == 0x000010, "Wrong alignment on UInteractionFPSCameraInstance");
static_assert(sizeof(UInteractionFPSCameraInstance) == 0x000420, "Wrong size on UInteractionFPSCameraInstance");
static_assert(offsetof(UInteractionFPSCameraInstance, CameraRange) == 0x0003C0, "Member 'UInteractionFPSCameraInstance::CameraRange' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, CameraSpeed) == 0x0003D0, "Member 'UInteractionFPSCameraInstance::CameraSpeed' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, CameraLerpSpeed) == 0x0003D4, "Member 'UInteractionFPSCameraInstance::CameraLerpSpeed' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, MobileCameraLerpSpeed) == 0x0003D8, "Member 'UInteractionFPSCameraInstance::MobileCameraLerpSpeed' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, FPSModifierInfo) == 0x0003DC, "Member 'UInteractionFPSCameraInstance::FPSModifierInfo' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, RotationInput) == 0x000404, "Member 'UInteractionFPSCameraInstance::RotationInput' has a wrong offset!");
static_assert(offsetof(UInteractionFPSCameraInstance, TargetRotator) == 0x00040C, "Member 'UInteractionFPSCameraInstance::TargetRotator' has a wrong offset!");

// Class CharacterInteractionV3.InteractionInputComponent
// 0x00B0 (0x0160 - 0x00B0)
class UInteractionInputComponent final : public UActorComponent
{
public:
	class AInteractionDirectorV3*                 Director;                                          // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionV3InputCollision*           CurrentPressedCollision;                           // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        InputComponent;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, int32>                    BlockInteractionOperateMap;                        // 0x00C8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractionPreInputInfo>       PreInputEvents;                                    // 0x0118(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x1F];                                     // 0x0128(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOperatePressed;                                   // 0x0147(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBlockInteractionOperate(const class FString& InReason);
	int32 AddMouseButtonEvent(bool bDown, TDelegate<void()> InAction);
	bool HandleMouseButtonEvent(bool bDown);
	int32 ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback);
	void ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback);
	void LookAround(float InValue);
	void LookUp(float InValue);
	void MoveForward(float InValue);
	void MoveRight(float InValue);
	void RemoveAllBlockInteractionOperate();
	void RemoveAllMouseButtonEvent();
	void RemoveBlockInteractionOperate(const class FString& InReason);
	void RemoveMouseButtonEvent(int32 InHandle);
	void SetIsMouseInScreen(const bool bInScreen);
	void SetIsMousePressed(const bool bDown);
	void SetMouseDownPosition(const struct FVector2D& Pos);
	void SetMousePosition(const struct FVector2D& Pos);

	void AddActionMapping(const struct FInteractionActionKeyMapping& InActionKeyMapping, const bool bAdd) const;
	class UScenarioStateNode* GetActiveStateNode() const;
	struct FVector2D GetMouseDownPosition() const;
	struct FVector2D GetMousePosition() const;
	struct FVector2D GetNonOperatePressedMouseMove() const;
	struct FVector2D GetPressedMouseMove() const;
	bool HasBlockInteractionOperate(const class FString& InReason) const;
	bool IsBlockInteractionOperate() const;
	bool IsListeningForInputAction(class FName ActionName) const;
	bool IsMouseInScreen() const;
	bool IsMousePressed() const;
	void RegisterInputComponent() const;
	void StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType) const;
	void StopListeningForHandle(int32 InHandle) const;
	int32 StopListeningForInputAction(class FName ActionName, EInputEvent EventType) const;
	void UnregisterInputComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionInputComponent">();
	}
	static class UInteractionInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionInputComponent>();
	}
};
static_assert(alignof(UInteractionInputComponent) == 0x000008, "Wrong alignment on UInteractionInputComponent");
static_assert(sizeof(UInteractionInputComponent) == 0x000160, "Wrong size on UInteractionInputComponent");
static_assert(offsetof(UInteractionInputComponent, Director) == 0x0000B0, "Member 'UInteractionInputComponent::Director' has a wrong offset!");
static_assert(offsetof(UInteractionInputComponent, CurrentPressedCollision) == 0x0000B8, "Member 'UInteractionInputComponent::CurrentPressedCollision' has a wrong offset!");
static_assert(offsetof(UInteractionInputComponent, InputComponent) == 0x0000C0, "Member 'UInteractionInputComponent::InputComponent' has a wrong offset!");
static_assert(offsetof(UInteractionInputComponent, BlockInteractionOperateMap) == 0x0000C8, "Member 'UInteractionInputComponent::BlockInteractionOperateMap' has a wrong offset!");
static_assert(offsetof(UInteractionInputComponent, PreInputEvents) == 0x000118, "Member 'UInteractionInputComponent::PreInputEvents' has a wrong offset!");
static_assert(offsetof(UInteractionInputComponent, bOperatePressed) == 0x000147, "Member 'UInteractionInputComponent::bOperatePressed' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3InputControl
// 0x0008 (0x0030 - 0x0028)
class UInteractionV3InputControl : public UObject
{
public:
	bool                                          bBlendOut;                                         // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlendOutAlpha() const;
	struct FVector GetDragOffset() const;
	struct FVector GetDragValue() const;
	float GetInputFloatValue() const;
	struct FVector2D GetInputValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3InputControl">();
	}
	static class UInteractionV3InputControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3InputControl>();
	}
};
static_assert(alignof(UInteractionV3InputControl) == 0x000008, "Wrong alignment on UInteractionV3InputControl");
static_assert(sizeof(UInteractionV3InputControl) == 0x000030, "Wrong size on UInteractionV3InputControl");
static_assert(offsetof(UInteractionV3InputControl, bBlendOut) == 0x000028, "Member 'UInteractionV3InputControl::bBlendOut' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3DragControl
// 0x00B0 (0x00E0 - 0x0030)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractionV3DragControl : public UInteractionV3InputControl
{
public:
	struct FDragControlDataV3                     DragControl;                                       // 0x0030(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bDisableAutoBlendOut : 1;                          // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetAdditiveRot_Pitch;                           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAdditiveRot_Yaw;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDragInterpolation;                          // 0x008C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionV3DragInterpolationType           DragInterpolationType;                             // 0x008D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionV3SpringInterpolation      SpringInterpolation;                               // 0x0094(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x34];                                      // 0x00A4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3DragControl">();
	}
	static class UInteractionV3DragControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3DragControl>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractionV3DragControl) == 0x000010, "Wrong alignment on UInteractionV3DragControl");
static_assert(sizeof(UInteractionV3DragControl) == 0x0000E0, "Wrong size on UInteractionV3DragControl");
static_assert(offsetof(UInteractionV3DragControl, DragControl) == 0x000030, "Member 'UInteractionV3DragControl::DragControl' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, OffsetAdditiveRot_Pitch) == 0x000084, "Member 'UInteractionV3DragControl::OffsetAdditiveRot_Pitch' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, OffsetAdditiveRot_Yaw) == 0x000088, "Member 'UInteractionV3DragControl::OffsetAdditiveRot_Yaw' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, bEnableDragInterpolation) == 0x00008C, "Member 'UInteractionV3DragControl::bEnableDragInterpolation' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, DragInterpolationType) == 0x00008D, "Member 'UInteractionV3DragControl::DragInterpolationType' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, Velocity) == 0x000090, "Member 'UInteractionV3DragControl::Velocity' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragControl, SpringInterpolation) == 0x000094, "Member 'UInteractionV3DragControl::SpringInterpolation' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3SequenceControl
// 0x0020 (0x0100 - 0x00E0)
class UInteractionV3SequenceControl final : public UInteractionV3DragControl
{
public:
	struct FVector2D                              ProjectDirection;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverPlaySpeed;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenAutoPlay;                                     // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoPlayPercent;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenAutoBackPlay;                                 // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Percentage;                                        // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3SequenceControl">();
	}
	static class UInteractionV3SequenceControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3SequenceControl>();
	}
};
static_assert(alignof(UInteractionV3SequenceControl) == 0x000010, "Wrong alignment on UInteractionV3SequenceControl");
static_assert(sizeof(UInteractionV3SequenceControl) == 0x000100, "Wrong size on UInteractionV3SequenceControl");
static_assert(offsetof(UInteractionV3SequenceControl, ProjectDirection) == 0x0000D8, "Member 'UInteractionV3SequenceControl::ProjectDirection' has a wrong offset!");
static_assert(offsetof(UInteractionV3SequenceControl, RecoverPlaySpeed) == 0x0000E0, "Member 'UInteractionV3SequenceControl::RecoverPlaySpeed' has a wrong offset!");
static_assert(offsetof(UInteractionV3SequenceControl, bOpenAutoPlay) == 0x0000E4, "Member 'UInteractionV3SequenceControl::bOpenAutoPlay' has a wrong offset!");
static_assert(offsetof(UInteractionV3SequenceControl, AutoPlayPercent) == 0x0000E8, "Member 'UInteractionV3SequenceControl::AutoPlayPercent' has a wrong offset!");
static_assert(offsetof(UInteractionV3SequenceControl, bOpenAutoBackPlay) == 0x0000EC, "Member 'UInteractionV3SequenceControl::bOpenAutoBackPlay' has a wrong offset!");
static_assert(offsetof(UInteractionV3SequenceControl, Percentage) == 0x0000F0, "Member 'UInteractionV3SequenceControl::Percentage' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3EyesFollowControl
// 0x00C0 (0x00F0 - 0x0030)
class UInteractionV3EyesFollowControl final : public UInteractionV3InputControl
{
public:
	struct FDragControlDataV3                     DragControl;                                       // 0x0030(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CharacterNames;                                    // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3EyesFollowControl">();
	}
	static class UInteractionV3EyesFollowControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3EyesFollowControl>();
	}
};
static_assert(alignof(UInteractionV3EyesFollowControl) == 0x000010, "Wrong alignment on UInteractionV3EyesFollowControl");
static_assert(sizeof(UInteractionV3EyesFollowControl) == 0x0000F0, "Wrong size on UInteractionV3EyesFollowControl");
static_assert(offsetof(UInteractionV3EyesFollowControl, DragControl) == 0x000030, "Member 'UInteractionV3EyesFollowControl::DragControl' has a wrong offset!");
static_assert(offsetof(UInteractionV3EyesFollowControl, CharacterNames) == 0x000080, "Member 'UInteractionV3EyesFollowControl::CharacterNames' has a wrong offset!");

// Class CharacterInteractionV3.InteractionPlayV3
// 0x0088 (0x02B0 - 0x0228)
class AInteractionPlayV3 final : public AActor
{
public:
	TArray<TSoftObjectPtr<class UScenarioStateMachine>> StateMachineTemplates;                             // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DirectorClass;                                     // 0x0238(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CameraActorClass;                                  // 0x0260(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AInteractionDirectorV3>  Director;                                          // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UScenarioStateMachine*>          StateMachinesInstances;                            // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AInteractionCameraActor> CameraActor;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionRuntimeSupport*             InteractionRuntimeSupport;                         // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UScenarioStateMachine* GetScenarioStateMachine(const class FString& InScenarioName);
	class UDataTable* GetSceneActorHideComConfig();
	bool Start(const class FString& InScenarioName);

	void Clear() const;
	bool GetActorStaticInfo(const class FName& ActorName, struct FInteractionActorStaticInfo* OutInfo) const;
	void GetCharacterActors(TArray<class AInteractionCharacterV3*>* OutCharacters) const;
	class AInteractionDirectorV3* GetInteractionDirector() const;
	bool GetScenarioActors(const class FName& ScenarioName, TSet<class FName>* OutNames) const;
	bool GetScenarioShowElementStaticInfo(const class FName& ShowElementName, struct FInteractionScenarioShowElementStaticInfo* OutInfo) const;
	bool GetStateStandByActors(const class FName& ScenaioName, const class FName& StateName, TSet<class FName>* ActorNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPlayV3">();
	}
	static class AInteractionPlayV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionPlayV3>();
	}
};
static_assert(alignof(AInteractionPlayV3) == 0x000008, "Wrong alignment on AInteractionPlayV3");
static_assert(sizeof(AInteractionPlayV3) == 0x0002B0, "Wrong size on AInteractionPlayV3");
static_assert(offsetof(AInteractionPlayV3, StateMachineTemplates) == 0x000228, "Member 'AInteractionPlayV3::StateMachineTemplates' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, DirectorClass) == 0x000238, "Member 'AInteractionPlayV3::DirectorClass' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, CameraActorClass) == 0x000260, "Member 'AInteractionPlayV3::CameraActorClass' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, Director) == 0x000288, "Member 'AInteractionPlayV3::Director' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, StateMachinesInstances) == 0x000290, "Member 'AInteractionPlayV3::StateMachinesInstances' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, CameraActor) == 0x0002A0, "Member 'AInteractionPlayV3::CameraActor' has a wrong offset!");
static_assert(offsetof(AInteractionPlayV3, InteractionRuntimeSupport) == 0x0002A8, "Member 'AInteractionPlayV3::InteractionRuntimeSupport' has a wrong offset!");

// Class CharacterInteractionV3.InteractionRuntimeSupport
// 0x0118 (0x0148 - 0x0030)
class UInteractionRuntimeSupport final : public UDataAsset
{
public:
	TMap<class FName, struct FInteractionActorStaticInfo> StaticActorInfoMap;                                // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInteractionScenarioShowElementStaticInfo> ShowElementActors;                                 // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInteractionActorNames> ScenarioActors;                                    // 0x00D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FInteractionStandByActortStaticInfo> ScenarioStandByActors;                             // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SceneActorHideComConfig;                           // 0x0130(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionRuntimeSupport">();
	}
	static class UInteractionRuntimeSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionRuntimeSupport>();
	}
};
static_assert(alignof(UInteractionRuntimeSupport) == 0x000008, "Wrong alignment on UInteractionRuntimeSupport");
static_assert(sizeof(UInteractionRuntimeSupport) == 0x000148, "Wrong size on UInteractionRuntimeSupport");
static_assert(offsetof(UInteractionRuntimeSupport, StaticActorInfoMap) == 0x000030, "Member 'UInteractionRuntimeSupport::StaticActorInfoMap' has a wrong offset!");
static_assert(offsetof(UInteractionRuntimeSupport, ShowElementActors) == 0x000080, "Member 'UInteractionRuntimeSupport::ShowElementActors' has a wrong offset!");
static_assert(offsetof(UInteractionRuntimeSupport, ScenarioActors) == 0x0000D0, "Member 'UInteractionRuntimeSupport::ScenarioActors' has a wrong offset!");
static_assert(offsetof(UInteractionRuntimeSupport, ScenarioStandByActors) == 0x000120, "Member 'UInteractionRuntimeSupport::ScenarioStandByActors' has a wrong offset!");
static_assert(offsetof(UInteractionRuntimeSupport, SceneActorHideComConfig) == 0x000130, "Member 'UInteractionRuntimeSupport::SceneActorHideComConfig' has a wrong offset!");

// Class CharacterInteractionV3.InteractionSettingsV3
// 0x0048 (0x0080 - 0x0038)
class UInteractionSettingsV3 final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        ScenarioOperateTemplate;                           // 0x0038(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ActorOperateActTemplate;                           // 0x0050(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StandbyCameraTable;                                // 0x0068(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSettingsV3">();
	}
	static class UInteractionSettingsV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionSettingsV3>();
	}
};
static_assert(alignof(UInteractionSettingsV3) == 0x000008, "Wrong alignment on UInteractionSettingsV3");
static_assert(sizeof(UInteractionSettingsV3) == 0x000080, "Wrong size on UInteractionSettingsV3");
static_assert(offsetof(UInteractionSettingsV3, ScenarioOperateTemplate) == 0x000038, "Member 'UInteractionSettingsV3::ScenarioOperateTemplate' has a wrong offset!");
static_assert(offsetof(UInteractionSettingsV3, ActorOperateActTemplate) == 0x000050, "Member 'UInteractionSettingsV3::ActorOperateActTemplate' has a wrong offset!");
static_assert(offsetof(UInteractionSettingsV3, StandbyCameraTable) == 0x000068, "Member 'UInteractionSettingsV3::StandbyCameraTable' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3CharacterAnimInstance
// 0x0120 (0x03E0 - 0x02C0)
class UInteractionV3CharacterAnimInstance final : public UAnimInstance
{
public:
	struct FVector2D                              HeadModifyOffset;                                  // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadModifyUseYawMove;                             // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSaveTransformBoneData                 CachedPostStandbyBoneNames;                        // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	float                                         KawaiiAlpha;                                       // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionV3BlendSpaceData>   BlendSpaceDatas;                                   // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               HeadRotator;                                       // 0x02F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeSpineWeight                    RuntimeSpineDatas;                                 // 0x0300(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EInteractionV3IKSlot, struct FInteractionV3IKData> IKDatas;                                           // 0x0350(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              EyesFollowHeadRot;                                 // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInteractionV3CharacterAnimLayer> LinkAnimLayerClass;                                // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimInstance*                          LinkedAnimLayer;                                   // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          IdleAnim;                                          // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           LastFrameMontage;                                  // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           ConfessionMontage;                                 // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           LastFrameBreathAdditiveMontage;                    // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayConfessionAnim(class UAnimSequence* InConfessionAnim, float InBlendInTime, float InBlendOutTime);
	void PlayLastFrameAnim(class UAnimSequence* InLastFrameAnim, class UAnimSequence* InBreathAdditiveAnim);
	void ResetSeqPlayerPos();
	void SetEyesFollowHeadRot(const struct FVector2D& InEyesFollowHeadRot);
	void SetIdleAnim(class UAnimSequence* InAnimSequence);
	void SetIdleAnimState(bool bNewState);
	void StopConfessionAnim();
	void StopLastFrameAdditiveAnim();
	void StopLastFrameAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3CharacterAnimInstance">();
	}
	static class UInteractionV3CharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3CharacterAnimInstance>();
	}
};
static_assert(alignof(UInteractionV3CharacterAnimInstance) == 0x000010, "Wrong alignment on UInteractionV3CharacterAnimInstance");
static_assert(sizeof(UInteractionV3CharacterAnimInstance) == 0x0003E0, "Wrong size on UInteractionV3CharacterAnimInstance");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, HeadModifyOffset) == 0x0002B8, "Member 'UInteractionV3CharacterAnimInstance::HeadModifyOffset' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, bHeadModifyUseYawMove) == 0x0002C0, "Member 'UInteractionV3CharacterAnimInstance::bHeadModifyUseYawMove' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, CachedPostStandbyBoneNames) == 0x0002C8, "Member 'UInteractionV3CharacterAnimInstance::CachedPostStandbyBoneNames' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, KawaiiAlpha) == 0x0002D8, "Member 'UInteractionV3CharacterAnimInstance::KawaiiAlpha' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, BlendSpaceDatas) == 0x0002E0, "Member 'UInteractionV3CharacterAnimInstance::BlendSpaceDatas' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, HeadRotator) == 0x0002F0, "Member 'UInteractionV3CharacterAnimInstance::HeadRotator' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, RuntimeSpineDatas) == 0x000300, "Member 'UInteractionV3CharacterAnimInstance::RuntimeSpineDatas' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, IKDatas) == 0x000350, "Member 'UInteractionV3CharacterAnimInstance::IKDatas' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, EyesFollowHeadRot) == 0x0003A0, "Member 'UInteractionV3CharacterAnimInstance::EyesFollowHeadRot' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, LinkAnimLayerClass) == 0x0003A8, "Member 'UInteractionV3CharacterAnimInstance::LinkAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, LinkedAnimLayer) == 0x0003B0, "Member 'UInteractionV3CharacterAnimInstance::LinkedAnimLayer' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, IdleAnim) == 0x0003B8, "Member 'UInteractionV3CharacterAnimInstance::IdleAnim' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, LastFrameMontage) == 0x0003C0, "Member 'UInteractionV3CharacterAnimInstance::LastFrameMontage' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, ConfessionMontage) == 0x0003C8, "Member 'UInteractionV3CharacterAnimInstance::ConfessionMontage' has a wrong offset!");
static_assert(offsetof(UInteractionV3CharacterAnimInstance, LastFrameBreathAdditiveMontage) == 0x0003D0, "Member 'UInteractionV3CharacterAnimInstance::LastFrameBreathAdditiveMontage' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3CharacterAnimLayer
// 0x0000 (0x02C0 - 0x02C0)
class UInteractionV3CharacterAnimLayer final : public UAnimInstance
{
public:
	float                                         KawaiiAlpha;                                       // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3CharacterAnimLayer">();
	}
	static class UInteractionV3CharacterAnimLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3CharacterAnimLayer>();
	}
};
static_assert(alignof(UInteractionV3CharacterAnimLayer) == 0x000010, "Wrong alignment on UInteractionV3CharacterAnimLayer");
static_assert(sizeof(UInteractionV3CharacterAnimLayer) == 0x0002C0, "Wrong size on UInteractionV3CharacterAnimLayer");
static_assert(offsetof(UInteractionV3CharacterAnimLayer, KawaiiAlpha) == 0x0002B8, "Member 'UInteractionV3CharacterAnimLayer::KawaiiAlpha' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3Event_Achievement
// 0x0008 (0x0030 - 0x0028)
class UInteractionV3Event_Achievement final : public UInteractionV3Event
{
public:
	int32                                         AchievementID;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInteractionArchivementComponentV3* GetArchivementComponentV3() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Event_Achievement">();
	}
	static class UInteractionV3Event_Achievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Event_Achievement>();
	}
};
static_assert(alignof(UInteractionV3Event_Achievement) == 0x000008, "Wrong alignment on UInteractionV3Event_Achievement");
static_assert(sizeof(UInteractionV3Event_Achievement) == 0x000030, "Wrong size on UInteractionV3Event_Achievement");
static_assert(offsetof(UInteractionV3Event_Achievement, AchievementID) == 0x000028, "Member 'UInteractionV3Event_Achievement::AchievementID' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3Event_ConditionCompleted
// 0x0008 (0x0030 - 0x0028)
class UInteractionV3Event_ConditionCompleted final : public UInteractionV3Event
{
public:
	int32                                         ConditionID;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefresh;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Event_ConditionCompleted">();
	}
	static class UInteractionV3Event_ConditionCompleted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Event_ConditionCompleted>();
	}
};
static_assert(alignof(UInteractionV3Event_ConditionCompleted) == 0x000008, "Wrong alignment on UInteractionV3Event_ConditionCompleted");
static_assert(sizeof(UInteractionV3Event_ConditionCompleted) == 0x000030, "Wrong size on UInteractionV3Event_ConditionCompleted");
static_assert(offsetof(UInteractionV3Event_ConditionCompleted, ConditionID) == 0x000028, "Member 'UInteractionV3Event_ConditionCompleted::ConditionID' has a wrong offset!");
static_assert(offsetof(UInteractionV3Event_ConditionCompleted, bRefresh) == 0x00002C, "Member 'UInteractionV3Event_ConditionCompleted::bRefresh' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3Event_EasterEgg
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3Event_EasterEgg final : public UInteractionV3Event
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Event_EasterEgg">();
	}
	static class UInteractionV3Event_EasterEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Event_EasterEgg>();
	}
};
static_assert(alignof(UInteractionV3Event_EasterEgg) == 0x000008, "Wrong alignment on UInteractionV3Event_EasterEgg");
static_assert(sizeof(UInteractionV3Event_EasterEgg) == 0x000028, "Wrong size on UInteractionV3Event_EasterEgg");

// Class CharacterInteractionV3.InteractionV3FunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3FunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActiveCameraBlendOut(const class UObject* WorldContextObject, bool bInForceCameraBlend);
	static struct FVector CalculateBezierPoint(float T, const struct FVector& Current, const struct FVector& Target);
	static class AUniversalCameraActor* CreateUniversalCamera(class UObject* WorldContextObject);
	static void DeactiveCameraBlendOut(const class UObject* WorldContextObject);
	static EScenarioNodeInnerState GetActiveScenarioNodeInnerState();
	static class UScenarioStateNode* GetActiveScenarioStateNode();
	static class FString GetCurrentOperateName();
	static struct FVector GetOperateDragOffset();
	static struct FVector2D GetOperateDragValue();
	static class UInteractionV3InputControl* GetOperateInputControl();
	static struct FVector GetTiltOffset(const struct FVector& InOffset, const struct FRotator& CameraRotation, const float& OffsetAdditiveRot_Pitch, const float& OffsetAdditiveRot_Yaw);
	static bool LineTraceComponentOnMousePos(class UObject* WorldContextObject, struct FHitResult* OutHit, class UPrimitiveComponent* InPrimitiveComp, bool bUsePressedPos);
	static void LockCameraBlendOutChange(const class UObject* WorldContextObject, bool bNewValue);
	static void SetActorHiddenInGame(class AInteractionActorV3* InteractionActorV3, bool bHidden);
	static class AUniversalCameraActor* SetViewTargetToUniversalCamera(class UObject* WorldContextObject, struct FUniversalCameraInfo* CameraInfo, class FName ModeName);
	static float SimpleFloatSpringInterp(float Current, float Target, float& Velocity, float Stiffness, float Damping, float DeltaTime, float VelocityClamp);
	static struct FVector SimpleVectorSpringInterp(const struct FVector& Current, const struct FVector& Target, struct FVector& Velocity, const struct FVector& Stiffness, const struct FVector& Damping, float DeltaTime, float VelocityClamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3FunctionLibrary">();
	}
	static class UInteractionV3FunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3FunctionLibrary>();
	}
};
static_assert(alignof(UInteractionV3FunctionLibrary) == 0x000008, "Wrong alignment on UInteractionV3FunctionLibrary");
static_assert(sizeof(UInteractionV3FunctionLibrary) == 0x000028, "Wrong size on UInteractionV3FunctionLibrary");

// Class CharacterInteractionV3.InteractionV3CableFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3CableFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetCableLengthRuntime(const TArray<struct FVector>& CablePoints);
	static float GetCableLengthRuntimeAtIndex(const TArray<struct FVector>& CablePoints, int32 Index_0);
	static TArray<struct FVector> GetCablePoints(const class UCableComponent* CableComponent, const TArray<struct FVector>& AdditionalPoints, bool bToEnd);
	static struct FVector GetLocationOnCableByPercentage(const TArray<struct FVector>& CablePoints, float _percentage);
	static int32 GetLowestLocationIndexOnCable(const TArray<struct FVector>& CablePoints);
	static struct FVector GetLowestLocationOnCable(const TArray<struct FVector>& CablePoints);
	static float GetPercentageByParticleIndex(const TArray<struct FVector>& CablePoints, int32 _Index);
	static TArray<struct FVector> GetSideLocationOnCableByPercentage(const TArray<struct FVector>& CablePoints, float _percentage);
	static float SpringInterpFloat(float DeltaTime, float _Target, float _Current, float* _Velocity, const TArray<struct FVector>& CablePoints, float _Stiffness, float _Damping, float _VelocityClamp, float _HeightScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3CableFunctionLibrary">();
	}
	static class UInteractionV3CableFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3CableFunctionLibrary>();
	}
};
static_assert(alignof(UInteractionV3CableFunctionLibrary) == 0x000008, "Wrong alignment on UInteractionV3CableFunctionLibrary");
static_assert(sizeof(UInteractionV3CableFunctionLibrary) == 0x000028, "Wrong size on UInteractionV3CableFunctionLibrary");

// Class CharacterInteractionV3.InteractionV3Lib
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3Lib final : public UBlueprintFunctionLibrary
{
public:
	static void ClearInteractionStat();
	static class FString GetInteractionStringStat(const class FString& StatName);
	static bool GetInterationBoolStat(const class FString& StatName);
	static int32 GetInterationIntStat(const class FString& StatName);
	static bool HasInteractionBoolStat(const class FString& StatName);
	static bool HasInteractionIntStat(const class FString& StatName);
	static bool HasInteractionStringStat(const class FString& StatName);
	static void SetInteractionBoolStat(const class FString& StatName, bool StatValue);
	static void SetInteractionIntStat(const class FString& StatName, int32 StatValue);
	static void SetInteractionStringStat(const class FString& StatName, const class FString& StatValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Lib">();
	}
	static class UInteractionV3Lib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Lib>();
	}
};
static_assert(alignof(UInteractionV3Lib) == 0x000008, "Wrong alignment on UInteractionV3Lib");
static_assert(sizeof(UInteractionV3Lib) == 0x000028, "Wrong size on UInteractionV3Lib");

// Class CharacterInteractionV3.InteractionV3PhysHandleComponent
// 0x0000 (0x0160 - 0x0160)
class UInteractionV3PhysHandleComponent final : public UPhysicsHandleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3PhysHandleComponent">();
	}
	static class UInteractionV3PhysHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3PhysHandleComponent>();
	}
};
static_assert(alignof(UInteractionV3PhysHandleComponent) == 0x000010, "Wrong alignment on UInteractionV3PhysHandleComponent");
static_assert(sizeof(UInteractionV3PhysHandleComponent) == 0x000160, "Wrong size on UInteractionV3PhysHandleComponent");

// Class CharacterInteractionV3.InteractionV3PhysicsControlComponent
// 0x0050 (0x0480 - 0x0430)
class UInteractionV3PhysicsControlComponent final : public UBaseGamePhysicsControlComponent
{
public:
	uint8                                         Pad_430[0x28];                                     // 0x0430(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MaintainWorldSpaceRelativeControlNames;            // 0x0458(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRigidBodyRelativeControlRecord> RigidBodyRelativeControls;                         // 0x0468(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConditionalCreateMaintainWorldSpaceRelativeControl(class FName Name_0, class UMeshComponent* ParentMeshComponent, const class FName ParentBoneName, class UMeshComponent* ChildMeshComponent, const class FName ChildBoneName, const class FName Set, const class FName AdditionalSetName);
	bool ConditionalDestroyAllMaintainWorldSpaceRelativeControls();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3PhysicsControlComponent">();
	}
	static class UInteractionV3PhysicsControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3PhysicsControlComponent>();
	}
};
static_assert(alignof(UInteractionV3PhysicsControlComponent) == 0x000010, "Wrong alignment on UInteractionV3PhysicsControlComponent");
static_assert(sizeof(UInteractionV3PhysicsControlComponent) == 0x000480, "Wrong size on UInteractionV3PhysicsControlComponent");
static_assert(offsetof(UInteractionV3PhysicsControlComponent, MaintainWorldSpaceRelativeControlNames) == 0x000458, "Member 'UInteractionV3PhysicsControlComponent::MaintainWorldSpaceRelativeControlNames' has a wrong offset!");
static_assert(offsetof(UInteractionV3PhysicsControlComponent, RigidBodyRelativeControls) == 0x000468, "Member 'UInteractionV3PhysicsControlComponent::RigidBodyRelativeControls' has a wrong offset!");

// Class CharacterInteractionV3.PhysicsAssetModifierEvent
// 0x0010 (0x0038 - 0x0028)
class UPhysicsAssetModifierEvent final : public UInteractionV3Event
{
public:
	TArray<struct FCharacterPhysicsAssetModifier> PhysicsAssetModifiers;                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsAssetModifierEvent">();
	}
	static class UPhysicsAssetModifierEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsAssetModifierEvent>();
	}
};
static_assert(alignof(UPhysicsAssetModifierEvent) == 0x000008, "Wrong alignment on UPhysicsAssetModifierEvent");
static_assert(sizeof(UPhysicsAssetModifierEvent) == 0x000038, "Wrong size on UPhysicsAssetModifierEvent");
static_assert(offsetof(UPhysicsAssetModifierEvent, PhysicsAssetModifiers) == 0x000028, "Member 'UPhysicsAssetModifierEvent::PhysicsAssetModifiers' has a wrong offset!");

// Class CharacterInteractionV3.CreatePhysicsControlEvent
// 0x0038 (0x0060 - 0x0028)
class UCreatePhysicsControlEvent final : public UInteractionV3Event
{
public:
	class FName                                   ControlName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetName;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentActorName;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParentBody;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentBoneName;                                    // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildActorName;                                    // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChildBody;                                      // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ChildBoneName;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatePhysicsControlEvent">();
	}
	static class UCreatePhysicsControlEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatePhysicsControlEvent>();
	}
};
static_assert(alignof(UCreatePhysicsControlEvent) == 0x000008, "Wrong alignment on UCreatePhysicsControlEvent");
static_assert(sizeof(UCreatePhysicsControlEvent) == 0x000060, "Wrong size on UCreatePhysicsControlEvent");
static_assert(offsetof(UCreatePhysicsControlEvent, ControlName) == 0x000028, "Member 'UCreatePhysicsControlEvent::ControlName' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, SetName) == 0x000030, "Member 'UCreatePhysicsControlEvent::SetName' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, ParentActorName) == 0x000038, "Member 'UCreatePhysicsControlEvent::ParentActorName' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, bIsParentBody) == 0x000040, "Member 'UCreatePhysicsControlEvent::bIsParentBody' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, ParentBoneName) == 0x000044, "Member 'UCreatePhysicsControlEvent::ParentBoneName' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, ChildActorName) == 0x00004C, "Member 'UCreatePhysicsControlEvent::ChildActorName' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, bIsChildBody) == 0x000054, "Member 'UCreatePhysicsControlEvent::bIsChildBody' has a wrong offset!");
static_assert(offsetof(UCreatePhysicsControlEvent, ChildBoneName) == 0x000058, "Member 'UCreatePhysicsControlEvent::ChildBoneName' has a wrong offset!");

// Class CharacterInteractionV3.DestroyPhysicsControlEvent
// 0x0020 (0x0048 - 0x0028)
class UDestroyPhysicsControlEvent final : public UInteractionV3Event
{
public:
	class FName                                   ControlName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetName;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBody;                                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyPhysicsControlEvent">();
	}
	static class UDestroyPhysicsControlEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyPhysicsControlEvent>();
	}
};
static_assert(alignof(UDestroyPhysicsControlEvent) == 0x000008, "Wrong alignment on UDestroyPhysicsControlEvent");
static_assert(sizeof(UDestroyPhysicsControlEvent) == 0x000048, "Wrong size on UDestroyPhysicsControlEvent");
static_assert(offsetof(UDestroyPhysicsControlEvent, ControlName) == 0x000028, "Member 'UDestroyPhysicsControlEvent::ControlName' has a wrong offset!");
static_assert(offsetof(UDestroyPhysicsControlEvent, SetName) == 0x000030, "Member 'UDestroyPhysicsControlEvent::SetName' has a wrong offset!");
static_assert(offsetof(UDestroyPhysicsControlEvent, ActorName) == 0x000038, "Member 'UDestroyPhysicsControlEvent::ActorName' has a wrong offset!");
static_assert(offsetof(UDestroyPhysicsControlEvent, bIsBody) == 0x000040, "Member 'UDestroyPhysicsControlEvent::bIsBody' has a wrong offset!");

// Class CharacterInteractionV3.AlignTransformToCharacterEvent
// 0x0018 (0x0040 - 0x0028)
class UAlignTransformToCharacterEvent final : public UInteractionV3Event
{
public:
	class FName                                   MasterActorName;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignAllSubActor;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubActorName;                                      // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignTranslation;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignRotation;                                     // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignScale;                                        // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlignTransformToCharacterEvent">();
	}
	static class UAlignTransformToCharacterEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlignTransformToCharacterEvent>();
	}
};
static_assert(alignof(UAlignTransformToCharacterEvent) == 0x000008, "Wrong alignment on UAlignTransformToCharacterEvent");
static_assert(sizeof(UAlignTransformToCharacterEvent) == 0x000040, "Wrong size on UAlignTransformToCharacterEvent");
static_assert(offsetof(UAlignTransformToCharacterEvent, MasterActorName) == 0x000028, "Member 'UAlignTransformToCharacterEvent::MasterActorName' has a wrong offset!");
static_assert(offsetof(UAlignTransformToCharacterEvent, AlignAllSubActor) == 0x000030, "Member 'UAlignTransformToCharacterEvent::AlignAllSubActor' has a wrong offset!");
static_assert(offsetof(UAlignTransformToCharacterEvent, SubActorName) == 0x000034, "Member 'UAlignTransformToCharacterEvent::SubActorName' has a wrong offset!");
static_assert(offsetof(UAlignTransformToCharacterEvent, AlignTranslation) == 0x00003C, "Member 'UAlignTransformToCharacterEvent::AlignTranslation' has a wrong offset!");
static_assert(offsetof(UAlignTransformToCharacterEvent, AlignRotation) == 0x00003D, "Member 'UAlignTransformToCharacterEvent::AlignRotation' has a wrong offset!");
static_assert(offsetof(UAlignTransformToCharacterEvent, AlignScale) == 0x00003E, "Member 'UAlignTransformToCharacterEvent::AlignScale' has a wrong offset!");

// Class CharacterInteractionV3.EyeLookAtBoneEvent
// 0x0018 (0x0040 - 0x0028)
class UEyeLookAtBoneEvent final : public UInteractionV3Event
{
public:
	class FName                                   ActorName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionLookAtBoneData             Boneinfo;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EyeLookAtBoneEvent">();
	}
	static class UEyeLookAtBoneEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEyeLookAtBoneEvent>();
	}
};
static_assert(alignof(UEyeLookAtBoneEvent) == 0x000008, "Wrong alignment on UEyeLookAtBoneEvent");
static_assert(sizeof(UEyeLookAtBoneEvent) == 0x000040, "Wrong size on UEyeLookAtBoneEvent");
static_assert(offsetof(UEyeLookAtBoneEvent, ActorName) == 0x000028, "Member 'UEyeLookAtBoneEvent::ActorName' has a wrong offset!");
static_assert(offsetof(UEyeLookAtBoneEvent, Boneinfo) == 0x000030, "Member 'UEyeLookAtBoneEvent::Boneinfo' has a wrong offset!");

// Class CharacterInteractionV3.ClearEyeLookAtBoneEvent
// 0x0008 (0x0030 - 0x0028)
class UClearEyeLookAtBoneEvent final : public UInteractionV3Event
{
public:
	class FName                                   ActorName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearEyeLookAtBoneEvent">();
	}
	static class UClearEyeLookAtBoneEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearEyeLookAtBoneEvent>();
	}
};
static_assert(alignof(UClearEyeLookAtBoneEvent) == 0x000008, "Wrong alignment on UClearEyeLookAtBoneEvent");
static_assert(sizeof(UClearEyeLookAtBoneEvent) == 0x000030, "Wrong size on UClearEyeLookAtBoneEvent");
static_assert(offsetof(UClearEyeLookAtBoneEvent, ActorName) == 0x000028, "Member 'UClearEyeLookAtBoneEvent::ActorName' has a wrong offset!");

// Class CharacterInteractionV3.SetCharacterShoeEvent
// 0x0010 (0x0038 - 0x0028)
class USetCharacterShoeEvent final : public UInteractionV3Event
{
public:
	class FName                                   ActorName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShoeTypes;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCharacterShoeEvent">();
	}
	static class USetCharacterShoeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCharacterShoeEvent>();
	}
};
static_assert(alignof(USetCharacterShoeEvent) == 0x000008, "Wrong alignment on USetCharacterShoeEvent");
static_assert(sizeof(USetCharacterShoeEvent) == 0x000038, "Wrong size on USetCharacterShoeEvent");
static_assert(offsetof(USetCharacterShoeEvent, ActorName) == 0x000028, "Member 'USetCharacterShoeEvent::ActorName' has a wrong offset!");
static_assert(offsetof(USetCharacterShoeEvent, ShoeTypes) == 0x000030, "Member 'USetCharacterShoeEvent::ShoeTypes' has a wrong offset!");
static_assert(offsetof(USetCharacterShoeEvent, bHide) == 0x000034, "Member 'USetCharacterShoeEvent::bHide' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3Trigger
// 0x0000 (0x0028 - 0x0028)
class UInteractionV3Trigger : public UObject
{
public:
	bool CanTrigger() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3Trigger">();
	}
	static class UInteractionV3Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3Trigger>();
	}
};
static_assert(alignof(UInteractionV3Trigger) == 0x000008, "Wrong alignment on UInteractionV3Trigger");
static_assert(sizeof(UInteractionV3Trigger) == 0x000028, "Wrong size on UInteractionV3Trigger");

// Class CharacterInteractionV3.ScenarioOperateContextTrigger
// 0x0000 (0x0028 - 0x0028)
class UScenarioOperateContextTrigger : public UInteractionV3Trigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioOperateContextTrigger">();
	}
	static class UScenarioOperateContextTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioOperateContextTrigger>();
	}
};
static_assert(alignof(UScenarioOperateContextTrigger) == 0x000008, "Wrong alignment on UScenarioOperateContextTrigger");
static_assert(sizeof(UScenarioOperateContextTrigger) == 0x000028, "Wrong size on UScenarioOperateContextTrigger");

// Class CharacterInteractionV3.ScenarioOperateForbidTrigger
// 0x0000 (0x0028 - 0x0028)
class UScenarioOperateForbidTrigger final : public UScenarioOperateContextTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioOperateForbidTrigger">();
	}
	static class UScenarioOperateForbidTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioOperateForbidTrigger>();
	}
};
static_assert(alignof(UScenarioOperateForbidTrigger) == 0x000008, "Wrong alignment on UScenarioOperateForbidTrigger");
static_assert(sizeof(UScenarioOperateForbidTrigger) == 0x000028, "Wrong size on UScenarioOperateForbidTrigger");

// Class CharacterInteractionV3.InteractionV3DragTrigger
// 0x0010 (0x0038 - 0x0028)
class UInteractionV3DragTrigger final : public UScenarioOperateContextTrigger
{
public:
	struct FVector2D                              DragLimit;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionDragValueCompareType              XCompareType;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionDragValueCompareType              YCompareType;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompareLength;                                  // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3DragTrigger">();
	}
	static class UInteractionV3DragTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3DragTrigger>();
	}
};
static_assert(alignof(UInteractionV3DragTrigger) == 0x000008, "Wrong alignment on UInteractionV3DragTrigger");
static_assert(sizeof(UInteractionV3DragTrigger) == 0x000038, "Wrong size on UInteractionV3DragTrigger");
static_assert(offsetof(UInteractionV3DragTrigger, DragLimit) == 0x000028, "Member 'UInteractionV3DragTrigger::DragLimit' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragTrigger, XCompareType) == 0x000030, "Member 'UInteractionV3DragTrigger::XCompareType' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragTrigger, YCompareType) == 0x000031, "Member 'UInteractionV3DragTrigger::YCompareType' has a wrong offset!");
static_assert(offsetof(UInteractionV3DragTrigger, bIsCompareLength) == 0x000032, "Member 'UInteractionV3DragTrigger::bIsCompareLength' has a wrong offset!");

// Class CharacterInteractionV3.InteractionV3SequenceTrigger
// 0x0008 (0x0030 - 0x0028)
class UInteractionV3SequenceTrigger final : public UScenarioOperateContextTrigger
{
public:
	float                                         Threshold;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionV3SequenceTrigger">();
	}
	static class UInteractionV3SequenceTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionV3SequenceTrigger>();
	}
};
static_assert(alignof(UInteractionV3SequenceTrigger) == 0x000008, "Wrong alignment on UInteractionV3SequenceTrigger");
static_assert(sizeof(UInteractionV3SequenceTrigger) == 0x000030, "Wrong size on UInteractionV3SequenceTrigger");
static_assert(offsetof(UInteractionV3SequenceTrigger, Threshold) == 0x000028, "Member 'UInteractionV3SequenceTrigger::Threshold' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioOperateStateTrigger
// 0x0008 (0x0030 - 0x0028)
class UScenarioOperateStateTrigger final : public UScenarioOperateContextTrigger
{
public:
	int32                                         OperateStates;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioOperateStateTrigger">();
	}
	static class UScenarioOperateStateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioOperateStateTrigger>();
	}
};
static_assert(alignof(UScenarioOperateStateTrigger) == 0x000008, "Wrong alignment on UScenarioOperateStateTrigger");
static_assert(sizeof(UScenarioOperateStateTrigger) == 0x000030, "Wrong size on UScenarioOperateStateTrigger");
static_assert(offsetof(UScenarioOperateStateTrigger, OperateStates) == 0x000028, "Member 'UScenarioOperateStateTrigger::OperateStates' has a wrong offset!");

// Class CharacterInteractionV3.InteractionOperateV3
// 0x0020 (0x0048 - 0x0028)
class UInteractionOperateV3 final : public UObject
{
public:
	class UInteractionV3InputCollision*           InputCollision;                                    // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScenarioOperate*                       ScenarioOperate;                                   // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionV3CharacterHolyLight> HolyLightData;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateV3">();
	}
	static class UInteractionOperateV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateV3>();
	}
};
static_assert(alignof(UInteractionOperateV3) == 0x000008, "Wrong alignment on UInteractionOperateV3");
static_assert(sizeof(UInteractionOperateV3) == 0x000048, "Wrong size on UInteractionOperateV3");
static_assert(offsetof(UInteractionOperateV3, InputCollision) == 0x000028, "Member 'UInteractionOperateV3::InputCollision' has a wrong offset!");
static_assert(offsetof(UInteractionOperateV3, ScenarioOperate) == 0x000030, "Member 'UInteractionOperateV3::ScenarioOperate' has a wrong offset!");
static_assert(offsetof(UInteractionOperateV3, HolyLightData) == 0x000038, "Member 'UInteractionOperateV3::HolyLightData' has a wrong offset!");

// Class CharacterInteractionV3.PhysicsControlProfileEvent
// 0x0050 (0x0078 - 0x0028)
class UPhysicsControlProfileEvent final : public UInteractionV3Event
{
public:
	TMap<class FName, struct FInteractionV3PhysProfileModifier> ActorNames;                                        // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlProfileEvent">();
	}
	static class UPhysicsControlProfileEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlProfileEvent>();
	}
};
static_assert(alignof(UPhysicsControlProfileEvent) == 0x000008, "Wrong alignment on UPhysicsControlProfileEvent");
static_assert(sizeof(UPhysicsControlProfileEvent) == 0x000078, "Wrong size on UPhysicsControlProfileEvent");
static_assert(offsetof(UPhysicsControlProfileEvent, ActorNames) == 0x000028, "Member 'UPhysicsControlProfileEvent::ActorNames' has a wrong offset!");

// Class CharacterInteractionV3.LevelSequenceUnit
// 0x0010 (0x0040 - 0x0030)
class ULevelSequenceUnit final : public UShowElementV3Unit
{
public:
	class ULevelSequence*                         Sequence;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFrame;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFrame;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelSequenceUnit">();
	}
	static class ULevelSequenceUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelSequenceUnit>();
	}
};
static_assert(alignof(ULevelSequenceUnit) == 0x000008, "Wrong alignment on ULevelSequenceUnit");
static_assert(sizeof(ULevelSequenceUnit) == 0x000040, "Wrong size on ULevelSequenceUnit");
static_assert(offsetof(ULevelSequenceUnit, Sequence) == 0x000030, "Member 'ULevelSequenceUnit::Sequence' has a wrong offset!");
static_assert(offsetof(ULevelSequenceUnit, StartFrame) == 0x000038, "Member 'ULevelSequenceUnit::StartFrame' has a wrong offset!");
static_assert(offsetof(ULevelSequenceUnit, EndFrame) == 0x00003C, "Member 'ULevelSequenceUnit::EndFrame' has a wrong offset!");

// Class CharacterInteractionV3.LipSyncSoundUnit
// 0x0048 (0x0078 - 0x0030)
class ULipSyncSoundUnit final : public UShowElementV3Unit
{
public:
	struct FInteractionVoiceConfig                VoiceConfig;                                       // 0x0030(0x0048)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LipSyncSoundUnit">();
	}
	static class ULipSyncSoundUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULipSyncSoundUnit>();
	}
};
static_assert(alignof(ULipSyncSoundUnit) == 0x000008, "Wrong alignment on ULipSyncSoundUnit");
static_assert(sizeof(ULipSyncSoundUnit) == 0x000078, "Wrong size on ULipSyncSoundUnit");
static_assert(offsetof(ULipSyncSoundUnit, VoiceConfig) == 0x000030, "Member 'ULipSyncSoundUnit::VoiceConfig' has a wrong offset!");

// Class CharacterInteractionV3.PlaceHolderAsset
// 0x0000 (0x0028 - 0x0028)
class UPlaceHolderAsset final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceHolderAsset">();
	}
	static class UPlaceHolderAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceHolderAsset>();
	}
};
static_assert(alignof(UPlaceHolderAsset) == 0x000008, "Wrong alignment on UPlaceHolderAsset");
static_assert(sizeof(UPlaceHolderAsset) == 0x000028, "Wrong size on UPlaceHolderAsset");

// Class CharacterInteractionV3.ScenarioMagicCardLittleGame
// 0x0000 (0x0068 - 0x0068)
class UScenarioMagicCardLittleGame final : public UScenarioStandardLittleGame
{
public:
	static struct FRotator QInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioMagicCardLittleGame">();
	}
	static class UScenarioMagicCardLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioMagicCardLittleGame>();
	}
};
static_assert(alignof(UScenarioMagicCardLittleGame) == 0x000008, "Wrong alignment on UScenarioMagicCardLittleGame");
static_assert(sizeof(UScenarioMagicCardLittleGame) == 0x000068, "Wrong size on UScenarioMagicCardLittleGame");

// Class CharacterInteractionV3.ScenarioOperate
// 0x0080 (0x00A8 - 0x0028)
class UScenarioOperate final : public UObject
{
public:
	class UInteractionV3InputControl*             InputControl;                                      // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OperatingHeadRotScale;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OperatingHeadRotInterpSpeed;                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OperateCameraID;                                   // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorOperateActInfo>           ActorOperateActs;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            StartEvents;                                       // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            UpdateEvents;                                      // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            EndEvents;                                         // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UScenarioOperateContextTrigger*         CompleteTrigger;                                   // 0x0088(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            CompleteEvents;                                    // 0x0090(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x1];                                       // 0x00A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EScenarioOperateState                         OperateState;                                      // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompleted;                                        // 0x00A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EScenarioOperateState GetOperateState() const;
	TArray<class FName> GetStandbyCameraIDs() const;
	bool IsCompleteAndBlendOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioOperate">();
	}
	static class UScenarioOperate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioOperate>();
	}
};
static_assert(alignof(UScenarioOperate) == 0x000008, "Wrong alignment on UScenarioOperate");
static_assert(sizeof(UScenarioOperate) == 0x0000A8, "Wrong size on UScenarioOperate");
static_assert(offsetof(UScenarioOperate, InputControl) == 0x000028, "Member 'UScenarioOperate::InputControl' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, OperatingHeadRotScale) == 0x000030, "Member 'UScenarioOperate::OperatingHeadRotScale' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, OperatingHeadRotInterpSpeed) == 0x000038, "Member 'UScenarioOperate::OperatingHeadRotInterpSpeed' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, OperateCameraID) == 0x00003C, "Member 'UScenarioOperate::OperateCameraID' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, ActorOperateActs) == 0x000048, "Member 'UScenarioOperate::ActorOperateActs' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, StartEvents) == 0x000058, "Member 'UScenarioOperate::StartEvents' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, UpdateEvents) == 0x000068, "Member 'UScenarioOperate::UpdateEvents' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, EndEvents) == 0x000078, "Member 'UScenarioOperate::EndEvents' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, CompleteTrigger) == 0x000088, "Member 'UScenarioOperate::CompleteTrigger' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, CompleteEvents) == 0x000090, "Member 'UScenarioOperate::CompleteEvents' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, OperateState) == 0x0000A1, "Member 'UScenarioOperate::OperateState' has a wrong offset!");
static_assert(offsetof(UScenarioOperate, bCompleted) == 0x0000A2, "Member 'UScenarioOperate::bCompleted' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioPropLittleGame
// 0x0000 (0x0068 - 0x0068)
class UScenarioPropLittleGame final : public UScenarioStandardLittleGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioPropLittleGame">();
	}
	static class UScenarioPropLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioPropLittleGame>();
	}
};
static_assert(alignof(UScenarioPropLittleGame) == 0x000008, "Wrong alignment on UScenarioPropLittleGame");
static_assert(sizeof(UScenarioPropLittleGame) == 0x000068, "Wrong size on UScenarioPropLittleGame");

// Class CharacterInteractionV3.ScenarioStateComponent
// 0x0010 (0x00C0 - 0x00B0)
class UScenarioStateComponent final : public UActorComponent
{
public:
	class UScenarioStateMachine*                  ActiveStateMachine;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScenarioStateMachine*                  LastActiveStateMachine;                            // 0x00B8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Play(class UScenarioStateMachine* InScenario);

	class UScenarioStateMachine* GetActiveStateMachine() const;
	class AInteractionDirectorV3* GetInteractionDirector() const;
	class UScenarioStateMachine* GetLastActiveStateMachine() const;
	bool TransitionState(const class FString& InScenarioStateName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateComponent">();
	}
	static class UScenarioStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateComponent>();
	}
};
static_assert(alignof(UScenarioStateComponent) == 0x000008, "Wrong alignment on UScenarioStateComponent");
static_assert(sizeof(UScenarioStateComponent) == 0x0000C0, "Wrong size on UScenarioStateComponent");
static_assert(offsetof(UScenarioStateComponent, ActiveStateMachine) == 0x0000B0, "Member 'UScenarioStateComponent::ActiveStateMachine' has a wrong offset!");
static_assert(offsetof(UScenarioStateComponent, LastActiveStateMachine) == 0x0000B8, "Member 'UScenarioStateComponent::LastActiveStateMachine' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateMachine
// 0x0100 (0x0128 - 0x0028)
class UScenarioStateMachine final : public UObject
{
public:
	TArray<class UScenarioStateNode*>             States;                                            // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ScenarioName;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScenarioActorInfo>             ActorInfos;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   InitShowElementName;                               // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgeLevel;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionV3Event*>            InitializeEvents;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            StartEvents;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            UpdateEvents;                                      // 0x0088(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            EndEvents;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Processor;                                         // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScenarioStateContext                  StateContext;                                      // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UScenarioStateNode*                     ActiveNode;                                        // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScenarioStateMachineStandardProcessor* ProcessorInstance;                                 // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInitialize : 1;                                   // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScenarioShowElementPlayInfo           RecordElementPlayInfo;                             // 0x00F8(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void End();
	void EndLastShowElement();
	const struct FScenarioShowElementPlayInfo GetConstRecordShowElementPlayInfo();
	struct FScenarioShowElementPlayInfo GetRecordShowElementPlayInfo();
	struct FScenarioStateContext GetScenarioStateContext();
	void Initialize();
	void OnPlayShowElement(const struct FScenarioShowElementPlayInfo& InPlayInfo);
	void QuitLastShowElement();
	void Start(const struct FScenarioStateContext& InContext);
	bool Transition(const class FString& ToStateNodeName);
	void Update(float DeltaSeconds);

	class UScenarioStateNode* GetActiveNode() const;
	class FString GetDebugInfo() const;
	class UScenarioStateMachineStandardProcessor* GetProcessor() const;
	class FString GetRecordPlayShowElement() const;
	class UScenarioStateNode* GetStateNodeByName(const class FString& InStateName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateMachine">();
	}
	static class UScenarioStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateMachine>();
	}
};
static_assert(alignof(UScenarioStateMachine) == 0x000008, "Wrong alignment on UScenarioStateMachine");
static_assert(sizeof(UScenarioStateMachine) == 0x000128, "Wrong size on UScenarioStateMachine");
static_assert(offsetof(UScenarioStateMachine, States) == 0x000028, "Member 'UScenarioStateMachine::States' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, ScenarioName) == 0x000038, "Member 'UScenarioStateMachine::ScenarioName' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, ActorInfos) == 0x000048, "Member 'UScenarioStateMachine::ActorInfos' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, InitShowElementName) == 0x000058, "Member 'UScenarioStateMachine::InitShowElementName' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, AgeLevel) == 0x000060, "Member 'UScenarioStateMachine::AgeLevel' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, InitializeEvents) == 0x000068, "Member 'UScenarioStateMachine::InitializeEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, StartEvents) == 0x000078, "Member 'UScenarioStateMachine::StartEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, UpdateEvents) == 0x000088, "Member 'UScenarioStateMachine::UpdateEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, EndEvents) == 0x000098, "Member 'UScenarioStateMachine::EndEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, bDebug) == 0x0000A8, "Member 'UScenarioStateMachine::bDebug' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, Processor) == 0x0000B0, "Member 'UScenarioStateMachine::Processor' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, StateContext) == 0x0000D8, "Member 'UScenarioStateMachine::StateContext' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, ActiveNode) == 0x0000E0, "Member 'UScenarioStateMachine::ActiveNode' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, ProcessorInstance) == 0x0000E8, "Member 'UScenarioStateMachine::ProcessorInstance' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachine, RecordElementPlayInfo) == 0x0000F8, "Member 'UScenarioStateMachine::RecordElementPlayInfo' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateMachineProcessorBase
// 0x0008 (0x0030 - 0x0028)
class UScenarioStateMachineProcessorBase : public UObject
{
public:
	TWeakObjectPtr<class UScenarioStateMachine>   StateMachine;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void End();
	void Initialize(class UScenarioStateMachine* InStateMachine);
	void OnEnd();
	void OnInitialize();
	void OnPostStart();
	void OnStart();
	void OnUpdate(float DeltaSeconds);
	void PostStart();
	void Start();
	void Update(float DeltaSeconds);

	class AInteractionDirectorV3* GetDirectorV3() const;
	class UScenarioStateMachine* GetStateMachine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateMachineProcessorBase">();
	}
	static class UScenarioStateMachineProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateMachineProcessorBase>();
	}
};
static_assert(alignof(UScenarioStateMachineProcessorBase) == 0x000008, "Wrong alignment on UScenarioStateMachineProcessorBase");
static_assert(sizeof(UScenarioStateMachineProcessorBase) == 0x000030, "Wrong size on UScenarioStateMachineProcessorBase");
static_assert(offsetof(UScenarioStateMachineProcessorBase, StateMachine) == 0x000028, "Member 'UScenarioStateMachineProcessorBase::StateMachine' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateMachineStandardProcessor
// 0x0018 (0x0048 - 0x0030)
class UScenarioStateMachineStandardProcessor : public UScenarioStateMachineProcessorBase
{
public:
	class FString                                 PlaySequenceReason;                                // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALevelSequenceActor>     PlaySequence;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearLevelSequence();
	class FString GetPlaySequenceReason();
	void K2_OnPlayShowElement(const class FString& InElementName);
	void OnPlayShowElement(const class FString& InElementName);
	void OnSequenceFinished();
	void PlayInitLevelSequence(const TSoftObjectPtr<class ULevelSequence> InSequence);
	class ALevelSequenceActor* PlayLevelSequence(const TSoftObjectPtr<class ULevelSequence> InSequence, const class FString& InReason, const int32 StartFrame, const int32 Duration);

	class AActor* GetActorByName(const class FName& InActorName) const;
	class ALevelSequenceActor* GetPlaySequence() const;
	void StopVoice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateMachineStandardProcessor">();
	}
	static class UScenarioStateMachineStandardProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateMachineStandardProcessor>();
	}
};
static_assert(alignof(UScenarioStateMachineStandardProcessor) == 0x000008, "Wrong alignment on UScenarioStateMachineStandardProcessor");
static_assert(sizeof(UScenarioStateMachineStandardProcessor) == 0x000048, "Wrong size on UScenarioStateMachineStandardProcessor");
static_assert(offsetof(UScenarioStateMachineStandardProcessor, PlaySequenceReason) == 0x000030, "Member 'UScenarioStateMachineStandardProcessor::PlaySequenceReason' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachineStandardProcessor, PlaySequence) == 0x000040, "Member 'UScenarioStateMachineStandardProcessor::PlaySequence' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateMachineProcessor_TessMarry
// 0x0028 (0x0070 - 0x0048)
class UScenarioStateMachineProcessor_TessMarry final : public UScenarioStateMachineStandardProcessor
{
public:
	TArray<struct FMagicCardInfo>                 CardLineInfos;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EggCardIndex;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TessMagicCardShowElementName;                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const struct FMagicCardInfo GetCardInfo(int32 InCardIndex);
	int32 RandomLineIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateMachineProcessor_TessMarry">();
	}
	static class UScenarioStateMachineProcessor_TessMarry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateMachineProcessor_TessMarry>();
	}
};
static_assert(alignof(UScenarioStateMachineProcessor_TessMarry) == 0x000008, "Wrong alignment on UScenarioStateMachineProcessor_TessMarry");
static_assert(sizeof(UScenarioStateMachineProcessor_TessMarry) == 0x000070, "Wrong size on UScenarioStateMachineProcessor_TessMarry");
static_assert(offsetof(UScenarioStateMachineProcessor_TessMarry, CardLineInfos) == 0x000048, "Member 'UScenarioStateMachineProcessor_TessMarry::CardLineInfos' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachineProcessor_TessMarry, EggCardIndex) == 0x000058, "Member 'UScenarioStateMachineProcessor_TessMarry::EggCardIndex' has a wrong offset!");
static_assert(offsetof(UScenarioStateMachineProcessor_TessMarry, TessMagicCardShowElementName) == 0x000060, "Member 'UScenarioStateMachineProcessor_TessMarry::TessMagicCardShowElementName' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateNodeBase
// 0x0068 (0x0090 - 0x0028)
class UScenarioStateNodeBase : public UObject
{
public:
	class FString                                 StateName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            InitializeEvents;                                  // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            EnterEvents;                                       // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            UpdateEvents;                                      // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            ExitEvents;                                        // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            StartStandbyEvents;                                // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EScenarioNodeStage                            NodeStage;                                         // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0089(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enter();
	void Exit();
	void Initialize();
	void OnEnter();
	void OnExit();
	void OnInitialize();
	void OnPostEnter();
	void OnPreEnter();
	void OnReady();
	void OnStartStandby();
	void OnUpdate(float DeltaSeconds);
	void PostEnter();
	void PreEnter();
	void Ready();
	void SetNodeStage(const EScenarioNodeStage NewStage);
	void StartStandby();
	void Update(float DeltaSeconds);

	class UHolyLightV3Component* GetHolyLightComponent() const;
	class AInteractionDirectorV3* GetInteractionDirector() const;
	class UInteractionInputComponent* GetInteractionInputComponent() const;
	class AInteractionPlayV3* GetInteractionPlayV3() const;
	EScenarioNodeStage GetNodeStage() const;
	class UScenarioStateComponent* GetStateComponent() const;
	class UScenarioStateMachine* GetStateMachine() const;
	class UScenarioStateMachineStandardProcessor* GetStateMachineProcessor() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNodeBase">();
	}
	static class UScenarioStateNodeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNodeBase>();
	}
};
static_assert(alignof(UScenarioStateNodeBase) == 0x000008, "Wrong alignment on UScenarioStateNodeBase");
static_assert(sizeof(UScenarioStateNodeBase) == 0x000090, "Wrong size on UScenarioStateNodeBase");
static_assert(offsetof(UScenarioStateNodeBase, StateName) == 0x000028, "Member 'UScenarioStateNodeBase::StateName' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, InitializeEvents) == 0x000038, "Member 'UScenarioStateNodeBase::InitializeEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, EnterEvents) == 0x000048, "Member 'UScenarioStateNodeBase::EnterEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, UpdateEvents) == 0x000058, "Member 'UScenarioStateNodeBase::UpdateEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, ExitEvents) == 0x000068, "Member 'UScenarioStateNodeBase::ExitEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, StartStandbyEvents) == 0x000078, "Member 'UScenarioStateNodeBase::StartStandbyEvents' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, NodeStage) == 0x000088, "Member 'UScenarioStateNodeBase::NodeStage' has a wrong offset!");
static_assert(offsetof(UScenarioStateNodeBase, bInitialized) == 0x000089, "Member 'UScenarioStateNodeBase::bInitialized' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateNode
// 0x0168 (0x01F8 - 0x0090)
class UScenarioStateNode : public UScenarioStateNodeBase
{
public:
	TArray<struct FScenarioCycleActorInfo>        CycleActorInfos;                                   // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStandby;                                    // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitNode;                                         // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScenarioStandbyActorInfo>      StandbyActorInfos;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          CameraSequenceAsset;                               // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StandbyCameraID;                                   // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CyclePerformanceTime;                              // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInteractionOperateV3*>          Operates;                                          // 0x00F0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FInteractionV3CharacterHolyLight> StateHolyLight;                                    // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInteractionOperateV3*>          ExecutableOperates;                                // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         LastOperateTime;                                   // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandbyTime;                                       // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CyclePerformanceTriggerTime;                       // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UScenarioOperate*>               ActivateOperates;                                  // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EScenarioNodeInnerState                       InnerState;                                        // 0x0140(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionV3InputCollision*           CurrentPressedCollision;                           // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 NextStateName;                                     // 0x0150(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FScenarioShowElementPlayInfo>   WaitPlayElements;                                  // 0x0160(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ListeningHandles;                                  // 0x0170(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractionCacheKeyBinding>    ListeningKeyBindings;                              // 0x0180(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bBlockInput;                                       // 0x0190(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FAddHolyLightDataInfo> AddHolyLightDataInfos;                             // 0x0198(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveStandbyCamera();
	void AddToExecutableOperates(const TArray<class UInteractionOperateV3*>& InOperates);
	void AppendShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish);
	void DisableInput();
	void EnableInput();
	class FString GetCurrentPressedCollisionName();
	class FString GetDebugInfo();
	void GetStateActorNames(TSet<class FName>* StateNames);
	void HideAllActors();
	void HideOtherActor();
	int32 ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback);
	void ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback);
	void OnEditorShowElementPlayFinish();
	void OnInitCameraSequenceFinished();
	void OnLookAround(float InValue);
	void OnLookUp(float InValue);
	void OnMoveForward(float InValue);
	void OnMoveRight(float InValue);
	void PlayShowElement(const class FString& ElementName, const class FString& NextState, bool bEndLastShowElement);
	void PlayShowElementByCallback(const class FString& InElement, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish, bool bEndLastShowElement);
	void PlayShowElementList(const TArray<class FString>& InElements, const class FString& NextState, bool bEndLastShowElement);
	void PlayShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish, bool bEndLastShowElement);
	void PlayStandBy();
	void RemoveAllAddHolyLightData();
	void RemoveFromExecutableOperates(const TArray<class UInteractionOperateV3*>& InOperates);
	void SetNodeInnerState(const EScenarioNodeInnerState InNewState);
	void StopAllListenForKeyAction();
	void StopAllListeningForHandle();
	void StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType);
	void StopListeningForHandle(int32 InHandle);
	void StopListeningForInputAction(class FName ActionName, EInputEvent EventType);
	void UpdateHolyLightData(const TArray<struct FInteractionV3CharacterHolyLight>& InDatas, const bool bAdd, const class FString& InReason);
	void UpdateOperateHolyLightData(class UScenarioOperate* InScenarioOperate, const bool bAdd);
	void UpdateShowElementHolyLightData(const class FString& InShowElementName, const bool bAdd);
	void UpdateStandbyHolyLightData(const bool bAdd);

	EScenarioNodeInnerState GetNodeInnerState() const;
	class UScenarioOperate* GetOperateScenarioOperate() const;
	class UInteractionV3InputCollision* GetPressedCollision() const;
	class UInteractionV3InputCollision* GetSelectedCollision() const;
	float GetShowElementPlayTime() const;
	float GetShowElementRemainingTime() const;
	TArray<class FName> GetStandbyCameraIDs() const;
	bool IsBlockInput() const;
	void SetCameraPosition() const;
	void TryFixCameraPos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode">();
	}
	static class UScenarioStateNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode>();
	}
};
static_assert(alignof(UScenarioStateNode) == 0x000008, "Wrong alignment on UScenarioStateNode");
static_assert(sizeof(UScenarioStateNode) == 0x0001F8, "Wrong size on UScenarioStateNode");
static_assert(offsetof(UScenarioStateNode, CycleActorInfos) == 0x000090, "Member 'UScenarioStateNode::CycleActorInfos' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, bIgnoreStandby) == 0x0000A0, "Member 'UScenarioStateNode::bIgnoreStandby' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, bExitNode) == 0x0000A1, "Member 'UScenarioStateNode::bExitNode' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, StandbyActorInfos) == 0x0000A8, "Member 'UScenarioStateNode::StandbyActorInfos' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, CameraSequenceAsset) == 0x0000B8, "Member 'UScenarioStateNode::CameraSequenceAsset' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, StandbyCameraID) == 0x0000E0, "Member 'UScenarioStateNode::StandbyCameraID' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, CyclePerformanceTime) == 0x0000E8, "Member 'UScenarioStateNode::CyclePerformanceTime' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, Operates) == 0x0000F0, "Member 'UScenarioStateNode::Operates' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, StateHolyLight) == 0x000100, "Member 'UScenarioStateNode::StateHolyLight' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, ExecutableOperates) == 0x000110, "Member 'UScenarioStateNode::ExecutableOperates' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, LastOperateTime) == 0x000120, "Member 'UScenarioStateNode::LastOperateTime' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, StandbyTime) == 0x000124, "Member 'UScenarioStateNode::StandbyTime' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, CyclePerformanceTriggerTime) == 0x000128, "Member 'UScenarioStateNode::CyclePerformanceTriggerTime' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, ActivateOperates) == 0x000130, "Member 'UScenarioStateNode::ActivateOperates' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, InnerState) == 0x000140, "Member 'UScenarioStateNode::InnerState' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, CurrentPressedCollision) == 0x000148, "Member 'UScenarioStateNode::CurrentPressedCollision' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, NextStateName) == 0x000150, "Member 'UScenarioStateNode::NextStateName' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, WaitPlayElements) == 0x000160, "Member 'UScenarioStateNode::WaitPlayElements' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, ListeningHandles) == 0x000170, "Member 'UScenarioStateNode::ListeningHandles' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, ListeningKeyBindings) == 0x000180, "Member 'UScenarioStateNode::ListeningKeyBindings' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, bBlockInput) == 0x000190, "Member 'UScenarioStateNode::bBlockInput' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode, AddHolyLightDataInfos) == 0x000198, "Member 'UScenarioStateNode::AddHolyLightDataInfos' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateNode_Confession
// 0x0028 (0x0220 - 0x01F8)
class UScenarioStateNode_Confession : public UScenarioStateNode
{
public:
	TArray<struct FConfessionFlowInfo>            FlowList;                                          // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConfessionStateActorInfo>      ConfessionActorInfos;                              // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EConfessionNodeEndType                        EndType;                                           // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConfessionInnerState                         ConfessionState;                                   // 0x0219(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetConfessionState(const EConfessionInnerState NewState);

	EConfessionInnerState GetConfessionState() const;
	bool IsAutoPlay() const;
	bool IsEndNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode_Confession">();
	}
	static class UScenarioStateNode_Confession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode_Confession>();
	}
};
static_assert(alignof(UScenarioStateNode_Confession) == 0x000008, "Wrong alignment on UScenarioStateNode_Confession");
static_assert(sizeof(UScenarioStateNode_Confession) == 0x000220, "Wrong size on UScenarioStateNode_Confession");
static_assert(offsetof(UScenarioStateNode_Confession, FlowList) == 0x0001F8, "Member 'UScenarioStateNode_Confession::FlowList' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode_Confession, ConfessionActorInfos) == 0x000208, "Member 'UScenarioStateNode_Confession::ConfessionActorInfos' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode_Confession, EndType) == 0x000218, "Member 'UScenarioStateNode_Confession::EndType' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode_Confession, ConfessionState) == 0x000219, "Member 'UScenarioStateNode_Confession::ConfessionState' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateNode_ConfessionEntry
// 0x0000 (0x0220 - 0x0220)
class UScenarioStateNode_ConfessionEntry final : public UScenarioStateNode_Confession
{
public:
	void OnInitShowElementFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode_ConfessionEntry">();
	}
	static class UScenarioStateNode_ConfessionEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode_ConfessionEntry>();
	}
};
static_assert(alignof(UScenarioStateNode_ConfessionEntry) == 0x000008, "Wrong alignment on UScenarioStateNode_ConfessionEntry");
static_assert(sizeof(UScenarioStateNode_ConfessionEntry) == 0x000220, "Wrong size on UScenarioStateNode_ConfessionEntry");

// Class CharacterInteractionV3.ScenarioStateNode_Entry
// 0x0000 (0x01F8 - 0x01F8)
class UScenarioStateNode_Entry final : public UScenarioStateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode_Entry">();
	}
	static class UScenarioStateNode_Entry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode_Entry>();
	}
};
static_assert(alignof(UScenarioStateNode_Entry) == 0x000008, "Wrong alignment on UScenarioStateNode_Entry");
static_assert(sizeof(UScenarioStateNode_Entry) == 0x0001F8, "Wrong size on UScenarioStateNode_Entry");

// Class CharacterInteractionV3.ScenarioStateNode_LittleGame
// 0x0038 (0x0230 - 0x01F8)
class UScenarioStateNode_LittleGame : public UScenarioStateNode
{
public:
	TSoftClassPtr<class UClass>                   LittleGameTemplate;                                // 0x01F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanActiveStandbyCamera;                           // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UScenarioStandardLittleGame*            LittleGameInstance;                                // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UScenarioStandardLittleGame* GetLittleGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode_LittleGame">();
	}
	static class UScenarioStateNode_LittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode_LittleGame>();
	}
};
static_assert(alignof(UScenarioStateNode_LittleGame) == 0x000008, "Wrong alignment on UScenarioStateNode_LittleGame");
static_assert(sizeof(UScenarioStateNode_LittleGame) == 0x000230, "Wrong size on UScenarioStateNode_LittleGame");
static_assert(offsetof(UScenarioStateNode_LittleGame, LittleGameTemplate) == 0x0001F8, "Member 'UScenarioStateNode_LittleGame::LittleGameTemplate' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode_LittleGame, bCanActiveStandbyCamera) == 0x000220, "Member 'UScenarioStateNode_LittleGame::bCanActiveStandbyCamera' has a wrong offset!");
static_assert(offsetof(UScenarioStateNode_LittleGame, LittleGameInstance) == 0x000228, "Member 'UScenarioStateNode_LittleGame::LittleGameInstance' has a wrong offset!");

// Class CharacterInteractionV3.ScenarioStateNode_LittleGameEntry
// 0x0000 (0x0230 - 0x0230)
class UScenarioStateNode_LittleGameEntry final : public UScenarioStateNode_LittleGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioStateNode_LittleGameEntry">();
	}
	static class UScenarioStateNode_LittleGameEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioStateNode_LittleGameEntry>();
	}
};
static_assert(alignof(UScenarioStateNode_LittleGameEntry) == 0x000008, "Wrong alignment on UScenarioStateNode_LittleGameEntry");
static_assert(sizeof(UScenarioStateNode_LittleGameEntry) == 0x000230, "Wrong size on UScenarioStateNode_LittleGameEntry");

// Class CharacterInteractionV3.ShowElementV3
// 0x0040 (0x0068 - 0x0028)
class UShowElementV3 final : public UObject
{
public:
	TArray<class UShowElementV3Unit*>             ShowElementUnits;                                  // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AInteractionActorV3>        InteractionActorClass;                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationTime;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionV3CharacterHolyLight> ShowElementHolyLight;                              // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequence*                          PreviewIdleAnim;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          PreviewFaceIdleAnim;                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetDurationTime();
	TArray<struct FInteractionV3CharacterHolyLight> GetShowElementHolyLight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3">();
	}
	static class UShowElementV3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3>();
	}
};
static_assert(alignof(UShowElementV3) == 0x000008, "Wrong alignment on UShowElementV3");
static_assert(sizeof(UShowElementV3) == 0x000068, "Wrong size on UShowElementV3");
static_assert(offsetof(UShowElementV3, ShowElementUnits) == 0x000028, "Member 'UShowElementV3::ShowElementUnits' has a wrong offset!");
static_assert(offsetof(UShowElementV3, InteractionActorClass) == 0x000038, "Member 'UShowElementV3::InteractionActorClass' has a wrong offset!");
static_assert(offsetof(UShowElementV3, DurationTime) == 0x000040, "Member 'UShowElementV3::DurationTime' has a wrong offset!");
static_assert(offsetof(UShowElementV3, ShowElementHolyLight) == 0x000048, "Member 'UShowElementV3::ShowElementHolyLight' has a wrong offset!");
static_assert(offsetof(UShowElementV3, PreviewIdleAnim) == 0x000058, "Member 'UShowElementV3::PreviewIdleAnim' has a wrong offset!");
static_assert(offsetof(UShowElementV3, PreviewFaceIdleAnim) == 0x000060, "Member 'UShowElementV3::PreviewFaceIdleAnim' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3UnitPlayer
// 0x0000 (0x0028 - 0x0028)
class UShowElementV3UnitPlayer : public UObject
{
public:
	void EndUnit();
	void OnInitializePlayer(class AInteractionActorV3* Actor);
	void PlayUnit(const class UShowElementV3Unit* Unit);
	void QuitUnit();
	void TickUnit(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3UnitPlayer">();
	}
	static class UShowElementV3UnitPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3UnitPlayer>();
	}
};
static_assert(alignof(UShowElementV3UnitPlayer) == 0x000008, "Wrong alignment on UShowElementV3UnitPlayer");
static_assert(sizeof(UShowElementV3UnitPlayer) == 0x000028, "Wrong size on UShowElementV3UnitPlayer");

// Class CharacterInteractionV3.ShowElementV3FacialAnimationPlayer
// 0x0020 (0x0048 - 0x0028)
class UShowElementV3FacialAnimationPlayer final : public UShowElementV3UnitPlayer
{
public:
	class FName                                   Tag;                                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 FaceSkeletalMeshComponent;                         // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionV3FaceAnimInstance*         CharacterFaceAnimInstance;                         // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PlayingFaceMontage;                                // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3FacialAnimationPlayer">();
	}
	static class UShowElementV3FacialAnimationPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3FacialAnimationPlayer>();
	}
};
static_assert(alignof(UShowElementV3FacialAnimationPlayer) == 0x000008, "Wrong alignment on UShowElementV3FacialAnimationPlayer");
static_assert(sizeof(UShowElementV3FacialAnimationPlayer) == 0x000048, "Wrong size on UShowElementV3FacialAnimationPlayer");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer, Tag) == 0x000028, "Member 'UShowElementV3FacialAnimationPlayer::Tag' has a wrong offset!");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer, FaceSkeletalMeshComponent) == 0x000030, "Member 'UShowElementV3FacialAnimationPlayer::FaceSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer, CharacterFaceAnimInstance) == 0x000038, "Member 'UShowElementV3FacialAnimationPlayer::CharacterFaceAnimInstance' has a wrong offset!");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer, PlayingFaceMontage) == 0x000040, "Member 'UShowElementV3FacialAnimationPlayer::PlayingFaceMontage' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3FacialAnimationPlayer_Confession
// 0x0018 (0x0040 - 0x0028)
class UShowElementV3FacialAnimationPlayer_Confession final : public UShowElementV3UnitPlayer
{
public:
	class FName                                   Tag;                                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 FaceSkeletalMeshComponent;                         // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionV3FaceAnimInstance*         CharacterFaceAnimInstance;                         // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3FacialAnimationPlayer_Confession">();
	}
	static class UShowElementV3FacialAnimationPlayer_Confession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3FacialAnimationPlayer_Confession>();
	}
};
static_assert(alignof(UShowElementV3FacialAnimationPlayer_Confession) == 0x000008, "Wrong alignment on UShowElementV3FacialAnimationPlayer_Confession");
static_assert(sizeof(UShowElementV3FacialAnimationPlayer_Confession) == 0x000040, "Wrong size on UShowElementV3FacialAnimationPlayer_Confession");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer_Confession, Tag) == 0x000028, "Member 'UShowElementV3FacialAnimationPlayer_Confession::Tag' has a wrong offset!");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer_Confession, FaceSkeletalMeshComponent) == 0x000030, "Member 'UShowElementV3FacialAnimationPlayer_Confession::FaceSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UShowElementV3FacialAnimationPlayer_Confession, CharacterFaceAnimInstance) == 0x000038, "Member 'UShowElementV3FacialAnimationPlayer_Confession::CharacterFaceAnimInstance' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3LevelSequencePlayer
// 0x0010 (0x0038 - 0x0028)
class UShowElementV3LevelSequencePlayer final : public UShowElementV3UnitPlayer
{
public:
	TWeakObjectPtr<class ALevelSequenceActor>     LevelSequenceActor;                                // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3LevelSequencePlayer">();
	}
	static class UShowElementV3LevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3LevelSequencePlayer>();
	}
};
static_assert(alignof(UShowElementV3LevelSequencePlayer) == 0x000008, "Wrong alignment on UShowElementV3LevelSequencePlayer");
static_assert(sizeof(UShowElementV3LevelSequencePlayer) == 0x000038, "Wrong size on UShowElementV3LevelSequencePlayer");
static_assert(offsetof(UShowElementV3LevelSequencePlayer, LevelSequenceActor) == 0x000028, "Member 'UShowElementV3LevelSequencePlayer::LevelSequenceActor' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3LipSyncSoundPlayer
// 0x0008 (0x0030 - 0x0028)
class UShowElementV3LipSyncSoundPlayer final : public UShowElementV3UnitPlayer
{
public:
	class AInteractionActorV3*                    Actor;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3LipSyncSoundPlayer">();
	}
	static class UShowElementV3LipSyncSoundPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3LipSyncSoundPlayer>();
	}
};
static_assert(alignof(UShowElementV3LipSyncSoundPlayer) == 0x000008, "Wrong alignment on UShowElementV3LipSyncSoundPlayer");
static_assert(sizeof(UShowElementV3LipSyncSoundPlayer) == 0x000030, "Wrong size on UShowElementV3LipSyncSoundPlayer");
static_assert(offsetof(UShowElementV3LipSyncSoundPlayer, Actor) == 0x000028, "Member 'UShowElementV3LipSyncSoundPlayer::Actor' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3SkeletalMeshPlayer
// 0x0020 (0x0048 - 0x0028)
class UShowElementV3SkeletalMeshPlayer final : public UShowElementV3UnitPlayer
{
public:
	class FName                                   Tag;                                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionV3CharacterAnimInstance*    CharacterAnimInstance;                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PlayingMontage;                                    // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3SkeletalMeshPlayer">();
	}
	static class UShowElementV3SkeletalMeshPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3SkeletalMeshPlayer>();
	}
};
static_assert(alignof(UShowElementV3SkeletalMeshPlayer) == 0x000008, "Wrong alignment on UShowElementV3SkeletalMeshPlayer");
static_assert(sizeof(UShowElementV3SkeletalMeshPlayer) == 0x000048, "Wrong size on UShowElementV3SkeletalMeshPlayer");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer, Tag) == 0x000028, "Member 'UShowElementV3SkeletalMeshPlayer::Tag' has a wrong offset!");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer, SkeletalMeshComponent) == 0x000030, "Member 'UShowElementV3SkeletalMeshPlayer::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer, CharacterAnimInstance) == 0x000038, "Member 'UShowElementV3SkeletalMeshPlayer::CharacterAnimInstance' has a wrong offset!");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer, PlayingMontage) == 0x000040, "Member 'UShowElementV3SkeletalMeshPlayer::PlayingMontage' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3SkeletalMeshPlayer_Confession
// 0x0018 (0x0040 - 0x0028)
class UShowElementV3SkeletalMeshPlayer_Confession final : public UShowElementV3UnitPlayer
{
public:
	class FName                                   Tag;                                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionV3CharacterAnimInstance*    CharacterAnimInstance;                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3SkeletalMeshPlayer_Confession">();
	}
	static class UShowElementV3SkeletalMeshPlayer_Confession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3SkeletalMeshPlayer_Confession>();
	}
};
static_assert(alignof(UShowElementV3SkeletalMeshPlayer_Confession) == 0x000008, "Wrong alignment on UShowElementV3SkeletalMeshPlayer_Confession");
static_assert(sizeof(UShowElementV3SkeletalMeshPlayer_Confession) == 0x000040, "Wrong size on UShowElementV3SkeletalMeshPlayer_Confession");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer_Confession, Tag) == 0x000028, "Member 'UShowElementV3SkeletalMeshPlayer_Confession::Tag' has a wrong offset!");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer_Confession, SkeletalMeshComponent) == 0x000030, "Member 'UShowElementV3SkeletalMeshPlayer_Confession::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UShowElementV3SkeletalMeshPlayer_Confession, CharacterAnimInstance) == 0x000038, "Member 'UShowElementV3SkeletalMeshPlayer_Confession::CharacterAnimInstance' has a wrong offset!");

// Class CharacterInteractionV3.ShowElementV3UnitPlayerConfigAsset
// 0x00A0 (0x00D0 - 0x0030)
class UShowElementV3UnitPlayerConfigAsset final : public UDataAsset
{
public:
	TMap<TSubclassOf<class UShowElementV3Unit>, class UShowElementV3UnitPlayer*> UnitPlayerMap;                                     // 0x0030(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, class UShowElementV3UnitPlayer*> TagPlayerMap;                                      // 0x0080(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowElementV3UnitPlayerConfigAsset">();
	}
	static class UShowElementV3UnitPlayerConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowElementV3UnitPlayerConfigAsset>();
	}
};
static_assert(alignof(UShowElementV3UnitPlayerConfigAsset) == 0x000008, "Wrong alignment on UShowElementV3UnitPlayerConfigAsset");
static_assert(sizeof(UShowElementV3UnitPlayerConfigAsset) == 0x0000D0, "Wrong size on UShowElementV3UnitPlayerConfigAsset");
static_assert(offsetof(UShowElementV3UnitPlayerConfigAsset, UnitPlayerMap) == 0x000030, "Member 'UShowElementV3UnitPlayerConfigAsset::UnitPlayerMap' has a wrong offset!");
static_assert(offsetof(UShowElementV3UnitPlayerConfigAsset, TagPlayerMap) == 0x000080, "Member 'UShowElementV3UnitPlayerConfigAsset::TagPlayerMap' has a wrong offset!");

// Class CharacterInteractionV3.SkeletalAnimationUnit
// 0x0018 (0x0048 - 0x0030)
class USkeletalAnimationUnit final : public UShowElementV3Unit
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoBlendOut;                               // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalAnimationUnit">();
	}
	static class USkeletalAnimationUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalAnimationUnit>();
	}
};
static_assert(alignof(USkeletalAnimationUnit) == 0x000008, "Wrong alignment on USkeletalAnimationUnit");
static_assert(sizeof(USkeletalAnimationUnit) == 0x000048, "Wrong size on USkeletalAnimationUnit");
static_assert(offsetof(USkeletalAnimationUnit, Sequence) == 0x000030, "Member 'USkeletalAnimationUnit::Sequence' has a wrong offset!");
static_assert(offsetof(USkeletalAnimationUnit, BlendInTime) == 0x000038, "Member 'USkeletalAnimationUnit::BlendInTime' has a wrong offset!");
static_assert(offsetof(USkeletalAnimationUnit, BlendOutTime) == 0x00003C, "Member 'USkeletalAnimationUnit::BlendOutTime' has a wrong offset!");
static_assert(offsetof(USkeletalAnimationUnit, BlendOutTriggerTime) == 0x000040, "Member 'USkeletalAnimationUnit::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(USkeletalAnimationUnit, bEnableAutoBlendOut) == 0x000044, "Member 'USkeletalAnimationUnit::bEnableAutoBlendOut' has a wrong offset!");

}


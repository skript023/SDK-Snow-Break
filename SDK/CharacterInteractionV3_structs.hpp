#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterInteractionV3

#include "Basic.hpp"

#include "CameraBlueprint_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Slate_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum CharacterInteractionV3.EInteractionV3OperateEventType
// NumValues: 0x0004
enum class EInteractionV3OperateEventType : uint8
{
	Start                                    = 0,
	Update                                   = 1,
	End                                      = 2,
	EInteractionV3OperateEventType_MAX       = 3,
};

// Enum CharacterInteractionV3.EInteractionConditionTypeV3
// NumValues: 0x0004
enum class EInteractionConditionTypeV3 : uint8
{
	Any                                      = 0,
	All                                      = 1,
	Order                                    = 2,
	EInteractionConditionTypeV3_MAX          = 3,
};

// Enum CharacterInteractionV3.EInteractionV3CameraMoveType
// NumValues: 0x0003
enum class EInteractionV3CameraMoveType : uint8
{
	Translate                                = 0,
	Rotate                                   = 1,
	EInteractionV3CameraMoveType_MAX         = 2,
};

// Enum CharacterInteractionV3.EInteractionV3StandbyCameraType
// NumValues: 0x0003
enum class EInteractionV3StandbyCameraType : uint8
{
	Self                                     = 0,
	Character                                = 1,
	EInteractionV3StandbyCameraType_MAX      = 2,
};

// Enum CharacterInteractionV3.EInteractionV3IKSlot
// NumValues: 0x0003
enum class EInteractionV3IKSlot : uint8
{
	Default                                  = 0,
	AfterBreathAdditive                      = 1,
	EInteractionV3IKSlot_MAX                 = 2,
};

// Enum CharacterInteractionV3.EInteractionV3BlendSpaceSlot
// NumValues: 0x0002
enum class EInteractionV3BlendSpaceSlot : uint8
{
	Default                                  = 0,
	EInteractionV3BlendSpaceSlot_MAX         = 1,
};

// Enum CharacterInteractionV3.EInteractionVoiceType
// NumValues: 0x0003
enum class EInteractionVoiceType : uint8
{
	ShowElement                              = 0,
	Operate                                  = 1,
	EInteractionVoiceType_MAX                = 2,
};

// Enum CharacterInteractionV3.EInteractionDragValueCompareType
// NumValues: 0x0004
enum class EInteractionDragValueCompareType : uint8
{
	Larger                                   = 0,
	Less                                     = 1,
	NotCompare                               = 2,
	EInteractionDragValueCompareType_MAX     = 3,
};

// Enum CharacterInteractionV3.EInteractionCharacterShoeType
// NumValues: 0x0003
enum class EInteractionCharacterShoeType : uint8
{
	LeftShoe                                 = 0,
	RightShoe                                = 1,
	EInteractionCharacterShoeType_MAX        = 2,
};

// Enum CharacterInteractionV3.EScenarioNodeInnerState
// NumValues: 0x0007
enum class EScenarioNodeInnerState : uint8
{
	None                                     = 0,
	Prepare                                  = 1,
	Standby                                  = 2,
	Operate                                  = 3,
	ShowElement                              = 4,
	Exit                                     = 5,
	EScenarioNodeInnerState_MAX              = 6,
};

// Enum CharacterInteractionV3.EInteractionV3DragInterpolationType
// NumValues: 0x0003
enum class EInteractionV3DragInterpolationType : uint8
{
	DecelerateInterpolation                  = 0,
	SpringInterpolation                      = 1,
	EInteractionV3DragInterpolationType_MAX  = 2,
};

// Enum CharacterInteractionV3.EInteractionV3InputType
// NumValues: 0x0006
enum class EInteractionV3InputType : uint8
{
	Press                                    = 0,
	Release                                  = 1,
	Click                                    = 2,
	Move                                     = 3,
	Confirm                                  = 4,
	EInteractionV3InputType_MAX              = 5,
};

// Enum CharacterInteractionV3.EScenarioOperateState
// NumValues: 0x0004
enum class EScenarioOperateState : uint8
{
	None                                     = 0,
	Operating                                = 1,
	BlendOut                                 = 2,
	EScenarioOperateState_MAX                = 3,
};

// Enum CharacterInteractionV3.EScenarioLittleGameUIState
// NumValues: 0x0004
enum class EScenarioLittleGameUIState : uint8
{
	NoCreate                                 = 0,
	Show                                     = 1,
	Hide                                     = 2,
	EScenarioLittleGameUIState_MAX           = 3,
};

// Enum CharacterInteractionV3.EConfessionInnerState
// NumValues: 0x0005
enum class EConfessionInnerState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Playing                                  = 2,
	End                                      = 3,
	EConfessionInnerState_MAX                = 4,
};

// Enum CharacterInteractionV3.EConfessionNodeEndType
// NumValues: 0x0003
enum class EConfessionNodeEndType : uint8
{
	SelfAnim                                 = 0,
	LastFrame                                = 1,
	EConfessionNodeEndType_MAX               = 2,
};

// Enum CharacterInteractionV3.EScenarioNodeStage
// NumValues: 0x0005
enum class EScenarioNodeStage : uint8
{
	Inactive                                 = 0,
	Initialize                               = 1,
	Entering                                 = 2,
	Activate                                 = 3,
	EScenarioNodeStage_MAX                   = 4,
};

// ScriptStruct CharacterInteractionV3.InteractionCaptionsConfig
// 0x0018 (0x0020 - 0x0008)
struct FInteractionCaptionsConfig final : public FTableRowBase
{
public:
	float                                         DelayTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Caption;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCaptionsConfig) == 0x000008, "Wrong alignment on FInteractionCaptionsConfig");
static_assert(sizeof(FInteractionCaptionsConfig) == 0x000020, "Wrong size on FInteractionCaptionsConfig");
static_assert(offsetof(FInteractionCaptionsConfig, DelayTime) == 0x000008, "Member 'FInteractionCaptionsConfig::DelayTime' has a wrong offset!");
static_assert(offsetof(FInteractionCaptionsConfig, DurationTime) == 0x00000C, "Member 'FInteractionCaptionsConfig::DurationTime' has a wrong offset!");
static_assert(offsetof(FInteractionCaptionsConfig, Caption) == 0x000010, "Member 'FInteractionCaptionsConfig::Caption' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.MusicQTEBtnData
// 0x0024 (0x0024 - 0x0000)
struct FMusicQTEBtnData final
{
public:
	float                                         ShowTime;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PosID;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BtnType;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GoodRange;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PerfectRange;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPressTime;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicQTEBtnData) == 0x000004, "Wrong alignment on FMusicQTEBtnData");
static_assert(sizeof(FMusicQTEBtnData) == 0x000024, "Wrong size on FMusicQTEBtnData");
static_assert(offsetof(FMusicQTEBtnData, ShowTime) == 0x000000, "Member 'FMusicQTEBtnData::ShowTime' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, PosID) == 0x000004, "Member 'FMusicQTEBtnData::PosID' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, BtnType) == 0x000008, "Member 'FMusicQTEBtnData::BtnType' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, Duration) == 0x00000C, "Member 'FMusicQTEBtnData::Duration' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, GoodRange) == 0x000010, "Member 'FMusicQTEBtnData::GoodRange' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, PerfectRange) == 0x000018, "Member 'FMusicQTEBtnData::PerfectRange' has a wrong offset!");
static_assert(offsetof(FMusicQTEBtnData, LongPressTime) == 0x000020, "Member 'FMusicQTEBtnData::LongPressTime' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.AnimNode_InteractionV3BlendSpace
// 0x0018 (0x0028 - 0x0010)
struct FAnimNode_InteractionV3BlendSpace final : public FAnimNode_Base
{
public:
	EInteractionV3BlendSpaceSlot                  SlotType;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x17];                                      // 0x0011(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_InteractionV3BlendSpace) == 0x000008, "Wrong alignment on FAnimNode_InteractionV3BlendSpace");
static_assert(sizeof(FAnimNode_InteractionV3BlendSpace) == 0x000028, "Wrong size on FAnimNode_InteractionV3BlendSpace");
static_assert(offsetof(FAnimNode_InteractionV3BlendSpace, SlotType) == 0x000010, "Member 'FAnimNode_InteractionV3BlendSpace::SlotType' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.AnimNode_InteractionV3IK
// 0x0018 (0x00E0 - 0x00C8)
struct FAnimNode_InteractionV3IK final : public FAnimNode_SkeletalControlBase
{
public:
	struct FComponentSpacePoseLink                RefComponentPose;                                  // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EInteractionV3IKSlot                          SlotType;                                          // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_InteractionV3IK) == 0x000008, "Wrong alignment on FAnimNode_InteractionV3IK");
static_assert(sizeof(FAnimNode_InteractionV3IK) == 0x0000E0, "Wrong size on FAnimNode_InteractionV3IK");
static_assert(offsetof(FAnimNode_InteractionV3IK, RefComponentPose) == 0x0000C8, "Member 'FAnimNode_InteractionV3IK::RefComponentPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_InteractionV3IK, SlotType) == 0x0000D8, "Member 'FAnimNode_InteractionV3IK::SlotType' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionCameraModifierInfo
// 0x0028 (0x0028 - 0x0000)
struct FInteractionCameraModifierInfo final
{
public:
	struct FRotator                               AdditiveRotation;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ViewPointLocationOffset;                           // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveArmLength;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation;                                    // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCameraModifierInfo) == 0x000004, "Wrong alignment on FInteractionCameraModifierInfo");
static_assert(sizeof(FInteractionCameraModifierInfo) == 0x000028, "Wrong size on FInteractionCameraModifierInfo");
static_assert(offsetof(FInteractionCameraModifierInfo, AdditiveRotation) == 0x000000, "Member 'FInteractionCameraModifierInfo::AdditiveRotation' has a wrong offset!");
static_assert(offsetof(FInteractionCameraModifierInfo, ViewPointLocationOffset) == 0x00000C, "Member 'FInteractionCameraModifierInfo::ViewPointLocationOffset' has a wrong offset!");
static_assert(offsetof(FInteractionCameraModifierInfo, AdditiveArmLength) == 0x000018, "Member 'FInteractionCameraModifierInfo::AdditiveArmLength' has a wrong offset!");
static_assert(offsetof(FInteractionCameraModifierInfo, CameraLocation) == 0x00001C, "Member 'FInteractionCameraModifierInfo::CameraLocation' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.CameraNode_InteractionStandby
// 0x0038 (0x0048 - 0x0010)
struct FCameraNode_InteractionStandby final : public FCameraNode_Base
{
public:
	struct FCameraParameterLink                   Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FInteractionCameraModifierInfo         StandbyModifierInfo;                               // 0x0020(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraNode_InteractionStandby) == 0x000008, "Wrong alignment on FCameraNode_InteractionStandby");
static_assert(sizeof(FCameraNode_InteractionStandby) == 0x000048, "Wrong size on FCameraNode_InteractionStandby");
static_assert(offsetof(FCameraNode_InteractionStandby, Source) == 0x000010, "Member 'FCameraNode_InteractionStandby::Source' has a wrong offset!");
static_assert(offsetof(FCameraNode_InteractionStandby, StandbyModifierInfo) == 0x000020, "Member 'FCameraNode_InteractionStandby::StandbyModifierInfo' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3WeightedVoice
// 0x0028 (0x0028 - 0x0000)
struct FInteractionV3WeightedVoice final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceID;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpeakingContent;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3WeightedVoice) == 0x000008, "Wrong alignment on FInteractionV3WeightedVoice");
static_assert(sizeof(FInteractionV3WeightedVoice) == 0x000028, "Wrong size on FInteractionV3WeightedVoice");
static_assert(offsetof(FInteractionV3WeightedVoice, Weight) == 0x000000, "Member 'FInteractionV3WeightedVoice::Weight' has a wrong offset!");
static_assert(offsetof(FInteractionV3WeightedVoice, VoiceID) == 0x000008, "Member 'FInteractionV3WeightedVoice::VoiceID' has a wrong offset!");
static_assert(offsetof(FInteractionV3WeightedVoice, SpeakingContent) == 0x000018, "Member 'FInteractionV3WeightedVoice::SpeakingContent' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionVoiceConfig
// 0x0040 (0x0048 - 0x0008)
struct FInteractionVoiceConfig final : public FTableRowBase
{
public:
	EInteractionVoiceType                         VoiceType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionV3WeightedVoice>    WeightedVoice;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CharacterID;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionCaptionsConfig>     CaptionConfigs;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPlayUntilFinished;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionVoiceConfig) == 0x000008, "Wrong alignment on FInteractionVoiceConfig");
static_assert(sizeof(FInteractionVoiceConfig) == 0x000048, "Wrong size on FInteractionVoiceConfig");
static_assert(offsetof(FInteractionVoiceConfig, VoiceType) == 0x000008, "Member 'FInteractionVoiceConfig::VoiceType' has a wrong offset!");
static_assert(offsetof(FInteractionVoiceConfig, Name) == 0x00000C, "Member 'FInteractionVoiceConfig::Name' has a wrong offset!");
static_assert(offsetof(FInteractionVoiceConfig, WeightedVoice) == 0x000018, "Member 'FInteractionVoiceConfig::WeightedVoice' has a wrong offset!");
static_assert(offsetof(FInteractionVoiceConfig, CharacterID) == 0x000028, "Member 'FInteractionVoiceConfig::CharacterID' has a wrong offset!");
static_assert(offsetof(FInteractionVoiceConfig, CaptionConfigs) == 0x000030, "Member 'FInteractionVoiceConfig::CaptionConfigs' has a wrong offset!");
static_assert(offsetof(FInteractionVoiceConfig, bPlayUntilFinished) == 0x000040, "Member 'FInteractionVoiceConfig::bPlayUntilFinished' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.FennyVoiceTipCfg
// 0x0058 (0x0058 - 0x0000)
struct FFennyVoiceTipCfg final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionVoiceConfig                VoiceConfig;                                       // 0x0008(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              DelayTime;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFennyVoiceTipCfg) == 0x000008, "Wrong alignment on FFennyVoiceTipCfg");
static_assert(sizeof(FFennyVoiceTipCfg) == 0x000058, "Wrong size on FFennyVoiceTipCfg");
static_assert(offsetof(FFennyVoiceTipCfg, ID) == 0x000000, "Member 'FFennyVoiceTipCfg::ID' has a wrong offset!");
static_assert(offsetof(FFennyVoiceTipCfg, Weight) == 0x000004, "Member 'FFennyVoiceTipCfg::Weight' has a wrong offset!");
static_assert(offsetof(FFennyVoiceTipCfg, VoiceConfig) == 0x000008, "Member 'FFennyVoiceTipCfg::VoiceConfig' has a wrong offset!");
static_assert(offsetof(FFennyVoiceTipCfg, DelayTime) == 0x000050, "Member 'FFennyVoiceTipCfg::DelayTime' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioStandbyActorInfo
// 0x0058 (0x0058 - 0x0000)
struct FScenarioStandbyActorInfo final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           StandbyAnim;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FaceStandbyAnim;                                   // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioStandbyActorInfo) == 0x000008, "Wrong alignment on FScenarioStandbyActorInfo");
static_assert(sizeof(FScenarioStandbyActorInfo) == 0x000058, "Wrong size on FScenarioStandbyActorInfo");
static_assert(offsetof(FScenarioStandbyActorInfo, ActorName) == 0x000000, "Member 'FScenarioStandbyActorInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FScenarioStandbyActorInfo, StandbyAnim) == 0x000008, "Member 'FScenarioStandbyActorInfo::StandbyAnim' has a wrong offset!");
static_assert(offsetof(FScenarioStandbyActorInfo, FaceStandbyAnim) == 0x000030, "Member 'FScenarioStandbyActorInfo::FaceStandbyAnim' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.FennyShowerStandbyCfg
// 0x0038 (0x0038 - 0x0000)
struct FFennyShowerStandbyCfg final
{
public:
	TArray<struct FScenarioStandbyActorInfo>      StandbyActorInfos;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          CameraSequenceAsset;                               // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFennyShowerStandbyCfg) == 0x000008, "Wrong alignment on FFennyShowerStandbyCfg");
static_assert(sizeof(FFennyShowerStandbyCfg) == 0x000038, "Wrong size on FFennyShowerStandbyCfg");
static_assert(offsetof(FFennyShowerStandbyCfg, StandbyActorInfos) == 0x000000, "Member 'FFennyShowerStandbyCfg::StandbyActorInfos' has a wrong offset!");
static_assert(offsetof(FFennyShowerStandbyCfg, CameraSequenceAsset) == 0x000010, "Member 'FFennyShowerStandbyCfg::CameraSequenceAsset' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3HolyLightData
// 0x0020 (0x0020 - 0x0000)
struct FInteractionV3HolyLightData final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Intensity;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UIName;                                            // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SizeRatio;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3HolyLightData) == 0x000008, "Wrong alignment on FInteractionV3HolyLightData");
static_assert(sizeof(FInteractionV3HolyLightData) == 0x000020, "Wrong size on FInteractionV3HolyLightData");
static_assert(offsetof(FInteractionV3HolyLightData, SocketName) == 0x000000, "Member 'FInteractionV3HolyLightData::SocketName' has a wrong offset!");
static_assert(offsetof(FInteractionV3HolyLightData, Intensity) == 0x000008, "Member 'FInteractionV3HolyLightData::Intensity' has a wrong offset!");
static_assert(offsetof(FInteractionV3HolyLightData, UIName) == 0x00000C, "Member 'FInteractionV3HolyLightData::UIName' has a wrong offset!");
static_assert(offsetof(FInteractionV3HolyLightData, SizeRatio) == 0x000018, "Member 'FInteractionV3HolyLightData::SizeRatio' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3HolyLightRuntimeData
// 0x0028 (0x0028 - 0x0000)
struct FInteractionV3HolyLightRuntimeData final
{
public:
	struct FInteractionV3HolyLightData            Data;                                              // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AddTimes;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionV3HolyLightRuntimeData) == 0x000008, "Wrong alignment on FInteractionV3HolyLightRuntimeData");
static_assert(sizeof(FInteractionV3HolyLightRuntimeData) == 0x000028, "Wrong size on FInteractionV3HolyLightRuntimeData");
static_assert(offsetof(FInteractionV3HolyLightRuntimeData, Data) == 0x000000, "Member 'FInteractionV3HolyLightRuntimeData::Data' has a wrong offset!");
static_assert(offsetof(FInteractionV3HolyLightRuntimeData, AddTimes) == 0x000020, "Member 'FInteractionV3HolyLightRuntimeData::AddTimes' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3HolyLightRuntimeDataArray
// 0x0010 (0x0010 - 0x0000)
struct FInteractionV3HolyLightRuntimeDataArray final
{
public:
	TArray<struct FInteractionV3HolyLightRuntimeData> ArrayData;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3HolyLightRuntimeDataArray) == 0x000008, "Wrong alignment on FInteractionV3HolyLightRuntimeDataArray");
static_assert(sizeof(FInteractionV3HolyLightRuntimeDataArray) == 0x000010, "Wrong size on FInteractionV3HolyLightRuntimeDataArray");
static_assert(offsetof(FInteractionV3HolyLightRuntimeDataArray, ArrayData) == 0x000000, "Member 'FInteractionV3HolyLightRuntimeDataArray::ArrayData' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionArchivementConditionV3
// 0x0018 (0x0018 - 0x0000)
struct FInteractionArchivementConditionV3 final
{
public:
	TArray<int32>                                 ConditionIDs;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EInteractionConditionTypeV3                   ConditionType;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionArchivementConditionV3) == 0x000008, "Wrong alignment on FInteractionArchivementConditionV3");
static_assert(sizeof(FInteractionArchivementConditionV3) == 0x000018, "Wrong size on FInteractionArchivementConditionV3");
static_assert(offsetof(FInteractionArchivementConditionV3, ConditionIDs) == 0x000000, "Member 'FInteractionArchivementConditionV3::ConditionIDs' has a wrong offset!");
static_assert(offsetof(FInteractionArchivementConditionV3, ConditionType) == 0x000010, "Member 'FInteractionArchivementConditionV3::ConditionType' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionArchivementInfoV3
// 0x0028 (0x0028 - 0x0000)
struct FInteractionArchivementInfoV3 final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractionArchivementConditionV3> Conditions;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInteractionV3Event*>            Events;                                            // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionArchivementInfoV3) == 0x000008, "Wrong alignment on FInteractionArchivementInfoV3");
static_assert(sizeof(FInteractionArchivementInfoV3) == 0x000028, "Wrong size on FInteractionArchivementInfoV3");
static_assert(offsetof(FInteractionArchivementInfoV3, ID) == 0x000000, "Member 'FInteractionArchivementInfoV3::ID' has a wrong offset!");
static_assert(offsetof(FInteractionArchivementInfoV3, Conditions) == 0x000008, "Member 'FInteractionArchivementInfoV3::Conditions' has a wrong offset!");
static_assert(offsetof(FInteractionArchivementInfoV3, Events) == 0x000018, "Member 'FInteractionArchivementInfoV3::Events' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.SceneActorComponentShowConfig
// 0x0028 (0x0030 - 0x0008)
struct FSceneActorComponentShowConfig final : public FTableRowBase
{
public:
	class FString                                 SceneName;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentTag;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneActorComponentShowConfig) == 0x000008, "Wrong alignment on FSceneActorComponentShowConfig");
static_assert(sizeof(FSceneActorComponentShowConfig) == 0x000030, "Wrong size on FSceneActorComponentShowConfig");
static_assert(offsetof(FSceneActorComponentShowConfig, SceneName) == 0x000008, "Member 'FSceneActorComponentShowConfig::SceneName' has a wrong offset!");
static_assert(offsetof(FSceneActorComponentShowConfig, ActorName) == 0x000018, "Member 'FSceneActorComponentShowConfig::ActorName' has a wrong offset!");
static_assert(offsetof(FSceneActorComponentShowConfig, ComponentTag) == 0x000020, "Member 'FSceneActorComponentShowConfig::ComponentTag' has a wrong offset!");
static_assert(offsetof(FSceneActorComponentShowConfig, bShow) == 0x000028, "Member 'FSceneActorComponentShowConfig::bShow' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ShowElementsAnim
// 0x0018 (0x0018 - 0x0000)
struct FShowElementsAnim final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FaceIdleAnim;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShowElementsAnim) == 0x000008, "Wrong alignment on FShowElementsAnim");
static_assert(sizeof(FShowElementsAnim) == 0x000018, "Wrong size on FShowElementsAnim");
static_assert(offsetof(FShowElementsAnim, ActorName) == 0x000000, "Member 'FShowElementsAnim::ActorName' has a wrong offset!");
static_assert(offsetof(FShowElementsAnim, IdleAnim) == 0x000008, "Member 'FShowElementsAnim::IdleAnim' has a wrong offset!");
static_assert(offsetof(FShowElementsAnim, FaceIdleAnim) == 0x000010, "Member 'FShowElementsAnim::FaceIdleAnim' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionActionKeyMapping
// 0x0068 (0x0068 - 0x0000)
struct FInteractionActionKeyMapping final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            KeyboardInputChord;                                // 0x0008(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            PS4InputChord;                                     // 0x0028(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            XBoxInputChord;                                    // 0x0048(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionActionKeyMapping) == 0x000008, "Wrong alignment on FInteractionActionKeyMapping");
static_assert(sizeof(FInteractionActionKeyMapping) == 0x000068, "Wrong size on FInteractionActionKeyMapping");
static_assert(offsetof(FInteractionActionKeyMapping, ActionName) == 0x000000, "Member 'FInteractionActionKeyMapping::ActionName' has a wrong offset!");
static_assert(offsetof(FInteractionActionKeyMapping, KeyboardInputChord) == 0x000008, "Member 'FInteractionActionKeyMapping::KeyboardInputChord' has a wrong offset!");
static_assert(offsetof(FInteractionActionKeyMapping, PS4InputChord) == 0x000028, "Member 'FInteractionActionKeyMapping::PS4InputChord' has a wrong offset!");
static_assert(offsetof(FInteractionActionKeyMapping, XBoxInputChord) == 0x000048, "Member 'FInteractionActionKeyMapping::XBoxInputChord' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionPreInputInfo
// 0x0018 (0x0018 - 0x0000)
struct FInteractionPreInputInfo final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDown;                                             // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             Action;                                            // 0x0008(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionPreInputInfo) == 0x000004, "Wrong alignment on FInteractionPreInputInfo");
static_assert(sizeof(FInteractionPreInputInfo) == 0x000018, "Wrong size on FInteractionPreInputInfo");
static_assert(offsetof(FInteractionPreInputInfo, Handle) == 0x000000, "Member 'FInteractionPreInputInfo::Handle' has a wrong offset!");
static_assert(offsetof(FInteractionPreInputInfo, bDown) == 0x000004, "Member 'FInteractionPreInputInfo::bDown' has a wrong offset!");
static_assert(offsetof(FInteractionPreInputInfo, Action) == 0x000008, "Member 'FInteractionPreInputInfo::Action' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionCacheKeyBinding
// 0x0020 (0x0020 - 0x0000)
struct FInteractionCacheKeyBinding final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   EventType;                                         // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionCacheKeyBinding) == 0x000008, "Wrong alignment on FInteractionCacheKeyBinding");
static_assert(sizeof(FInteractionCacheKeyBinding) == 0x000020, "Wrong size on FInteractionCacheKeyBinding");
static_assert(offsetof(FInteractionCacheKeyBinding, Key) == 0x000000, "Member 'FInteractionCacheKeyBinding::Key' has a wrong offset!");
static_assert(offsetof(FInteractionCacheKeyBinding, EventType) == 0x000018, "Member 'FInteractionCacheKeyBinding::EventType' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionInputContext
// 0x0020 (0x0020 - 0x0000)
struct FInteractionInputContext final
{
public:
	class UInteractionInputComponent*             InputComponent;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionInputContext) == 0x000008, "Wrong alignment on FInteractionInputContext");
static_assert(sizeof(FInteractionInputContext) == 0x000020, "Wrong size on FInteractionInputContext");
static_assert(offsetof(FInteractionInputContext, InputComponent) == 0x000000, "Member 'FInteractionInputContext::InputComponent' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.DragCircleDataV3
// 0x0010 (0x0010 - 0x0000)
struct FDragCircleDataV3 final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CircleMappingCurve;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragCircleDataV3) == 0x000008, "Wrong alignment on FDragCircleDataV3");
static_assert(sizeof(FDragCircleDataV3) == 0x000010, "Wrong size on FDragCircleDataV3");
static_assert(offsetof(FDragCircleDataV3, Radius) == 0x000000, "Member 'FDragCircleDataV3::Radius' has a wrong offset!");
static_assert(offsetof(FDragCircleDataV3, CircleMappingCurve) == 0x000008, "Member 'FDragCircleDataV3::CircleMappingCurve' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.DragControlDataV3
// 0x0050 (0x0050 - 0x0000)
struct FDragControlDataV3 final
{
public:
	struct FVector2D                              ScreenPercentToWorld;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               WorldSpaceLimit;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DragDampingCurve;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DragRecoverCurve;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragRecoverTime;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUseCircleMapping;                               // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragCircleDataV3                      CircleMappingData;                                 // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsUseLimitSpeed;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpdLimit;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragControlDataV3) == 0x000010, "Wrong alignment on FDragControlDataV3");
static_assert(sizeof(FDragControlDataV3) == 0x000050, "Wrong size on FDragControlDataV3");
static_assert(offsetof(FDragControlDataV3, ScreenPercentToWorld) == 0x000000, "Member 'FDragControlDataV3::ScreenPercentToWorld' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, WorldSpaceLimit) == 0x000010, "Member 'FDragControlDataV3::WorldSpaceLimit' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, DragDampingCurve) == 0x000020, "Member 'FDragControlDataV3::DragDampingCurve' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, DragRecoverCurve) == 0x000028, "Member 'FDragControlDataV3::DragRecoverCurve' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, DragRecoverTime) == 0x000030, "Member 'FDragControlDataV3::DragRecoverTime' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, bIsUseCircleMapping) == 0x000034, "Member 'FDragControlDataV3::bIsUseCircleMapping' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, CircleMappingData) == 0x000038, "Member 'FDragControlDataV3::CircleMappingData' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, bIsUseLimitSpeed) == 0x000048, "Member 'FDragControlDataV3::bIsUseLimitSpeed' has a wrong offset!");
static_assert(offsetof(FDragControlDataV3, SpdLimit) == 0x00004C, "Member 'FDragControlDataV3::SpdLimit' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionStandByActortStaticInfo
// 0x0060 (0x0060 - 0x0000)
struct FInteractionStandByActortStaticInfo final
{
public:
	class FName                                   ScenarioName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             ActorNames;                                        // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionStandByActortStaticInfo) == 0x000008, "Wrong alignment on FInteractionStandByActortStaticInfo");
static_assert(sizeof(FInteractionStandByActortStaticInfo) == 0x000060, "Wrong size on FInteractionStandByActortStaticInfo");
static_assert(offsetof(FInteractionStandByActortStaticInfo, ScenarioName) == 0x000000, "Member 'FInteractionStandByActortStaticInfo::ScenarioName' has a wrong offset!");
static_assert(offsetof(FInteractionStandByActortStaticInfo, StateName) == 0x000008, "Member 'FInteractionStandByActortStaticInfo::StateName' has a wrong offset!");
static_assert(offsetof(FInteractionStandByActortStaticInfo, ActorNames) == 0x000010, "Member 'FInteractionStandByActortStaticInfo::ActorNames' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionActorNames
// 0x0050 (0x0050 - 0x0000)
struct FInteractionActorNames final
{
public:
	TSet<class FName>                             ActorNames;                                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionActorNames) == 0x000008, "Wrong alignment on FInteractionActorNames");
static_assert(sizeof(FInteractionActorNames) == 0x000050, "Wrong size on FInteractionActorNames");
static_assert(offsetof(FInteractionActorNames, ActorNames) == 0x000000, "Member 'FInteractionActorNames::ActorNames' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionActorShowElementStaticInfo
// 0x0030 (0x0030 - 0x0000)
struct FInteractionActorShowElementStaticInfo final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UShowElementV3>          ShowElement;                                       // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionActorShowElementStaticInfo) == 0x000008, "Wrong alignment on FInteractionActorShowElementStaticInfo");
static_assert(sizeof(FInteractionActorShowElementStaticInfo) == 0x000030, "Wrong size on FInteractionActorShowElementStaticInfo");
static_assert(offsetof(FInteractionActorShowElementStaticInfo, ActorName) == 0x000000, "Member 'FInteractionActorShowElementStaticInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FInteractionActorShowElementStaticInfo, ShowElement) == 0x000008, "Member 'FInteractionActorShowElementStaticInfo::ShowElement' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionScenarioShowElementStaticInfo
// 0x0010 (0x0010 - 0x0000)
struct FInteractionScenarioShowElementStaticInfo final
{
public:
	TArray<struct FInteractionActorShowElementStaticInfo> ShowElementInfos;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionScenarioShowElementStaticInfo) == 0x000008, "Wrong alignment on FInteractionScenarioShowElementStaticInfo");
static_assert(sizeof(FInteractionScenarioShowElementStaticInfo) == 0x000010, "Wrong size on FInteractionScenarioShowElementStaticInfo");
static_assert(offsetof(FInteractionScenarioShowElementStaticInfo, ShowElementInfos) == 0x000000, "Member 'FInteractionScenarioShowElementStaticInfo::ShowElementInfos' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionActorStaticInfo
// 0x0028 (0x0028 - 0x0000)
struct FInteractionActorStaticInfo final
{
public:
	TSoftClassPtr<class UClass>                   ActorClassRef;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionActorStaticInfo) == 0x000008, "Wrong alignment on FInteractionActorStaticInfo");
static_assert(sizeof(FInteractionActorStaticInfo) == 0x000028, "Wrong size on FInteractionActorStaticInfo");
static_assert(offsetof(FInteractionActorStaticInfo, ActorClassRef) == 0x000000, "Member 'FInteractionActorStaticInfo::ActorClassRef' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.PerformerRuntimeSupport
// 0x0050 (0x0050 - 0x0000)
struct FPerformerRuntimeSupport final
{
public:
	TMap<class FName, TSoftObjectPtr<class UShowElementV3>> ShowElementsRefMap;                                // 0x0000(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformerRuntimeSupport) == 0x000008, "Wrong alignment on FPerformerRuntimeSupport");
static_assert(sizeof(FPerformerRuntimeSupport) == 0x000050, "Wrong size on FPerformerRuntimeSupport");
static_assert(offsetof(FPerformerRuntimeSupport, ShowElementsRefMap) == 0x000000, "Member 'FPerformerRuntimeSupport::ShowElementsRefMap' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.RuleStringConfig
// 0x0010 (0x0018 - 0x0008)
struct FRuleStringConfig final : public FTableRowBase
{
public:
	class FName                                   RuleStringName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuleStringContent;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleStringConfig) == 0x000008, "Wrong alignment on FRuleStringConfig");
static_assert(sizeof(FRuleStringConfig) == 0x000018, "Wrong size on FRuleStringConfig");
static_assert(offsetof(FRuleStringConfig, RuleStringName) == 0x000008, "Member 'FRuleStringConfig::RuleStringName' has a wrong offset!");
static_assert(offsetof(FRuleStringConfig, RuleStringContent) == 0x000010, "Member 'FRuleStringConfig::RuleStringContent' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3BlendSpaceData
// 0x0020 (0x0020 - 0x0000)
struct FInteractionV3BlendSpaceData final
{
public:
	EInteractionV3BlendSpaceSlot                  SlotType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            BlendSpace;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlendSpaceValue;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRatio;                                        // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionV3BlendSpaceData) == 0x000008, "Wrong alignment on FInteractionV3BlendSpaceData");
static_assert(sizeof(FInteractionV3BlendSpaceData) == 0x000020, "Wrong size on FInteractionV3BlendSpaceData");
static_assert(offsetof(FInteractionV3BlendSpaceData, SlotType) == 0x000000, "Member 'FInteractionV3BlendSpaceData::SlotType' has a wrong offset!");
static_assert(offsetof(FInteractionV3BlendSpaceData, BlendSpace) == 0x000008, "Member 'FInteractionV3BlendSpaceData::BlendSpace' has a wrong offset!");
static_assert(offsetof(FInteractionV3BlendSpaceData, BlendSpaceValue) == 0x000010, "Member 'FInteractionV3BlendSpaceData::BlendSpaceValue' has a wrong offset!");
static_assert(offsetof(FInteractionV3BlendSpaceData, BlendRatio) == 0x000018, "Member 'FInteractionV3BlendSpaceData::BlendRatio' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKMaintainRefPose
// 0x0014 (0x0014 - 0x0000)
struct FIKMaintainRefPose final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKMaintainRefPose) == 0x000004, "Wrong alignment on FIKMaintainRefPose");
static_assert(sizeof(FIKMaintainRefPose) == 0x000014, "Wrong size on FIKMaintainRefPose");
static_assert(offsetof(FIKMaintainRefPose, BoneName) == 0x000000, "Member 'FIKMaintainRefPose::BoneName' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPose, JointOffset) == 0x000008, "Member 'FIKMaintainRefPose::JointOffset' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKMaintainRefPoseRelative
// 0x0010 (0x0010 - 0x0000)
struct FIKMaintainRefPoseRelative final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefBoneName;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKMaintainRefPoseRelative) == 0x000004, "Wrong alignment on FIKMaintainRefPoseRelative");
static_assert(sizeof(FIKMaintainRefPoseRelative) == 0x000010, "Wrong size on FIKMaintainRefPoseRelative");
static_assert(offsetof(FIKMaintainRefPoseRelative, BoneName) == 0x000000, "Member 'FIKMaintainRefPoseRelative::BoneName' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPoseRelative, RefBoneName) == 0x000008, "Member 'FIKMaintainRefPoseRelative::RefBoneName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.WorldSpaceIKTarget
// 0x0050 (0x0050 - 0x0000)
struct FWorldSpaceIKTarget final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetTransform;                                   // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverValue;                                      // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldSpaceIKTarget) == 0x000010, "Wrong alignment on FWorldSpaceIKTarget");
static_assert(sizeof(FWorldSpaceIKTarget) == 0x000050, "Wrong size on FWorldSpaceIKTarget");
static_assert(offsetof(FWorldSpaceIKTarget, BoneName) == 0x000000, "Member 'FWorldSpaceIKTarget::BoneName' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTarget, TargetTransform) == 0x000010, "Member 'FWorldSpaceIKTarget::TargetTransform' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTarget, JointOffset) == 0x000040, "Member 'FWorldSpaceIKTarget::JointOffset' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTarget, RecoverValue) == 0x00004C, "Member 'FWorldSpaceIKTarget::RecoverValue' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKWorldSpaceEffectorAccumulate
// 0x0060 (0x0060 - 0x0000)
struct FIKWorldSpaceEffectorAccumulate final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AccumulateEffectorTransform;                       // 0x0020(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMaintainCSPoseRotation;                           // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIKWorldSpaceEffectorAccumulate) == 0x000010, "Wrong alignment on FIKWorldSpaceEffectorAccumulate");
static_assert(sizeof(FIKWorldSpaceEffectorAccumulate) == 0x000060, "Wrong size on FIKWorldSpaceEffectorAccumulate");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulate, BoneName) == 0x000000, "Member 'FIKWorldSpaceEffectorAccumulate::BoneName' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulate, JointOffset) == 0x000008, "Member 'FIKWorldSpaceEffectorAccumulate::JointOffset' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulate, AccumulateEffectorTransform) == 0x000020, "Member 'FIKWorldSpaceEffectorAccumulate::AccumulateEffectorTransform' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulate, bMaintainCSPoseRotation) == 0x000050, "Member 'FIKWorldSpaceEffectorAccumulate::bMaintainCSPoseRotation' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKWorldSpaceJointAccumulate
// 0x0040 (0x0040 - 0x0000)
struct FIKWorldSpaceJointAccumulate final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AccumulateJointTransform;                          // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKWorldSpaceJointAccumulate) == 0x000010, "Wrong alignment on FIKWorldSpaceJointAccumulate");
static_assert(sizeof(FIKWorldSpaceJointAccumulate) == 0x000040, "Wrong size on FIKWorldSpaceJointAccumulate");
static_assert(offsetof(FIKWorldSpaceJointAccumulate, BoneName) == 0x000000, "Member 'FIKWorldSpaceJointAccumulate::BoneName' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceJointAccumulate, AccumulateJointTransform) == 0x000010, "Member 'FIKWorldSpaceJointAccumulate::AccumulateJointTransform' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3IKData
// 0x0190 (0x0190 - 0x0000)
struct FInteractionV3IKData final
{
public:
	TMap<class FName, struct FIKMaintainRefPose>  MaintainRefPoses;                                  // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FIKMaintainRefPoseRelative> MaintainRefPoseRelatives;                          // 0x0050(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FWorldSpaceIKTarget> WorldSpaceIKTargets;                               // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FIKWorldSpaceEffectorAccumulate> WorldSpaceEffectorAccumulates;                     // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FIKWorldSpaceJointAccumulate> WorldSpaceJointAccumulates;                        // 0x0140(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3IKData) == 0x000008, "Wrong alignment on FInteractionV3IKData");
static_assert(sizeof(FInteractionV3IKData) == 0x000190, "Wrong size on FInteractionV3IKData");
static_assert(offsetof(FInteractionV3IKData, MaintainRefPoses) == 0x000000, "Member 'FInteractionV3IKData::MaintainRefPoses' has a wrong offset!");
static_assert(offsetof(FInteractionV3IKData, MaintainRefPoseRelatives) == 0x000050, "Member 'FInteractionV3IKData::MaintainRefPoseRelatives' has a wrong offset!");
static_assert(offsetof(FInteractionV3IKData, WorldSpaceIKTargets) == 0x0000A0, "Member 'FInteractionV3IKData::WorldSpaceIKTargets' has a wrong offset!");
static_assert(offsetof(FInteractionV3IKData, WorldSpaceEffectorAccumulates) == 0x0000F0, "Member 'FInteractionV3IKData::WorldSpaceEffectorAccumulates' has a wrong offset!");
static_assert(offsetof(FInteractionV3IKData, WorldSpaceJointAccumulates) == 0x000140, "Member 'FInteractionV3IKData::WorldSpaceJointAccumulates' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3AnimInstanceProxy
// 0x0060 (0x07C0 - 0x0760)
struct FInteractionV3AnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	TArray<struct FInteractionV3BlendSpaceData>   BlendSpaceDatas;                                   // 0x0760(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<EInteractionV3IKSlot, struct FInteractionV3IKData> IKDatas;                                           // 0x0770(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3AnimInstanceProxy) == 0x000010, "Wrong alignment on FInteractionV3AnimInstanceProxy");
static_assert(sizeof(FInteractionV3AnimInstanceProxy) == 0x0007C0, "Wrong size on FInteractionV3AnimInstanceProxy");
static_assert(offsetof(FInteractionV3AnimInstanceProxy, BlendSpaceDatas) == 0x000760, "Member 'FInteractionV3AnimInstanceProxy::BlendSpaceDatas' has a wrong offset!");
static_assert(offsetof(FInteractionV3AnimInstanceProxy, IKDatas) == 0x000770, "Member 'FInteractionV3AnimInstanceProxy::IKDatas' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.PhysicsControlRigidBodyRelativeControlTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FPhysicsControlRigidBodyRelativeControlTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhysicsControlRigidBodyRelativeControlTickFunction) == 0x000008, "Wrong alignment on FPhysicsControlRigidBodyRelativeControlTickFunction");
static_assert(sizeof(FPhysicsControlRigidBodyRelativeControlTickFunction) == 0x000030, "Wrong size on FPhysicsControlRigidBodyRelativeControlTickFunction");

// ScriptStruct CharacterInteractionV3.RigidBodyRelativeControlRecord
// 0x0028 (0x0028 - 0x0000)
struct FRigidBodyRelativeControlRecord final
{
public:
	class FName                                   ControlName;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          ParentMeshComponent;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentBoneName;                                    // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          ChildMeshComponent;                                // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChildBoneName;                                     // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigidBodyRelativeControlRecord) == 0x000004, "Wrong alignment on FRigidBodyRelativeControlRecord");
static_assert(sizeof(FRigidBodyRelativeControlRecord) == 0x000028, "Wrong size on FRigidBodyRelativeControlRecord");
static_assert(offsetof(FRigidBodyRelativeControlRecord, ControlName) == 0x000000, "Member 'FRigidBodyRelativeControlRecord::ControlName' has a wrong offset!");
static_assert(offsetof(FRigidBodyRelativeControlRecord, ParentMeshComponent) == 0x000008, "Member 'FRigidBodyRelativeControlRecord::ParentMeshComponent' has a wrong offset!");
static_assert(offsetof(FRigidBodyRelativeControlRecord, ParentBoneName) == 0x000010, "Member 'FRigidBodyRelativeControlRecord::ParentBoneName' has a wrong offset!");
static_assert(offsetof(FRigidBodyRelativeControlRecord, ChildMeshComponent) == 0x000018, "Member 'FRigidBodyRelativeControlRecord::ChildMeshComponent' has a wrong offset!");
static_assert(offsetof(FRigidBodyRelativeControlRecord, ChildBoneName) == 0x000020, "Member 'FRigidBodyRelativeControlRecord::ChildBoneName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.StandbyCameraConfig
// 0x00E8 (0x00F0 - 0x0008)
struct FStandbyCameraConfig final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionV3StandbyCameraType               CameraType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Direction;                                         // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PitchRange;                                        // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              YawRange;                                          // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalDistance;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveFocalDistance_Pitch;                          // 0x0030(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveFocalDistance_Yaw;                            // 0x0048(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionV3CameraMoveType                  PitchMoveType;                                     // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CurveDampingPitch;                                 // 0x0068(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveDampingYaw;                                   // 0x0080(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveScreenInputPitch;                             // 0x0098(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CurveScreenInputYaw;                               // 0x00B0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCameraLag;                                   // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagRotateSpeed;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagTranslateSpeed;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CanOpreateCameraState;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCameraTranslat;                              // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CameraTranslateH;                                  // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraTranslateV;                                  // 0x00E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandbyCameraConfig) == 0x000008, "Wrong alignment on FStandbyCameraConfig");
static_assert(sizeof(FStandbyCameraConfig) == 0x0000F0, "Wrong size on FStandbyCameraConfig");
static_assert(offsetof(FStandbyCameraConfig, ID) == 0x000008, "Member 'FStandbyCameraConfig::ID' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CameraType) == 0x000010, "Member 'FStandbyCameraConfig::CameraType' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, Direction) == 0x000014, "Member 'FStandbyCameraConfig::Direction' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, PitchRange) == 0x00001C, "Member 'FStandbyCameraConfig::PitchRange' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, YawRange) == 0x000024, "Member 'FStandbyCameraConfig::YawRange' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, FocalDistance) == 0x00002C, "Member 'FStandbyCameraConfig::FocalDistance' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveFocalDistance_Pitch) == 0x000030, "Member 'FStandbyCameraConfig::CurveFocalDistance_Pitch' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveFocalDistance_Yaw) == 0x000048, "Member 'FStandbyCameraConfig::CurveFocalDistance_Yaw' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, PitchMoveType) == 0x000060, "Member 'FStandbyCameraConfig::PitchMoveType' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveDampingPitch) == 0x000068, "Member 'FStandbyCameraConfig::CurveDampingPitch' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveDampingYaw) == 0x000080, "Member 'FStandbyCameraConfig::CurveDampingYaw' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveScreenInputPitch) == 0x000098, "Member 'FStandbyCameraConfig::CurveScreenInputPitch' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CurveScreenInputYaw) == 0x0000B0, "Member 'FStandbyCameraConfig::CurveScreenInputYaw' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, EnableCameraLag) == 0x0000C8, "Member 'FStandbyCameraConfig::EnableCameraLag' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CameraLagRotateSpeed) == 0x0000CC, "Member 'FStandbyCameraConfig::CameraLagRotateSpeed' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CameraLagTranslateSpeed) == 0x0000D0, "Member 'FStandbyCameraConfig::CameraLagTranslateSpeed' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CanOpreateCameraState) == 0x0000D4, "Member 'FStandbyCameraConfig::CanOpreateCameraState' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, EnableCameraTranslat) == 0x0000D8, "Member 'FStandbyCameraConfig::EnableCameraTranslat' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CameraTranslateH) == 0x0000DC, "Member 'FStandbyCameraConfig::CameraTranslateH' has a wrong offset!");
static_assert(offsetof(FStandbyCameraConfig, CameraTranslateV) == 0x0000E4, "Member 'FStandbyCameraConfig::CameraTranslateV' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.PhysicsProfileModifier
// 0x0020 (0x0020 - 0x0000)
struct FPhysicsProfileModifier final
{
public:
	class FName                                   StartPhysicsControlProfile;                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndPhysicsControlProfile;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartConstraintProfile;                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndConstraintProfile;                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicsProfileModifier) == 0x000004, "Wrong alignment on FPhysicsProfileModifier");
static_assert(sizeof(FPhysicsProfileModifier) == 0x000020, "Wrong size on FPhysicsProfileModifier");
static_assert(offsetof(FPhysicsProfileModifier, StartPhysicsControlProfile) == 0x000000, "Member 'FPhysicsProfileModifier::StartPhysicsControlProfile' has a wrong offset!");
static_assert(offsetof(FPhysicsProfileModifier, EndPhysicsControlProfile) == 0x000008, "Member 'FPhysicsProfileModifier::EndPhysicsControlProfile' has a wrong offset!");
static_assert(offsetof(FPhysicsProfileModifier, StartConstraintProfile) == 0x000010, "Member 'FPhysicsProfileModifier::StartConstraintProfile' has a wrong offset!");
static_assert(offsetof(FPhysicsProfileModifier, EndConstraintProfile) == 0x000018, "Member 'FPhysicsProfileModifier::EndConstraintProfile' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3PhysProfileModifier
// 0x0060 (0x0060 - 0x0000)
struct FInteractionV3PhysProfileModifier final
{
public:
	struct FPhysicsProfileModifier                BodyProfile;                                       // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsProfileModifier                BodyAnimNodeProfile;                               // 0x0020(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsProfileModifier                FaceProfile;                                       // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3PhysProfileModifier) == 0x000004, "Wrong alignment on FInteractionV3PhysProfileModifier");
static_assert(sizeof(FInteractionV3PhysProfileModifier) == 0x000060, "Wrong size on FInteractionV3PhysProfileModifier");
static_assert(offsetof(FInteractionV3PhysProfileModifier, BodyProfile) == 0x000000, "Member 'FInteractionV3PhysProfileModifier::BodyProfile' has a wrong offset!");
static_assert(offsetof(FInteractionV3PhysProfileModifier, BodyAnimNodeProfile) == 0x000020, "Member 'FInteractionV3PhysProfileModifier::BodyAnimNodeProfile' has a wrong offset!");
static_assert(offsetof(FInteractionV3PhysProfileModifier, FaceProfile) == 0x000040, "Member 'FInteractionV3PhysProfileModifier::FaceProfile' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKWorldSpaceEffectorAccumulateConfig
// 0x0028 (0x0028 - 0x0000)
struct FIKWorldSpaceEffectorAccumulateConfig final
{
public:
	EInteractionV3IKSlot                          SlotType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffectorOffsetScale;                               // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainCSPoseRotation;                           // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIKWorldSpaceEffectorAccumulateConfig) == 0x000004, "Wrong alignment on FIKWorldSpaceEffectorAccumulateConfig");
static_assert(sizeof(FIKWorldSpaceEffectorAccumulateConfig) == 0x000028, "Wrong size on FIKWorldSpaceEffectorAccumulateConfig");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulateConfig, SlotType) == 0x000000, "Member 'FIKWorldSpaceEffectorAccumulateConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulateConfig, BoneName) == 0x000004, "Member 'FIKWorldSpaceEffectorAccumulateConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulateConfig, JointOffset) == 0x00000C, "Member 'FIKWorldSpaceEffectorAccumulateConfig::JointOffset' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulateConfig, EffectorOffsetScale) == 0x000018, "Member 'FIKWorldSpaceEffectorAccumulateConfig::EffectorOffsetScale' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceEffectorAccumulateConfig, bMaintainCSPoseRotation) == 0x000024, "Member 'FIKWorldSpaceEffectorAccumulateConfig::bMaintainCSPoseRotation' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKWorldSpaceJointAccumulateConfig
// 0x000C (0x000C - 0x0000)
struct FIKWorldSpaceJointAccumulateConfig final
{
public:
	EInteractionV3IKSlot                          SlotType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKWorldSpaceJointAccumulateConfig) == 0x000004, "Wrong alignment on FIKWorldSpaceJointAccumulateConfig");
static_assert(sizeof(FIKWorldSpaceJointAccumulateConfig) == 0x00000C, "Wrong size on FIKWorldSpaceJointAccumulateConfig");
static_assert(offsetof(FIKWorldSpaceJointAccumulateConfig, SlotType) == 0x000000, "Member 'FIKWorldSpaceJointAccumulateConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceJointAccumulateConfig, BoneName) == 0x000004, "Member 'FIKWorldSpaceJointAccumulateConfig::BoneName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKWorldSpaceOffsetData
// 0x0020 (0x0020 - 0x0000)
struct FIKWorldSpaceOffsetData final
{
public:
	TArray<struct FIKWorldSpaceEffectorAccumulateConfig> EffectorOffsetConfigs;                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FIKWorldSpaceJointAccumulateConfig> JointOffsetConfigs;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKWorldSpaceOffsetData) == 0x000008, "Wrong alignment on FIKWorldSpaceOffsetData");
static_assert(sizeof(FIKWorldSpaceOffsetData) == 0x000020, "Wrong size on FIKWorldSpaceOffsetData");
static_assert(offsetof(FIKWorldSpaceOffsetData, EffectorOffsetConfigs) == 0x000000, "Member 'FIKWorldSpaceOffsetData::EffectorOffsetConfigs' has a wrong offset!");
static_assert(offsetof(FIKWorldSpaceOffsetData, JointOffsetConfigs) == 0x000010, "Member 'FIKWorldSpaceOffsetData::JointOffsetConfigs' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.WorldSpaceIKTargetBoneConfig
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FWorldSpaceIKTargetBoneConfig final
{
public:
	EInteractionV3IKSlot                          SlotType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x38];                                      // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldSpaceIKTargetBoneConfig) == 0x000010, "Wrong alignment on FWorldSpaceIKTargetBoneConfig");
static_assert(sizeof(FWorldSpaceIKTargetBoneConfig) == 0x000050, "Wrong size on FWorldSpaceIKTargetBoneConfig");
static_assert(offsetof(FWorldSpaceIKTargetBoneConfig, SlotType) == 0x000000, "Member 'FWorldSpaceIKTargetBoneConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTargetBoneConfig, BoneName) == 0x000004, "Member 'FWorldSpaceIKTargetBoneConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTargetBoneConfig, JointOffset) == 0x00000C, "Member 'FWorldSpaceIKTargetBoneConfig::JointOffset' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.WorldSpaceIKTargetConfig
// 0x0020 (0x0020 - 0x0000)
struct FWorldSpaceIKTargetConfig final
{
public:
	class FName                                   ParentActorName;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentBoneName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWorldSpaceIKTargetBoneConfig>  BoneConfigs;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldSpaceIKTargetConfig) == 0x000008, "Wrong alignment on FWorldSpaceIKTargetConfig");
static_assert(sizeof(FWorldSpaceIKTargetConfig) == 0x000020, "Wrong size on FWorldSpaceIKTargetConfig");
static_assert(offsetof(FWorldSpaceIKTargetConfig, ParentActorName) == 0x000000, "Member 'FWorldSpaceIKTargetConfig::ParentActorName' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTargetConfig, ParentBoneName) == 0x000008, "Member 'FWorldSpaceIKTargetConfig::ParentBoneName' has a wrong offset!");
static_assert(offsetof(FWorldSpaceIKTargetConfig, BoneConfigs) == 0x000010, "Member 'FWorldSpaceIKTargetConfig::BoneConfigs' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKMaintainWorldSpaceRelativeData
// 0x0010 (0x0010 - 0x0000)
struct FIKMaintainWorldSpaceRelativeData final
{
public:
	TArray<struct FWorldSpaceIKTargetConfig>      Configs;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKMaintainWorldSpaceRelativeData) == 0x000008, "Wrong alignment on FIKMaintainWorldSpaceRelativeData");
static_assert(sizeof(FIKMaintainWorldSpaceRelativeData) == 0x000010, "Wrong size on FIKMaintainWorldSpaceRelativeData");
static_assert(offsetof(FIKMaintainWorldSpaceRelativeData, Configs) == 0x000000, "Member 'FIKMaintainWorldSpaceRelativeData::Configs' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKMaintainRefPoseConfig
// 0x0018 (0x0018 - 0x0000)
struct FIKMaintainRefPoseConfig final
{
public:
	EInteractionV3IKSlot                          SlotType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointOffset;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKMaintainRefPoseConfig) == 0x000004, "Wrong alignment on FIKMaintainRefPoseConfig");
static_assert(sizeof(FIKMaintainRefPoseConfig) == 0x000018, "Wrong size on FIKMaintainRefPoseConfig");
static_assert(offsetof(FIKMaintainRefPoseConfig, SlotType) == 0x000000, "Member 'FIKMaintainRefPoseConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPoseConfig, BoneName) == 0x000004, "Member 'FIKMaintainRefPoseConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPoseConfig, JointOffset) == 0x00000C, "Member 'FIKMaintainRefPoseConfig::JointOffset' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKMaintainRefPoseRelativeConfig
// 0x0014 (0x0014 - 0x0000)
struct FIKMaintainRefPoseRelativeConfig final
{
public:
	EInteractionV3IKSlot                          SlotType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RefBoneName;                                       // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKMaintainRefPoseRelativeConfig) == 0x000004, "Wrong alignment on FIKMaintainRefPoseRelativeConfig");
static_assert(sizeof(FIKMaintainRefPoseRelativeConfig) == 0x000014, "Wrong size on FIKMaintainRefPoseRelativeConfig");
static_assert(offsetof(FIKMaintainRefPoseRelativeConfig, SlotType) == 0x000000, "Member 'FIKMaintainRefPoseRelativeConfig::SlotType' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPoseRelativeConfig, BoneName) == 0x000004, "Member 'FIKMaintainRefPoseRelativeConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FIKMaintainRefPoseRelativeConfig, RefBoneName) == 0x00000C, "Member 'FIKMaintainRefPoseRelativeConfig::RefBoneName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.IKRefPoseFixData
// 0x0020 (0x0020 - 0x0000)
struct FIKRefPoseFixData final
{
public:
	TArray<struct FIKMaintainRefPoseConfig>       MaintainRefPoseConfigs;                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FIKMaintainRefPoseRelativeConfig> MaintainRefPoseRelativeConfigs;                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKRefPoseFixData) == 0x000008, "Wrong alignment on FIKRefPoseFixData");
static_assert(sizeof(FIKRefPoseFixData) == 0x000020, "Wrong size on FIKRefPoseFixData");
static_assert(offsetof(FIKRefPoseFixData, MaintainRefPoseConfigs) == 0x000000, "Member 'FIKRefPoseFixData::MaintainRefPoseConfigs' has a wrong offset!");
static_assert(offsetof(FIKRefPoseFixData, MaintainRefPoseRelativeConfigs) == 0x000010, "Member 'FIKRefPoseFixData::MaintainRefPoseRelativeConfigs' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ActorOperateActTemplate
// 0x0068 (0x0070 - 0x0008)
struct FActorOperateActTemplate final : public FTableRowBase
{
public:
	class FName                                   TemplateName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ActorOperateActPath;                               // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         InputControlPath;                                  // 0x0028(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CompleteTriggerPath;                               // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AutoConfigPath;                                    // 0x0058(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorOperateActTemplate) == 0x000008, "Wrong alignment on FActorOperateActTemplate");
static_assert(sizeof(FActorOperateActTemplate) == 0x000070, "Wrong size on FActorOperateActTemplate");
static_assert(offsetof(FActorOperateActTemplate, TemplateName) == 0x000008, "Member 'FActorOperateActTemplate::TemplateName' has a wrong offset!");
static_assert(offsetof(FActorOperateActTemplate, ActorOperateActPath) == 0x000010, "Member 'FActorOperateActTemplate::ActorOperateActPath' has a wrong offset!");
static_assert(offsetof(FActorOperateActTemplate, InputControlPath) == 0x000028, "Member 'FActorOperateActTemplate::InputControlPath' has a wrong offset!");
static_assert(offsetof(FActorOperateActTemplate, CompleteTriggerPath) == 0x000040, "Member 'FActorOperateActTemplate::CompleteTriggerPath' has a wrong offset!");
static_assert(offsetof(FActorOperateActTemplate, AutoConfigPath) == 0x000058, "Member 'FActorOperateActTemplate::AutoConfigPath' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioOperateTemplate
// 0x0020 (0x0028 - 0x0008)
struct FScenarioOperateTemplate final : public FTableRowBase
{
public:
	class FName                                   TemplateName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ScenarioOperatePath;                               // 0x0010(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioOperateTemplate) == 0x000008, "Wrong alignment on FScenarioOperateTemplate");
static_assert(sizeof(FScenarioOperateTemplate) == 0x000028, "Wrong size on FScenarioOperateTemplate");
static_assert(offsetof(FScenarioOperateTemplate, TemplateName) == 0x000008, "Member 'FScenarioOperateTemplate::TemplateName' has a wrong offset!");
static_assert(offsetof(FScenarioOperateTemplate, ScenarioOperatePath) == 0x000010, "Member 'FScenarioOperateTemplate::ScenarioOperatePath' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ActorOperateActInfo
// 0x0010 (0x0010 - 0x0000)
struct FActorOperateActInfo final
{
public:
	class FName                                   CharacterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorOperateAct*                       ActorOperateAct;                                   // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorOperateActInfo) == 0x000008, "Wrong alignment on FActorOperateActInfo");
static_assert(sizeof(FActorOperateActInfo) == 0x000010, "Wrong size on FActorOperateActInfo");
static_assert(offsetof(FActorOperateActInfo, CharacterName) == 0x000000, "Member 'FActorOperateActInfo::CharacterName' has a wrong offset!");
static_assert(offsetof(FActorOperateActInfo, ActorOperateAct) == 0x000008, "Member 'FActorOperateActInfo::ActorOperateAct' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionLookAtBoneData
// 0x0010 (0x0010 - 0x0000)
struct FInteractionLookAtBoneData final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionLookAtBoneData) == 0x000004, "Wrong alignment on FInteractionLookAtBoneData");
static_assert(sizeof(FInteractionLookAtBoneData) == 0x000010, "Wrong size on FInteractionLookAtBoneData");
static_assert(offsetof(FInteractionLookAtBoneData, ActorName) == 0x000000, "Member 'FInteractionLookAtBoneData::ActorName' has a wrong offset!");
static_assert(offsetof(FInteractionLookAtBoneData, BoneName) == 0x000008, "Member 'FInteractionLookAtBoneData::BoneName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.PhysicsAssetModifier
// 0x0050 (0x0050 - 0x0000)
struct FPhysicsAssetModifier final
{
public:
	TSoftObjectPtr<class UPhysicsAsset>           OverridePhysicsAsset;                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPhysicsControlAsset>    OverridePhysicsControlAsset;                       // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicsAssetModifier) == 0x000008, "Wrong alignment on FPhysicsAssetModifier");
static_assert(sizeof(FPhysicsAssetModifier) == 0x000050, "Wrong size on FPhysicsAssetModifier");
static_assert(offsetof(FPhysicsAssetModifier, OverridePhysicsAsset) == 0x000000, "Member 'FPhysicsAssetModifier::OverridePhysicsAsset' has a wrong offset!");
static_assert(offsetof(FPhysicsAssetModifier, OverridePhysicsControlAsset) == 0x000028, "Member 'FPhysicsAssetModifier::OverridePhysicsControlAsset' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.CharacterPhysicsAssetModifier
// 0x00F8 (0x00F8 - 0x0000)
struct FCharacterPhysicsAssetModifier final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicsAssetModifier                  BodyModifier;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPhysicsAssetModifier                  BodyAnimNodeModifier;                              // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPhysicsAssetModifier                  FaceModifier;                                      // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPhysicsAssetModifier) == 0x000008, "Wrong alignment on FCharacterPhysicsAssetModifier");
static_assert(sizeof(FCharacterPhysicsAssetModifier) == 0x0000F8, "Wrong size on FCharacterPhysicsAssetModifier");
static_assert(offsetof(FCharacterPhysicsAssetModifier, ActorName) == 0x000000, "Member 'FCharacterPhysicsAssetModifier::ActorName' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsAssetModifier, BodyModifier) == 0x000008, "Member 'FCharacterPhysicsAssetModifier::BodyModifier' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsAssetModifier, BodyAnimNodeModifier) == 0x000058, "Member 'FCharacterPhysicsAssetModifier::BodyAnimNodeModifier' has a wrong offset!");
static_assert(offsetof(FCharacterPhysicsAssetModifier, FaceModifier) == 0x0000A8, "Member 'FCharacterPhysicsAssetModifier::FaceModifier' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3OperateWwise
// 0x0010 (0x0010 - 0x0000)
struct FInteractionV3OperateWwise final
{
public:
	class FString                                 WwiseEventName;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3OperateWwise) == 0x000008, "Wrong alignment on FInteractionV3OperateWwise");
static_assert(sizeof(FInteractionV3OperateWwise) == 0x000010, "Wrong size on FInteractionV3OperateWwise");
static_assert(offsetof(FInteractionV3OperateWwise, WwiseEventName) == 0x000000, "Member 'FInteractionV3OperateWwise::WwiseEventName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3CharacterHolyLight
// 0x0018 (0x0018 - 0x0000)
struct FInteractionV3CharacterHolyLight final
{
public:
	class FName                                   CharacterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionV3HolyLightData>    HolyLightData;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3CharacterHolyLight) == 0x000008, "Wrong alignment on FInteractionV3CharacterHolyLight");
static_assert(sizeof(FInteractionV3CharacterHolyLight) == 0x000018, "Wrong size on FInteractionV3CharacterHolyLight");
static_assert(offsetof(FInteractionV3CharacterHolyLight, CharacterName) == 0x000000, "Member 'FInteractionV3CharacterHolyLight::CharacterName' has a wrong offset!");
static_assert(offsetof(FInteractionV3CharacterHolyLight, HolyLightData) == 0x000008, "Member 'FInteractionV3CharacterHolyLight::HolyLightData' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.InteractionV3SpringInterpolation
// 0x0010 (0x0010 - 0x0000)
struct FInteractionV3SpringInterpolation final
{
public:
	float                                         Damping;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DragVelocity;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionV3SpringInterpolation) == 0x000004, "Wrong alignment on FInteractionV3SpringInterpolation");
static_assert(sizeof(FInteractionV3SpringInterpolation) == 0x000010, "Wrong size on FInteractionV3SpringInterpolation");
static_assert(offsetof(FInteractionV3SpringInterpolation, Damping) == 0x000000, "Member 'FInteractionV3SpringInterpolation::Damping' has a wrong offset!");
static_assert(offsetof(FInteractionV3SpringInterpolation, Stiffness) == 0x000004, "Member 'FInteractionV3SpringInterpolation::Stiffness' has a wrong offset!");
static_assert(offsetof(FInteractionV3SpringInterpolation, DragVelocity) == 0x000008, "Member 'FInteractionV3SpringInterpolation::DragVelocity' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.LittleGameMusicQTEConfig
// 0x0030 (0x0038 - 0x0008)
struct FLittleGameMusicQTEConfig final : public FTableRowBase
{
public:
	TArray<struct FMusicQTEBtnData>               BtnData;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SuccessNum;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QTETime;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QTEBGM;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuccessBGM;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailBGM;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLittleGameMusicQTEConfig) == 0x000008, "Wrong alignment on FLittleGameMusicQTEConfig");
static_assert(sizeof(FLittleGameMusicQTEConfig) == 0x000038, "Wrong size on FLittleGameMusicQTEConfig");
static_assert(offsetof(FLittleGameMusicQTEConfig, BtnData) == 0x000008, "Member 'FLittleGameMusicQTEConfig::BtnData' has a wrong offset!");
static_assert(offsetof(FLittleGameMusicQTEConfig, SuccessNum) == 0x000018, "Member 'FLittleGameMusicQTEConfig::SuccessNum' has a wrong offset!");
static_assert(offsetof(FLittleGameMusicQTEConfig, QTETime) == 0x00001C, "Member 'FLittleGameMusicQTEConfig::QTETime' has a wrong offset!");
static_assert(offsetof(FLittleGameMusicQTEConfig, QTEBGM) == 0x000020, "Member 'FLittleGameMusicQTEConfig::QTEBGM' has a wrong offset!");
static_assert(offsetof(FLittleGameMusicQTEConfig, SuccessBGM) == 0x000028, "Member 'FLittleGameMusicQTEConfig::SuccessBGM' has a wrong offset!");
static_assert(offsetof(FLittleGameMusicQTEConfig, FailBGM) == 0x000030, "Member 'FLittleGameMusicQTEConfig::FailBGM' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ActorMetaTableConfig
// 0x0040 (0x0048 - 0x0008)
struct FActorMetaTableConfig final : public FTableRowBase
{
public:
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResourceName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimID;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCharacter;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FaceResourceName;                                  // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FaceID;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBodyChannel0;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBodyChannel1;                                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBodyChannel2;                                     // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceChannel0;                                     // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceChannel1;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceChannel2;                                     // 0x0045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorMetaTableConfig) == 0x000008, "Wrong alignment on FActorMetaTableConfig");
static_assert(sizeof(FActorMetaTableConfig) == 0x000048, "Wrong size on FActorMetaTableConfig");
static_assert(offsetof(FActorMetaTableConfig, ActorName) == 0x000008, "Member 'FActorMetaTableConfig::ActorName' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, ResourceName) == 0x000010, "Member 'FActorMetaTableConfig::ResourceName' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, AnimID) == 0x000018, "Member 'FActorMetaTableConfig::AnimID' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bIsCharacter) == 0x000020, "Member 'FActorMetaTableConfig::bIsCharacter' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, FaceResourceName) == 0x000024, "Member 'FActorMetaTableConfig::FaceResourceName' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, FaceID) == 0x000030, "Member 'FActorMetaTableConfig::FaceID' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bBodyChannel0) == 0x000040, "Member 'FActorMetaTableConfig::bBodyChannel0' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bBodyChannel1) == 0x000041, "Member 'FActorMetaTableConfig::bBodyChannel1' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bBodyChannel2) == 0x000042, "Member 'FActorMetaTableConfig::bBodyChannel2' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bFaceChannel0) == 0x000043, "Member 'FActorMetaTableConfig::bFaceChannel0' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bFaceChannel1) == 0x000044, "Member 'FActorMetaTableConfig::bFaceChannel1' has a wrong offset!");
static_assert(offsetof(FActorMetaTableConfig, bFaceChannel2) == 0x000045, "Member 'FActorMetaTableConfig::bFaceChannel2' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.LittleGameInputEvent
// 0x0018 (0x0018 - 0x0000)
struct FLittleGameInputEvent final
{
public:
	struct FVector2D                              MousePos;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ControlName;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLittleGameInputEvent) == 0x000008, "Wrong alignment on FLittleGameInputEvent");
static_assert(sizeof(FLittleGameInputEvent) == 0x000018, "Wrong size on FLittleGameInputEvent");
static_assert(offsetof(FLittleGameInputEvent, MousePos) == 0x000000, "Member 'FLittleGameInputEvent::MousePos' has a wrong offset!");
static_assert(offsetof(FLittleGameInputEvent, ControlName) == 0x000008, "Member 'FLittleGameInputEvent::ControlName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FScenarioActorInfo final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PositionActorName;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioActorInfo) == 0x000004, "Wrong alignment on FScenarioActorInfo");
static_assert(sizeof(FScenarioActorInfo) == 0x000010, "Wrong size on FScenarioActorInfo");
static_assert(offsetof(FScenarioActorInfo, ActorName) == 0x000000, "Member 'FScenarioActorInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FScenarioActorInfo, PositionActorName) == 0x000008, "Member 'FScenarioActorInfo::PositionActorName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioStateContext
// 0x0008 (0x0008 - 0x0000)
struct FScenarioStateContext final
{
public:
	class UScenarioStateComponent*                StateComponent;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScenarioStateContext) == 0x000008, "Wrong alignment on FScenarioStateContext");
static_assert(sizeof(FScenarioStateContext) == 0x000008, "Wrong size on FScenarioStateContext");
static_assert(offsetof(FScenarioStateContext, StateComponent) == 0x000000, "Member 'FScenarioStateContext::StateComponent' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.MagicCardInfo
// 0x000C (0x000C - 0x0000)
struct FMagicCardInfo final
{
public:
	int32                                         CardIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompleteValue;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagicCardInfo) == 0x000004, "Wrong alignment on FMagicCardInfo");
static_assert(sizeof(FMagicCardInfo) == 0x00000C, "Wrong size on FMagicCardInfo");
static_assert(offsetof(FMagicCardInfo, CardIndex) == 0x000000, "Member 'FMagicCardInfo::CardIndex' has a wrong offset!");
static_assert(offsetof(FMagicCardInfo, Weight) == 0x000004, "Member 'FMagicCardInfo::Weight' has a wrong offset!");
static_assert(offsetof(FMagicCardInfo, CompleteValue) == 0x000008, "Member 'FMagicCardInfo::CompleteValue' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.AddHolyLightDataInfo
// 0x0010 (0x0010 - 0x0000)
struct FAddHolyLightDataInfo final
{
public:
	TArray<struct FInteractionV3CharacterHolyLight> HolyLights;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddHolyLightDataInfo) == 0x000008, "Wrong alignment on FAddHolyLightDataInfo");
static_assert(sizeof(FAddHolyLightDataInfo) == 0x000010, "Wrong size on FAddHolyLightDataInfo");
static_assert(offsetof(FAddHolyLightDataInfo, HolyLights) == 0x000000, "Member 'FAddHolyLightDataInfo::HolyLights' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioShowElementPlayInfo
// 0x0030 (0x0030 - 0x0000)
struct FScenarioShowElementPlayInfo final
{
public:
	class FString                                 ShowElementName;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndLastShowElement;                               // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ElementPlayFinishEvent;                            // 0x0014(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaying;                                          // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayedTime;                                        // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioShowElementPlayInfo) == 0x000008, "Wrong alignment on FScenarioShowElementPlayInfo");
static_assert(sizeof(FScenarioShowElementPlayInfo) == 0x000030, "Wrong size on FScenarioShowElementPlayInfo");
static_assert(offsetof(FScenarioShowElementPlayInfo, ShowElementName) == 0x000000, "Member 'FScenarioShowElementPlayInfo::ShowElementName' has a wrong offset!");
static_assert(offsetof(FScenarioShowElementPlayInfo, bEndLastShowElement) == 0x000010, "Member 'FScenarioShowElementPlayInfo::bEndLastShowElement' has a wrong offset!");
static_assert(offsetof(FScenarioShowElementPlayInfo, ElementPlayFinishEvent) == 0x000014, "Member 'FScenarioShowElementPlayInfo::ElementPlayFinishEvent' has a wrong offset!");
static_assert(offsetof(FScenarioShowElementPlayInfo, DurationTime) == 0x000024, "Member 'FScenarioShowElementPlayInfo::DurationTime' has a wrong offset!");
static_assert(offsetof(FScenarioShowElementPlayInfo, bPlaying) == 0x000028, "Member 'FScenarioShowElementPlayInfo::bPlaying' has a wrong offset!");
static_assert(offsetof(FScenarioShowElementPlayInfo, PlayedTime) == 0x00002C, "Member 'FScenarioShowElementPlayInfo::PlayedTime' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ScenarioCycleActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FScenarioCycleActorInfo final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShowElementName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScenarioCycleActorInfo) == 0x000004, "Wrong alignment on FScenarioCycleActorInfo");
static_assert(sizeof(FScenarioCycleActorInfo) == 0x000010, "Wrong size on FScenarioCycleActorInfo");
static_assert(offsetof(FScenarioCycleActorInfo, ActorName) == 0x000000, "Member 'FScenarioCycleActorInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FScenarioCycleActorInfo, ShowElementName) == 0x000008, "Member 'FScenarioCycleActorInfo::ShowElementName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ConfessionFlowInfo
// 0x0038 (0x0038 - 0x0000)
struct FConfessionFlowInfo final
{
public:
	class FString                                 StateName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FlowId;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OptionText;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShowElementName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConfessionFlowInfo) == 0x000008, "Wrong alignment on FConfessionFlowInfo");
static_assert(sizeof(FConfessionFlowInfo) == 0x000038, "Wrong size on FConfessionFlowInfo");
static_assert(offsetof(FConfessionFlowInfo, StateName) == 0x000000, "Member 'FConfessionFlowInfo::StateName' has a wrong offset!");
static_assert(offsetof(FConfessionFlowInfo, FlowId) == 0x000010, "Member 'FConfessionFlowInfo::FlowId' has a wrong offset!");
static_assert(offsetof(FConfessionFlowInfo, OptionText) == 0x000020, "Member 'FConfessionFlowInfo::OptionText' has a wrong offset!");
static_assert(offsetof(FConfessionFlowInfo, ShowElementName) == 0x000030, "Member 'FConfessionFlowInfo::ShowElementName' has a wrong offset!");

// ScriptStruct CharacterInteractionV3.ConfessionStateActorInfo
// 0x0030 (0x0030 - 0x0000)
struct FConfessionStateActorInfo final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           AdditiveAnim;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConfessionStateActorInfo) == 0x000008, "Wrong alignment on FConfessionStateActorInfo");
static_assert(sizeof(FConfessionStateActorInfo) == 0x000030, "Wrong size on FConfessionStateActorInfo");
static_assert(offsetof(FConfessionStateActorInfo, ActorName) == 0x000000, "Member 'FConfessionStateActorInfo::ActorName' has a wrong offset!");
static_assert(offsetof(FConfessionStateActorInfo, AdditiveAnim) == 0x000008, "Member 'FConfessionStateActorInfo::AdditiveAnim' has a wrong offset!");

}


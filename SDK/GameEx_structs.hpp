#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameEx

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum GameEx.GECurveChangeType
// NumValues: 0x000A
enum class EGECurveChangeType : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	Pitch                                    = 3,
	Yaw                                      = 4,
	Roll                                     = 5,
	ScaleX                                   = 6,
	ScaleY                                   = 7,
	ScaleZ                                   = 8,
	GECurveChangeType_MAX                    = 9,
};

// Enum GameEx.ECheckTraceType
// NumValues: 0x0003
enum class ECheckTraceType : uint8
{
	ObjectChannel                            = 0,
	ObjectType                               = 1,
	ECheckTraceType_MAX                      = 2,
};

// Enum GameEx.EGECampRelation
// NumValues: 0x0005
enum class EGECampRelation : uint8
{
	Self                                     = 0,
	Friendly                                 = 2,
	Enermy                                   = 22,
	None                                     = 50,
	EGECampRelation_MAX                      = 51,
};

// Enum GameEx.EGEAttributeAttachType
// NumValues: 0x0003
enum class EGEAttributeAttachType : uint8
{
	Charater                                 = 0,
	Weapon                                   = 1,
	EGEAttributeAttachType_MAX               = 2,
};

// Enum GameEx.EGEAttributeValueType
// NumValues: 0x0004
enum class EGEAttributeValueType : uint8
{
	Numerical                                = 0,
	Percentage                               = 1,
	Multiply                                 = 2,
	EGEAttributeValueType_MAX                = 3,
};

// Enum GameEx.EGEAbilityForceFeedbackType
// NumValues: 0x0003
enum class EGEAbilityForceFeedbackType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	EGEAbilityForceFeedbackType_MAX          = 2,
};

// Enum GameEx.EGEBulletMovementType
// NumValues: 0x0006
enum class EGEBulletMovementType : uint8
{
	Naturally                                = 0,
	Parabola                                 = 1,
	AimLocation                              = 2,
	AimTarget                                = 3,
	Bomb                                     = 4,
	EGEBulletMovementType_MAX                = 5,
};

// Enum GameEx.EGEBulletWorkType
// NumValues: 0x0005
enum class EGEBulletWorkType : uint8
{
	None                                     = 0,
	EntityBullet                             = 1,
	RayBullet                                = 2,
	KeepRayBullet                            = 3,
	EGEBulletWorkType_MAX                    = 4,
};

// Enum GameEx.EGEBulletHitType
// NumValues: 0x0003
enum class EGEBulletHitType : uint8
{
	EntityBullet                             = 0,
	RayBullet                                = 1,
	EGEBulletHitType_MAX                     = 2,
};

// Enum GameEx.EGEWeaponFireMode
// NumValues: 0x0007
enum class EGEWeaponFireMode : uint8
{
	Normal                                   = 0,
	Single                                   = 1,
	Continuity                               = 2,
	AimFire                                  = 3,
	ShootFire                                = 4,
	Max_FireMode                             = 5,
	EGEWeaponFireMode_MAX                    = 6,
};

// Enum GameEx.EGEWeaponType
// NumValues: 0x0006
enum class EGEWeaponType : uint8
{
	None                                     = 0,
	SubmachineGun                            = 1,
	ShotGun                                  = 2,
	Hotwizer                                 = 3,
	ZBugMelle                                = 4,
	EGEWeaponType_MAX                        = 5,
};

// Enum GameEx.EGEWeaponBulletShootType
// NumValues: 0x0004
enum class EGEWeaponBulletShootType : uint8
{
	NotUse                                   = 0,
	UseDistance                              = 1,
	FullUse                                  = 2,
	EGEWeaponBulletShootType_MAX             = 3,
};

// Enum GameEx.EGEBuffAttachType
// NumValues: 0x0003
enum class EGEBuffAttachType : uint8
{
	Char                                     = 0,
	Weapon                                   = 1,
	EGEBuffAttachType_MAX                    = 2,
};

// Enum GameEx.EGEBuffTeamType
// NumValues: 0x0005
enum class EGEBuffTeamType : uint8
{
	Normal                                   = 0,
	ZBug                                     = 1,
	People                                   = 2,
	Hero                                     = 3,
	EGEBuffTeamType_MAX                      = 4,
};

// Enum GameEx.EGEAttributeType
// NumValues: 0x0003
enum class EGEAttributeType : uint8
{
	HealthBase                               = 0,
	AttackBase                               = 1,
	EGEAttributeType_MAX                     = 2,
};

// Enum GameEx.EGEZBugRunBugType
// NumValues: 0x0007
enum class EGEZBugRunBugType : uint8
{
	None                                     = 0,
	Invisible                                = 1,
	Tank                                     = 2,
	Furious                                  = 3,
	Cure                                     = 4,
	Origin                                   = 5,
	EGEZBugRunBugType_MAX                    = 6,
};

// Enum GameEx.EGEZBugRunTeamType
// NumValues: 0x0004
enum class EGEZBugRunTeamType : uint8
{
	None                                     = 0,
	ZBug                                     = 1,
	People                                   = 2,
	EGEZBugRunTeamType_MAX                   = 3,
};

// Enum GameEx.EGEHASTeamType
// NumValues: 0x0004
enum class EGEHASTeamType : uint8
{
	None                                     = 0,
	Catch                                    = 1,
	Hide                                     = 2,
	EGEHASTeamType_MAX                       = 3,
};

// Enum GameEx.EGELevelType
// NumValues: 0x0007
enum class EGELevelType : uint8
{
	None                                     = 0,
	Racing                                   = 1,
	Survive                                  = 2,
	Score                                    = 3,
	HideAndSeek                              = 4,
	ZBugRun                                  = 5,
	EGELevelType_MAX                         = 6,
};

// Enum GameEx.EWaterParkCharState
// NumValues: 0x000F
enum class EWaterParkCharState : uint8
{
	Normal                                   = 0,
	Walk                                     = 1,
	Jump                                     = 2,
	JumpSecond                               = 3,
	JumpEnd                                  = 4,
	HitFly                                   = 5,
	HitFlyEnd                                = 6,
	HitBack                                  = 7,
	Falling                                  = 8,
	Pounce                                   = 9,
	NormalStateCheck                         = 10,
	PounceUp                                 = 11,
	Slide                                    = 12,
	SlideEnd                                 = 13,
	EWaterParkCharState_MAX                  = 14,
};

// Enum GameEx.EGEBombState
// NumValues: 0x0008
enum class EGEBombState : uint8
{
	None                                     = 0,
	InPool                                   = 1,
	InScene                                  = 2,
	Catched                                  = 3,
	Throwed_Spline                           = 4,
	FreeMove                                 = 5,
	Boom                                     = 6,
	EGEBombState_MAX                         = 7,
};

// Enum GameEx.EWPClientGameTimeUpdateMode
// NumValues: 0x0004
enum class EWPClientGameTimeUpdateMode : uint8
{
	UpdatePerValidRTT                        = 0,
	UpdateOnlySmallerRTT                     = 1,
	UpdateOnlyDelay                          = 2,
	EWPClientGameTimeUpdateMode_MAX          = 3,
};

// Enum GameEx.EGEBrickRotateType
// NumValues: 0x0004
enum class EGEBrickRotateType : uint8
{
	Pitch                                    = 0,
	Yaw                                      = 1,
	Roll                                     = 2,
	EGEBrickRotateType_MAX                   = 3,
};

// Enum GameEx.EGERotateBrickState
// NumValues: 0x0004
enum class EGERotateBrickState : uint8
{
	Normal                                   = 0,
	ReadyToRotate                            = 1,
	Rotating                                 = 2,
	EGERotateBrickState_MAX                  = 3,
};

// Enum GameEx.EGESideBySideType
// NumValues: 0x0002
enum class EGESideBySideType : uint8
{
	CurveMoveRandom                          = 0,
	EGESideBySideType_MAX                    = 1,
};

// Enum GameEx.EGEZBug_RecoilState
// NumValues: 0x0005
enum class EGEZBug_RecoilState : uint8
{
	RecoilIdle                               = 0,
	RecoilFire                               = 1,
	RecoilSteady                             = 2,
	RecoilRecovery                           = 3,
	EGEZBug_MAX                              = 4,
};

// Enum GameEx.EAddCharSpeedType
// NumValues: 0x0004
enum class EAddCharSpeedType : uint8
{
	Value                                    = 0,
	Percent                                  = 1,
	UseBBPer                                 = 2,
	EAddCharSpeedType_MAX                    = 3,
};

// Enum GameEx.EWPModifySkillType
// NumValues: 0x0003
enum class EWPModifySkillType : uint8
{
	ReduceCD                                 = 0,
	AddStoreCount                            = 1,
	EWPModifySkillType_MAX                   = 2,
};

// ScriptStruct GameEx.GEWeaponAttributeTemplate
// 0x0034 (0x0034 - 0x0000)
struct FGEWeaponAttributeTemplate final
{
public:
	float                                         WeaponAttack;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRTValue;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRTDamage;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootSpeed;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCapacity;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadSpeed;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponFitRate;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardShootRange;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceDmgFactor;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceShootRange;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtremeDmgFactor;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtremeShootRange;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeAtkRange;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEWeaponAttributeTemplate) == 0x000004, "Wrong alignment on FGEWeaponAttributeTemplate");
static_assert(sizeof(FGEWeaponAttributeTemplate) == 0x000034, "Wrong size on FGEWeaponAttributeTemplate");
static_assert(offsetof(FGEWeaponAttributeTemplate, WeaponAttack) == 0x000000, "Member 'FGEWeaponAttributeTemplate::WeaponAttack' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, CRTValue) == 0x000004, "Member 'FGEWeaponAttributeTemplate::CRTValue' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, CRTDamage) == 0x000008, "Member 'FGEWeaponAttributeTemplate::CRTDamage' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ShootSpeed) == 0x00000C, "Member 'FGEWeaponAttributeTemplate::ShootSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, MagazineCapacity) == 0x000010, "Member 'FGEWeaponAttributeTemplate::MagazineCapacity' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ReloadSpeed) == 0x000014, "Member 'FGEWeaponAttributeTemplate::ReloadSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, WeaponFitRate) == 0x000018, "Member 'FGEWeaponAttributeTemplate::WeaponFitRate' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, StandardShootRange) == 0x00001C, "Member 'FGEWeaponAttributeTemplate::StandardShootRange' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ReduceDmgFactor) == 0x000020, "Member 'FGEWeaponAttributeTemplate::ReduceDmgFactor' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ReduceShootRange) == 0x000024, "Member 'FGEWeaponAttributeTemplate::ReduceShootRange' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ExtremeDmgFactor) == 0x000028, "Member 'FGEWeaponAttributeTemplate::ExtremeDmgFactor' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, ExtremeShootRange) == 0x00002C, "Member 'FGEWeaponAttributeTemplate::ExtremeShootRange' has a wrong offset!");
static_assert(offsetof(FGEWeaponAttributeTemplate, MeleeAtkRange) == 0x000030, "Member 'FGEWeaponAttributeTemplate::MeleeAtkRange' has a wrong offset!");

// ScriptStruct GameEx.GECharLevelAttributeTemplate
// 0x0024 (0x0024 - 0x0000)
struct FGECharLevelAttributeTemplate final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attack;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Defence;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRTValue;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRTDamage;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLevelExp;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScatterRatio;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootAddScatterRatio;                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverScatterSpeedRatio;                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGECharLevelAttributeTemplate) == 0x000004, "Wrong alignment on FGECharLevelAttributeTemplate");
static_assert(sizeof(FGECharLevelAttributeTemplate) == 0x000024, "Wrong size on FGECharLevelAttributeTemplate");
static_assert(offsetof(FGECharLevelAttributeTemplate, Health) == 0x000000, "Member 'FGECharLevelAttributeTemplate::Health' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, Attack) == 0x000004, "Member 'FGECharLevelAttributeTemplate::Attack' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, Defence) == 0x000008, "Member 'FGECharLevelAttributeTemplate::Defence' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, CRTValue) == 0x00000C, "Member 'FGECharLevelAttributeTemplate::CRTValue' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, CRTDamage) == 0x000010, "Member 'FGECharLevelAttributeTemplate::CRTDamage' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, NextLevelExp) == 0x000014, "Member 'FGECharLevelAttributeTemplate::NextLevelExp' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, MaxScatterRatio) == 0x000018, "Member 'FGECharLevelAttributeTemplate::MaxScatterRatio' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, ShootAddScatterRatio) == 0x00001C, "Member 'FGECharLevelAttributeTemplate::ShootAddScatterRatio' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplate, RecoverScatterSpeedRatio) == 0x000020, "Member 'FGECharLevelAttributeTemplate::RecoverScatterSpeedRatio' has a wrong offset!");

// ScriptStruct GameEx.GECharLevelAttributeTemplateKey
// 0x0008 (0x0008 - 0x0000)
struct FGECharLevelAttributeTemplateKey final
{
public:
	int32                                         TemplateId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGECharLevelAttributeTemplateKey) == 0x000004, "Wrong alignment on FGECharLevelAttributeTemplateKey");
static_assert(sizeof(FGECharLevelAttributeTemplateKey) == 0x000008, "Wrong size on FGECharLevelAttributeTemplateKey");
static_assert(offsetof(FGECharLevelAttributeTemplateKey, TemplateId) == 0x000000, "Member 'FGECharLevelAttributeTemplateKey::TemplateId' has a wrong offset!");
static_assert(offsetof(FGECharLevelAttributeTemplateKey, Level) == 0x000004, "Member 'FGECharLevelAttributeTemplateKey::Level' has a wrong offset!");

// ScriptStruct GameEx.GEAbilityAttribute
// 0x0030 (0x0030 - 0x0000)
struct FGEAbilityAttribute final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrGroup;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicated;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitMaxValue;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEAttributeAttachType                        AttachType;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEAttributeValueType                         ValueType;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEAbilityAttribute) == 0x000008, "Wrong alignment on FGEAbilityAttribute");
static_assert(sizeof(FGEAbilityAttribute) == 0x000030, "Wrong size on FGEAbilityAttribute");
static_assert(offsetof(FGEAbilityAttribute, Name) == 0x000000, "Member 'FGEAbilityAttribute::Name' has a wrong offset!");
static_assert(offsetof(FGEAbilityAttribute, AttrGroup) == 0x000010, "Member 'FGEAbilityAttribute::AttrGroup' has a wrong offset!");
static_assert(offsetof(FGEAbilityAttribute, bReplicated) == 0x000020, "Member 'FGEAbilityAttribute::bReplicated' has a wrong offset!");
static_assert(offsetof(FGEAbilityAttribute, LimitMaxValue) == 0x000024, "Member 'FGEAbilityAttribute::LimitMaxValue' has a wrong offset!");
static_assert(offsetof(FGEAbilityAttribute, AttachType) == 0x000028, "Member 'FGEAbilityAttribute::AttachType' has a wrong offset!");
static_assert(offsetof(FGEAbilityAttribute, ValueType) == 0x000029, "Member 'FGEAbilityAttribute::ValueType' has a wrong offset!");

// ScriptStruct GameEx.WaterParkAIModifyInfo
// 0x0002 (0x0002 - 0x0000)
struct FWaterParkAIModifyInfo final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterParkAIModifyInfo) == 0x000001, "Wrong alignment on FWaterParkAIModifyInfo");
static_assert(sizeof(FWaterParkAIModifyInfo) == 0x000002, "Wrong size on FWaterParkAIModifyInfo");

// ScriptStruct GameEx.GEBulletInfo
// 0x0298 (0x02A0 - 0x0008)
struct FGEBulletInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BulletClass;                                       // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterID;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBulletHitType                              HitEffectType;                                     // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBulletWorkType                             SpawnType;                                         // 0x002D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereCollisionRadius;                             // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombCollisionRadius;                               // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityCollisionRadius;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterp;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GravityScaleCurve;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBulletMovementType                         MovementType;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Frequency;                                         // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyRange;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletExtremeRange;                                // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGELevelType, int32>                     IgnoreCollToTeam;                                  // 0x0078(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          HitDie;                                            // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SameTargetMaxNum;                                  // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetNum;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillBoomWhenDead;                                  // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BombEffectID;                                      // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             BulletChannel;                                     // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BulletRayPath;                                     // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletRayParamName;                                // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BulletRayParam;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BulletRayPlayPre;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletRayDestroyImmediately;                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        StopFireParticlePath;                              // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiTrace;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TraceShape;                                        // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidthTraceNum;                                     // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidthHeightNum;                                    // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStrength;                                       // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCurveHitReaction;                           // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitShakeEffectSelfOnly;                           // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         CameraShakeClassPath;                              // 0x0150(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeMaxValidDistance;                             // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttenuation;                                      // 0x016C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         HitAbilityTargetShake_NoAimPath;                   // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         HitAbilityTargetShake_InAimPath;                   // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectID;                                       // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectNotPlayInTime;                            // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HitEffectPlayPre;                                  // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitWeaknessEffectNotPlayInTime;                    // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HitWeaknessEffectPlayPre;                          // 0x01B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitEffectTable;                                // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectComposite;                               // 0x01BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HitEffectParticlePath;                             // 0x01C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectAttach;                                  // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitEffectFollowBulletRotation;                    // 0x01D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA[0x2];                                      // 0x01DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleCount;                                  // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeTime;                                          // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0xC];                                      // 0x01E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitEffectRelativeTransform;                        // 0x01F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 HitCharEffectSoundEvent;                           // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HitWorldEffectSoundEvent;                          // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SubSkillIDs;                                       // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CastRange;                                         // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ActorTraceChannel;                                 // 0x0254(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BombDamageType;                                    // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BombEmitterID;                                     // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletDirectHitAsBomb;                            // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TailBeamParticleParamName;                         // 0x0264(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TailBeamParticleParam;                             // 0x026C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TailParticlePath;                                  // 0x0278(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TailParticlePlayPre;                               // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBug_SlowSpeedDur;                                 // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBug_SlowSpeedPer;                                 // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEBulletInfo) == 0x000010, "Wrong alignment on FGEBulletInfo");
static_assert(sizeof(FGEBulletInfo) == 0x0002A0, "Wrong size on FGEBulletInfo");
static_assert(offsetof(FGEBulletInfo, ID) == 0x000008, "Member 'FGEBulletInfo::ID' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletClass) == 0x000010, "Member 'FGEBulletInfo::BulletClass' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, EmitterID) == 0x000028, "Member 'FGEBulletInfo::EmitterID' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectType) == 0x00002C, "Member 'FGEBulletInfo::HitEffectType' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, SpawnType) == 0x00002D, "Member 'FGEBulletInfo::SpawnType' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, Scale) == 0x000030, "Member 'FGEBulletInfo::Scale' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, SphereCollisionRadius) == 0x000034, "Member 'FGEBulletInfo::SphereCollisionRadius' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BombCollisionRadius) == 0x000038, "Member 'FGEBulletInfo::BombCollisionRadius' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, AbilityCollisionRadius) == 0x00003C, "Member 'FGEBulletInfo::AbilityCollisionRadius' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, InitialSpeed) == 0x000040, "Member 'FGEBulletInfo::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, Acceleration) == 0x000044, "Member 'FGEBulletInfo::Acceleration' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, AccelerationCurve) == 0x000048, "Member 'FGEBulletInfo::AccelerationCurve' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, RotationInterp) == 0x000050, "Member 'FGEBulletInfo::RotationInterp' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, GravityScale) == 0x000054, "Member 'FGEBulletInfo::GravityScale' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, GravityScaleCurve) == 0x000058, "Member 'FGEBulletInfo::GravityScaleCurve' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, MovementType) == 0x000060, "Member 'FGEBulletInfo::MovementType' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, Frequency) == 0x000064, "Member 'FGEBulletInfo::Frequency' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, FrequencyRange) == 0x000068, "Member 'FGEBulletInfo::FrequencyRange' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, LifeTime) == 0x00006C, "Member 'FGEBulletInfo::LifeTime' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletExtremeRange) == 0x000070, "Member 'FGEBulletInfo::BulletExtremeRange' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, IgnoreCollToTeam) == 0x000078, "Member 'FGEBulletInfo::IgnoreCollToTeam' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitDie) == 0x0000C8, "Member 'FGEBulletInfo::HitDie' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, SameTargetMaxNum) == 0x0000CC, "Member 'FGEBulletInfo::SameTargetMaxNum' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, MaxTargetNum) == 0x0000D0, "Member 'FGEBulletInfo::MaxTargetNum' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, WillBoomWhenDead) == 0x0000D4, "Member 'FGEBulletInfo::WillBoomWhenDead' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BombEffectID) == 0x0000D8, "Member 'FGEBulletInfo::BombEffectID' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletChannel) == 0x0000DC, "Member 'FGEBulletInfo::BulletChannel' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletRayPath) == 0x0000E0, "Member 'FGEBulletInfo::BulletRayPath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletRayParamName) == 0x0000F8, "Member 'FGEBulletInfo::BulletRayParamName' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletRayParam) == 0x000100, "Member 'FGEBulletInfo::BulletRayParam' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BulletRayPlayPre) == 0x000108, "Member 'FGEBulletInfo::BulletRayPlayPre' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bBulletRayDestroyImmediately) == 0x000110, "Member 'FGEBulletInfo::bBulletRayDestroyImmediately' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, StopFireParticlePath) == 0x000118, "Member 'FGEBulletInfo::StopFireParticlePath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bMultiTrace) == 0x000130, "Member 'FGEBulletInfo::bMultiTrace' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, TraceShape) == 0x000134, "Member 'FGEBulletInfo::TraceShape' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, WidthTraceNum) == 0x00013C, "Member 'FGEBulletInfo::WidthTraceNum' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, WidthHeightNum) == 0x000140, "Member 'FGEBulletInfo::WidthHeightNum' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitStrength) == 0x000144, "Member 'FGEBulletInfo::HitStrength' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bEnableCurveHitReaction) == 0x000148, "Member 'FGEBulletInfo::bEnableCurveHitReaction' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bHitShakeEffectSelfOnly) == 0x000149, "Member 'FGEBulletInfo::bHitShakeEffectSelfOnly' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, CameraShakeClassPath) == 0x000150, "Member 'FGEBulletInfo::CameraShakeClassPath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, ShakeMaxValidDistance) == 0x000168, "Member 'FGEBulletInfo::ShakeMaxValidDistance' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bAttenuation) == 0x00016C, "Member 'FGEBulletInfo::bAttenuation' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitAbilityTargetShake_NoAimPath) == 0x000170, "Member 'FGEBulletInfo::HitAbilityTargetShake_NoAimPath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitAbilityTargetShake_InAimPath) == 0x000188, "Member 'FGEBulletInfo::HitAbilityTargetShake_InAimPath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectID) == 0x0001A0, "Member 'FGEBulletInfo::HitEffectID' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectNotPlayInTime) == 0x0001A4, "Member 'FGEBulletInfo::HitEffectNotPlayInTime' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectPlayPre) == 0x0001A8, "Member 'FGEBulletInfo::HitEffectPlayPre' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitWeaknessEffectNotPlayInTime) == 0x0001B0, "Member 'FGEBulletInfo::HitWeaknessEffectNotPlayInTime' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitWeaknessEffectPlayPre) == 0x0001B4, "Member 'FGEBulletInfo::HitWeaknessEffectPlayPre' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bUseHitEffectTable) == 0x0001BC, "Member 'FGEBulletInfo::bUseHitEffectTable' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bHitEffectComposite) == 0x0001BD, "Member 'FGEBulletInfo::bHitEffectComposite' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectParticlePath) == 0x0001C0, "Member 'FGEBulletInfo::HitEffectParticlePath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bHitEffectAttach) == 0x0001D8, "Member 'FGEBulletInfo::bHitEffectAttach' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bHitEffectFollowBulletRotation) == 0x0001D9, "Member 'FGEBulletInfo::bHitEffectFollowBulletRotation' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, MaxParticleCount) == 0x0001DC, "Member 'FGEBulletInfo::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, FreeTime) == 0x0001E0, "Member 'FGEBulletInfo::FreeTime' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitEffectRelativeTransform) == 0x0001F0, "Member 'FGEBulletInfo::HitEffectRelativeTransform' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitCharEffectSoundEvent) == 0x000220, "Member 'FGEBulletInfo::HitCharEffectSoundEvent' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, HitWorldEffectSoundEvent) == 0x000230, "Member 'FGEBulletInfo::HitWorldEffectSoundEvent' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, SubSkillIDs) == 0x000240, "Member 'FGEBulletInfo::SubSkillIDs' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, CastRange) == 0x000250, "Member 'FGEBulletInfo::CastRange' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, ActorTraceChannel) == 0x000254, "Member 'FGEBulletInfo::ActorTraceChannel' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BombDamageType) == 0x000258, "Member 'FGEBulletInfo::BombDamageType' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, BombEmitterID) == 0x00025C, "Member 'FGEBulletInfo::BombEmitterID' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, bBulletDirectHitAsBomb) == 0x000260, "Member 'FGEBulletInfo::bBulletDirectHitAsBomb' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, TailBeamParticleParamName) == 0x000264, "Member 'FGEBulletInfo::TailBeamParticleParamName' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, TailBeamParticleParam) == 0x00026C, "Member 'FGEBulletInfo::TailBeamParticleParam' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, TailParticlePath) == 0x000278, "Member 'FGEBulletInfo::TailParticlePath' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, TailParticlePlayPre) == 0x000290, "Member 'FGEBulletInfo::TailParticlePlayPre' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, ZBug_SlowSpeedDur) == 0x000298, "Member 'FGEBulletInfo::ZBug_SlowSpeedDur' has a wrong offset!");
static_assert(offsetof(FGEBulletInfo, ZBug_SlowSpeedPer) == 0x00029C, "Member 'FGEBulletInfo::ZBug_SlowSpeedPer' has a wrong offset!");

// ScriptStruct GameEx.GEAbilityCommonForceFeedback
// 0x0028 (0x0028 - 0x0000)
struct FGEAbilityCommonForceFeedback final
{
public:
	struct FSoftObjectPath                        ForceFeedbackCurve;                                // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColdDownTime;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEAbilityCommonForceFeedback) == 0x000008, "Wrong alignment on FGEAbilityCommonForceFeedback");
static_assert(sizeof(FGEAbilityCommonForceFeedback) == 0x000028, "Wrong size on FGEAbilityCommonForceFeedback");
static_assert(offsetof(FGEAbilityCommonForceFeedback, ForceFeedbackCurve) == 0x000000, "Member 'FGEAbilityCommonForceFeedback::ForceFeedbackCurve' has a wrong offset!");
static_assert(offsetof(FGEAbilityCommonForceFeedback, BlendInTime) == 0x000018, "Member 'FGEAbilityCommonForceFeedback::BlendInTime' has a wrong offset!");
static_assert(offsetof(FGEAbilityCommonForceFeedback, BlendOutTime) == 0x00001C, "Member 'FGEAbilityCommonForceFeedback::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FGEAbilityCommonForceFeedback, ColdDownTime) == 0x000020, "Member 'FGEAbilityCommonForceFeedback::ColdDownTime' has a wrong offset!");
static_assert(offsetof(FGEAbilityCommonForceFeedback, Priority) == 0x000024, "Member 'FGEAbilityCommonForceFeedback::Priority' has a wrong offset!");

// ScriptStruct GameEx.GEWeaponFireParam
// 0x0158 (0x0158 - 0x0000)
struct FGEWeaponFireParam final
{
public:
	float                                         MoveScatteringArea;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushScatteringArea;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandScatteringArea;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimScatteringArea;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMaxScatteringArea;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushMaxScatteringArea;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandMaxScatteringArea;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimMaxScatteringArea;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootAddScatter;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootAddScatter;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootAddScatter;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopFireRecoverScatterSpeed;                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShootScatterCurve;                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShootScatterAddCurve;                              // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootScatterTime;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootScatterTime;                             // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootScatterTime;                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootScatterWaitRecoverTime;                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ShootScatterRecoverCurve;                          // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveShootScatterRecoverTime;                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandShootScatterRecoverTime;                      // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimShootScatterRecoverTime;                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShoulderShotRecoilForceYaw;                        // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InAimShotRecoilForceYaw;                           // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShoulderShotRecoilForcePitch;                      // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InAimShotRecoilForcePitch;                         // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilForceLimit;                                  // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilForceTime;                                   // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        RecoilPath;                                        // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RecoilRecoveryPath;                                // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RecoilForcePitchRateCurve;                         // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilForcePitchRateRecoverTime;                   // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         ShootCameraShake;                                  // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AimShootCameraShake;                               // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CameraShakeCurvePath;                              // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEWeaponFireParam) == 0x000008, "Wrong alignment on FGEWeaponFireParam");
static_assert(sizeof(FGEWeaponFireParam) == 0x000158, "Wrong size on FGEWeaponFireParam");
static_assert(offsetof(FGEWeaponFireParam, MoveScatteringArea) == 0x000000, "Member 'FGEWeaponFireParam::MoveScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RushScatteringArea) == 0x000004, "Member 'FGEWeaponFireParam::RushScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StandScatteringArea) == 0x000008, "Member 'FGEWeaponFireParam::StandScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimScatteringArea) == 0x00000C, "Member 'FGEWeaponFireParam::AimScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, MoveMaxScatteringArea) == 0x000010, "Member 'FGEWeaponFireParam::MoveMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RushMaxScatteringArea) == 0x000014, "Member 'FGEWeaponFireParam::RushMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StandMaxScatteringArea) == 0x000018, "Member 'FGEWeaponFireParam::StandMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimMaxScatteringArea) == 0x00001C, "Member 'FGEWeaponFireParam::AimMaxScatteringArea' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, MoveShootAddScatter) == 0x000020, "Member 'FGEWeaponFireParam::MoveShootAddScatter' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StandShootAddScatter) == 0x000024, "Member 'FGEWeaponFireParam::StandShootAddScatter' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimShootAddScatter) == 0x000028, "Member 'FGEWeaponFireParam::AimShootAddScatter' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StopFireRecoverScatterSpeed) == 0x00002C, "Member 'FGEWeaponFireParam::StopFireRecoverScatterSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, bUseShootScatterCurve) == 0x000030, "Member 'FGEWeaponFireParam::bUseShootScatterCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShootScatterAddCurve) == 0x000038, "Member 'FGEWeaponFireParam::ShootScatterAddCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, MoveShootScatterTime) == 0x000050, "Member 'FGEWeaponFireParam::MoveShootScatterTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StandShootScatterTime) == 0x000054, "Member 'FGEWeaponFireParam::StandShootScatterTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimShootScatterTime) == 0x000058, "Member 'FGEWeaponFireParam::AimShootScatterTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShootScatterWaitRecoverTime) == 0x00005C, "Member 'FGEWeaponFireParam::ShootScatterWaitRecoverTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShootScatterRecoverCurve) == 0x000060, "Member 'FGEWeaponFireParam::ShootScatterRecoverCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, MoveShootScatterRecoverTime) == 0x000078, "Member 'FGEWeaponFireParam::MoveShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, StandShootScatterRecoverTime) == 0x00007C, "Member 'FGEWeaponFireParam::StandShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimShootScatterRecoverTime) == 0x000080, "Member 'FGEWeaponFireParam::AimShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShoulderShotRecoilForceYaw) == 0x000084, "Member 'FGEWeaponFireParam::ShoulderShotRecoilForceYaw' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, InAimShotRecoilForceYaw) == 0x00008C, "Member 'FGEWeaponFireParam::InAimShotRecoilForceYaw' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShoulderShotRecoilForcePitch) == 0x000094, "Member 'FGEWeaponFireParam::ShoulderShotRecoilForcePitch' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, InAimShotRecoilForcePitch) == 0x00009C, "Member 'FGEWeaponFireParam::InAimShotRecoilForcePitch' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilForceLimit) == 0x0000A4, "Member 'FGEWeaponFireParam::RecoilForceLimit' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilForceTime) == 0x0000B0, "Member 'FGEWeaponFireParam::RecoilForceTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilPath) == 0x0000C0, "Member 'FGEWeaponFireParam::RecoilPath' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilRecoveryPath) == 0x0000D8, "Member 'FGEWeaponFireParam::RecoilRecoveryPath' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilForcePitchRateCurve) == 0x0000F0, "Member 'FGEWeaponFireParam::RecoilForcePitchRateCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, RecoilForcePitchRateRecoverTime) == 0x000108, "Member 'FGEWeaponFireParam::RecoilForcePitchRateRecoverTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, ShootCameraShake) == 0x000110, "Member 'FGEWeaponFireParam::ShootCameraShake' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, AimShootCameraShake) == 0x000128, "Member 'FGEWeaponFireParam::AimShootCameraShake' has a wrong offset!");
static_assert(offsetof(FGEWeaponFireParam, CameraShakeCurvePath) == 0x000140, "Member 'FGEWeaponFireParam::CameraShakeCurvePath' has a wrong offset!");

// ScriptStruct GameEx.GEWeaponFollowInfo
// 0x0078 (0x0078 - 0x0000)
struct FGEWeaponFollowInfo final
{
public:
	bool                                          bEnableFollow;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdsorbentRangePer;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdsorbentTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AdsorbentCurve;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Distance2SpeedCurve;                               // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowSpeed;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuitFollow;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireFireFollowRangePer;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FireFollowSpeed;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireFollowReduceTime;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_FireFireFollowRangePer;                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Aim_FireFollowSpeed;                               // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_FireFollowReduceTime;                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FireFollowAngle;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEWeaponFollowInfo) == 0x000008, "Wrong alignment on FGEWeaponFollowInfo");
static_assert(sizeof(FGEWeaponFollowInfo) == 0x000078, "Wrong size on FGEWeaponFollowInfo");
static_assert(offsetof(FGEWeaponFollowInfo, bEnableFollow) == 0x000000, "Member 'FGEWeaponFollowInfo::bEnableFollow' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, AdsorbentRangePer) == 0x000004, "Member 'FGEWeaponFollowInfo::AdsorbentRangePer' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, AdsorbentTime) == 0x000008, "Member 'FGEWeaponFollowInfo::AdsorbentTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, AdsorbentCurve) == 0x000010, "Member 'FGEWeaponFollowInfo::AdsorbentCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, Distance2SpeedCurve) == 0x000028, "Member 'FGEWeaponFollowInfo::Distance2SpeedCurve' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, FollowSpeed) == 0x000040, "Member 'FGEWeaponFollowInfo::FollowSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, QuitFollow) == 0x000044, "Member 'FGEWeaponFollowInfo::QuitFollow' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, FireFireFollowRangePer) == 0x000048, "Member 'FGEWeaponFollowInfo::FireFireFollowRangePer' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, FireFollowSpeed) == 0x00004C, "Member 'FGEWeaponFollowInfo::FireFollowSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, FireFollowReduceTime) == 0x000054, "Member 'FGEWeaponFollowInfo::FireFollowReduceTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, Aim_FireFireFollowRangePer) == 0x000058, "Member 'FGEWeaponFollowInfo::Aim_FireFireFollowRangePer' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, Aim_FireFollowSpeed) == 0x00005C, "Member 'FGEWeaponFollowInfo::Aim_FireFollowSpeed' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, Aim_FireFollowReduceTime) == 0x000064, "Member 'FGEWeaponFollowInfo::Aim_FireFollowReduceTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponFollowInfo, FireFollowAngle) == 0x000068, "Member 'FGEWeaponFollowInfo::FireFollowAngle' has a wrong offset!");

// ScriptStruct GameEx.GEWeaponInfo
// 0x0470 (0x0478 - 0x0008)
struct FGEWeaponInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeaponName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Blueprint;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEWeaponType                                 WeaponType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bsemiAutomatic;                                    // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEZBugRunTeamType                            TeamType;                                          // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResPath;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGEWeaponAttributeTemplate             AttrTemplate;                                      // 0x0078(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireEffectID;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstBulletCount;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBurstBulletEndRecoil;                             // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletCost;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletLaunchCount;                                 // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGEWeaponFireParam                     FireParam;                                         // 0x00C8(0x0158)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              CheckShootRange;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustWeakBulletDir;                               // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBodyBulletDir;                               // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustWeakBulletDir_PC;                            // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustBodyBulletDir_PC;                            // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CrossHairUIWidget;                                 // 0x0238(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AmmunitionUIWidget;                                // 0x0250(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AmmunitionOffset;                                  // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEWeaponBulletShootType                      NormalBulletShootType;                             // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBulletShootOffsete;                          // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGEAbilityCommonForceFeedback          ForceFeedbackCommon;                               // 0x0278(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGEAbilityCommonForceFeedback          ForceFeedbackCommonPS;                             // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoFire;                                   // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEWeaponFireMode                             FireMode;                                          // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGEWeaponFollowInfo                    FollowInfo_Mobile;                                 // 0x02D0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGEWeaponFollowInfo                    FollowInfo_PC;                                     // 0x0348(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGEWeaponFollowInfo                    FollowInfo_Gamepad;                                // 0x03C0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bDisableScattering;                                // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponAngleThreshold;                              // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseWeaponTime;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRetainWeaponRaising;                           // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FireSoundEvent;                                    // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReloadSoundEvent;                                  // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stability;                                         // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalStability;                               // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accuracy;                                          // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEWeaponInfo) == 0x000008, "Wrong alignment on FGEWeaponInfo");
static_assert(sizeof(FGEWeaponInfo) == 0x000478, "Wrong size on FGEWeaponInfo");
static_assert(offsetof(FGEWeaponInfo, ID) == 0x000008, "Member 'FGEWeaponInfo::ID' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, WeaponName) == 0x000010, "Member 'FGEWeaponInfo::WeaponName' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, Comment) == 0x000020, "Member 'FGEWeaponInfo::Comment' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, Blueprint) == 0x000030, "Member 'FGEWeaponInfo::Blueprint' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, WeaponType) == 0x000048, "Member 'FGEWeaponInfo::WeaponType' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, bsemiAutomatic) == 0x000049, "Member 'FGEWeaponInfo::bsemiAutomatic' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, TeamType) == 0x00004A, "Member 'FGEWeaponInfo::TeamType' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, ResPath) == 0x000050, "Member 'FGEWeaponInfo::ResPath' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, Icon) == 0x000060, "Member 'FGEWeaponInfo::Icon' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AttrTemplate) == 0x000078, "Member 'FGEWeaponInfo::AttrTemplate' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, BulletID) == 0x0000AC, "Member 'FGEWeaponInfo::BulletID' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FireEffectID) == 0x0000B0, "Member 'FGEWeaponInfo::FireEffectID' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, BurstBulletCount) == 0x0000B4, "Member 'FGEWeaponInfo::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, bBurstBulletEndRecoil) == 0x0000B8, "Member 'FGEWeaponInfo::bBurstBulletEndRecoil' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, BulletCost) == 0x0000BC, "Member 'FGEWeaponInfo::BulletCost' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, BulletLaunchCount) == 0x0000C0, "Member 'FGEWeaponInfo::BulletLaunchCount' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FireParam) == 0x0000C8, "Member 'FGEWeaponInfo::FireParam' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, CheckShootRange) == 0x000220, "Member 'FGEWeaponInfo::CheckShootRange' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AdjustWeakBulletDir) == 0x000228, "Member 'FGEWeaponInfo::AdjustWeakBulletDir' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AdjustBodyBulletDir) == 0x00022C, "Member 'FGEWeaponInfo::AdjustBodyBulletDir' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AdjustWeakBulletDir_PC) == 0x000230, "Member 'FGEWeaponInfo::AdjustWeakBulletDir_PC' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AdjustBodyBulletDir_PC) == 0x000234, "Member 'FGEWeaponInfo::AdjustBodyBulletDir_PC' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, CrossHairUIWidget) == 0x000238, "Member 'FGEWeaponInfo::CrossHairUIWidget' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AmmunitionUIWidget) == 0x000250, "Member 'FGEWeaponInfo::AmmunitionUIWidget' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AmmunitionOffset) == 0x000268, "Member 'FGEWeaponInfo::AmmunitionOffset' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, NormalBulletShootType) == 0x000270, "Member 'FGEWeaponInfo::NormalBulletShootType' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, CameraBulletShootOffsete) == 0x000274, "Member 'FGEWeaponInfo::CameraBulletShootOffsete' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, ForceFeedbackCommon) == 0x000278, "Member 'FGEWeaponInfo::ForceFeedbackCommon' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, ForceFeedbackCommonPS) == 0x0002A0, "Member 'FGEWeaponInfo::ForceFeedbackCommonPS' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, bEnableAutoFire) == 0x0002C8, "Member 'FGEWeaponInfo::bEnableAutoFire' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FireMode) == 0x0002C9, "Member 'FGEWeaponInfo::FireMode' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FollowInfo_Mobile) == 0x0002D0, "Member 'FGEWeaponInfo::FollowInfo_Mobile' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FollowInfo_PC) == 0x000348, "Member 'FGEWeaponInfo::FollowInfo_PC' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FollowInfo_Gamepad) == 0x0003C0, "Member 'FGEWeaponInfo::FollowInfo_Gamepad' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, bDisableScattering) == 0x000438, "Member 'FGEWeaponInfo::bDisableScattering' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, WeaponAngleThreshold) == 0x00043C, "Member 'FGEWeaponInfo::WeaponAngleThreshold' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, RaiseWeaponTime) == 0x000440, "Member 'FGEWeaponInfo::RaiseWeaponTime' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FireRetainWeaponRaising) == 0x000444, "Member 'FGEWeaponInfo::FireRetainWeaponRaising' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, FireSoundEvent) == 0x000448, "Member 'FGEWeaponInfo::FireSoundEvent' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, ReloadSoundEvent) == 0x000458, "Member 'FGEWeaponInfo::ReloadSoundEvent' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, Stability) == 0x000468, "Member 'FGEWeaponInfo::Stability' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, AdditionalStability) == 0x00046C, "Member 'FGEWeaponInfo::AdditionalStability' has a wrong offset!");
static_assert(offsetof(FGEWeaponInfo, Accuracy) == 0x000470, "Member 'FGEWeaponInfo::Accuracy' has a wrong offset!");

// ScriptStruct GameEx.GECharOwnBuffInfo
// 0x000C (0x000C - 0x0000)
struct FGECharOwnBuffInfo final
{
public:
	int32                                         BuffId;                                            // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLevel;                                         // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBuffTeamType                               TeamType;                                          // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivate;                                        // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGECharOwnBuffInfo) == 0x000004, "Wrong alignment on FGECharOwnBuffInfo");
static_assert(sizeof(FGECharOwnBuffInfo) == 0x00000C, "Wrong size on FGECharOwnBuffInfo");
static_assert(offsetof(FGECharOwnBuffInfo, BuffId) == 0x000000, "Member 'FGECharOwnBuffInfo::BuffId' has a wrong offset!");
static_assert(offsetof(FGECharOwnBuffInfo, BuffLevel) == 0x000004, "Member 'FGECharOwnBuffInfo::BuffLevel' has a wrong offset!");
static_assert(offsetof(FGECharOwnBuffInfo, TeamType) == 0x000008, "Member 'FGECharOwnBuffInfo::TeamType' has a wrong offset!");
static_assert(offsetof(FGECharOwnBuffInfo, IsActivate) == 0x000009, "Member 'FGECharOwnBuffInfo::IsActivate' has a wrong offset!");

// ScriptStruct GameEx.GEBuffInfo
// 0x0110 (0x0118 - 0x0008)
struct FGEBuffInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BuffName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NameComment;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Des;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescParam;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SimpleDes;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DesComment;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBuffTeamType                               Team;                                              // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBuffAttachType                             OwnType;                                           // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BuffParam;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuffParamComment;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        QualityIcon;                                       // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGameLogicTreeEntity>    LogicTreePath;                                     // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponLimit;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelLimit;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffLimit;                                         // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bMultiCast;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEBuffInfo) == 0x000008, "Wrong alignment on FGEBuffInfo");
static_assert(sizeof(FGEBuffInfo) == 0x000118, "Wrong size on FGEBuffInfo");
static_assert(offsetof(FGEBuffInfo, ID) == 0x000008, "Member 'FGEBuffInfo::ID' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, BuffName) == 0x000010, "Member 'FGEBuffInfo::BuffName' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, NameComment) == 0x000020, "Member 'FGEBuffInfo::NameComment' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, Des) == 0x000030, "Member 'FGEBuffInfo::Des' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, DescParam) == 0x000040, "Member 'FGEBuffInfo::DescParam' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, SimpleDes) == 0x000050, "Member 'FGEBuffInfo::SimpleDes' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, DesComment) == 0x000060, "Member 'FGEBuffInfo::DesComment' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, Team) == 0x000070, "Member 'FGEBuffInfo::Team' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, OwnType) == 0x000071, "Member 'FGEBuffInfo::OwnType' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, BuffParam) == 0x000078, "Member 'FGEBuffInfo::BuffParam' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, BuffParamComment) == 0x000088, "Member 'FGEBuffInfo::BuffParamComment' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, MaxLevel) == 0x000098, "Member 'FGEBuffInfo::MaxLevel' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, Weight) == 0x00009C, "Member 'FGEBuffInfo::Weight' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, Icon) == 0x0000A0, "Member 'FGEBuffInfo::Icon' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, QualityIcon) == 0x0000B8, "Member 'FGEBuffInfo::QualityIcon' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, LogicTreePath) == 0x0000D0, "Member 'FGEBuffInfo::LogicTreePath' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, WeaponLimit) == 0x0000F8, "Member 'FGEBuffInfo::WeaponLimit' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, LevelLimit) == 0x0000FC, "Member 'FGEBuffInfo::LevelLimit' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, BuffLimit) == 0x000100, "Member 'FGEBuffInfo::BuffLimit' has a wrong offset!");
static_assert(offsetof(FGEBuffInfo, bMultiCast) == 0x000110, "Member 'FGEBuffInfo::bMultiCast' has a wrong offset!");

// ScriptStruct GameEx.GESkillEquipInfo
// 0x0034 (0x0034 - 0x0000)
struct FGESkillEquipInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDForStoreItem;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseLimit;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUseCount;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseStore;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStoreCount;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurUseTime;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextUseTime;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextUseTimeForStoreItem;                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceCDPer;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGESkillEquipInfo) == 0x000004, "Wrong alignment on FGESkillEquipInfo");
static_assert(sizeof(FGESkillEquipInfo) == 0x000034, "Wrong size on FGESkillEquipInfo");
static_assert(offsetof(FGESkillEquipInfo, Index) == 0x000000, "Member 'FGESkillEquipInfo::Index' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, ConfigId) == 0x000004, "Member 'FGESkillEquipInfo::ConfigId' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, CD) == 0x000008, "Member 'FGESkillEquipInfo::CD' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, CDForStoreItem) == 0x00000C, "Member 'FGESkillEquipInfo::CDForStoreItem' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, UseLimit) == 0x000010, "Member 'FGESkillEquipInfo::UseLimit' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, MaxUseCount) == 0x000014, "Member 'FGESkillEquipInfo::MaxUseCount' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, UseStore) == 0x000018, "Member 'FGESkillEquipInfo::UseStore' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, MaxStoreCount) == 0x00001C, "Member 'FGESkillEquipInfo::MaxStoreCount' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, CurUseTime) == 0x000020, "Member 'FGESkillEquipInfo::CurUseTime' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, NextUseTime) == 0x000024, "Member 'FGESkillEquipInfo::NextUseTime' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, NextUseTimeForStoreItem) == 0x000028, "Member 'FGESkillEquipInfo::NextUseTimeForStoreItem' has a wrong offset!");
static_assert(offsetof(FGESkillEquipInfo, ReduceCDPer) == 0x00002C, "Member 'FGESkillEquipInfo::ReduceCDPer' has a wrong offset!");

// ScriptStruct GameEx.GESkillInfo
// 0x00A0 (0x00A8 - 0x0008)
struct FGESkillInfo final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Des;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DesVal;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDForStoreItem;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUseCount;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStoreCount;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGameLogicTreeEntity>    LogicTreePath;                                     // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Icon;                                              // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiCast;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenReborn;                                   // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGESkillInfo) == 0x000008, "Wrong alignment on FGESkillInfo");
static_assert(sizeof(FGESkillInfo) == 0x0000A8, "Wrong size on FGESkillInfo");
static_assert(offsetof(FGESkillInfo, ID) == 0x000008, "Member 'FGESkillInfo::ID' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, SkillName) == 0x000010, "Member 'FGESkillInfo::SkillName' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, Comment) == 0x000020, "Member 'FGESkillInfo::Comment' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, Des) == 0x000030, "Member 'FGESkillInfo::Des' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, DesVal) == 0x000040, "Member 'FGESkillInfo::DesVal' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, CD) == 0x000050, "Member 'FGESkillInfo::CD' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, CDForStoreItem) == 0x000054, "Member 'FGESkillInfo::CDForStoreItem' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, MaxUseCount) == 0x000058, "Member 'FGESkillInfo::MaxUseCount' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, MaxStoreCount) == 0x00005C, "Member 'FGESkillInfo::MaxStoreCount' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, LogicTreePath) == 0x000060, "Member 'FGESkillInfo::LogicTreePath' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, Icon) == 0x000088, "Member 'FGESkillInfo::Icon' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, bMultiCast) == 0x0000A0, "Member 'FGESkillInfo::bMultiCast' has a wrong offset!");
static_assert(offsetof(FGESkillInfo, bStopWhenReborn) == 0x0000A1, "Member 'FGESkillInfo::bStopWhenReborn' has a wrong offset!");

// ScriptStruct GameEx.GEItemInfo
// 0x0038 (0x0038 - 0x0000)
struct FGEItemInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigId;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDForStoreItem;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseLimit;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUseCount;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseStore;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStoreCount;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitUseCount;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextUseTime;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextUseTimeForStoreItem;                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Lua_canUse;                                        // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEItemInfo) == 0x000004, "Wrong alignment on FGEItemInfo");
static_assert(sizeof(FGEItemInfo) == 0x000038, "Wrong size on FGEItemInfo");
static_assert(offsetof(FGEItemInfo, Index) == 0x000000, "Member 'FGEItemInfo::Index' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, ConfigId) == 0x000004, "Member 'FGEItemInfo::ConfigId' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, CD) == 0x000008, "Member 'FGEItemInfo::CD' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, CDForStoreItem) == 0x00000C, "Member 'FGEItemInfo::CDForStoreItem' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, Type) == 0x000010, "Member 'FGEItemInfo::Type' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, Level) == 0x000014, "Member 'FGEItemInfo::Level' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, UseLimit) == 0x000018, "Member 'FGEItemInfo::UseLimit' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, MaxUseCount) == 0x00001C, "Member 'FGEItemInfo::MaxUseCount' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, UseStore) == 0x000020, "Member 'FGEItemInfo::UseStore' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, MaxStoreCount) == 0x000024, "Member 'FGEItemInfo::MaxStoreCount' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, InitUseCount) == 0x000028, "Member 'FGEItemInfo::InitUseCount' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, NextUseTime) == 0x00002C, "Member 'FGEItemInfo::NextUseTime' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, NextUseTimeForStoreItem) == 0x000030, "Member 'FGEItemInfo::NextUseTimeForStoreItem' has a wrong offset!");
static_assert(offsetof(FGEItemInfo, Lua_canUse) == 0x000034, "Member 'FGEItemInfo::Lua_canUse' has a wrong offset!");

// ScriptStruct GameEx.WPDropItemEntry
// 0x0004 (0x0010 - 0x000C)
struct FWPDropItemEntry final : public FFastArraySerializerItem
{
public:
	bool                                          IsColllision;                                      // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDestroy;                                         // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWPDropItemEntry) == 0x000004, "Wrong alignment on FWPDropItemEntry");
static_assert(sizeof(FWPDropItemEntry) == 0x000010, "Wrong size on FWPDropItemEntry");
static_assert(offsetof(FWPDropItemEntry, IsColllision) == 0x00000C, "Member 'FWPDropItemEntry::IsColllision' has a wrong offset!");
static_assert(offsetof(FWPDropItemEntry, IsDestroy) == 0x00000D, "Member 'FWPDropItemEntry::IsDestroy' has a wrong offset!");

// ScriptStruct GameEx.WPDropItemArray
// 0x0010 (0x0118 - 0x0108)
struct FWPDropItemArray final : public FFastArraySerializer
{
public:
	TArray<struct FWPDropItemEntry>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWPDropItemArray) == 0x000008, "Wrong alignment on FWPDropItemArray");
static_assert(sizeof(FWPDropItemArray) == 0x000118, "Wrong size on FWPDropItemArray");
static_assert(offsetof(FWPDropItemArray, Items) == 0x000108, "Member 'FWPDropItemArray::Items' has a wrong offset!");

// ScriptStruct GameEx.MatGroupSettings
// 0x0010 (0x0010 - 0x0000)
struct FMatGroupSettings final
{
public:
	TArray<int32>                                 Settings;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatGroupSettings) == 0x000008, "Wrong alignment on FMatGroupSettings");
static_assert(sizeof(FMatGroupSettings) == 0x000010, "Wrong size on FMatGroupSettings");
static_assert(offsetof(FMatGroupSettings, Settings) == 0x000000, "Member 'FMatGroupSettings::Settings' has a wrong offset!");

// ScriptStruct GameEx.PicWaveTimePoint
// 0x0008 (0x0008 - 0x0000)
struct FPicWaveTimePoint final
{
public:
	int32                                         TimePoint;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropCount;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPicWaveTimePoint) == 0x000004, "Wrong alignment on FPicWaveTimePoint");
static_assert(sizeof(FPicWaveTimePoint) == 0x000008, "Wrong size on FPicWaveTimePoint");
static_assert(offsetof(FPicWaveTimePoint, TimePoint) == 0x000000, "Member 'FPicWaveTimePoint::TimePoint' has a wrong offset!");
static_assert(offsetof(FPicWaveTimePoint, DropCount) == 0x000004, "Member 'FPicWaveTimePoint::DropCount' has a wrong offset!");

// ScriptStruct GameEx.PicWave
// 0x0040 (0x0040 - 0x0000)
struct FPicWave final
{
public:
	int32                                         TotalTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenTimePoint;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenMatIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatGroupSettings>              MatGroupSettings;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MatGroups;                                         // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPicWaveTimePoint>              TimePointGroups;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPicWave) == 0x000008, "Wrong alignment on FPicWave");
static_assert(sizeof(FPicWave) == 0x000040, "Wrong size on FPicWave");
static_assert(offsetof(FPicWave, TotalTime) == 0x000000, "Member 'FPicWave::TotalTime' has a wrong offset!");
static_assert(offsetof(FPicWave, ScreenTimePoint) == 0x000004, "Member 'FPicWave::ScreenTimePoint' has a wrong offset!");
static_assert(offsetof(FPicWave, ScreenMatIndex) == 0x000008, "Member 'FPicWave::ScreenMatIndex' has a wrong offset!");
static_assert(offsetof(FPicWave, MatGroupSettings) == 0x000010, "Member 'FPicWave::MatGroupSettings' has a wrong offset!");
static_assert(offsetof(FPicWave, MatGroups) == 0x000020, "Member 'FPicWave::MatGroups' has a wrong offset!");
static_assert(offsetof(FPicWave, TimePointGroups) == 0x000030, "Member 'FPicWave::TimePointGroups' has a wrong offset!");

// ScriptStruct GameEx.GEZBugRunSpeedModifierDataInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGEZBugRunSpeedModifierDataInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEZBugRunSpeedModifierDataInfo) == 0x000004, "Wrong alignment on FGEZBugRunSpeedModifierDataInfo");
static_assert(sizeof(FGEZBugRunSpeedModifierDataInfo) == 0x00000C, "Wrong size on FGEZBugRunSpeedModifierDataInfo");

// ScriptStruct GameEx.WaterParkCurveMoveInfo
// 0x0038 (0x0038 - 0x0000)
struct FWaterParkCurveMoveInfo final
{
public:
	class UCurveFloat*                            NowCurve;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NowSpeedScale;                                     // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowCurveTime;                                      // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveMinTime;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveMaxTime;                                      // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowCurveValue;                                     // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVertical;                                        // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginOffset;                                      // 0x002C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterParkCurveMoveInfo) == 0x000008, "Wrong alignment on FWaterParkCurveMoveInfo");
static_assert(sizeof(FWaterParkCurveMoveInfo) == 0x000038, "Wrong size on FWaterParkCurveMoveInfo");
static_assert(offsetof(FWaterParkCurveMoveInfo, NowCurve) == 0x000000, "Member 'FWaterParkCurveMoveInfo::NowCurve' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, NowSpeedScale) == 0x000008, "Member 'FWaterParkCurveMoveInfo::NowSpeedScale' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, NowCurveTime) == 0x000018, "Member 'FWaterParkCurveMoveInfo::NowCurveTime' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, CurveMinTime) == 0x00001C, "Member 'FWaterParkCurveMoveInfo::CurveMinTime' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, CurveMaxTime) == 0x000020, "Member 'FWaterParkCurveMoveInfo::CurveMaxTime' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, NowCurveValue) == 0x000024, "Member 'FWaterParkCurveMoveInfo::NowCurveValue' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, IsVertical) == 0x000028, "Member 'FWaterParkCurveMoveInfo::IsVertical' has a wrong offset!");
static_assert(offsetof(FWaterParkCurveMoveInfo, OriginOffset) == 0x00002C, "Member 'FWaterParkCurveMoveInfo::OriginOffset' has a wrong offset!");

// ScriptStruct GameEx.GEZBug_DamageRPCInfo
// 0x0034 (0x0034 - 0x0000)
struct FGEZBug_DamageRPCInfo final
{
public:
	int32                                         LauncherGEUniqueID;                                // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetGEUniqueID;                                  // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectID;                                       // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitPos;                                            // 0x000C(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    HitStartPos;                                       // 0x0018(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCritical;                                        // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponID;                                          // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEWeaponType                                 WeaponType;                                        // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEZBug_DamageRPCInfo) == 0x000004, "Wrong alignment on FGEZBug_DamageRPCInfo");
static_assert(sizeof(FGEZBug_DamageRPCInfo) == 0x000034, "Wrong size on FGEZBug_DamageRPCInfo");
static_assert(offsetof(FGEZBug_DamageRPCInfo, LauncherGEUniqueID) == 0x000000, "Member 'FGEZBug_DamageRPCInfo::LauncherGEUniqueID' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, TargetGEUniqueID) == 0x000004, "Member 'FGEZBug_DamageRPCInfo::TargetGEUniqueID' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, HitEffectID) == 0x000008, "Member 'FGEZBug_DamageRPCInfo::HitEffectID' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, HitPos) == 0x00000C, "Member 'FGEZBug_DamageRPCInfo::HitPos' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, HitStartPos) == 0x000018, "Member 'FGEZBug_DamageRPCInfo::HitStartPos' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, Damage) == 0x000024, "Member 'FGEZBug_DamageRPCInfo::Damage' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, IsCritical) == 0x000028, "Member 'FGEZBug_DamageRPCInfo::IsCritical' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, WeaponID) == 0x00002C, "Member 'FGEZBug_DamageRPCInfo::WeaponID' has a wrong offset!");
static_assert(offsetof(FGEZBug_DamageRPCInfo, WeaponType) == 0x000030, "Member 'FGEZBug_DamageRPCInfo::WeaponType' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCameraInfo
// 0x0014 (0x0014 - 0x0000)
struct FWaterParkCameraInfo final
{
public:
	struct FVector                                SocketOffset;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLength;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterParkCameraInfo) == 0x000004, "Wrong alignment on FWaterParkCameraInfo");
static_assert(sizeof(FWaterParkCameraInfo) == 0x000014, "Wrong size on FWaterParkCameraInfo");
static_assert(offsetof(FWaterParkCameraInfo, SocketOffset) == 0x000000, "Member 'FWaterParkCameraInfo::SocketOffset' has a wrong offset!");
static_assert(offsetof(FWaterParkCameraInfo, TargetLength) == 0x00000C, "Member 'FWaterParkCameraInfo::TargetLength' has a wrong offset!");
static_assert(offsetof(FWaterParkCameraInfo, FOV) == 0x000010, "Member 'FWaterParkCameraInfo::FOV' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharItemInfo
// 0x0008 (0x0008 - 0x0000)
struct FWaterParkCharItemInfo final
{
public:
	bool                                          HasItemHold;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemState;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterParkCharItemInfo) == 0x000004, "Wrong alignment on FWaterParkCharItemInfo");
static_assert(sizeof(FWaterParkCharItemInfo) == 0x000008, "Wrong size on FWaterParkCharItemInfo");
static_assert(offsetof(FWaterParkCharItemInfo, HasItemHold) == 0x000000, "Member 'FWaterParkCharItemInfo::HasItemHold' has a wrong offset!");
static_assert(offsetof(FWaterParkCharItemInfo, ItemState) == 0x000004, "Member 'FWaterParkCharItemInfo::ItemState' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharFace
// 0x0038 (0x0038 - 0x0000)
struct FWaterParkCharFace final
{
public:
	TSoftObjectPtr<class UTexture2D>              FaceTexture;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandWeight;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD;                                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterParkCharFace) == 0x000008, "Wrong alignment on FWaterParkCharFace");
static_assert(sizeof(FWaterParkCharFace) == 0x000038, "Wrong size on FWaterParkCharFace");
static_assert(offsetof(FWaterParkCharFace, FaceTexture) == 0x000000, "Member 'FWaterParkCharFace::FaceTexture' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFace, Duration) == 0x000028, "Member 'FWaterParkCharFace::Duration' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFace, RandWeight) == 0x00002C, "Member 'FWaterParkCharFace::RandWeight' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFace, CD) == 0x000030, "Member 'FWaterParkCharFace::CD' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharFaceChangeCfg
// 0x0058 (0x0058 - 0x0000)
struct FWaterParkCharFaceChangeCfg final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              DefaultFace;                                       // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWaterParkCharFace>             RandomGroup;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterParkCharFaceChangeCfg) == 0x000008, "Wrong alignment on FWaterParkCharFaceChangeCfg");
static_assert(sizeof(FWaterParkCharFaceChangeCfg) == 0x000058, "Wrong size on FWaterParkCharFaceChangeCfg");
static_assert(offsetof(FWaterParkCharFaceChangeCfg, Slot) == 0x000000, "Member 'FWaterParkCharFaceChangeCfg::Slot' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFaceChangeCfg, TargetName) == 0x000008, "Member 'FWaterParkCharFaceChangeCfg::TargetName' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFaceChangeCfg, LayerIndex) == 0x000018, "Member 'FWaterParkCharFaceChangeCfg::LayerIndex' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFaceChangeCfg, DefaultFace) == 0x000020, "Member 'FWaterParkCharFaceChangeCfg::DefaultFace' has a wrong offset!");
static_assert(offsetof(FWaterParkCharFaceChangeCfg, RandomGroup) == 0x000048, "Member 'FWaterParkCharFaceChangeCfg::RandomGroup' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharacterTemplate
// 0x00C8 (0x00D0 - 0x0008)
struct FWaterParkCharacterTemplate final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         Blueprint;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResPath;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZSpeed;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZSpeedSec;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         PreviewBlueprint;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWaterParkCharFaceChangeCfg            FaceInfo;                                          // 0x0060(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                SettlementCamOffset;                               // 0x00B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SettlementFailCamOffset;                           // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterParkCharacterTemplate) == 0x000008, "Wrong alignment on FWaterParkCharacterTemplate");
static_assert(sizeof(FWaterParkCharacterTemplate) == 0x0000D0, "Wrong size on FWaterParkCharacterTemplate");
static_assert(offsetof(FWaterParkCharacterTemplate, ID) == 0x000008, "Member 'FWaterParkCharacterTemplate::ID' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, Blueprint) == 0x000010, "Member 'FWaterParkCharacterTemplate::Blueprint' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, ResPath) == 0x000028, "Member 'FWaterParkCharacterTemplate::ResPath' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, MoveSpeed) == 0x000038, "Member 'FWaterParkCharacterTemplate::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, JumpZSpeed) == 0x00003C, "Member 'FWaterParkCharacterTemplate::JumpZSpeed' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, JumpZSpeedSec) == 0x000040, "Member 'FWaterParkCharacterTemplate::JumpZSpeedSec' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, PreviewBlueprint) == 0x000048, "Member 'FWaterParkCharacterTemplate::PreviewBlueprint' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, FaceInfo) == 0x000060, "Member 'FWaterParkCharacterTemplate::FaceInfo' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, SettlementCamOffset) == 0x0000B8, "Member 'FWaterParkCharacterTemplate::SettlementCamOffset' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterTemplate, SettlementFailCamOffset) == 0x0000C4, "Member 'FWaterParkCharacterTemplate::SettlementFailCamOffset' has a wrong offset!");

// ScriptStruct GameEx.GEItemPool
// 0x0020 (0x0020 - 0x0000)
struct FGEItemPool final
{
public:
	TArray<TWeakObjectPtr<class AGEItem>>         UsedList;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AGEItem>>         UnusedList;                                        // 0x0010(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEItemPool) == 0x000008, "Wrong alignment on FGEItemPool");
static_assert(sizeof(FGEItemPool) == 0x000020, "Wrong size on FGEItemPool");
static_assert(offsetof(FGEItemPool, UsedList) == 0x000000, "Member 'FGEItemPool::UsedList' has a wrong offset!");
static_assert(offsetof(FGEItemPool, UnusedList) == 0x000010, "Member 'FGEItemPool::UnusedList' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharacterContinuesVecForward
// 0x000C (0x000C - 0x0000)
struct FWaterParkCharacterContinuesVecForward final
{
public:
	float                                         OffsetValue;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectiveTimer;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValidWhenFalling;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTimerEffect;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterParkCharacterContinuesVecForward) == 0x000004, "Wrong alignment on FWaterParkCharacterContinuesVecForward");
static_assert(sizeof(FWaterParkCharacterContinuesVecForward) == 0x00000C, "Wrong size on FWaterParkCharacterContinuesVecForward");
static_assert(offsetof(FWaterParkCharacterContinuesVecForward, OffsetValue) == 0x000000, "Member 'FWaterParkCharacterContinuesVecForward::OffsetValue' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterContinuesVecForward, EffectiveTimer) == 0x000004, "Member 'FWaterParkCharacterContinuesVecForward::EffectiveTimer' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterContinuesVecForward, IsValidWhenFalling) == 0x000008, "Member 'FWaterParkCharacterContinuesVecForward::IsValidWhenFalling' has a wrong offset!");
static_assert(offsetof(FWaterParkCharacterContinuesVecForward, IsTimerEffect) == 0x000009, "Member 'FWaterParkCharacterContinuesVecForward::IsTimerEffect' has a wrong offset!");

// ScriptStruct GameEx.GEDSDebugInfo
// 0x0030 (0x0030 - 0x0000)
struct FGEDSDebugInfo final
{
public:
	class FString                                 AddressURL;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PID;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogName;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LevelID;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEDSDebugInfo) == 0x000008, "Wrong alignment on FGEDSDebugInfo");
static_assert(sizeof(FGEDSDebugInfo) == 0x000030, "Wrong size on FGEDSDebugInfo");
static_assert(offsetof(FGEDSDebugInfo, AddressURL) == 0x000000, "Member 'FGEDSDebugInfo::AddressURL' has a wrong offset!");
static_assert(offsetof(FGEDSDebugInfo, PID) == 0x000010, "Member 'FGEDSDebugInfo::PID' has a wrong offset!");
static_assert(offsetof(FGEDSDebugInfo, LogName) == 0x000018, "Member 'FGEDSDebugInfo::LogName' has a wrong offset!");
static_assert(offsetof(FGEDSDebugInfo, LevelID) == 0x000028, "Member 'FGEDSDebugInfo::LevelID' has a wrong offset!");

// ScriptStruct GameEx.HASMeshSettings
// 0x0030 (0x0030 - 0x0000)
struct FHASMeshSettings final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      TransparentMat;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TransRot;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TransScale;                                        // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraOffsetZ;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHASMeshSettings) == 0x000008, "Wrong alignment on FHASMeshSettings");
static_assert(sizeof(FHASMeshSettings) == 0x000030, "Wrong size on FHASMeshSettings");
static_assert(offsetof(FHASMeshSettings, Mesh) == 0x000000, "Member 'FHASMeshSettings::Mesh' has a wrong offset!");
static_assert(offsetof(FHASMeshSettings, TransparentMat) == 0x000008, "Member 'FHASMeshSettings::TransparentMat' has a wrong offset!");
static_assert(offsetof(FHASMeshSettings, TransRot) == 0x000010, "Member 'FHASMeshSettings::TransRot' has a wrong offset!");
static_assert(offsetof(FHASMeshSettings, TransScale) == 0x00001C, "Member 'FHASMeshSettings::TransScale' has a wrong offset!");
static_assert(offsetof(FHASMeshSettings, ExtraOffsetZ) == 0x000028, "Member 'FHASMeshSettings::ExtraOffsetZ' has a wrong offset!");

// ScriptStruct GameEx.GEItemClientInfo
// 0x0018 (0x0018 - 0x0000)
struct FGEItemClientInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEItemClientInfo) == 0x000004, "Wrong alignment on FGEItemClientInfo");
static_assert(sizeof(FGEItemClientInfo) == 0x000018, "Wrong size on FGEItemClientInfo");
static_assert(offsetof(FGEItemClientInfo, Location) == 0x000000, "Member 'FGEItemClientInfo::Location' has a wrong offset!");
static_assert(offsetof(FGEItemClientInfo, Rotation) == 0x00000C, "Member 'FGEItemClientInfo::Rotation' has a wrong offset!");

// ScriptStruct GameEx.PicDropMat
// 0x0018 (0x0018 - 0x0000)
struct FPicDropMat final
{
public:
	int32                                         MatIndex;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            RealMesh;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      RealMaterial;                                      // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPicDropMat) == 0x000008, "Wrong alignment on FPicDropMat");
static_assert(sizeof(FPicDropMat) == 0x000018, "Wrong size on FPicDropMat");
static_assert(offsetof(FPicDropMat, MatIndex) == 0x000000, "Member 'FPicDropMat::MatIndex' has a wrong offset!");
static_assert(offsetof(FPicDropMat, RealMesh) == 0x000008, "Member 'FPicDropMat::RealMesh' has a wrong offset!");
static_assert(offsetof(FPicDropMat, RealMaterial) == 0x000010, "Member 'FPicDropMat::RealMaterial' has a wrong offset!");

// ScriptStruct GameEx.GERotateBrickSequence
// 0x000C (0x000C - 0x0000)
struct FGERotateBrickSequence final
{
public:
	int32                                         TimePoint;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HaveChangeMat;                                     // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGERotateBrickSequence) == 0x000004, "Wrong alignment on FGERotateBrickSequence");
static_assert(sizeof(FGERotateBrickSequence) == 0x00000C, "Wrong size on FGERotateBrickSequence");
static_assert(offsetof(FGERotateBrickSequence, TimePoint) == 0x000000, "Member 'FGERotateBrickSequence::TimePoint' has a wrong offset!");
static_assert(offsetof(FGERotateBrickSequence, Count) == 0x000004, "Member 'FGERotateBrickSequence::Count' has a wrong offset!");
static_assert(offsetof(FGERotateBrickSequence, HaveChangeMat) == 0x000008, "Member 'FGERotateBrickSequence::HaveChangeMat' has a wrong offset!");

// ScriptStruct GameEx.WPRotateBrickEntry
// 0x0004 (0x0010 - 0x000C)
struct FWPRotateBrickEntry final : public FFastArraySerializerItem
{
public:
	EGERotateBrickState                           BrickState;                                        // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWPRotateBrickEntry) == 0x000004, "Wrong alignment on FWPRotateBrickEntry");
static_assert(sizeof(FWPRotateBrickEntry) == 0x000010, "Wrong size on FWPRotateBrickEntry");
static_assert(offsetof(FWPRotateBrickEntry, BrickState) == 0x00000C, "Member 'FWPRotateBrickEntry::BrickState' has a wrong offset!");

// ScriptStruct GameEx.WPRotateBrickArray
// 0x0010 (0x0118 - 0x0108)
struct FWPRotateBrickArray final : public FFastArraySerializer
{
public:
	TArray<struct FWPRotateBrickEntry>            Items;                                             // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWPRotateBrickArray) == 0x000008, "Wrong alignment on FWPRotateBrickArray");
static_assert(sizeof(FWPRotateBrickArray) == 0x000118, "Wrong size on FWPRotateBrickArray");
static_assert(offsetof(FWPRotateBrickArray, Items) == 0x000108, "Member 'FWPRotateBrickArray::Items' has a wrong offset!");

// ScriptStruct GameEx.WPZBugTestCRT
// 0x0008 (0x0008 - 0x0000)
struct FWPZBugTestCRT final
{
public:
	int32                                         TestTotalDmgCount;                                 // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestCRTDmgCount;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWPZBugTestCRT) == 0x000004, "Wrong alignment on FWPZBugTestCRT");
static_assert(sizeof(FWPZBugTestCRT) == 0x000008, "Wrong size on FWPZBugTestCRT");
static_assert(offsetof(FWPZBugTestCRT, TestTotalDmgCount) == 0x000000, "Member 'FWPZBugTestCRT::TestTotalDmgCount' has a wrong offset!");
static_assert(offsetof(FWPZBugTestCRT, TestCRTDmgCount) == 0x000004, "Member 'FWPZBugTestCRT::TestCRTDmgCount' has a wrong offset!");

// ScriptStruct GameEx.GEZBug_DmgHitInfo
// 0x0048 (0x0048 - 0x0000)
struct FGEZBug_DmgHitInfo final
{
public:
	TArray<struct FVector>                        FireStartPos;                                      // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FireEndPos;                                        // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TargetPos;                                         // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 TargetId;                                          // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         WeaponID;                                          // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletID;                                          // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEZBug_DmgHitInfo) == 0x000008, "Wrong alignment on FGEZBug_DmgHitInfo");
static_assert(sizeof(FGEZBug_DmgHitInfo) == 0x000048, "Wrong size on FGEZBug_DmgHitInfo");
static_assert(offsetof(FGEZBug_DmgHitInfo, FireStartPos) == 0x000000, "Member 'FGEZBug_DmgHitInfo::FireStartPos' has a wrong offset!");
static_assert(offsetof(FGEZBug_DmgHitInfo, FireEndPos) == 0x000010, "Member 'FGEZBug_DmgHitInfo::FireEndPos' has a wrong offset!");
static_assert(offsetof(FGEZBug_DmgHitInfo, TargetPos) == 0x000020, "Member 'FGEZBug_DmgHitInfo::TargetPos' has a wrong offset!");
static_assert(offsetof(FGEZBug_DmgHitInfo, TargetId) == 0x000030, "Member 'FGEZBug_DmgHitInfo::TargetId' has a wrong offset!");
static_assert(offsetof(FGEZBug_DmgHitInfo, WeaponID) == 0x000040, "Member 'FGEZBug_DmgHitInfo::WeaponID' has a wrong offset!");
static_assert(offsetof(FGEZBug_DmgHitInfo, BulletID) == 0x000044, "Member 'FGEZBug_DmgHitInfo::BulletID' has a wrong offset!");

// ScriptStruct GameEx.GEWeaponScatterSigma
// 0x000C (0x000C - 0x0000)
struct FGEWeaponScatterSigma final
{
public:
	EGEWeaponType                                 WeaponType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScatterSigma;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScatterRange;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGEWeaponScatterSigma) == 0x000004, "Wrong alignment on FGEWeaponScatterSigma");
static_assert(sizeof(FGEWeaponScatterSigma) == 0x00000C, "Wrong size on FGEWeaponScatterSigma");
static_assert(offsetof(FGEWeaponScatterSigma, WeaponType) == 0x000000, "Member 'FGEWeaponScatterSigma::WeaponType' has a wrong offset!");
static_assert(offsetof(FGEWeaponScatterSigma, ScatterSigma) == 0x000004, "Member 'FGEWeaponScatterSigma::ScatterSigma' has a wrong offset!");
static_assert(offsetof(FGEWeaponScatterSigma, ScatterRange) == 0x000008, "Member 'FGEWeaponScatterSigma::ScatterRange' has a wrong offset!");

// ScriptStruct GameEx.GEZBug_Recoil
// 0x0030 (0x0030 - 0x0000)
struct FGEZBug_Recoil final
{
public:
	EGEZBug_RecoilState                           RecoilState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Shake;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastBulletCount;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShootBulletCount;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilForcePitchRateRecoverTime;                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGEZBug_Recoil) == 0x000010, "Wrong alignment on FGEZBug_Recoil");
static_assert(sizeof(FGEZBug_Recoil) == 0x000030, "Wrong size on FGEZBug_Recoil");
static_assert(offsetof(FGEZBug_Recoil, RecoilState) == 0x000000, "Member 'FGEZBug_Recoil::RecoilState' has a wrong offset!");
static_assert(offsetof(FGEZBug_Recoil, Shake) == 0x000010, "Member 'FGEZBug_Recoil::Shake' has a wrong offset!");
static_assert(offsetof(FGEZBug_Recoil, LastBulletCount) == 0x000020, "Member 'FGEZBug_Recoil::LastBulletCount' has a wrong offset!");
static_assert(offsetof(FGEZBug_Recoil, ShootBulletCount) == 0x000024, "Member 'FGEZBug_Recoil::ShootBulletCount' has a wrong offset!");
static_assert(offsetof(FGEZBug_Recoil, RecoilForcePitchRateRecoverTime) == 0x000028, "Member 'FGEZBug_Recoil::RecoilForcePitchRateRecoverTime' has a wrong offset!");

// ScriptStruct GameEx.WaterPark_MeleeSweepInfo
// 0x0020 (0x0020 - 0x0000)
struct FWaterPark_MeleeSweepInfo final
{
public:
	struct FVector                                RelativeLoc;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               RelativeRot;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterPark_MeleeSweepInfo) == 0x000010, "Wrong alignment on FWaterPark_MeleeSweepInfo");
static_assert(sizeof(FWaterPark_MeleeSweepInfo) == 0x000020, "Wrong size on FWaterPark_MeleeSweepInfo");
static_assert(offsetof(FWaterPark_MeleeSweepInfo, RelativeLoc) == 0x000000, "Member 'FWaterPark_MeleeSweepInfo::RelativeLoc' has a wrong offset!");
static_assert(offsetof(FWaterPark_MeleeSweepInfo, RelativeRot) == 0x000010, "Member 'FWaterPark_MeleeSweepInfo::RelativeRot' has a wrong offset!");

// ScriptStruct GameEx.WaterParkCharMoveCfg
// 0x0008 (0x0010 - 0x0008)
struct FWaterParkCharMoveCfg final : public FTableRowBase
{
public:
	int32                                         ID;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterParkCharMoveCfg) == 0x000008, "Wrong alignment on FWaterParkCharMoveCfg");
static_assert(sizeof(FWaterParkCharMoveCfg) == 0x000010, "Wrong size on FWaterParkCharMoveCfg");
static_assert(offsetof(FWaterParkCharMoveCfg, ID) == 0x000008, "Member 'FWaterParkCharMoveCfg::ID' has a wrong offset!");

}


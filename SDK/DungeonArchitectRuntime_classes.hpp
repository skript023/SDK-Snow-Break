#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonArchitectRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DungeonArchitectRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class DungeonArchitectRuntime.FlowExecTask
// 0x0030 (0x0058 - 0x0028)
class UFlowExecTask : public UObject
{
public:
	class FString                                 Description;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NodeVariableName;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlowExecTaskExtender*>          Extenders;                                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowExecTask">();
	}
	static class UFlowExecTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowExecTask>();
	}
};
static_assert(alignof(UFlowExecTask) == 0x000008, "Wrong alignment on UFlowExecTask");
static_assert(sizeof(UFlowExecTask) == 0x000058, "Wrong size on UFlowExecTask");
static_assert(offsetof(UFlowExecTask, Description) == 0x000028, "Member 'UFlowExecTask::Description' has a wrong offset!");
static_assert(offsetof(UFlowExecTask, NodeVariableName) == 0x000038, "Member 'UFlowExecTask::NodeVariableName' has a wrong offset!");
static_assert(offsetof(UFlowExecTask, Extenders) == 0x000048, "Member 'UFlowExecTask::Extenders' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstractBase
// 0x0000 (0x0058 - 0x0058)
class UFlowTaskAbstractBase : public UFlowExecTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstractBase">();
	}
	static class UFlowTaskAbstractBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstractBase>();
	}
};
static_assert(alignof(UFlowTaskAbstractBase) == 0x000008, "Wrong alignment on UFlowTaskAbstractBase");
static_assert(sizeof(UFlowTaskAbstractBase) == 0x000058, "Wrong size on UFlowTaskAbstractBase");

// Class DungeonArchitectRuntime.Dungeon
// 0x00F8 (0x0320 - 0x0228)
class ADungeon final : public AActor
{
public:
	struct FGuid                                  Uid;                                               // 0x0228(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDungeonThemeAsset*>             Themes;                                            // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDungeonBuilder>            BuilderClass;                                      // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDungeonMarkerEmitter*>          MarkerEmitters;                                    // 0x0250(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, SimpleDisplay, NativeAccessSpecifierPublic)
	TArray<class UDungeonEventListener*>          EventListeners;                                    // 0x0260(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, SimpleDisplay, NativeAccessSpecifierPublic)
	TArray<struct FClusterThemeInfo>              ClusterThemes;                                     // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugData;                                    // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonBuilder*                        Builder;                                           // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonConfig*                         Config;                                            // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonModel*                          DungeonModel;                                      // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonToolData*                       ToolData;                                          // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonQuery*                          Query;                                             // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDungeonLevelStreamingConfig           LevelStreamingConfig;                              // 0x02B0(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class UDungeonLevelStreamingModel*            LevelStreamingModel;                               // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BuildPriorityLocation;                             // 0x02D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDungeonBuildComplete;                            // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x30];                                     // 0x02F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADungeon* GetDungeonActor();
	static int32 GetDungeonLevelNumber(const class UObject* SceneObject);

	void BuildDungeon();
	void DestroyDungeon();
	class UDungeonQuery* GetQuery();
	class UDungeonBuilder* SetBuilderClass(TSubclassOf<class UDungeonBuilder> InBuilderClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Dungeon">();
	}
	static class ADungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeon>();
	}
};
static_assert(alignof(ADungeon) == 0x000008, "Wrong alignment on ADungeon");
static_assert(sizeof(ADungeon) == 0x000320, "Wrong size on ADungeon");
static_assert(offsetof(ADungeon, Uid) == 0x000228, "Member 'ADungeon::Uid' has a wrong offset!");
static_assert(offsetof(ADungeon, Themes) == 0x000238, "Member 'ADungeon::Themes' has a wrong offset!");
static_assert(offsetof(ADungeon, BuilderClass) == 0x000248, "Member 'ADungeon::BuilderClass' has a wrong offset!");
static_assert(offsetof(ADungeon, MarkerEmitters) == 0x000250, "Member 'ADungeon::MarkerEmitters' has a wrong offset!");
static_assert(offsetof(ADungeon, EventListeners) == 0x000260, "Member 'ADungeon::EventListeners' has a wrong offset!");
static_assert(offsetof(ADungeon, ClusterThemes) == 0x000270, "Member 'ADungeon::ClusterThemes' has a wrong offset!");
static_assert(offsetof(ADungeon, bDrawDebugData) == 0x000280, "Member 'ADungeon::bDrawDebugData' has a wrong offset!");
static_assert(offsetof(ADungeon, Builder) == 0x000288, "Member 'ADungeon::Builder' has a wrong offset!");
static_assert(offsetof(ADungeon, Config) == 0x000290, "Member 'ADungeon::Config' has a wrong offset!");
static_assert(offsetof(ADungeon, DungeonModel) == 0x000298, "Member 'ADungeon::DungeonModel' has a wrong offset!");
static_assert(offsetof(ADungeon, ToolData) == 0x0002A0, "Member 'ADungeon::ToolData' has a wrong offset!");
static_assert(offsetof(ADungeon, Query) == 0x0002A8, "Member 'ADungeon::Query' has a wrong offset!");
static_assert(offsetof(ADungeon, LevelStreamingConfig) == 0x0002B0, "Member 'ADungeon::LevelStreamingConfig' has a wrong offset!");
static_assert(offsetof(ADungeon, LevelStreamingModel) == 0x0002C8, "Member 'ADungeon::LevelStreamingModel' has a wrong offset!");
static_assert(offsetof(ADungeon, BuildPriorityLocation) == 0x0002D0, "Member 'ADungeon::BuildPriorityLocation' has a wrong offset!");
static_assert(offsetof(ADungeon, OnDungeonBuildComplete) == 0x0002E0, "Member 'ADungeon::OnDungeonBuildComplete' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstract_CreateKeyLock
// 0x0040 (0x0098 - 0x0058)
class UFlowTaskAbstract_CreateKeyLock : public UFlowTaskAbstractBase
{
public:
	class FString                                 KeyPath;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LockPath;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyMarkerName;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LockMarkerName;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_CreateKeyLock">();
	}
	static class UFlowTaskAbstract_CreateKeyLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_CreateKeyLock>();
	}
};
static_assert(alignof(UFlowTaskAbstract_CreateKeyLock) == 0x000008, "Wrong alignment on UFlowTaskAbstract_CreateKeyLock");
static_assert(sizeof(UFlowTaskAbstract_CreateKeyLock) == 0x000098, "Wrong size on UFlowTaskAbstract_CreateKeyLock");
static_assert(offsetof(UFlowTaskAbstract_CreateKeyLock, KeyPath) == 0x000058, "Member 'UFlowTaskAbstract_CreateKeyLock::KeyPath' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateKeyLock, LockPath) == 0x000068, "Member 'UFlowTaskAbstract_CreateKeyLock::LockPath' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateKeyLock, KeyMarkerName) == 0x000078, "Member 'UFlowTaskAbstract_CreateKeyLock::KeyMarkerName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateKeyLock, LockMarkerName) == 0x000088, "Member 'UFlowTaskAbstract_CreateKeyLock::LockMarkerName' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonActorTemplate
// 0x0010 (0x0038 - 0x0028)
class UDungeonActorTemplate final : public UObject
{
public:
	TSubclassOf<class AActor>                     ClassTemplate;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorTemplate;                                     // 0x0030(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonActorTemplate">();
	}
	static class UDungeonActorTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonActorTemplate>();
	}
};
static_assert(alignof(UDungeonActorTemplate) == 0x000008, "Wrong alignment on UDungeonActorTemplate");
static_assert(sizeof(UDungeonActorTemplate) == 0x000038, "Wrong size on UDungeonActorTemplate");
static_assert(offsetof(UDungeonActorTemplate, ClassTemplate) == 0x000028, "Member 'UDungeonActorTemplate::ClassTemplate' has a wrong offset!");
static_assert(offsetof(UDungeonActorTemplate, ActorTemplate) == 0x000030, "Member 'UDungeonActorTemplate::ActorTemplate' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstract_PathBuilderBase
// 0x0000 (0x0058 - 0x0058)
class UFlowTaskAbstract_PathBuilderBase : public UFlowTaskAbstractBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_PathBuilderBase">();
	}
	static class UFlowTaskAbstract_PathBuilderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_PathBuilderBase>();
	}
};
static_assert(alignof(UFlowTaskAbstract_PathBuilderBase) == 0x000008, "Wrong alignment on UFlowTaskAbstract_PathBuilderBase");
static_assert(sizeof(UFlowTaskAbstract_PathBuilderBase) == 0x000058, "Wrong size on UFlowTaskAbstract_PathBuilderBase");

// Class DungeonArchitectRuntime.DungeonBPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDungeonBPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorBelongsToDungeon(class ADungeon* Dungeon, class AActor* ActorToCheck);
	static bool DungeonObjectHasAuthority(class UObject* Object);
	static class AActor* SpawnDungeonOwnedActor(class ADungeon* Dungeon, TSubclassOf<class AActor> ActorClass, const struct FTransform& Transform);
	static class ULevelStreamingDynamic* StreamDungeonModuleLevel(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> Level, int32 InstanceId, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonBPFunctionLibrary">();
	}
	static class UDungeonBPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonBPFunctionLibrary>();
	}
};
static_assert(alignof(UDungeonBPFunctionLibrary) == 0x000008, "Wrong alignment on UDungeonBPFunctionLibrary");
static_assert(sizeof(UDungeonBPFunctionLibrary) == 0x000028, "Wrong size on UDungeonBPFunctionLibrary");

// Class DungeonArchitectRuntime.FlowTaskAbstract_CreateMainPath
// 0x0078 (0x00D0 - 0x0058)
class UFlowTaskAbstract_CreateMainPath : public UFlowTaskAbstract_PathBuilderBase
{
public:
	int32                                         PathSize;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathName;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NodeColor;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartMarkerName;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GoalMarkerName;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartNodePathName;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GoalNodePathName;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumParallelSearches;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxFramesToProcess;                                // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_CreateMainPath">();
	}
	static class UFlowTaskAbstract_CreateMainPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_CreateMainPath>();
	}
};
static_assert(alignof(UFlowTaskAbstract_CreateMainPath) == 0x000008, "Wrong alignment on UFlowTaskAbstract_CreateMainPath");
static_assert(sizeof(UFlowTaskAbstract_CreateMainPath) == 0x0000D0, "Wrong size on UFlowTaskAbstract_CreateMainPath");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, PathSize) == 0x000058, "Member 'UFlowTaskAbstract_CreateMainPath::PathSize' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, PathName) == 0x000060, "Member 'UFlowTaskAbstract_CreateMainPath::PathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, NodeColor) == 0x000070, "Member 'UFlowTaskAbstract_CreateMainPath::NodeColor' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, StartMarkerName) == 0x000080, "Member 'UFlowTaskAbstract_CreateMainPath::StartMarkerName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, GoalMarkerName) == 0x000090, "Member 'UFlowTaskAbstract_CreateMainPath::GoalMarkerName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, StartNodePathName) == 0x0000A0, "Member 'UFlowTaskAbstract_CreateMainPath::StartNodePathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, GoalNodePathName) == 0x0000B0, "Member 'UFlowTaskAbstract_CreateMainPath::GoalNodePathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, NumParallelSearches) == 0x0000C0, "Member 'UFlowTaskAbstract_CreateMainPath::NumParallelSearches' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateMainPath, MaxFramesToProcess) == 0x0000C8, "Member 'UFlowTaskAbstract_CreateMainPath::MaxFramesToProcess' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonBuilder
// 0x0048 (0x0070 - 0x0028)
class UDungeonBuilder : public UObject
{
public:
	class UDungeonConfig*                         Config;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADungeon*                               Dungeon;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDungeonModel*                          Model;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDungeonQuery*                          Query;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EmitDungeonMarkers();
	void EmitMarker(const class FString& SocketType, const struct FTransform& Transform);

	TArray<struct FPropSocket> GetMarkers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonBuilder">();
	}
	static class UDungeonBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonBuilder>();
	}
};
static_assert(alignof(UDungeonBuilder) == 0x000008, "Wrong alignment on UDungeonBuilder");
static_assert(sizeof(UDungeonBuilder) == 0x000070, "Wrong size on UDungeonBuilder");
static_assert(offsetof(UDungeonBuilder, Config) == 0x000028, "Member 'UDungeonBuilder::Config' has a wrong offset!");
static_assert(offsetof(UDungeonBuilder, Dungeon) == 0x000040, "Member 'UDungeonBuilder::Dungeon' has a wrong offset!");
static_assert(offsetof(UDungeonBuilder, Model) == 0x000048, "Member 'UDungeonBuilder::Model' has a wrong offset!");
static_assert(offsetof(UDungeonBuilder, Query) == 0x000050, "Member 'UDungeonBuilder::Query' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonConfig
// 0x0020 (0x0048 - 0x0028)
class UDungeonConfig : public UObject
{
public:
	class FString                                 OrderCategory;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Instanced;                                         // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBuildTimePerFrameMs;                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonConfig">();
	}
	static class UDungeonConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonConfig>();
	}
};
static_assert(alignof(UDungeonConfig) == 0x000008, "Wrong alignment on UDungeonConfig");
static_assert(sizeof(UDungeonConfig) == 0x000048, "Wrong size on UDungeonConfig");
static_assert(offsetof(UDungeonConfig, OrderCategory) == 0x000028, "Member 'UDungeonConfig::OrderCategory' has a wrong offset!");
static_assert(offsetof(UDungeonConfig, Seed) == 0x000038, "Member 'UDungeonConfig::Seed' has a wrong offset!");
static_assert(offsetof(UDungeonConfig, Instanced) == 0x00003C, "Member 'UDungeonConfig::Instanced' has a wrong offset!");
static_assert(offsetof(UDungeonConfig, MaxBuildTimePerFrameMs) == 0x000040, "Member 'UDungeonConfig::MaxBuildTimePerFrameMs' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonDebug
// 0x0008 (0x0230 - 0x0228)
class ADungeonDebug final : public AActor
{
public:
	class AActor*                                 CloneTemplate;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonDebug">();
	}
	static class ADungeonDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonDebug>();
	}
};
static_assert(alignof(ADungeonDebug) == 0x000008, "Wrong alignment on ADungeonDebug");
static_assert(sizeof(ADungeonDebug) == 0x000230, "Wrong size on ADungeonDebug");
static_assert(offsetof(ADungeonDebug, CloneTemplate) == 0x000228, "Member 'ADungeonDebug::CloneTemplate' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonEditorViewportProperties
// 0x0030 (0x0058 - 0x0028)
class UDungeonEditorViewportProperties final : public UObject
{
public:
	class UDungeonConfig*                         DungeonConfig;                                     // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDungeonMarkerEmitter*>          MarkerEmitters;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, SimpleDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UDungeonBuilder>            BuilderClass;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonEditorViewportProperties">();
	}
	static class UDungeonEditorViewportProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonEditorViewportProperties>();
	}
};
static_assert(alignof(UDungeonEditorViewportProperties) == 0x000008, "Wrong alignment on UDungeonEditorViewportProperties");
static_assert(sizeof(UDungeonEditorViewportProperties) == 0x000058, "Wrong size on UDungeonEditorViewportProperties");
static_assert(offsetof(UDungeonEditorViewportProperties, DungeonConfig) == 0x000028, "Member 'UDungeonEditorViewportProperties::DungeonConfig' has a wrong offset!");
static_assert(offsetof(UDungeonEditorViewportProperties, MarkerEmitters) == 0x000030, "Member 'UDungeonEditorViewportProperties::MarkerEmitters' has a wrong offset!");
static_assert(offsetof(UDungeonEditorViewportProperties, BuilderClass) == 0x000040, "Member 'UDungeonEditorViewportProperties::BuilderClass' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonEventListener
// 0x0000 (0x0028 - 0x0028)
class UDungeonEventListener : public UObject
{
public:
	void OnDungeonDestroyed(class ADungeon* Dungeon);
	void OnDungeonLayoutBuilt(class ADungeon* Dungeon);
	void OnMarkersEmitted(class ADungeon* Dungeon, TArray<struct FDungeonMarkerInfo>& MarkerList, TArray<struct FDungeonMarkerInfo>* MarkerListRef);
	void OnPostDungeonBuild(class ADungeon* Dungeon);
	void OnPreDungeonBuild(class ADungeon* Dungeon);
	void OnPreDungeonDestroy(class ADungeon* Dungeon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonEventListener">();
	}
	static class UDungeonEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonEventListener>();
	}
};
static_assert(alignof(UDungeonEventListener) == 0x000008, "Wrong alignment on UDungeonEventListener");
static_assert(sizeof(UDungeonEventListener) == 0x000028, "Wrong size on UDungeonEventListener");

// Class DungeonArchitectRuntime.DungeonInstancedMeshActor
// 0x0050 (0x0278 - 0x0228)
class ADungeonInstancedMeshActor final : public AActor
{
public:
	uint8                                         Pad_228[0x50];                                     // 0x0228(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonInstancedMeshActor">();
	}
	static class ADungeonInstancedMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonInstancedMeshActor>();
	}
};
static_assert(alignof(ADungeonInstancedMeshActor) == 0x000008, "Wrong alignment on ADungeonInstancedMeshActor");
static_assert(sizeof(ADungeonInstancedMeshActor) == 0x000278, "Wrong size on ADungeonInstancedMeshActor");

// Class DungeonArchitectRuntime.DungeonLandscapeModifier
// 0x0040 (0x0068 - 0x0028)
class UDungeonLandscapeModifier final : public UDungeonEventListener
{
public:
	class ALandscape*                             Landscape;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightBlurRadius;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeightBlurIterations;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightBlurWeight;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintBlurRadius;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PaintBlurIterations;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintBlurWeight;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PaintBlurWeightCurve;                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseHeight;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULandscapeLayerInfoObject*>      Layers;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonLandscapeModifier">();
	}
	static class UDungeonLandscapeModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonLandscapeModifier>();
	}
};
static_assert(alignof(UDungeonLandscapeModifier) == 0x000008, "Wrong alignment on UDungeonLandscapeModifier");
static_assert(sizeof(UDungeonLandscapeModifier) == 0x000068, "Wrong size on UDungeonLandscapeModifier");
static_assert(offsetof(UDungeonLandscapeModifier, Landscape) == 0x000028, "Member 'UDungeonLandscapeModifier::Landscape' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, HeightBlurRadius) == 0x000030, "Member 'UDungeonLandscapeModifier::HeightBlurRadius' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, HeightBlurIterations) == 0x000034, "Member 'UDungeonLandscapeModifier::HeightBlurIterations' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, HeightBlurWeight) == 0x000038, "Member 'UDungeonLandscapeModifier::HeightBlurWeight' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, PaintBlurRadius) == 0x00003C, "Member 'UDungeonLandscapeModifier::PaintBlurRadius' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, PaintBlurIterations) == 0x000040, "Member 'UDungeonLandscapeModifier::PaintBlurIterations' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, PaintBlurWeight) == 0x000044, "Member 'UDungeonLandscapeModifier::PaintBlurWeight' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, PaintBlurWeightCurve) == 0x000048, "Member 'UDungeonLandscapeModifier::PaintBlurWeightCurve' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, BaseHeight) == 0x000050, "Member 'UDungeonLandscapeModifier::BaseHeight' has a wrong offset!");
static_assert(offsetof(UDungeonLandscapeModifier, Layers) == 0x000058, "Member 'UDungeonLandscapeModifier::Layers' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonStreamingLevel
// 0x0018 (0x0040 - 0x0028)
class UDungeonStreamingLevel : public UObject
{
public:
	class ULevelStreamingDynamic*                 LevelStreaming;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPackage*                               LevelPackage;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleChunkHidden();
	void HandleChunkLoaded();
	void HandleChunkUnloaded();
	void HandleChunkVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonStreamingLevel">();
	}
	static class UDungeonStreamingLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonStreamingLevel>();
	}
};
static_assert(alignof(UDungeonStreamingLevel) == 0x000008, "Wrong alignment on UDungeonStreamingLevel");
static_assert(sizeof(UDungeonStreamingLevel) == 0x000040, "Wrong size on UDungeonStreamingLevel");
static_assert(offsetof(UDungeonStreamingLevel, LevelStreaming) == 0x000028, "Member 'UDungeonStreamingLevel::LevelStreaming' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingLevel, LevelPackage) == 0x000030, "Member 'UDungeonStreamingLevel::LevelPackage' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonLogicStreamingLevel
// 0x0000 (0x0040 - 0x0040)
class UDungeonLogicStreamingLevel final : public UDungeonStreamingLevel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonLogicStreamingLevel">();
	}
	static class UDungeonLogicStreamingLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonLogicStreamingLevel>();
	}
};
static_assert(alignof(UDungeonLogicStreamingLevel) == 0x000008, "Wrong alignment on UDungeonLogicStreamingLevel");
static_assert(sizeof(UDungeonLogicStreamingLevel) == 0x000040, "Wrong size on UDungeonLogicStreamingLevel");

// Class DungeonArchitectRuntime.DungeonStreamingChunk
// 0x00D0 (0x00F8 - 0x0028)
class UDungeonStreamingChunk : public UObject
{
public:
	int32                                         OrderNum;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Category;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0050(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UDungeonStreamingChunk*>           Neighbors;                                         // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bSpawnRoomChunk;                                   // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x17];                                      // 0x00C1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonStreamingLevel*                 ArtLevel;                                          // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDungeonLogicStreamingLevel*            LogicLevel;                                        // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllActorsOfClass(class UClass* InClass, TArray<class AActor*>* OutActors);
	void HandleChunkHidden();
	void HandleChunkLoaded();
	void HandleChunkUnloaded();
	void HandleChunkVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonStreamingChunk">();
	}
	static class UDungeonStreamingChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonStreamingChunk>();
	}
};
static_assert(alignof(UDungeonStreamingChunk) == 0x000008, "Wrong alignment on UDungeonStreamingChunk");
static_assert(sizeof(UDungeonStreamingChunk) == 0x0000F8, "Wrong size on UDungeonStreamingChunk");
static_assert(offsetof(UDungeonStreamingChunk, OrderNum) == 0x000028, "Member 'UDungeonStreamingChunk::OrderNum' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, Category) == 0x000030, "Member 'UDungeonStreamingChunk::Category' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, ID) == 0x000040, "Member 'UDungeonStreamingChunk::ID' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, Bounds) == 0x000050, "Member 'UDungeonStreamingChunk::Bounds' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, Neighbors) == 0x000070, "Member 'UDungeonStreamingChunk::Neighbors' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, bSpawnRoomChunk) == 0x0000C0, "Member 'UDungeonStreamingChunk::bSpawnRoomChunk' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, ArtLevel) == 0x0000D8, "Member 'UDungeonStreamingChunk::ArtLevel' has a wrong offset!");
static_assert(offsetof(UDungeonStreamingChunk, LogicLevel) == 0x0000E0, "Member 'UDungeonStreamingChunk::LogicLevel' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonLevelStreamingModel
// 0x0090 (0x0140 - 0x00B0)
class UDungeonLevelStreamingModel final : public UActorComponent
{
public:
	TArray<class UDungeonStreamingChunk*>         Chunks;                                            // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDungeonLevelStreamingNavigation*       StreamingNavigation;                               // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInitialChunksLoaded;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChunkVisible;                                    // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChunkUnload;                                     // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewCorridor;                                     // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         StartRoomId;                                       // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x24];                                     // 0x010C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDungeonStreamingChunkParamRep> ChunkParamsToClient;                               // 0x0130(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_ChunkParamsToClient();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonLevelStreamingModel">();
	}
	static class UDungeonLevelStreamingModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonLevelStreamingModel>();
	}
};
static_assert(alignof(UDungeonLevelStreamingModel) == 0x000008, "Wrong alignment on UDungeonLevelStreamingModel");
static_assert(sizeof(UDungeonLevelStreamingModel) == 0x000140, "Wrong size on UDungeonLevelStreamingModel");
static_assert(offsetof(UDungeonLevelStreamingModel, Chunks) == 0x0000B0, "Member 'UDungeonLevelStreamingModel::Chunks' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, StreamingNavigation) == 0x0000C0, "Member 'UDungeonLevelStreamingModel::StreamingNavigation' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, OnInitialChunksLoaded) == 0x0000C8, "Member 'UDungeonLevelStreamingModel::OnInitialChunksLoaded' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, OnChunkVisible) == 0x0000D8, "Member 'UDungeonLevelStreamingModel::OnChunkVisible' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, OnChunkUnload) == 0x0000E8, "Member 'UDungeonLevelStreamingModel::OnChunkUnload' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, OnNewCorridor) == 0x0000F8, "Member 'UDungeonLevelStreamingModel::OnNewCorridor' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, StartRoomId) == 0x000108, "Member 'UDungeonLevelStreamingModel::StartRoomId' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingModel, ChunkParamsToClient) == 0x000130, "Member 'UDungeonLevelStreamingModel::ChunkParamsToClient' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonLevelStreamingNavigation
// 0x0010 (0x0038 - 0x0028)
class UDungeonLevelStreamingNavigation final : public UObject
{
public:
	bool                                          bEnabled;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoResizeNavVolume;                              // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0xE];                                       // 0x002A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonLevelStreamingNavigation">();
	}
	static class UDungeonLevelStreamingNavigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonLevelStreamingNavigation>();
	}
};
static_assert(alignof(UDungeonLevelStreamingNavigation) == 0x000008, "Wrong alignment on UDungeonLevelStreamingNavigation");
static_assert(sizeof(UDungeonLevelStreamingNavigation) == 0x000038, "Wrong size on UDungeonLevelStreamingNavigation");
static_assert(offsetof(UDungeonLevelStreamingNavigation, bEnabled) == 0x000028, "Member 'UDungeonLevelStreamingNavigation::bEnabled' has a wrong offset!");
static_assert(offsetof(UDungeonLevelStreamingNavigation, bAutoResizeNavVolume) == 0x000029, "Member 'UDungeonLevelStreamingNavigation::bAutoResizeNavVolume' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMarkerEmitter
// 0x0000 (0x0028 - 0x0028)
class UDungeonMarkerEmitter final : public UObject
{
public:
	void EmitMarkers(class UDungeonBuilder* Builder, class UDungeonModel* Model, class UDungeonConfig* Config, class UDungeonQuery* Query);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMarkerEmitter">();
	}
	static class UDungeonMarkerEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonMarkerEmitter>();
	}
};
static_assert(alignof(UDungeonMarkerEmitter) == 0x000008, "Wrong alignment on UDungeonMarkerEmitter");
static_assert(sizeof(UDungeonMarkerEmitter) == 0x000028, "Wrong size on UDungeonMarkerEmitter");

// Class DungeonArchitectRuntime.DungeonVolume
// 0x0010 (0x0270 - 0x0260)
class ADungeonVolume : public AVolume
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RealtimeUpdate;                                    // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonVolume">();
	}
	static class ADungeonVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonVolume>();
	}
};
static_assert(alignof(ADungeonVolume) == 0x000008, "Wrong alignment on ADungeonVolume");
static_assert(sizeof(ADungeonVolume) == 0x000270, "Wrong size on ADungeonVolume");
static_assert(offsetof(ADungeonVolume, Dungeon) == 0x000260, "Member 'ADungeonVolume::Dungeon' has a wrong offset!");
static_assert(offsetof(ADungeonVolume, RealtimeUpdate) == 0x000268, "Member 'ADungeonVolume::RealtimeUpdate' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMarkerReplaceVolume
// 0x0010 (0x0280 - 0x0270)
class ADungeonMarkerReplaceVolume final : public ADungeonVolume
{
public:
	TArray<struct FMarkerReplaceEntry>            Replacements;                                      // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMarkerReplaceVolume">();
	}
	static class ADungeonMarkerReplaceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonMarkerReplaceVolume>();
	}
};
static_assert(alignof(ADungeonMarkerReplaceVolume) == 0x000008, "Wrong alignment on ADungeonMarkerReplaceVolume");
static_assert(sizeof(ADungeonMarkerReplaceVolume) == 0x000280, "Wrong size on ADungeonMarkerReplaceVolume");
static_assert(offsetof(ADungeonMarkerReplaceVolume, Replacements) == 0x000270, "Member 'ADungeonMarkerReplaceVolume::Replacements' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMesh
// 0x0028 (0x0050 - 0x0028)
class UDungeonMesh final : public UObject
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaterialOverride>              MaterialOverrides;                                 // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        HashCode;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Template;                                          // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMesh">();
	}
	static class UDungeonMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonMesh>();
	}
};
static_assert(alignof(UDungeonMesh) == 0x000008, "Wrong alignment on UDungeonMesh");
static_assert(sizeof(UDungeonMesh) == 0x000050, "Wrong size on UDungeonMesh");
static_assert(offsetof(UDungeonMesh, StaticMesh) == 0x000028, "Member 'UDungeonMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(UDungeonMesh, MaterialOverrides) == 0x000030, "Member 'UDungeonMesh::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(UDungeonMesh, HashCode) == 0x000040, "Member 'UDungeonMesh::HashCode' has a wrong offset!");
static_assert(offsetof(UDungeonMesh, Template) == 0x000048, "Member 'UDungeonMesh::Template' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMiniMap
// 0x00B8 (0x02E0 - 0x0228)
class ADungeonMiniMap : public AActor
{
public:
	int32                                         TextureSize;                                       // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineThickness;                                  // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorThickness;                                     // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDungeonMiniMapOverlayIcon>     OverlayIcons;                                      // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialTemplate;                                  // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDungeonMiniMapOverlayTracking> DynamicTracking;                                   // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BlurRadius;                                        // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlurIterations;                                    // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFogOfWar;                                   // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FogOfWarTextureScale;                              // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FogOfWarTrackingItem;                              // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FogOfWarExploreTexture;                            // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogOfWarVisiblityDistance;                         // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MaskTexture;                                       // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 StaticOverlayTexture;                              // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 DynamicOverlayTexture;                             // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 FogOfWarTexture;                                   // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldToScreen;                                     // 0x02B0(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void BuildLayout(class UDungeonModel* DungeonModel, class UDungeonConfig* DungeonConfig);
	class UMaterialInterface* CreateMaterialInstance();
	class UMaterialInterface* CreateMaterialInstanceFromTemplate(class UMaterialInterface* InMaterialTemplate);
	void UpdateMaterial(class UMaterialInterface* InMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMiniMap">();
	}
	static class ADungeonMiniMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonMiniMap>();
	}
};
static_assert(alignof(ADungeonMiniMap) == 0x000010, "Wrong alignment on ADungeonMiniMap");
static_assert(sizeof(ADungeonMiniMap) == 0x0002E0, "Wrong size on ADungeonMiniMap");
static_assert(offsetof(ADungeonMiniMap, TextureSize) == 0x000228, "Member 'ADungeonMiniMap::TextureSize' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, OutlineThickness) == 0x00022C, "Member 'ADungeonMiniMap::OutlineThickness' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, DoorThickness) == 0x000230, "Member 'ADungeonMiniMap::DoorThickness' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, OverlayIcons) == 0x000238, "Member 'ADungeonMiniMap::OverlayIcons' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, MaterialTemplate) == 0x000248, "Member 'ADungeonMiniMap::MaterialTemplate' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, DynamicTracking) == 0x000250, "Member 'ADungeonMiniMap::DynamicTracking' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, BlurRadius) == 0x000260, "Member 'ADungeonMiniMap::BlurRadius' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, BlurIterations) == 0x000264, "Member 'ADungeonMiniMap::BlurIterations' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, bEnableFogOfWar) == 0x000268, "Member 'ADungeonMiniMap::bEnableFogOfWar' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, FogOfWarTextureScale) == 0x00026C, "Member 'ADungeonMiniMap::FogOfWarTextureScale' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, FogOfWarTrackingItem) == 0x000270, "Member 'ADungeonMiniMap::FogOfWarTrackingItem' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, FogOfWarExploreTexture) == 0x000278, "Member 'ADungeonMiniMap::FogOfWarExploreTexture' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, FogOfWarVisiblityDistance) == 0x000280, "Member 'ADungeonMiniMap::FogOfWarVisiblityDistance' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, MaskTexture) == 0x000288, "Member 'ADungeonMiniMap::MaskTexture' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, StaticOverlayTexture) == 0x000290, "Member 'ADungeonMiniMap::StaticOverlayTexture' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, DynamicOverlayTexture) == 0x000298, "Member 'ADungeonMiniMap::DynamicOverlayTexture' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, FogOfWarTexture) == 0x0002A0, "Member 'ADungeonMiniMap::FogOfWarTexture' has a wrong offset!");
static_assert(offsetof(ADungeonMiniMap, WorldToScreen) == 0x0002B0, "Member 'ADungeonMiniMap::WorldToScreen' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMiniMapTrackedObject
// 0x0018 (0x00C8 - 0x00B0)
class UDungeonMiniMapTrackedObject final : public UActorComponent
{
public:
	class FName                                   ID;                                                // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconName;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientToRotation;                                 // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMiniMapTrackedObject">();
	}
	static class UDungeonMiniMapTrackedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonMiniMapTrackedObject>();
	}
};
static_assert(alignof(UDungeonMiniMapTrackedObject) == 0x000008, "Wrong alignment on UDungeonMiniMapTrackedObject");
static_assert(sizeof(UDungeonMiniMapTrackedObject) == 0x0000C8, "Wrong size on UDungeonMiniMapTrackedObject");
static_assert(offsetof(UDungeonMiniMapTrackedObject, ID) == 0x0000B0, "Member 'UDungeonMiniMapTrackedObject::ID' has a wrong offset!");
static_assert(offsetof(UDungeonMiniMapTrackedObject, IconName) == 0x0000B8, "Member 'UDungeonMiniMapTrackedObject::IconName' has a wrong offset!");
static_assert(offsetof(UDungeonMiniMapTrackedObject, bOrientToRotation) == 0x0000C0, "Member 'UDungeonMiniMapTrackedObject::bOrientToRotation' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonMirrorVolume
// 0x0000 (0x0270 - 0x0270)
class ADungeonMirrorVolume final : public ADungeonVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMirrorVolume">();
	}
	static class ADungeonMirrorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonMirrorVolume>();
	}
};
static_assert(alignof(ADungeonMirrorVolume) == 0x000008, "Wrong alignment on ADungeonMirrorVolume");
static_assert(sizeof(ADungeonMirrorVolume) == 0x000270, "Wrong size on ADungeonMirrorVolume");

// Class DungeonArchitectRuntime.DungeonModel
// 0x0000 (0x0028 - 0x0028)
class UDungeonModel : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonModel">();
	}
	static class UDungeonModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonModel>();
	}
};
static_assert(alignof(UDungeonModel) == 0x000008, "Wrong alignment on UDungeonModel");
static_assert(sizeof(UDungeonModel) == 0x000028, "Wrong size on UDungeonModel");

// Class DungeonArchitectRuntime.DungeonModelHelper
// 0x0000 (0x0028 - 0x0028)
class UDungeonModelHelper : public UObject
{
public:
	static void ExpandBounds(const struct FRectangle& Bounds, int32 Size, struct FRectangle* Result);
	static void GetCenterExtent(const struct FRectangle& Rectangle, struct FVector* Center, struct FVector* Extent);
	static void GetRectAreaPoints(const struct FRectangle& Rectangle, TArray<struct FIntVector>* BorderPoints);
	static void GetRectBorderPoints(const struct FRectangle& Rectangle, TArray<struct FIntVector>* BorderPoints);
	static struct FIntVector MakeIntVector(const struct FVector& In);
	static struct FVector MakeVector(const struct FIntVector& In, float Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonModelHelper">();
	}
	static class UDungeonModelHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonModelHelper>();
	}
};
static_assert(alignof(UDungeonModelHelper) == 0x000008, "Wrong alignment on UDungeonModelHelper");
static_assert(sizeof(UDungeonModelHelper) == 0x000028, "Wrong size on UDungeonModelHelper");

// Class DungeonArchitectRuntime.SnapMapDungeonModel
// 0x0028 (0x0050 - 0x0028)
class USnapMapDungeonModel final : public UDungeonModel
{
public:
	TArray<struct FSnapConnectionInstance>        Connections;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSnapMapModuleInstanceSerializedData> ModuleInstances;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGrammarScriptGraph*                    MissionGraph;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonModel">();
	}
	static class USnapMapDungeonModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonModel>();
	}
};
static_assert(alignof(USnapMapDungeonModel) == 0x000008, "Wrong alignment on USnapMapDungeonModel");
static_assert(sizeof(USnapMapDungeonModel) == 0x000050, "Wrong size on USnapMapDungeonModel");
static_assert(offsetof(USnapMapDungeonModel, Connections) == 0x000028, "Member 'USnapMapDungeonModel::Connections' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonModel, ModuleInstances) == 0x000038, "Member 'USnapMapDungeonModel::ModuleInstances' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonModel, MissionGraph) == 0x000048, "Member 'USnapMapDungeonModel::MissionGraph' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonNavLinkProxy
// 0x0000 (0x0278 - 0x0278)
class ADungeonNavLinkProxy final : public ANavLinkProxy
{
public:
	void SetupSmartLinkData(const struct FVector& Start, const struct FVector& End, ENavLinkDirection Direction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonNavLinkProxy">();
	}
	static class ADungeonNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonNavLinkProxy>();
	}
};
static_assert(alignof(ADungeonNavLinkProxy) == 0x000008, "Wrong alignment on ADungeonNavLinkProxy");
static_assert(sizeof(ADungeonNavLinkProxy) == 0x000278, "Wrong size on ADungeonNavLinkProxy");

// Class DungeonArchitectRuntime.DungeonNegationVolume
// 0x0008 (0x0278 - 0x0270)
class ADungeonNegationVolume final : public ADungeonVolume
{
public:
	bool                                          Reversed;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectsUserDefinedCells;                           // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonNegationVolume">();
	}
	static class ADungeonNegationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonNegationVolume>();
	}
};
static_assert(alignof(ADungeonNegationVolume) == 0x000008, "Wrong alignment on ADungeonNegationVolume");
static_assert(sizeof(ADungeonNegationVolume) == 0x000278, "Wrong size on ADungeonNegationVolume");
static_assert(offsetof(ADungeonNegationVolume, Reversed) == 0x000270, "Member 'ADungeonNegationVolume::Reversed' has a wrong offset!");
static_assert(offsetof(ADungeonNegationVolume, AffectsUserDefinedCells) == 0x000271, "Member 'ADungeonNegationVolume::AffectsUserDefinedCells' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonQuery
// 0x0038 (0x0060 - 0x0028)
class alignas(0x10) UDungeonQuery : public UObject
{
public:
	class UDungeonQueryUserState*                 UserState;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonQuery">();
	}
	static class UDungeonQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonQuery>();
	}
};
static_assert(alignof(UDungeonQuery) == 0x000010, "Wrong alignment on UDungeonQuery");
static_assert(sizeof(UDungeonQuery) == 0x000060, "Wrong size on UDungeonQuery");
static_assert(offsetof(UDungeonQuery, UserState) == 0x000028, "Member 'UDungeonQuery::UserState' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapGridFlowQuery
// 0x0000 (0x0060 - 0x0060)
class USnapGridFlowQuery final : public UDungeonQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowQuery">();
	}
	static class USnapGridFlowQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowQuery>();
	}
};
static_assert(alignof(USnapGridFlowQuery) == 0x000010, "Wrong alignment on USnapGridFlowQuery");
static_assert(sizeof(USnapGridFlowQuery) == 0x000060, "Wrong size on USnapGridFlowQuery");

// Class DungeonArchitectRuntime.DungeonParticleSystem
// 0x0010 (0x0238 - 0x0228)
class ADungeonParticleSystem final : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonParticleSystem">();
	}
	static class ADungeonParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonParticleSystem>();
	}
};
static_assert(alignof(ADungeonParticleSystem) == 0x000008, "Wrong alignment on ADungeonParticleSystem");
static_assert(sizeof(ADungeonParticleSystem) == 0x000238, "Wrong size on ADungeonParticleSystem");

// Class DungeonArchitectRuntime.DungeonQueryUserState
// 0x0050 (0x0078 - 0x0028)
class UDungeonQueryUserState final : public UObject
{
public:
	TMap<class FName, class FString>              UserData;                                          // 0x0028(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ClearAllState();
	bool GetBool(const class FName& Name_0);
	float GetFloat(const class FName& Name_0);
	int32 GetInt(const class FName& Name_0);
	class FString GetString(const class FName& Name_0);
	struct FVector GetVector(const class FName& Name_0);
	void SetBool(const class FName& Name_0, bool Value);
	void SetFloat(const class FName& Name_0, float Value);
	void SetInt(const class FName& Name_0, int32 Value);
	void SetString(const class FName& Name_0, const class FString& Value);
	void SetVector(const class FName& Name_0, const struct FVector& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonQueryUserState">();
	}
	static class UDungeonQueryUserState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonQueryUserState>();
	}
};
static_assert(alignof(UDungeonQueryUserState) == 0x000008, "Wrong alignment on UDungeonQueryUserState");
static_assert(sizeof(UDungeonQueryUserState) == 0x000078, "Wrong size on UDungeonQueryUserState");
static_assert(offsetof(UDungeonQueryUserState, UserData) == 0x000028, "Member 'UDungeonQueryUserState::UserData' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonTransformLogic
// 0x0000 (0x0028 - 0x0028)
class UDungeonTransformLogic : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonTransformLogic">();
	}
	static class UDungeonTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonTransformLogic>();
	}
};
static_assert(alignof(UDungeonTransformLogic) == 0x000008, "Wrong alignment on UDungeonTransformLogic");
static_assert(sizeof(UDungeonTransformLogic) == 0x000028, "Wrong size on UDungeonTransformLogic");

// Class DungeonArchitectRuntime.SnapMapDungeonTransformLogic
// 0x0000 (0x0028 - 0x0028)
class USnapMapDungeonTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class USnapMapDungeonModel* Model, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonTransformLogic">();
	}
	static class USnapMapDungeonTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonTransformLogic>();
	}
};
static_assert(alignof(USnapMapDungeonTransformLogic) == 0x000008, "Wrong alignment on USnapMapDungeonTransformLogic");
static_assert(sizeof(USnapMapDungeonTransformLogic) == 0x000028, "Wrong size on USnapMapDungeonTransformLogic");

// Class DungeonArchitectRuntime.DungeonSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class UDungeonSelectorLogic : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSelectorLogic">();
	}
	static class UDungeonSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSelectorLogic>();
	}
};
static_assert(alignof(UDungeonSelectorLogic) == 0x000008, "Wrong alignment on UDungeonSelectorLogic");
static_assert(sizeof(UDungeonSelectorLogic) == 0x000028, "Wrong size on UDungeonSelectorLogic");

// Class DungeonArchitectRuntime.DungeonSpatialConstraint
// 0x0008 (0x0030 - 0x0028)
class UDungeonSpatialConstraint : public UObject
{
public:
	bool                                          bApplyBaseRotation;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateToFitConstraint;                            // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSpatialConstraint">();
	}
	static class UDungeonSpatialConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSpatialConstraint>();
	}
};
static_assert(alignof(UDungeonSpatialConstraint) == 0x000008, "Wrong alignment on UDungeonSpatialConstraint");
static_assert(sizeof(UDungeonSpatialConstraint) == 0x000030, "Wrong size on UDungeonSpatialConstraint");
static_assert(offsetof(UDungeonSpatialConstraint, bApplyBaseRotation) == 0x000028, "Member 'UDungeonSpatialConstraint::bApplyBaseRotation' has a wrong offset!");
static_assert(offsetof(UDungeonSpatialConstraint, bRotateToFitConstraint) == 0x000029, "Member 'UDungeonSpatialConstraint::bRotateToFitConstraint' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonSpawnLogic
// 0x0000 (0x0028 - 0x0028)
class UDungeonSpawnLogic final : public UObject
{
public:
	void OnItemSpawn(class AActor* Actor, class ADungeon* Dungeon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonSpawnLogic">();
	}
	static class UDungeonSpawnLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonSpawnLogic>();
	}
};
static_assert(alignof(UDungeonSpawnLogic) == 0x000008, "Wrong alignment on UDungeonSpawnLogic");
static_assert(sizeof(UDungeonSpawnLogic) == 0x000028, "Wrong size on UDungeonSpawnLogic");

// Class DungeonArchitectRuntime.IsaacRoomLayoutBuilder
// 0x0000 (0x0028 - 0x0028)
class UIsaacRoomLayoutBuilder : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacRoomLayoutBuilder">();
	}
	static class UIsaacRoomLayoutBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacRoomLayoutBuilder>();
	}
};
static_assert(alignof(UIsaacRoomLayoutBuilder) == 0x000008, "Wrong alignment on UIsaacRoomLayoutBuilder");
static_assert(sizeof(UIsaacRoomLayoutBuilder) == 0x000028, "Wrong size on UIsaacRoomLayoutBuilder");

// Class DungeonArchitectRuntime.StylizedIsaacRoomLayoutBuilder
// 0x0008 (0x0030 - 0x0028)
class UStylizedIsaacRoomLayoutBuilder final : public UIsaacRoomLayoutBuilder
{
public:
	int32                                         MinBrushSize;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBrushSize;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StylizedIsaacRoomLayoutBuilder">();
	}
	static class UStylizedIsaacRoomLayoutBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStylizedIsaacRoomLayoutBuilder>();
	}
};
static_assert(alignof(UStylizedIsaacRoomLayoutBuilder) == 0x000008, "Wrong alignment on UStylizedIsaacRoomLayoutBuilder");
static_assert(sizeof(UStylizedIsaacRoomLayoutBuilder) == 0x000030, "Wrong size on UStylizedIsaacRoomLayoutBuilder");
static_assert(offsetof(UStylizedIsaacRoomLayoutBuilder, MinBrushSize) == 0x000028, "Member 'UStylizedIsaacRoomLayoutBuilder::MinBrushSize' has a wrong offset!");
static_assert(offsetof(UStylizedIsaacRoomLayoutBuilder, MaxBrushSize) == 0x00002C, "Member 'UStylizedIsaacRoomLayoutBuilder::MaxBrushSize' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonThemeAsset
// 0x0018 (0x0040 - 0x0028)
class UDungeonThemeAsset final : public UObject
{
public:
	TArray<struct FPropTypeData>                  Props;                                             // 0x0028(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDungeonEditorViewportProperties*       PreviewViewportProperties;                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonThemeAsset">();
	}
	static class UDungeonThemeAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonThemeAsset>();
	}
};
static_assert(alignof(UDungeonThemeAsset) == 0x000008, "Wrong alignment on UDungeonThemeAsset");
static_assert(sizeof(UDungeonThemeAsset) == 0x000040, "Wrong size on UDungeonThemeAsset");
static_assert(offsetof(UDungeonThemeAsset, Props) == 0x000028, "Member 'UDungeonThemeAsset::Props' has a wrong offset!");
static_assert(offsetof(UDungeonThemeAsset, PreviewViewportProperties) == 0x000038, "Member 'UDungeonThemeAsset::PreviewViewportProperties' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonThemeOverrideVolume
// 0x0018 (0x0288 - 0x0270)
class ADungeonThemeOverrideVolume final : public ADungeonVolume
{
public:
	bool                                          Reversed;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FallbackOnMissingMarkers;                          // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonThemeAsset*                     ThemeOverride;                                     // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideWeight;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonThemeOverrideVolume">();
	}
	static class ADungeonThemeOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonThemeOverrideVolume>();
	}
};
static_assert(alignof(ADungeonThemeOverrideVolume) == 0x000008, "Wrong alignment on ADungeonThemeOverrideVolume");
static_assert(sizeof(ADungeonThemeOverrideVolume) == 0x000288, "Wrong size on ADungeonThemeOverrideVolume");
static_assert(offsetof(ADungeonThemeOverrideVolume, Reversed) == 0x000270, "Member 'ADungeonThemeOverrideVolume::Reversed' has a wrong offset!");
static_assert(offsetof(ADungeonThemeOverrideVolume, FallbackOnMissingMarkers) == 0x000271, "Member 'ADungeonThemeOverrideVolume::FallbackOnMissingMarkers' has a wrong offset!");
static_assert(offsetof(ADungeonThemeOverrideVolume, ThemeOverride) == 0x000278, "Member 'ADungeonThemeOverrideVolume::ThemeOverride' has a wrong offset!");
static_assert(offsetof(ADungeonThemeOverrideVolume, OverrideWeight) == 0x000280, "Member 'ADungeonThemeOverrideVolume::OverrideWeight' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapDungeonBuilder
// 0x0030 (0x00A0 - 0x0070)
class USnapMapDungeonBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildPreviewSnapLayout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonBuilder">();
	}
	static class USnapMapDungeonBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonBuilder>();
	}
};
static_assert(alignof(USnapMapDungeonBuilder) == 0x000008, "Wrong alignment on USnapMapDungeonBuilder");
static_assert(sizeof(USnapMapDungeonBuilder) == 0x0000A0, "Wrong size on USnapMapDungeonBuilder");

// Class DungeonArchitectRuntime.DungeonToolData
// 0x0000 (0x0028 - 0x0028)
class UDungeonToolData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonToolData">();
	}
	static class UDungeonToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonToolData>();
	}
};
static_assert(alignof(UDungeonToolData) == 0x000008, "Wrong alignment on UDungeonToolData");
static_assert(sizeof(UDungeonToolData) == 0x000028, "Wrong size on UDungeonToolData");

// Class DungeonArchitectRuntime.FloorPlanBuilder
// 0x0100 (0x0170 - 0x0070)
class UFloorPlanBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x100];                                     // 0x0070(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanBuilder">();
	}
	static class UFloorPlanBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanBuilder>();
	}
};
static_assert(alignof(UFloorPlanBuilder) == 0x000008, "Wrong alignment on UFloorPlanBuilder");
static_assert(sizeof(UFloorPlanBuilder) == 0x000170, "Wrong size on UFloorPlanBuilder");

// Class DungeonArchitectRuntime.FloorPlanConfig
// 0x0030 (0x0078 - 0x0048)
class UFloorPlanConfig final : public UDungeonConfig
{
public:
	struct FVector                                BuildingSize;                                      // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GridSize;                                          // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRoomSize;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRoomSize;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HallWidth;                                         // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRoomChunkArea;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomSplitProbabilityOffset;                        // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanConfig">();
	}
	static class UFloorPlanConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanConfig>();
	}
};
static_assert(alignof(UFloorPlanConfig) == 0x000008, "Wrong alignment on UFloorPlanConfig");
static_assert(sizeof(UFloorPlanConfig) == 0x000078, "Wrong size on UFloorPlanConfig");
static_assert(offsetof(UFloorPlanConfig, BuildingSize) == 0x000048, "Member 'UFloorPlanConfig::BuildingSize' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, GridSize) == 0x000054, "Member 'UFloorPlanConfig::GridSize' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, MinRoomSize) == 0x000060, "Member 'UFloorPlanConfig::MinRoomSize' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, MaxRoomSize) == 0x000064, "Member 'UFloorPlanConfig::MaxRoomSize' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, HallWidth) == 0x000068, "Member 'UFloorPlanConfig::HallWidth' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, MinRoomChunkArea) == 0x00006C, "Member 'UFloorPlanConfig::MinRoomChunkArea' has a wrong offset!");
static_assert(offsetof(UFloorPlanConfig, RoomSplitProbabilityOffset) == 0x000070, "Member 'UFloorPlanConfig::RoomSplitProbabilityOffset' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowExecTaskExtender
// 0x0000 (0x0028 - 0x0028)
class UFlowExecTaskExtender : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowExecTaskExtender">();
	}
	static class UFlowExecTaskExtender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowExecTaskExtender>();
	}
};
static_assert(alignof(UFlowExecTaskExtender) == 0x000008, "Wrong alignment on UFlowExecTaskExtender");
static_assert(sizeof(UFlowExecTaskExtender) == 0x000028, "Wrong size on UFlowExecTaskExtender");

// Class DungeonArchitectRuntime.FlowAbstractGraphTaskExtender
// 0x0000 (0x0028 - 0x0028)
class UFlowAbstractGraphTaskExtender : public UFlowExecTaskExtender
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAbstractGraphTaskExtender">();
	}
	static class UFlowAbstractGraphTaskExtender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAbstractGraphTaskExtender>();
	}
};
static_assert(alignof(UFlowAbstractGraphTaskExtender) == 0x000008, "Wrong alignment on UFlowAbstractGraphTaskExtender");
static_assert(sizeof(UFlowAbstractGraphTaskExtender) == 0x000028, "Wrong size on UFlowAbstractGraphTaskExtender");

// Class DungeonArchitectRuntime.SnapFlowAGTaskExtender
// 0x0048 (0x0070 - 0x0028)
class USnapFlowAGTaskExtender final : public UFlowAbstractGraphTaskExtender
{
public:
	TArray<class FName>                           ModuleCategories;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ESnapFlowAGTaskModuleCategoryOverrideMethod   ModuleCategoryOverrideMethod;                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           StartNodeCategoryOverride;                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           EndNodeCategoryOverride;                           // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USnapFlowNodeCategorySelectionOverride*> CategoryOverrideLogic;                             // 0x0060(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, SimpleDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapFlowAGTaskExtender">();
	}
	static class USnapFlowAGTaskExtender* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapFlowAGTaskExtender>();
	}
};
static_assert(alignof(USnapFlowAGTaskExtender) == 0x000008, "Wrong alignment on USnapFlowAGTaskExtender");
static_assert(sizeof(USnapFlowAGTaskExtender) == 0x000070, "Wrong size on USnapFlowAGTaskExtender");
static_assert(offsetof(USnapFlowAGTaskExtender, ModuleCategories) == 0x000028, "Member 'USnapFlowAGTaskExtender::ModuleCategories' has a wrong offset!");
static_assert(offsetof(USnapFlowAGTaskExtender, ModuleCategoryOverrideMethod) == 0x000038, "Member 'USnapFlowAGTaskExtender::ModuleCategoryOverrideMethod' has a wrong offset!");
static_assert(offsetof(USnapFlowAGTaskExtender, StartNodeCategoryOverride) == 0x000040, "Member 'USnapFlowAGTaskExtender::StartNodeCategoryOverride' has a wrong offset!");
static_assert(offsetof(USnapFlowAGTaskExtender, EndNodeCategoryOverride) == 0x000050, "Member 'USnapFlowAGTaskExtender::EndNodeCategoryOverride' has a wrong offset!");
static_assert(offsetof(USnapFlowAGTaskExtender, CategoryOverrideLogic) == 0x000060, "Member 'USnapFlowAGTaskExtender::CategoryOverrideLogic' has a wrong offset!");

// Class DungeonArchitectRuntime.FloorPlanDoorVolume
// 0x0010 (0x0280 - 0x0270)
class AFloorPlanDoorVolume final : public ADungeonVolume
{
public:
	class FString                                 DoorMarker;                                        // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanDoorVolume">();
	}
	static class AFloorPlanDoorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorPlanDoorVolume>();
	}
};
static_assert(alignof(AFloorPlanDoorVolume) == 0x000008, "Wrong alignment on AFloorPlanDoorVolume");
static_assert(sizeof(AFloorPlanDoorVolume) == 0x000280, "Wrong size on AFloorPlanDoorVolume");
static_assert(offsetof(AFloorPlanDoorVolume, DoorMarker) == 0x000270, "Member 'AFloorPlanDoorVolume::DoorMarker' has a wrong offset!");

// Class DungeonArchitectRuntime.FloorPlanModel
// 0x0000 (0x0028 - 0x0028)
class UFloorPlanModel final : public UDungeonModel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanModel">();
	}
	static class UFloorPlanModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanModel>();
	}
};
static_assert(alignof(UFloorPlanModel) == 0x000008, "Wrong alignment on UFloorPlanModel");
static_assert(sizeof(UFloorPlanModel) == 0x000028, "Wrong size on UFloorPlanModel");

// Class DungeonArchitectRuntime.FloorPlanQuery
// 0x0000 (0x0060 - 0x0060)
class UFloorPlanQuery final : public UDungeonQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanQuery">();
	}
	static class UFloorPlanQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanQuery>();
	}
};
static_assert(alignof(UFloorPlanQuery) == 0x000010, "Wrong alignment on UFloorPlanQuery");
static_assert(sizeof(UFloorPlanQuery) == 0x000060, "Wrong size on UFloorPlanQuery");

// Class DungeonArchitectRuntime.FloorPlanRoomVolume
// 0x0068 (0x02D8 - 0x0270)
class AFloorPlanRoomVolume final : public ADungeonVolume
{
public:
	bool                                          bCreateWalls;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConnectDoors;                                     // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x2];                                      // 0x0272(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WallMarker;                                        // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroundMarker;                                      // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CeilingMarker;                                     // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DoorMarker;                                        // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CenterMarker;                                      // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PerFloorCenterMarker;                              // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanRoomVolume">();
	}
	static class AFloorPlanRoomVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorPlanRoomVolume>();
	}
};
static_assert(alignof(AFloorPlanRoomVolume) == 0x000008, "Wrong alignment on AFloorPlanRoomVolume");
static_assert(sizeof(AFloorPlanRoomVolume) == 0x0002D8, "Wrong size on AFloorPlanRoomVolume");
static_assert(offsetof(AFloorPlanRoomVolume, bCreateWalls) == 0x000270, "Member 'AFloorPlanRoomVolume::bCreateWalls' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, bConnectDoors) == 0x000271, "Member 'AFloorPlanRoomVolume::bConnectDoors' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, Priority) == 0x000274, "Member 'AFloorPlanRoomVolume::Priority' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, WallMarker) == 0x000278, "Member 'AFloorPlanRoomVolume::WallMarker' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, GroundMarker) == 0x000288, "Member 'AFloorPlanRoomVolume::GroundMarker' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, CeilingMarker) == 0x000298, "Member 'AFloorPlanRoomVolume::CeilingMarker' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, DoorMarker) == 0x0002A8, "Member 'AFloorPlanRoomVolume::DoorMarker' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, CenterMarker) == 0x0002B8, "Member 'AFloorPlanRoomVolume::CenterMarker' has a wrong offset!");
static_assert(offsetof(AFloorPlanRoomVolume, PerFloorCenterMarker) == 0x0002C8, "Member 'AFloorPlanRoomVolume::PerFloorCenterMarker' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapModuleDatabase
// 0x0010 (0x0040 - 0x0030)
class USnapMapModuleDatabase final : public UDataAsset
{
public:
	TArray<struct FSnapMapModuleDatabaseItem>     Modules;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapModuleDatabase">();
	}
	static class USnapMapModuleDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapModuleDatabase>();
	}
};
static_assert(alignof(USnapMapModuleDatabase) == 0x000008, "Wrong alignment on USnapMapModuleDatabase");
static_assert(sizeof(USnapMapModuleDatabase) == 0x000040, "Wrong size on USnapMapModuleDatabase");
static_assert(offsetof(USnapMapModuleDatabase, Modules) == 0x000030, "Member 'USnapMapModuleDatabase::Modules' has a wrong offset!");

// Class DungeonArchitectRuntime.FloorPlanSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class UFloorPlanSelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool SelectNode(class UFloorPlanModel* Model, class UFloorPlanConfig* Config, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, int32 GridZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanSelectorLogic">();
	}
	static class UFloorPlanSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanSelectorLogic>();
	}
};
static_assert(alignof(UFloorPlanSelectorLogic) == 0x000008, "Wrong alignment on UFloorPlanSelectorLogic");
static_assert(sizeof(UFloorPlanSelectorLogic) == 0x000028, "Wrong size on UFloorPlanSelectorLogic");

// Class DungeonArchitectRuntime.FloorPlanToolData
// 0x0000 (0x0028 - 0x0028)
class UFloorPlanToolData final : public UDungeonToolData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanToolData">();
	}
	static class UFloorPlanToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanToolData>();
	}
};
static_assert(alignof(UFloorPlanToolData) == 0x000008, "Wrong alignment on UFloorPlanToolData");
static_assert(sizeof(UFloorPlanToolData) == 0x000028, "Wrong size on UFloorPlanToolData");

// Class DungeonArchitectRuntime.FloorPlanTransformLogic
// 0x0000 (0x0028 - 0x0028)
class UFloorPlanTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class UFloorPlanModel* Model, class UFloorPlanConfig* Config, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorPlanTransformLogic">();
	}
	static class UFloorPlanTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloorPlanTransformLogic>();
	}
};
static_assert(alignof(UFloorPlanTransformLogic) == 0x000008, "Wrong alignment on UFloorPlanTransformLogic");
static_assert(sizeof(UFloorPlanTransformLogic) == 0x000028, "Wrong size on UFloorPlanTransformLogic");

// Class DungeonArchitectRuntime.FlowAbstractGraphBase
// 0x0020 (0x0048 - 0x0028)
class UFlowAbstractGraphBase : public UObject
{
public:
	TArray<class UFlowAbstractNode*>              GraphNodes;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFlowAbstractLink*>              GraphLinks;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAbstractGraphBase">();
	}
	static class UFlowAbstractGraphBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAbstractGraphBase>();
	}
};
static_assert(alignof(UFlowAbstractGraphBase) == 0x000008, "Wrong alignment on UFlowAbstractGraphBase");
static_assert(sizeof(UFlowAbstractGraphBase) == 0x000048, "Wrong size on UFlowAbstractGraphBase");
static_assert(offsetof(UFlowAbstractGraphBase, GraphNodes) == 0x000028, "Member 'UFlowAbstractGraphBase::GraphNodes' has a wrong offset!");
static_assert(offsetof(UFlowAbstractGraphBase, GraphLinks) == 0x000038, "Member 'UFlowAbstractGraphBase::GraphLinks' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapGridFlowModuleBoundsComponent
// 0x0030 (0x0490 - 0x0460)
class USnapGridFlowModuleBoundsComponent final : public UPrimitiveComponent
{
public:
	struct FIntVector                             NumChunks;                                         // 0x0458(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderBounds;                                     // 0x0464(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USnapGridFlowModuleBoundsAsset> ModuleBounds;                                      // 0x0468(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowModuleBoundsComponent">();
	}
	static class USnapGridFlowModuleBoundsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowModuleBoundsComponent>();
	}
};
static_assert(alignof(USnapGridFlowModuleBoundsComponent) == 0x000010, "Wrong alignment on USnapGridFlowModuleBoundsComponent");
static_assert(sizeof(USnapGridFlowModuleBoundsComponent) == 0x000490, "Wrong size on USnapGridFlowModuleBoundsComponent");
static_assert(offsetof(USnapGridFlowModuleBoundsComponent, NumChunks) == 0x000458, "Member 'USnapGridFlowModuleBoundsComponent::NumChunks' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleBoundsComponent, bRenderBounds) == 0x000464, "Member 'USnapGridFlowModuleBoundsComponent::bRenderBounds' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleBoundsComponent, ModuleBounds) == 0x000468, "Member 'USnapGridFlowModuleBoundsComponent::ModuleBounds' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowLayoutNodeCreationConstraint
// 0x0000 (0x0028 - 0x0028)
class UFlowLayoutNodeCreationConstraint : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLayoutNodeCreationConstraint">();
	}
	static class UFlowLayoutNodeCreationConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLayoutNodeCreationConstraint>();
	}
};
static_assert(alignof(UFlowLayoutNodeCreationConstraint) == 0x000008, "Wrong alignment on UFlowLayoutNodeCreationConstraint");
static_assert(sizeof(UFlowLayoutNodeCreationConstraint) == 0x000028, "Wrong size on UFlowLayoutNodeCreationConstraint");

// Class DungeonArchitectRuntime.FlowGraphItem
// 0x0078 (0x00A0 - 0x0028)
class UFlowGraphItem final : public UObject
{
public:
	struct FGuid                                  ItemId;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlowGraphItemType                            ItemType;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerName;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          ReferencedItemIds;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bEditorSelected;                                   // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowItemCustomInfo                CustomInfo;                                        // 0x0068(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowGraphItem">();
	}
	static class UFlowGraphItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowGraphItem>();
	}
};
static_assert(alignof(UFlowGraphItem) == 0x000008, "Wrong alignment on UFlowGraphItem");
static_assert(sizeof(UFlowGraphItem) == 0x0000A0, "Wrong size on UFlowGraphItem");
static_assert(offsetof(UFlowGraphItem, ItemId) == 0x000028, "Member 'UFlowGraphItem::ItemId' has a wrong offset!");
static_assert(offsetof(UFlowGraphItem, ItemType) == 0x000038, "Member 'UFlowGraphItem::ItemType' has a wrong offset!");
static_assert(offsetof(UFlowGraphItem, MarkerName) == 0x000040, "Member 'UFlowGraphItem::MarkerName' has a wrong offset!");
static_assert(offsetof(UFlowGraphItem, ReferencedItemIds) == 0x000050, "Member 'UFlowGraphItem::ReferencedItemIds' has a wrong offset!");
static_assert(offsetof(UFlowGraphItem, bEditorSelected) == 0x000060, "Member 'UFlowGraphItem::bEditorSelected' has a wrong offset!");
static_assert(offsetof(UFlowGraphItem, CustomInfo) == 0x000068, "Member 'UFlowGraphItem::CustomInfo' has a wrong offset!");

// Class DungeonArchitectRuntime.DungeonFlowItemMetadataComponent
// 0x0018 (0x00C8 - 0x00B0)
class UDungeonFlowItemMetadataComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class UFlowGraphItem>          FlowItem;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlowItemUpdated;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonFlowItemMetadataComponent">();
	}
	static class UDungeonFlowItemMetadataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonFlowItemMetadataComponent>();
	}
};
static_assert(alignof(UDungeonFlowItemMetadataComponent) == 0x000008, "Wrong alignment on UDungeonFlowItemMetadataComponent");
static_assert(sizeof(UDungeonFlowItemMetadataComponent) == 0x0000C8, "Wrong size on UDungeonFlowItemMetadataComponent");
static_assert(offsetof(UDungeonFlowItemMetadataComponent, FlowItem) == 0x0000B0, "Member 'UDungeonFlowItemMetadataComponent::FlowItem' has a wrong offset!");
static_assert(offsetof(UDungeonFlowItemMetadataComponent, OnFlowItemUpdated) == 0x0000B8, "Member 'UDungeonFlowItemMetadataComponent::OnFlowItemUpdated' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowAbstractLink
// 0x0068 (0x0090 - 0x0028)
class UFlowAbstractLink final : public UObject
{
public:
	struct FGuid                                  LinkID;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Source;                                            // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Destination;                                       // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlowAbstractLinkType                         Type;                                              // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFlowGraphItem*>                 LinkItems;                                         // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  SourceSubNode;                                     // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  DestinationSubNode;                                // 0x0080(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAbstractLink">();
	}
	static class UFlowAbstractLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAbstractLink>();
	}
};
static_assert(alignof(UFlowAbstractLink) == 0x000008, "Wrong alignment on UFlowAbstractLink");
static_assert(sizeof(UFlowAbstractLink) == 0x000090, "Wrong size on UFlowAbstractLink");
static_assert(offsetof(UFlowAbstractLink, LinkID) == 0x000028, "Member 'UFlowAbstractLink::LinkID' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, Source) == 0x000038, "Member 'UFlowAbstractLink::Source' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, Destination) == 0x000048, "Member 'UFlowAbstractLink::Destination' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, Type) == 0x000058, "Member 'UFlowAbstractLink::Type' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, LinkItems) == 0x000060, "Member 'UFlowAbstractLink::LinkItems' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, SourceSubNode) == 0x000070, "Member 'UFlowAbstractLink::SourceSubNode' has a wrong offset!");
static_assert(offsetof(UFlowAbstractLink, DestinationSubNode) == 0x000080, "Member 'UFlowAbstractLink::DestinationSubNode' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowAbstractNode
// 0x0088 (0x00B0 - 0x0028)
class UFlowAbstractNode final : public UObject
{
public:
	struct FGuid                                  NodeId;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x003C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Coord;                                             // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathName;                                          // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFlowGraphItem*>                 NodeItems;                                         // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                PreviewLocation;                                   // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFlowAbstractNode*>              MergedCompositeNodes;                              // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        CrossDomainNodeData;                               // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PathIndex;                                         // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathLength;                                        // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ContainsItem(EFlowGraphItemType ItemType, int32* Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAbstractNode">();
	}
	static class UFlowAbstractNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAbstractNode>();
	}
};
static_assert(alignof(UFlowAbstractNode) == 0x000008, "Wrong alignment on UFlowAbstractNode");
static_assert(sizeof(UFlowAbstractNode) == 0x0000B0, "Wrong size on UFlowAbstractNode");
static_assert(offsetof(UFlowAbstractNode, NodeId) == 0x000028, "Member 'UFlowAbstractNode::NodeId' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, bActive) == 0x000038, "Member 'UFlowAbstractNode::bActive' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, Color) == 0x00003C, "Member 'UFlowAbstractNode::Color' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, Coord) == 0x00004C, "Member 'UFlowAbstractNode::Coord' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, PathName) == 0x000058, "Member 'UFlowAbstractNode::PathName' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, NodeItems) == 0x000068, "Member 'UFlowAbstractNode::NodeItems' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, PreviewLocation) == 0x000078, "Member 'UFlowAbstractNode::PreviewLocation' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, MergedCompositeNodes) == 0x000088, "Member 'UFlowAbstractNode::MergedCompositeNodes' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, CrossDomainNodeData) == 0x000098, "Member 'UFlowAbstractNode::CrossDomainNodeData' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, PathIndex) == 0x0000A8, "Member 'UFlowAbstractNode::PathIndex' has a wrong offset!");
static_assert(offsetof(UFlowAbstractNode, PathLength) == 0x0000AC, "Member 'UFlowAbstractNode::PathLength' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowAssetBase
// 0x0008 (0x0030 - 0x0028)
class UFlowAssetBase : public UObject
{
public:
	class UGridFlowExecScript*                    ExecScript;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAssetBase">();
	}
	static class UFlowAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAssetBase>();
	}
};
static_assert(alignof(UFlowAssetBase) == 0x000008, "Wrong alignment on UFlowAssetBase");
static_assert(sizeof(UFlowAssetBase) == 0x000030, "Wrong size on UFlowAssetBase");
static_assert(offsetof(UFlowAssetBase, ExecScript) == 0x000028, "Member 'UFlowAssetBase::ExecScript' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowExecScriptGraphNode
// 0x0030 (0x0058 - 0x0028)
class UGridFlowExecScriptGraphNode : public UObject
{
public:
	struct FGuid                                  NodeId;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGridFlowExecScriptGraphNode*>   OutgoingNodes;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGridFlowExecScriptGraphNode*>   IncomingNodes;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowExecScriptGraphNode">();
	}
	static class UGridFlowExecScriptGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowExecScriptGraphNode>();
	}
};
static_assert(alignof(UGridFlowExecScriptGraphNode) == 0x000008, "Wrong alignment on UGridFlowExecScriptGraphNode");
static_assert(sizeof(UGridFlowExecScriptGraphNode) == 0x000058, "Wrong size on UGridFlowExecScriptGraphNode");
static_assert(offsetof(UGridFlowExecScriptGraphNode, NodeId) == 0x000028, "Member 'UGridFlowExecScriptGraphNode::NodeId' has a wrong offset!");
static_assert(offsetof(UGridFlowExecScriptGraphNode, OutgoingNodes) == 0x000038, "Member 'UGridFlowExecScriptGraphNode::OutgoingNodes' has a wrong offset!");
static_assert(offsetof(UGridFlowExecScriptGraphNode, IncomingNodes) == 0x000048, "Member 'UGridFlowExecScriptGraphNode::IncomingNodes' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowExecScriptTaskNode
// 0x0008 (0x0060 - 0x0058)
class UGridFlowExecScriptTaskNode final : public UGridFlowExecScriptGraphNode
{
public:
	class UFlowExecTask*                          Task;                                              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowExecScriptTaskNode">();
	}
	static class UGridFlowExecScriptTaskNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowExecScriptTaskNode>();
	}
};
static_assert(alignof(UGridFlowExecScriptTaskNode) == 0x000008, "Wrong alignment on UGridFlowExecScriptTaskNode");
static_assert(sizeof(UGridFlowExecScriptTaskNode) == 0x000060, "Wrong size on UGridFlowExecScriptTaskNode");
static_assert(offsetof(UGridFlowExecScriptTaskNode, Task) == 0x000058, "Member 'UGridFlowExecScriptTaskNode::Task' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapDungeonSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class USnapMapDungeonSelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool SelectNode(class USnapMapDungeonModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonSelectorLogic">();
	}
	static class USnapMapDungeonSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonSelectorLogic>();
	}
};
static_assert(alignof(USnapMapDungeonSelectorLogic) == 0x000008, "Wrong alignment on USnapMapDungeonSelectorLogic");
static_assert(sizeof(USnapMapDungeonSelectorLogic) == 0x000028, "Wrong size on USnapMapDungeonSelectorLogic");

// Class DungeonArchitectRuntime.GridFlowExecScriptResultNode
// 0x0000 (0x0058 - 0x0058)
class UGridFlowExecScriptResultNode final : public UGridFlowExecScriptGraphNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowExecScriptResultNode">();
	}
	static class UGridFlowExecScriptResultNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowExecScriptResultNode>();
	}
};
static_assert(alignof(UGridFlowExecScriptResultNode) == 0x000008, "Wrong alignment on UGridFlowExecScriptResultNode");
static_assert(sizeof(UGridFlowExecScriptResultNode) == 0x000058, "Wrong size on UGridFlowExecScriptResultNode");

// Class DungeonArchitectRuntime.GridFlowExecScriptGraph
// 0x0010 (0x0038 - 0x0028)
class UGridFlowExecScriptGraph final : public UObject
{
public:
	TArray<class UGridFlowExecScriptGraphNode*>   Nodes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowExecScriptGraph">();
	}
	static class UGridFlowExecScriptGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowExecScriptGraph>();
	}
};
static_assert(alignof(UGridFlowExecScriptGraph) == 0x000008, "Wrong alignment on UGridFlowExecScriptGraph");
static_assert(sizeof(UGridFlowExecScriptGraph) == 0x000038, "Wrong size on UGridFlowExecScriptGraph");
static_assert(offsetof(UGridFlowExecScriptGraph, Nodes) == 0x000028, "Member 'UGridFlowExecScriptGraph::Nodes' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowExecScript
// 0x0010 (0x0038 - 0x0028)
class UGridFlowExecScript final : public UObject
{
public:
	class UGridFlowExecScriptGraph*               ScriptGraph;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowExecScriptResultNode*          ResultNode;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowExecScript">();
	}
	static class UGridFlowExecScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowExecScript>();
	}
};
static_assert(alignof(UGridFlowExecScript) == 0x000008, "Wrong alignment on UGridFlowExecScript");
static_assert(sizeof(UGridFlowExecScript) == 0x000038, "Wrong size on UGridFlowExecScript");
static_assert(offsetof(UGridFlowExecScript, ScriptGraph) == 0x000028, "Member 'UGridFlowExecScript::ScriptGraph' has a wrong offset!");
static_assert(offsetof(UGridFlowExecScript, ResultNode) == 0x000030, "Member 'UGridFlowExecScript::ResultNode' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowExecCloneableState
// 0x0000 (0x0028 - 0x0028)
class IFlowExecCloneableState final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowExecCloneableState">();
	}
	static class IFlowExecCloneableState* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlowExecCloneableState>();
	}
};
static_assert(alignof(IFlowExecCloneableState) == 0x000008, "Wrong alignment on IFlowExecCloneableState");
static_assert(sizeof(IFlowExecCloneableState) == 0x000028, "Wrong size on IFlowExecCloneableState");

// Class DungeonArchitectRuntime.FlowTaskAbstract_CreatePath
// 0x0090 (0x00E8 - 0x0058)
class UFlowTaskAbstract_CreatePath : public UFlowTaskAbstract_PathBuilderBase
{
public:
	int32                                         MinPathSize;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPathSize;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PathName;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           NodeColor;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StartFromPath;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EndOnPath;                                         // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnterThroughTeleporter;                           // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TeleporterMarkerName;                              // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StartNodePathNameOverride;                         // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EndNodePathNameOverride;                           // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumParallelSearches;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxFramesToProcess;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_CreatePath">();
	}
	static class UFlowTaskAbstract_CreatePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_CreatePath>();
	}
};
static_assert(alignof(UFlowTaskAbstract_CreatePath) == 0x000008, "Wrong alignment on UFlowTaskAbstract_CreatePath");
static_assert(sizeof(UFlowTaskAbstract_CreatePath) == 0x0000E8, "Wrong size on UFlowTaskAbstract_CreatePath");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, MinPathSize) == 0x000058, "Member 'UFlowTaskAbstract_CreatePath::MinPathSize' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, MaxPathSize) == 0x00005C, "Member 'UFlowTaskAbstract_CreatePath::MaxPathSize' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, PathName) == 0x000060, "Member 'UFlowTaskAbstract_CreatePath::PathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, NodeColor) == 0x000070, "Member 'UFlowTaskAbstract_CreatePath::NodeColor' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, StartFromPath) == 0x000080, "Member 'UFlowTaskAbstract_CreatePath::StartFromPath' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, EndOnPath) == 0x000090, "Member 'UFlowTaskAbstract_CreatePath::EndOnPath' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, bEnterThroughTeleporter) == 0x0000A0, "Member 'UFlowTaskAbstract_CreatePath::bEnterThroughTeleporter' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, TeleporterMarkerName) == 0x0000A8, "Member 'UFlowTaskAbstract_CreatePath::TeleporterMarkerName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, StartNodePathNameOverride) == 0x0000B8, "Member 'UFlowTaskAbstract_CreatePath::StartNodePathNameOverride' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, EndNodePathNameOverride) == 0x0000C8, "Member 'UFlowTaskAbstract_CreatePath::EndNodePathNameOverride' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, NumParallelSearches) == 0x0000D8, "Member 'UFlowTaskAbstract_CreatePath::NumParallelSearches' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreatePath, MaxFramesToProcess) == 0x0000E0, "Member 'UFlowTaskAbstract_CreatePath::MaxFramesToProcess' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstract_CreateTeleporter
// 0x0030 (0x0088 - 0x0058)
class UFlowTaskAbstract_CreateTeleporter final : public UFlowTaskAbstractBase
{
public:
	class FString                                 FirstPathName;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecondPathName;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeleporterMarkerName;                              // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_CreateTeleporter">();
	}
	static class UFlowTaskAbstract_CreateTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_CreateTeleporter>();
	}
};
static_assert(alignof(UFlowTaskAbstract_CreateTeleporter) == 0x000008, "Wrong alignment on UFlowTaskAbstract_CreateTeleporter");
static_assert(sizeof(UFlowTaskAbstract_CreateTeleporter) == 0x000088, "Wrong size on UFlowTaskAbstract_CreateTeleporter");
static_assert(offsetof(UFlowTaskAbstract_CreateTeleporter, FirstPathName) == 0x000058, "Member 'UFlowTaskAbstract_CreateTeleporter::FirstPathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateTeleporter, SecondPathName) == 0x000068, "Member 'UFlowTaskAbstract_CreateTeleporter::SecondPathName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_CreateTeleporter, TeleporterMarkerName) == 0x000078, "Member 'UFlowTaskAbstract_CreateTeleporter::TeleporterMarkerName' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstract_Finalize
// 0x0008 (0x0060 - 0x0058)
class UFlowTaskAbstract_Finalize : public UFlowTaskAbstractBase
{
public:
	float                                         OneWayDoorPromotionWeight;                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugData;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_Finalize">();
	}
	static class UFlowTaskAbstract_Finalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_Finalize>();
	}
};
static_assert(alignof(UFlowTaskAbstract_Finalize) == 0x000008, "Wrong alignment on UFlowTaskAbstract_Finalize");
static_assert(sizeof(UFlowTaskAbstract_Finalize) == 0x000060, "Wrong size on UFlowTaskAbstract_Finalize");
static_assert(offsetof(UFlowTaskAbstract_Finalize, OneWayDoorPromotionWeight) == 0x000058, "Member 'UFlowTaskAbstract_Finalize::OneWayDoorPromotionWeight' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_Finalize, bShowDebugData) == 0x00005C, "Member 'UFlowTaskAbstract_Finalize::bShowDebugData' has a wrong offset!");

// Class DungeonArchitectRuntime.FlowTaskAbstract_SpawnItems
// 0x0090 (0x00E8 - 0x0058)
class UFlowTaskAbstract_SpawnItems : public UFlowTaskAbstractBase
{
public:
	TArray<class FString>                         Paths;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EFlowGraphItemType                            ItemType;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerName;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGridFlowItemCustomInfo                CustomItemInfo;                                    // 0x0080(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EridFlowTask_SpawnItemsMethod                 SpawnMethod;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDistributionVariance;                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpawnDifficulty;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbability;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugShowDifficulty;                              // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DifficultyInfoColor;                               // 0x00D4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTaskAbstract_SpawnItems">();
	}
	static class UFlowTaskAbstract_SpawnItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTaskAbstract_SpawnItems>();
	}
};
static_assert(alignof(UFlowTaskAbstract_SpawnItems) == 0x000008, "Wrong alignment on UFlowTaskAbstract_SpawnItems");
static_assert(sizeof(UFlowTaskAbstract_SpawnItems) == 0x0000E8, "Wrong size on UFlowTaskAbstract_SpawnItems");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, Paths) == 0x000058, "Member 'UFlowTaskAbstract_SpawnItems::Paths' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, ItemType) == 0x000068, "Member 'UFlowTaskAbstract_SpawnItems::ItemType' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, MarkerName) == 0x000070, "Member 'UFlowTaskAbstract_SpawnItems::MarkerName' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, CustomItemInfo) == 0x000080, "Member 'UFlowTaskAbstract_SpawnItems::CustomItemInfo' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, MinCount) == 0x0000B8, "Member 'UFlowTaskAbstract_SpawnItems::MinCount' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, MaxCount) == 0x0000BC, "Member 'UFlowTaskAbstract_SpawnItems::MaxCount' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, SpawnMethod) == 0x0000C0, "Member 'UFlowTaskAbstract_SpawnItems::SpawnMethod' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, SpawnDistributionVariance) == 0x0000C4, "Member 'UFlowTaskAbstract_SpawnItems::SpawnDistributionVariance' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, MinSpawnDifficulty) == 0x0000C8, "Member 'UFlowTaskAbstract_SpawnItems::MinSpawnDifficulty' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, SpawnProbability) == 0x0000CC, "Member 'UFlowTaskAbstract_SpawnItems::SpawnProbability' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, bDebugShowDifficulty) == 0x0000D0, "Member 'UFlowTaskAbstract_SpawnItems::bDebugShowDifficulty' has a wrong offset!");
static_assert(offsetof(UFlowTaskAbstract_SpawnItems, DifficultyInfoColor) == 0x0000D4, "Member 'UFlowTaskAbstract_SpawnItems::DifficultyInfoColor' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarScriptGraphNode
// 0x0030 (0x0058 - 0x0028)
class UGrammarScriptGraphNode : public UObject
{
public:
	struct FGuid                                  NodeId;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGrammarScriptGraphNode*>        OutgoingNodes;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGrammarScriptGraphNode*>        IncomingNodes;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarScriptGraphNode">();
	}
	static class UGrammarScriptGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarScriptGraphNode>();
	}
};
static_assert(alignof(UGrammarScriptGraphNode) == 0x000008, "Wrong alignment on UGrammarScriptGraphNode");
static_assert(sizeof(UGrammarScriptGraphNode) == 0x000058, "Wrong size on UGrammarScriptGraphNode");
static_assert(offsetof(UGrammarScriptGraphNode, NodeId) == 0x000028, "Member 'UGrammarScriptGraphNode::NodeId' has a wrong offset!");
static_assert(offsetof(UGrammarScriptGraphNode, OutgoingNodes) == 0x000038, "Member 'UGrammarScriptGraphNode::OutgoingNodes' has a wrong offset!");
static_assert(offsetof(UGrammarScriptGraphNode, IncomingNodes) == 0x000048, "Member 'UGrammarScriptGraphNode::IncomingNodes' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarExecutionScriptEntryNode
// 0x0000 (0x0058 - 0x0058)
class UGrammarExecutionScriptEntryNode final : public UGrammarScriptGraphNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarExecutionScriptEntryNode">();
	}
	static class UGrammarExecutionScriptEntryNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarExecutionScriptEntryNode>();
	}
};
static_assert(alignof(UGrammarExecutionScriptEntryNode) == 0x000008, "Wrong alignment on UGrammarExecutionScriptEntryNode");
static_assert(sizeof(UGrammarExecutionScriptEntryNode) == 0x000058, "Wrong size on UGrammarExecutionScriptEntryNode");

// Class DungeonArchitectRuntime.GrammarExecutionScriptRuleNode
// 0x0020 (0x0078 - 0x0058)
class UGrammarExecutionScriptRuleNode final : public UGrammarScriptGraphNode
{
public:
	TWeakObjectPtr<class UGraphGrammarProduction> Rule;                                              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERuleNodeExecutionMode                        ExecutionMode;                                     // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuleNodeExecutionModeConfig           ExecutionConfig;                                   // 0x0064(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarExecutionScriptRuleNode">();
	}
	static class UGrammarExecutionScriptRuleNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarExecutionScriptRuleNode>();
	}
};
static_assert(alignof(UGrammarExecutionScriptRuleNode) == 0x000008, "Wrong alignment on UGrammarExecutionScriptRuleNode");
static_assert(sizeof(UGrammarExecutionScriptRuleNode) == 0x000078, "Wrong size on UGrammarExecutionScriptRuleNode");
static_assert(offsetof(UGrammarExecutionScriptRuleNode, Rule) == 0x000058, "Member 'UGrammarExecutionScriptRuleNode::Rule' has a wrong offset!");
static_assert(offsetof(UGrammarExecutionScriptRuleNode, ExecutionMode) == 0x000060, "Member 'UGrammarExecutionScriptRuleNode::ExecutionMode' has a wrong offset!");
static_assert(offsetof(UGrammarExecutionScriptRuleNode, ExecutionConfig) == 0x000064, "Member 'UGrammarExecutionScriptRuleNode::ExecutionConfig' has a wrong offset!");

// Class DungeonArchitectRuntime.FANodeSnapDomainData
// 0x0010 (0x0038 - 0x0028)
class UFANodeSnapDomainData final : public UObject
{
public:
	TArray<class FName>                           ModuleCategories;                                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FANodeSnapDomainData">();
	}
	static class UFANodeSnapDomainData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFANodeSnapDomainData>();
	}
};
static_assert(alignof(UFANodeSnapDomainData) == 0x000008, "Wrong alignment on UFANodeSnapDomainData");
static_assert(sizeof(UFANodeSnapDomainData) == 0x000038, "Wrong size on UFANodeSnapDomainData");
static_assert(offsetof(UFANodeSnapDomainData, ModuleCategories) == 0x000028, "Member 'UFANodeSnapDomainData::ModuleCategories' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarExecutionScript
// 0x0010 (0x0038 - 0x0028)
class UGrammarExecutionScript final : public UObject
{
public:
	class UGrammarScriptGraph*                    ScriptGraph;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGrammarExecutionScriptEntryNode*       EntryNode;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarExecutionScript">();
	}
	static class UGrammarExecutionScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarExecutionScript>();
	}
};
static_assert(alignof(UGrammarExecutionScript) == 0x000008, "Wrong alignment on UGrammarExecutionScript");
static_assert(sizeof(UGrammarExecutionScript) == 0x000038, "Wrong size on UGrammarExecutionScript");
static_assert(offsetof(UGrammarExecutionScript, ScriptGraph) == 0x000028, "Member 'UGrammarExecutionScript::ScriptGraph' has a wrong offset!");
static_assert(offsetof(UGrammarExecutionScript, EntryNode) == 0x000030, "Member 'UGrammarExecutionScript::EntryNode' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarRuleScriptGraphNode
// 0x0010 (0x0068 - 0x0058)
class UGrammarRuleScriptGraphNode final : public UGrammarScriptGraphNode
{
public:
	TWeakObjectPtr<class UGrammarNodeType>        TypeInfo;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayIndex;                                     // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarRuleScriptGraphNode">();
	}
	static class UGrammarRuleScriptGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarRuleScriptGraphNode>();
	}
};
static_assert(alignof(UGrammarRuleScriptGraphNode) == 0x000008, "Wrong alignment on UGrammarRuleScriptGraphNode");
static_assert(sizeof(UGrammarRuleScriptGraphNode) == 0x000068, "Wrong size on UGrammarRuleScriptGraphNode");
static_assert(offsetof(UGrammarRuleScriptGraphNode, TypeInfo) == 0x000058, "Member 'UGrammarRuleScriptGraphNode::TypeInfo' has a wrong offset!");
static_assert(offsetof(UGrammarRuleScriptGraphNode, Index_0) == 0x000060, "Member 'UGrammarRuleScriptGraphNode::Index_0' has a wrong offset!");
static_assert(offsetof(UGrammarRuleScriptGraphNode, bDisplayIndex) == 0x000064, "Member 'UGrammarRuleScriptGraphNode::bDisplayIndex' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarRuleScript
// 0x0010 (0x0038 - 0x0028)
class UGrammarRuleScript final : public UObject
{
public:
	float                                         Weight;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGrammarScriptGraph*                    ScriptGraph;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarRuleScript">();
	}
	static class UGrammarRuleScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarRuleScript>();
	}
};
static_assert(alignof(UGrammarRuleScript) == 0x000008, "Wrong alignment on UGrammarRuleScript");
static_assert(sizeof(UGrammarRuleScript) == 0x000038, "Wrong size on UGrammarRuleScript");
static_assert(offsetof(UGrammarRuleScript, Weight) == 0x000028, "Member 'UGrammarRuleScript::Weight' has a wrong offset!");
static_assert(offsetof(UGrammarRuleScript, ScriptGraph) == 0x000030, "Member 'UGrammarRuleScript::ScriptGraph' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarScriptGraph
// 0x0010 (0x0038 - 0x0028)
class UGrammarScriptGraph final : public UObject
{
public:
	TArray<class UGrammarScriptGraphNode*>        Nodes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarScriptGraph">();
	}
	static class UGrammarScriptGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarScriptGraph>();
	}
};
static_assert(alignof(UGrammarScriptGraph) == 0x000008, "Wrong alignment on UGrammarScriptGraph");
static_assert(sizeof(UGrammarScriptGraph) == 0x000038, "Wrong size on UGrammarScriptGraph");
static_assert(offsetof(UGrammarScriptGraph, Nodes) == 0x000028, "Member 'UGrammarScriptGraph::Nodes' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapGridFlowConfig
// 0x00D8 (0x0120 - 0x0048)
class USnapGridFlowConfig final : public UDungeonConfig
{
public:
	TSoftObjectPtr<class USnapGridFlowModuleDatabase> ModuleDatabase;                                    // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USnapGridFlowAsset>      FlowGraph;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDungeonThemeAsset>      ItemTheme;                                         // 0x0098(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLayoutBuildRetries;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreferModulesWithMinimumDoors;                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ParameterOverrides;                                // 0x00C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         NumTimeoutsRetriesAllowed;                         // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowConfig">();
	}
	static class USnapGridFlowConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowConfig>();
	}
};
static_assert(alignof(USnapGridFlowConfig) == 0x000008, "Wrong alignment on USnapGridFlowConfig");
static_assert(sizeof(USnapGridFlowConfig) == 0x000120, "Wrong size on USnapGridFlowConfig");
static_assert(offsetof(USnapGridFlowConfig, ModuleDatabase) == 0x000048, "Member 'USnapGridFlowConfig::ModuleDatabase' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, FlowGraph) == 0x000070, "Member 'USnapGridFlowConfig::FlowGraph' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, ItemTheme) == 0x000098, "Member 'USnapGridFlowConfig::ItemTheme' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, NumLayoutBuildRetries) == 0x0000C0, "Member 'USnapGridFlowConfig::NumLayoutBuildRetries' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, PreferModulesWithMinimumDoors) == 0x0000C4, "Member 'USnapGridFlowConfig::PreferModulesWithMinimumDoors' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, ParameterOverrides) == 0x0000C8, "Member 'USnapGridFlowConfig::ParameterOverrides' has a wrong offset!");
static_assert(offsetof(USnapGridFlowConfig, NumTimeoutsRetriesAllowed) == 0x000118, "Member 'USnapGridFlowConfig::NumTimeoutsRetriesAllowed' has a wrong offset!");

// Class DungeonArchitectRuntime.GraphGrammarProduction
// 0x0030 (0x0058 - 0x0028)
class UGraphGrammarProduction final : public UObject
{
public:
	class FText                                   RuleName;                                          // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGrammarRuleScript*                     SourceGraph;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGrammarRuleScript*>             DestGraphs;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphGrammarProduction">();
	}
	static class UGraphGrammarProduction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphGrammarProduction>();
	}
};
static_assert(alignof(UGraphGrammarProduction) == 0x000008, "Wrong alignment on UGraphGrammarProduction");
static_assert(sizeof(UGraphGrammarProduction) == 0x000058, "Wrong size on UGraphGrammarProduction");
static_assert(offsetof(UGraphGrammarProduction, RuleName) == 0x000028, "Member 'UGraphGrammarProduction::RuleName' has a wrong offset!");
static_assert(offsetof(UGraphGrammarProduction, SourceGraph) == 0x000040, "Member 'UGraphGrammarProduction::SourceGraph' has a wrong offset!");
static_assert(offsetof(UGraphGrammarProduction, DestGraphs) == 0x000048, "Member 'UGraphGrammarProduction::DestGraphs' has a wrong offset!");

// Class DungeonArchitectRuntime.GrammarNodeType
// 0x0028 (0x0050 - 0x0028)
class UGrammarNodeType final : public UObject
{
public:
	class FName                                   TypeName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bNonTerminal;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWildcard;                                         // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrammarNodeType">();
	}
	static class UGrammarNodeType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrammarNodeType>();
	}
};
static_assert(alignof(UGrammarNodeType) == 0x000008, "Wrong alignment on UGrammarNodeType");
static_assert(sizeof(UGrammarNodeType) == 0x000050, "Wrong size on UGrammarNodeType");
static_assert(offsetof(UGrammarNodeType, TypeName) == 0x000028, "Member 'UGrammarNodeType::TypeName' has a wrong offset!");
static_assert(offsetof(UGrammarNodeType, Description) == 0x000030, "Member 'UGrammarNodeType::Description' has a wrong offset!");
static_assert(offsetof(UGrammarNodeType, bNonTerminal) == 0x000048, "Member 'UGrammarNodeType::bNonTerminal' has a wrong offset!");
static_assert(offsetof(UGrammarNodeType, bWildcard) == 0x000049, "Member 'UGrammarNodeType::bWildcard' has a wrong offset!");

// Class DungeonArchitectRuntime.GraphGrammar
// 0x0030 (0x0058 - 0x0028)
class UGraphGrammar final : public UObject
{
public:
	TArray<class UGraphGrammarProduction*>        ProductionRules;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGrammarExecutionScript*                ExecutionGraphScript;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGrammarNodeType*>               NodeTypes;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGrammarNodeType*                       WildcardType;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphGrammar">();
	}
	static class UGraphGrammar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphGrammar>();
	}
};
static_assert(alignof(UGraphGrammar) == 0x000008, "Wrong alignment on UGraphGrammar");
static_assert(sizeof(UGraphGrammar) == 0x000058, "Wrong size on UGraphGrammar");
static_assert(offsetof(UGraphGrammar, ProductionRules) == 0x000028, "Member 'UGraphGrammar::ProductionRules' has a wrong offset!");
static_assert(offsetof(UGraphGrammar, ExecutionGraphScript) == 0x000038, "Member 'UGraphGrammar::ExecutionGraphScript' has a wrong offset!");
static_assert(offsetof(UGraphGrammar, NodeTypes) == 0x000040, "Member 'UGraphGrammar::NodeTypes' has a wrong offset!");
static_assert(offsetof(UGraphGrammar, WildcardType) == 0x000050, "Member 'UGraphGrammar::WildcardType' has a wrong offset!");

// Class DungeonArchitectRuntime.Grid3DLayoutNodeCreationConstraint
// 0x0000 (0x0028 - 0x0028)
class UGrid3DLayoutNodeCreationConstraint final : public UFlowLayoutNodeCreationConstraint
{
public:
	bool CanCreateLayoutNode(const struct FIntVector& NodeCoord, const struct FIntVector& GridSize, int32 TotalPathLength, int32 CurrentPathPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DLayoutNodeCreationConstraint">();
	}
	static class UGrid3DLayoutNodeCreationConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DLayoutNodeCreationConstraint>();
	}
};
static_assert(alignof(UGrid3DLayoutNodeCreationConstraint) == 0x000008, "Wrong alignment on UGrid3DLayoutNodeCreationConstraint");
static_assert(sizeof(UGrid3DLayoutNodeCreationConstraint) == 0x000028, "Wrong size on UGrid3DLayoutNodeCreationConstraint");

// Class DungeonArchitectRuntime.SnapGridFlowBuilder
// 0x0070 (0x00E0 - 0x0070)
class USnapGridFlowBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x70];                                      // 0x0070(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowBuilder">();
	}
	static class USnapGridFlowBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowBuilder>();
	}
};
static_assert(alignof(USnapGridFlowBuilder) == 0x000008, "Wrong alignment on USnapGridFlowBuilder");
static_assert(sizeof(USnapGridFlowBuilder) == 0x0000E0, "Wrong size on USnapGridFlowBuilder");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_CreateGrid
// 0x0010 (0x0068 - 0x0058)
class UGrid3DFlowTaskAbstract_CreateGrid final : public UFlowTaskAbstractBase
{
public:
	struct FIntVector                             GridSize;                                          // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeparationDistance;                                // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_CreateGrid">();
	}
	static class UGrid3DFlowTaskAbstract_CreateGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_CreateGrid>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_CreateGrid) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_CreateGrid");
static_assert(sizeof(UGrid3DFlowTaskAbstract_CreateGrid) == 0x000068, "Wrong size on UGrid3DFlowTaskAbstract_CreateGrid");
static_assert(offsetof(UGrid3DFlowTaskAbstract_CreateGrid, GridSize) == 0x000058, "Member 'UGrid3DFlowTaskAbstract_CreateGrid::GridSize' has a wrong offset!");
static_assert(offsetof(UGrid3DFlowTaskAbstract_CreateGrid, SeparationDistance) == 0x000064, "Member 'UGrid3DFlowTaskAbstract_CreateGrid::SeparationDistance' has a wrong offset!");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_CreateKeyLock
// 0x0000 (0x0098 - 0x0098)
class UGrid3DFlowTaskAbstract_CreateKeyLock final : public UFlowTaskAbstract_CreateKeyLock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_CreateKeyLock">();
	}
	static class UGrid3DFlowTaskAbstract_CreateKeyLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_CreateKeyLock>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_CreateKeyLock) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_CreateKeyLock");
static_assert(sizeof(UGrid3DFlowTaskAbstract_CreateKeyLock) == 0x000098, "Wrong size on UGrid3DFlowTaskAbstract_CreateKeyLock");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_CreateMainPath
// 0x0010 (0x00E0 - 0x00D0)
class UGrid3DFlowTaskAbstract_CreateMainPath final : public UFlowTaskAbstract_CreateMainPath
{
public:
	bool                                          bUseNodeCreationConstraint;                        // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGrid3DLayoutNodeCreationConstraint*    NodeCreationConstraint;                            // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, SimpleDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_CreateMainPath">();
	}
	static class UGrid3DFlowTaskAbstract_CreateMainPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_CreateMainPath>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_CreateMainPath) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_CreateMainPath");
static_assert(sizeof(UGrid3DFlowTaskAbstract_CreateMainPath) == 0x0000E0, "Wrong size on UGrid3DFlowTaskAbstract_CreateMainPath");
static_assert(offsetof(UGrid3DFlowTaskAbstract_CreateMainPath, bUseNodeCreationConstraint) == 0x0000D0, "Member 'UGrid3DFlowTaskAbstract_CreateMainPath::bUseNodeCreationConstraint' has a wrong offset!");
static_assert(offsetof(UGrid3DFlowTaskAbstract_CreateMainPath, NodeCreationConstraint) == 0x0000D8, "Member 'UGrid3DFlowTaskAbstract_CreateMainPath::NodeCreationConstraint' has a wrong offset!");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_CreatePath
// 0x0000 (0x00E8 - 0x00E8)
class UGrid3DFlowTaskAbstract_CreatePath final : public UFlowTaskAbstract_CreatePath
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_CreatePath">();
	}
	static class UGrid3DFlowTaskAbstract_CreatePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_CreatePath>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_CreatePath) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_CreatePath");
static_assert(sizeof(UGrid3DFlowTaskAbstract_CreatePath) == 0x0000E8, "Wrong size on UGrid3DFlowTaskAbstract_CreatePath");

// Class DungeonArchitectRuntime.SnapGridFlowModuleDatabase
// 0x0018 (0x0040 - 0x0028)
class USnapGridFlowModuleDatabase final : public UObject
{
public:
	class USnapGridFlowModuleBoundsAsset*         ModuleBoundsAsset;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSnapGridFlowModuleDatabaseItem> Modules;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowModuleDatabase">();
	}
	static class USnapGridFlowModuleDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowModuleDatabase>();
	}
};
static_assert(alignof(USnapGridFlowModuleDatabase) == 0x000008, "Wrong alignment on USnapGridFlowModuleDatabase");
static_assert(sizeof(USnapGridFlowModuleDatabase) == 0x000040, "Wrong size on USnapGridFlowModuleDatabase");
static_assert(offsetof(USnapGridFlowModuleDatabase, ModuleBoundsAsset) == 0x000028, "Member 'USnapGridFlowModuleDatabase::ModuleBoundsAsset' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleDatabase, Modules) == 0x000030, "Member 'USnapGridFlowModuleDatabase::Modules' has a wrong offset!");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_Finalize
// 0x0000 (0x0060 - 0x0060)
class UGrid3DFlowTaskAbstract_Finalize final : public UFlowTaskAbstract_Finalize
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_Finalize">();
	}
	static class UGrid3DFlowTaskAbstract_Finalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_Finalize>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_Finalize) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_Finalize");
static_assert(sizeof(UGrid3DFlowTaskAbstract_Finalize) == 0x000060, "Wrong size on UGrid3DFlowTaskAbstract_Finalize");

// Class DungeonArchitectRuntime.Grid3DFlowTaskAbstract_SpawnItems
// 0x0000 (0x00E8 - 0x00E8)
class UGrid3DFlowTaskAbstract_SpawnItems final : public UFlowTaskAbstract_SpawnItems
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grid3DFlowTaskAbstract_SpawnItems">();
	}
	static class UGrid3DFlowTaskAbstract_SpawnItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrid3DFlowTaskAbstract_SpawnItems>();
	}
};
static_assert(alignof(UGrid3DFlowTaskAbstract_SpawnItems) == 0x000008, "Wrong alignment on UGrid3DFlowTaskAbstract_SpawnItems");
static_assert(sizeof(UGrid3DFlowTaskAbstract_SpawnItems) == 0x0000E8, "Wrong size on UGrid3DFlowTaskAbstract_SpawnItems");

// Class DungeonArchitectRuntime.GridDungeonBuilder
// 0x0030 (0x00A0 - 0x0070)
class UGridDungeonBuilder : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainsCell(int32 X, int32 Y);
	void GetCellsOfType(EFCellType CellType, TArray<struct FCell>* Cells);
	void GetCorridors(TArray<struct FCell>* CorridorCells);
	void GetRandomStream(struct FRandomStream* OutRandomStream);
	void GetRooms(TArray<struct FCell>* RoomCells);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonBuilder">();
	}
	static class UGridDungeonBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonBuilder>();
	}
};
static_assert(alignof(UGridDungeonBuilder) == 0x000008, "Wrong alignment on UGridDungeonBuilder");
static_assert(sizeof(UGridDungeonBuilder) == 0x0000A0, "Wrong size on UGridDungeonBuilder");

// Class DungeonArchitectRuntime.GridCustomDungeonBuilder
// 0x0028 (0x00C8 - 0x00A0)
class UGridCustomDungeonBuilder final : public UGridDungeonBuilder
{
public:
	bool                                          bUseHeightVariation;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x27];                                      // 0x00A1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConnectRooms(int32 Room1, int32 Room2);
	void GenerateCustomLayout(class UGridDungeonConfig* GridConfig);
	void GetRandomOffset(int32 X, int32 Y, float Radius, int32* OutX, int32* OutY);
	void RegisterRoom(int32 X, int32 Y, int32 Z, int32 Width, int32 Height, int32* RoomId);
	void RegisterRoomAt(int32 X, int32 Y, int32 Z, int32* RoomId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridCustomDungeonBuilder">();
	}
	static class UGridCustomDungeonBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridCustomDungeonBuilder>();
	}
};
static_assert(alignof(UGridCustomDungeonBuilder) == 0x000008, "Wrong alignment on UGridCustomDungeonBuilder");
static_assert(sizeof(UGridCustomDungeonBuilder) == 0x0000C8, "Wrong size on UGridCustomDungeonBuilder");
static_assert(offsetof(UGridCustomDungeonBuilder, bUseHeightVariation) == 0x0000A0, "Member 'UGridCustomDungeonBuilder::bUseHeightVariation' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonConfig
// 0x0060 (0x00A8 - 0x0048)
class UGridDungeonConfig final : public UDungeonConfig
{
public:
	int32                                         NumCells;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GridCellSize;                                      // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCellSize;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellSize;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomAreaThreshold;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomAspectDelta;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpanningTreeLoopProbability;                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StairConnectionTollerance;                         // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorProximitySteps;                                // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightVariationProbability;                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalMean;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStd;                                         // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAllowedStairHeight;                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneWidth;                                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableClusteredTheming;                           // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClusterWithHeightVariation;                       // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FloorHeight;                                       // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridDungeonWallType                          WallLayoutType;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialRoomRadius;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastCellDistribution;                             // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DungeonWidth;                                      // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonLength;                                     // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonConfig">();
	}
	static class UGridDungeonConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonConfig>();
	}
};
static_assert(alignof(UGridDungeonConfig) == 0x000008, "Wrong alignment on UGridDungeonConfig");
static_assert(sizeof(UGridDungeonConfig) == 0x0000A8, "Wrong size on UGridDungeonConfig");
static_assert(offsetof(UGridDungeonConfig, NumCells) == 0x000048, "Member 'UGridDungeonConfig::NumCells' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, GridCellSize) == 0x00004C, "Member 'UGridDungeonConfig::GridCellSize' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, MinCellSize) == 0x000058, "Member 'UGridDungeonConfig::MinCellSize' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, MaxCellSize) == 0x00005C, "Member 'UGridDungeonConfig::MaxCellSize' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, RoomAreaThreshold) == 0x000060, "Member 'UGridDungeonConfig::RoomAreaThreshold' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, RoomAspectDelta) == 0x000064, "Member 'UGridDungeonConfig::RoomAspectDelta' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, SpanningTreeLoopProbability) == 0x000068, "Member 'UGridDungeonConfig::SpanningTreeLoopProbability' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, StairConnectionTollerance) == 0x00006C, "Member 'UGridDungeonConfig::StairConnectionTollerance' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, DoorProximitySteps) == 0x000070, "Member 'UGridDungeonConfig::DoorProximitySteps' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, HeightVariationProbability) == 0x000074, "Member 'UGridDungeonConfig::HeightVariationProbability' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, NormalMean) == 0x000078, "Member 'UGridDungeonConfig::NormalMean' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, NormalStd) == 0x00007C, "Member 'UGridDungeonConfig::NormalStd' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, MaxAllowedStairHeight) == 0x000080, "Member 'UGridDungeonConfig::MaxAllowedStairHeight' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, LaneWidth) == 0x000084, "Member 'UGridDungeonConfig::LaneWidth' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, bEnableClusteredTheming) == 0x000088, "Member 'UGridDungeonConfig::bEnableClusteredTheming' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, bClusterWithHeightVariation) == 0x000089, "Member 'UGridDungeonConfig::bClusterWithHeightVariation' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, FloorHeight) == 0x00008C, "Member 'UGridDungeonConfig::FloorHeight' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, WallLayoutType) == 0x000090, "Member 'UGridDungeonConfig::WallLayoutType' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, InitialRoomRadius) == 0x000094, "Member 'UGridDungeonConfig::InitialRoomRadius' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, bFastCellDistribution) == 0x000098, "Member 'UGridDungeonConfig::bFastCellDistribution' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, DungeonWidth) == 0x00009C, "Member 'UGridDungeonConfig::DungeonWidth' has a wrong offset!");
static_assert(offsetof(UGridDungeonConfig, DungeonLength) == 0x0000A0, "Member 'UGridDungeonConfig::DungeonLength' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonModel
// 0x0188 (0x01B0 - 0x0028)
class UGridDungeonModel final : public UDungeonModel
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	EDungeonModelBuildState                       BuildState;                                        // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCell>                          Cells;                                             // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCellDoor>                      Doors;                                             // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStairInfo>                     Stairs;                                            // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0xF0];                                      // 0x00C0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGridCellInfo GetGridCellLookup(int32 X, int32 Y) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonModel">();
	}
	static class UGridDungeonModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonModel>();
	}
};
static_assert(alignof(UGridDungeonModel) == 0x000008, "Wrong alignment on UGridDungeonModel");
static_assert(sizeof(UGridDungeonModel) == 0x0001B0, "Wrong size on UGridDungeonModel");
static_assert(offsetof(UGridDungeonModel, BuildState) == 0x000088, "Member 'UGridDungeonModel::BuildState' has a wrong offset!");
static_assert(offsetof(UGridDungeonModel, Cells) == 0x000090, "Member 'UGridDungeonModel::Cells' has a wrong offset!");
static_assert(offsetof(UGridDungeonModel, Doors) == 0x0000A0, "Member 'UGridDungeonModel::Doors' has a wrong offset!");
static_assert(offsetof(UGridDungeonModel, Stairs) == 0x0000B0, "Member 'UGridDungeonModel::Stairs' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonModelHelper
// 0x0000 (0x0028 - 0x0028)
class UGridDungeonModelHelper final : public UDungeonModelHelper
{
public:
	static void AddPaintCell(const struct FGridToolPaintStrokeData& CellData, class ADungeon* Dungeon, bool bAutomaticRebuild);
	static void GetBoundingBox(const TArray<struct FCell>& Cells, struct FRectangle* Bounds);
	static void GetCellCenter(const struct FCell& Cell, struct FVector* Center);
	static void GetCellConnectedRooms(const struct FCell& Cell, TArray<int32>* ConnectedRooms);
	static void GetCellMSTRooms(const struct FCell& Cell, TArray<int32>* MSTRooms);
	static void GetDoorExits(const struct FCellDoor& Door, struct FVector* ExitA, struct FVector* ExitB);
	static struct FVector GetRandomCellLocation(class UGridDungeonModel* Model, class UGridDungeonConfig* Config);
	static void GetRoomFreeEdge(class UGridDungeonModel* Model, const struct FCell& RoomCell, TArray<struct FVector>* FreeEdgeCenters, TArray<float>* FreeEdgeAngles);
	static void RemovePaintCell(const struct FGridToolPaintStrokeData& CellData, class ADungeon* Dungeon, bool bAutomaticRebuild);
	static void ToWorldCoords(const struct FRectangle& Bounds, const struct FVector& GridSize, struct FVector* Location, struct FVector* Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonModelHelper">();
	}
	static class UGridDungeonModelHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonModelHelper>();
	}
};
static_assert(alignof(UGridDungeonModelHelper) == 0x000008, "Wrong alignment on UGridDungeonModelHelper");
static_assert(sizeof(UGridDungeonModelHelper) == 0x000028, "Wrong size on UGridDungeonModelHelper");

// Class DungeonArchitectRuntime.GridDungeonPlatformVolume
// 0x0008 (0x0278 - 0x0270)
class AGridDungeonPlatformVolume final : public ADungeonVolume
{
public:
	EFCellType                                    CellType;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonPlatformVolume">();
	}
	static class AGridDungeonPlatformVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGridDungeonPlatformVolume>();
	}
};
static_assert(alignof(AGridDungeonPlatformVolume) == 0x000008, "Wrong alignment on AGridDungeonPlatformVolume");
static_assert(sizeof(AGridDungeonPlatformVolume) == 0x000278, "Wrong size on AGridDungeonPlatformVolume");
static_assert(offsetof(AGridDungeonPlatformVolume, CellType) == 0x000270, "Member 'AGridDungeonPlatformVolume::CellType' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonQuery
// 0x0010 (0x0070 - 0x0060)
class UGridDungeonQuery final : public UDungeonQuery
{
public:
	class UGridDungeonConfig*                     Config;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGridDungeonModel*                      Model;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool ContainsDoorBetween(int32 CellA, int32 CellB);
	bool ContainsStairBetween(int32 CellA, int32 CellB);
	void GetAdjacentCells(int32 CellId, TArray<int32>* OutAdjacentCells);
	void GetAdjacentCellsOnEdge(const struct FTransform& WallMarkerTransform, int32* CellA, int32* CellB);
	void GetCellAtLocation(const struct FVector& WorldLocation, int32* OutCellId, bool* bOutValid);
	void GetCellDimension(int32 CellId, struct FVector* OutCenter, struct FVector* OutSize);
	TArray<int32> GetCells();
	TArray<int32> GetCellsOfType(EFCellType CellType);
	EFCellType GetCellType(int32 CellId);
	struct FCellDoor GetDoorBetween(int32 CellA, int32 CellB);
	void GetFurthestRooms(int32* OutRoomA, int32* OutRoomB);
	struct FVector GetOpeningPointBetweenAdjacentCells(int32 CellA, int32 CellB);
	void GetPathBetweenCells(int32 CellA, int32 CellB, TArray<int32>* OutResult, bool* bOutSuccess);
	int32 GetRandomCell();
	int32 GetRandomCellFromStream(struct FRandomStream* RandomStream);
	int32 GetRandomCellOfType(EFCellType CellType);
	int32 GetRandomCellOfTypeFromStream(EFCellType CellType, struct FRandomStream* RandomStream);
	struct FStairInfo GetStairBetween(int32 CellA, int32 CellB);
	void IsNearMarker(const struct FTransform& CurrentMarkerTransform, const class FString& NearbyMarkerName, float NearbyDistance, class UDungeonBuilder* Builder, bool* bIsNear, int32* NumFound);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonQuery">();
	}
	static class UGridDungeonQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonQuery>();
	}
};
static_assert(alignof(UGridDungeonQuery) == 0x000010, "Wrong alignment on UGridDungeonQuery");
static_assert(sizeof(UGridDungeonQuery) == 0x000070, "Wrong size on UGridDungeonQuery");
static_assert(offsetof(UGridDungeonQuery, Config) == 0x000060, "Member 'UGridDungeonQuery::Config' has a wrong offset!");
static_assert(offsetof(UGridDungeonQuery, Model) == 0x000068, "Member 'UGridDungeonQuery::Model' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class UGridDungeonSelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool ContainsStair(class UGridDungeonModel* Model, const struct FCell& Cell, int32 GridX, int32 GridY);
	bool IsOnCorner(class UGridDungeonModel* Model, int32 GridX, int32 GridY);
	bool IsPassageTooNarrow(class UGridDungeonModel* Model, int32 GridX, int32 GridY);
	bool IsPillarOnCorner(class UGridDungeonModel* Model, int32 GridX, int32 GridY, struct FTransform* OutCornerOffset);
	bool SelectNode(class UGridDungeonModel* Model, class UGridDungeonConfig* Config, class UGridDungeonBuilder* Builder, class UGridDungeonQuery* Query, const struct FCell& Cell, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, const struct FTransform& MarkerTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonSelectorLogic">();
	}
	static class UGridDungeonSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonSelectorLogic>();
	}
};
static_assert(alignof(UGridDungeonSelectorLogic) == 0x000008, "Wrong alignment on UGridDungeonSelectorLogic");
static_assert(sizeof(UGridDungeonSelectorLogic) == 0x000028, "Wrong size on UGridDungeonSelectorLogic");

// Class DungeonArchitectRuntime.GridDungeonToolData
// 0x0030 (0x0058 - 0x0028)
class UGridDungeonToolData final : public UDungeonToolData
{
public:
	TArray<struct FGridToolPaintStrokeData>       PaintedCells;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGridToolRectStrokeData>        Rectangles;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGridToolRectStrokeData>        Borders;                                           // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonToolData">();
	}
	static class UGridDungeonToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonToolData>();
	}
};
static_assert(alignof(UGridDungeonToolData) == 0x000008, "Wrong alignment on UGridDungeonToolData");
static_assert(sizeof(UGridDungeonToolData) == 0x000058, "Wrong size on UGridDungeonToolData");
static_assert(offsetof(UGridDungeonToolData, PaintedCells) == 0x000028, "Member 'UGridDungeonToolData::PaintedCells' has a wrong offset!");
static_assert(offsetof(UGridDungeonToolData, Rectangles) == 0x000038, "Member 'UGridDungeonToolData::Rectangles' has a wrong offset!");
static_assert(offsetof(UGridDungeonToolData, Borders) == 0x000048, "Member 'UGridDungeonToolData::Borders' has a wrong offset!");

// Class DungeonArchitectRuntime.GridDungeonTransformLogic
// 0x0000 (0x0028 - 0x0028)
class UGridDungeonTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class UGridDungeonModel* Model, class UGridDungeonConfig* Config, class UGridDungeonBuilder* Builder, class UGridDungeonQuery* Query, const struct FCell& Cell, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, const struct FTransform& MarkerTransform, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridDungeonTransformLogic">();
	}
	static class UGridDungeonTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridDungeonTransformLogic>();
	}
};
static_assert(alignof(UGridDungeonTransformLogic) == 0x000008, "Wrong alignment on UGridDungeonTransformLogic");
static_assert(sizeof(UGridDungeonTransformLogic) == 0x000028, "Wrong size on UGridDungeonTransformLogic");

// Class DungeonArchitectRuntime.GridFlowAbstractGraph
// 0x0010 (0x0058 - 0x0048)
class UGridFlowAbstractGraph final : public UFlowAbstractGraphBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              GridSize;                                          // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowAbstractGraph">();
	}
	static class UGridFlowAbstractGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowAbstractGraph>();
	}
};
static_assert(alignof(UGridFlowAbstractGraph) == 0x000008, "Wrong alignment on UGridFlowAbstractGraph");
static_assert(sizeof(UGridFlowAbstractGraph) == 0x000058, "Wrong size on UGridFlowAbstractGraph");
static_assert(offsetof(UGridFlowAbstractGraph, GridSize) == 0x000050, "Member 'UGridFlowAbstractGraph::GridSize' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowAbstractGraph3D
// 0x0018 (0x0060 - 0x0048)
class UGridFlowAbstractGraph3D final : public UFlowAbstractGraphBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             GridSize;                                          // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowAbstractGraph3D">();
	}
	static class UGridFlowAbstractGraph3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowAbstractGraph3D>();
	}
};
static_assert(alignof(UGridFlowAbstractGraph3D) == 0x000008, "Wrong alignment on UGridFlowAbstractGraph3D");
static_assert(sizeof(UGridFlowAbstractGraph3D) == 0x000060, "Wrong size on UGridFlowAbstractGraph3D");
static_assert(offsetof(UGridFlowAbstractGraph3D, GridSize) == 0x000050, "Member 'UGridFlowAbstractGraph3D::GridSize' has a wrong offset!");

// Class DungeonArchitectRuntime.FDAbstractNodePreview
// 0x0040 (0x0240 - 0x0200)
class UFDAbstractNodePreview final : public USceneComponent
{
public:
	class UStaticMeshComponent*                   NodeMesh;                                          // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BoundsMesh;                                        // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   TextRenderer;                                      // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextMaterial;                                      // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DefaultMaterial;                                   // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SelectedMaterial;                                  // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BoundsMaterial;                                    // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FDAbstractNodePreview">();
	}
	static class UFDAbstractNodePreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFDAbstractNodePreview>();
	}
};
static_assert(alignof(UFDAbstractNodePreview) == 0x000010, "Wrong alignment on UFDAbstractNodePreview");
static_assert(sizeof(UFDAbstractNodePreview) == 0x000240, "Wrong size on UFDAbstractNodePreview");
static_assert(offsetof(UFDAbstractNodePreview, NodeMesh) == 0x0001F8, "Member 'UFDAbstractNodePreview::NodeMesh' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, BoundsMesh) == 0x000200, "Member 'UFDAbstractNodePreview::BoundsMesh' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, TextRenderer) == 0x000208, "Member 'UFDAbstractNodePreview::TextRenderer' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, TextMaterial) == 0x000210, "Member 'UFDAbstractNodePreview::TextMaterial' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, DefaultMaterial) == 0x000218, "Member 'UFDAbstractNodePreview::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, SelectedMaterial) == 0x000220, "Member 'UFDAbstractNodePreview::SelectedMaterial' has a wrong offset!");
static_assert(offsetof(UFDAbstractNodePreview, BoundsMaterial) == 0x000228, "Member 'UFDAbstractNodePreview::BoundsMaterial' has a wrong offset!");

// Class DungeonArchitectRuntime.FDAbstractLink
// 0x0060 (0x0260 - 0x0200)
class UFDAbstractLink final : public USceneComponent
{
public:
	class UStaticMeshComponent*                   LineMesh;                                          // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               LineMaterial;                                      // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HeadMaterial;                                      // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FDAbstractLink">();
	}
	static class UFDAbstractLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFDAbstractLink>();
	}
};
static_assert(alignof(UFDAbstractLink) == 0x000010, "Wrong alignment on UFDAbstractLink");
static_assert(sizeof(UFDAbstractLink) == 0x000260, "Wrong size on UFDAbstractLink");
static_assert(offsetof(UFDAbstractLink, LineMesh) == 0x0001F8, "Member 'UFDAbstractLink::LineMesh' has a wrong offset!");
static_assert(offsetof(UFDAbstractLink, LineMaterial) == 0x000200, "Member 'UFDAbstractLink::LineMaterial' has a wrong offset!");
static_assert(offsetof(UFDAbstractLink, HeadMaterial) == 0x000208, "Member 'UFDAbstractLink::HeadMaterial' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowAbstractGraphVisualizer
// 0x0050 (0x0278 - 0x0228)
class AGridFlowAbstractGraphVisualizer final : public AActor
{
public:
	struct FGuid                                  DungeonID;                                         // 0x0228(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneRoot;                                         // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoAlignToLevelViewport;                         // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x37];                                     // 0x0241(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowAbstractGraphVisualizer">();
	}
	static class AGridFlowAbstractGraphVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGridFlowAbstractGraphVisualizer>();
	}
};
static_assert(alignof(AGridFlowAbstractGraphVisualizer) == 0x000008, "Wrong alignment on AGridFlowAbstractGraphVisualizer");
static_assert(sizeof(AGridFlowAbstractGraphVisualizer) == 0x000278, "Wrong size on AGridFlowAbstractGraphVisualizer");
static_assert(offsetof(AGridFlowAbstractGraphVisualizer, DungeonID) == 0x000228, "Member 'AGridFlowAbstractGraphVisualizer::DungeonID' has a wrong offset!");
static_assert(offsetof(AGridFlowAbstractGraphVisualizer, SceneRoot) == 0x000238, "Member 'AGridFlowAbstractGraphVisualizer::SceneRoot' has a wrong offset!");
static_assert(offsetof(AGridFlowAbstractGraphVisualizer, bAutoAlignToLevelViewport) == 0x000240, "Member 'AGridFlowAbstractGraphVisualizer::bAutoAlignToLevelViewport' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowAsset
// 0x0000 (0x0030 - 0x0030)
class UGridFlowAsset final : public UFlowAssetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowAsset">();
	}
	static class UGridFlowAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowAsset>();
	}
};
static_assert(alignof(UGridFlowAsset) == 0x000008, "Wrong alignment on UGridFlowAsset");
static_assert(sizeof(UGridFlowAsset) == 0x000030, "Wrong size on UGridFlowAsset");

// Class DungeonArchitectRuntime.GridFlowBuilder
// 0x0068 (0x00D8 - 0x0070)
class UGridFlowBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x68];                                      // 0x0070(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowBuilder">();
	}
	static class UGridFlowBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowBuilder>();
	}
};
static_assert(alignof(UGridFlowBuilder) == 0x000008, "Wrong alignment on UGridFlowBuilder");
static_assert(sizeof(UGridFlowBuilder) == 0x0000D8, "Wrong size on UGridFlowBuilder");

// Class DungeonArchitectRuntime.GridFlowConfig
// 0x0090 (0x00D8 - 0x0048)
class UGridFlowConfig final : public UDungeonConfig
{
public:
	TSoftObjectPtr<class UGridFlowAsset>          GridFlow;                                          // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRetries;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GridSize;                                          // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ParameterOverrides;                                // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAlignDungeonAtCenter;                             // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowConfig">();
	}
	static class UGridFlowConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowConfig>();
	}
};
static_assert(alignof(UGridFlowConfig) == 0x000008, "Wrong alignment on UGridFlowConfig");
static_assert(sizeof(UGridFlowConfig) == 0x0000D8, "Wrong size on UGridFlowConfig");
static_assert(offsetof(UGridFlowConfig, GridFlow) == 0x000048, "Member 'UGridFlowConfig::GridFlow' has a wrong offset!");
static_assert(offsetof(UGridFlowConfig, MaxRetries) == 0x000070, "Member 'UGridFlowConfig::MaxRetries' has a wrong offset!");
static_assert(offsetof(UGridFlowConfig, GridSize) == 0x000074, "Member 'UGridFlowConfig::GridSize' has a wrong offset!");
static_assert(offsetof(UGridFlowConfig, ParameterOverrides) == 0x000080, "Member 'UGridFlowConfig::ParameterOverrides' has a wrong offset!");
static_assert(offsetof(UGridFlowConfig, bAlignDungeonAtCenter) == 0x0000D0, "Member 'UGridFlowConfig::bAlignDungeonAtCenter' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowMiniMap
// 0x0000 (0x02E0 - 0x02E0)
class AGridFlowMiniMap final : public ADungeonMiniMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowMiniMap">();
	}
	static class AGridFlowMiniMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGridFlowMiniMap>();
	}
};
static_assert(alignof(AGridFlowMiniMap) == 0x000010, "Wrong alignment on AGridFlowMiniMap");
static_assert(sizeof(AGridFlowMiniMap) == 0x0002E0, "Wrong size on AGridFlowMiniMap");

// Class DungeonArchitectRuntime.GridFlowModel
// 0x0018 (0x0040 - 0x0028)
class UGridFlowModel final : public UDungeonModel
{
public:
	class UGridFlowAbstractGraph*                 AbstractGraph;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowTilemap*                       Tilemap;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              BuildTileOffset;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowModel">();
	}
	static class UGridFlowModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowModel>();
	}
};
static_assert(alignof(UGridFlowModel) == 0x000008, "Wrong alignment on UGridFlowModel");
static_assert(sizeof(UGridFlowModel) == 0x000040, "Wrong size on UGridFlowModel");
static_assert(offsetof(UGridFlowModel, AbstractGraph) == 0x000028, "Member 'UGridFlowModel::AbstractGraph' has a wrong offset!");
static_assert(offsetof(UGridFlowModel, Tilemap) == 0x000030, "Member 'UGridFlowModel::Tilemap' has a wrong offset!");
static_assert(offsetof(UGridFlowModel, BuildTileOffset) == 0x000038, "Member 'UGridFlowModel::BuildTileOffset' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowQuery
// 0x0010 (0x0070 - 0x0060)
class UGridFlowQuery final : public UDungeonQuery
{
public:
	class UGridFlowConfig*                        Config;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGridFlowModel*                         Model;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void GetChunkAtLayoutNode(const class UFlowAbstractNode* InLayoutNode, struct FGridFlowChunkQueryResult* Result);
	static void IsNearMarker(const struct FTransform& CurrentMarkerTransform, const class FString& NearbyMarkerName, float NearbyDistance, class UDungeonBuilder* Builder, bool* bIsNear, int32* NumFound);

	struct FVector ConvertTileToWorldCoord(const struct FVector& TileCoord);
	struct FVector ConvertWorldToTileCoord(const struct FVector& WorldCoords);
	bool GetCellAtTileCoord(const struct FVector& TileCoord, struct FGridFlowTilemapCell* OutCell);
	bool GetCellAtWorldCoord(const struct FVector& WorldCoord, struct FGridFlowTilemapCell* OutCell);
	bool GetCellRoomType(const struct FVector& WorldCoord, EGridFlowAbstractNodeRoomType* OutRoomType);
	bool GetChunkAtWorldCoord(const struct FVector& InWorldCoord, struct FGridFlowChunkQueryResult* Result);
	void GetFreeTileLocation(const TArray<EGridFlowAbstractNodeRoomType>& AllowedRoomTypes, const struct FRandomStream& Random, bool* OutSuccess, struct FVector* OutWorldCoord);

	void GetAllChunksOfType(EGridFlowAbstractNodeRoomType RoomType, TArray<struct FGridFlowChunkQueryResult>* OutChunks) const;
	bool GetChunkAtLayoutNodeCoord(const struct FVector& InLayoutNodeCoord, struct FGridFlowChunkQueryResult* Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowQuery">();
	}
	static class UGridFlowQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowQuery>();
	}
};
static_assert(alignof(UGridFlowQuery) == 0x000010, "Wrong alignment on UGridFlowQuery");
static_assert(sizeof(UGridFlowQuery) == 0x000070, "Wrong size on UGridFlowQuery");
static_assert(offsetof(UGridFlowQuery, Config) == 0x000060, "Member 'UGridFlowQuery::Config' has a wrong offset!");
static_assert(offsetof(UGridFlowQuery, Model) == 0x000068, "Member 'UGridFlowQuery::Model' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class UGridFlowSelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool SelectNode(class UGridFlowModel* Model, class UGridFlowConfig* Config, class UGridFlowBuilder* Builder, class UGridFlowQuery* Query, const struct FRandomStream& RandomStream, int32 TileX, int32 TileY, const struct FTransform& MarkerTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowSelectorLogic">();
	}
	static class UGridFlowSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowSelectorLogic>();
	}
};
static_assert(alignof(UGridFlowSelectorLogic) == 0x000008, "Wrong alignment on UGridFlowSelectorLogic");
static_assert(sizeof(UGridFlowSelectorLogic) == 0x000028, "Wrong size on UGridFlowSelectorLogic");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_CreateGrid
// 0x0010 (0x0068 - 0x0058)
class UGridFlowTaskAbstract_CreateGrid final : public UFlowTaskAbstractBase
{
public:
	struct FIntPoint                              GridSize;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeparationDistance;                                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_CreateGrid">();
	}
	static class UGridFlowTaskAbstract_CreateGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_CreateGrid>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_CreateGrid) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_CreateGrid");
static_assert(sizeof(UGridFlowTaskAbstract_CreateGrid) == 0x000068, "Wrong size on UGridFlowTaskAbstract_CreateGrid");
static_assert(offsetof(UGridFlowTaskAbstract_CreateGrid, GridSize) == 0x000058, "Member 'UGridFlowTaskAbstract_CreateGrid::GridSize' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_CreateGrid, SeparationDistance) == 0x000060, "Member 'UGridFlowTaskAbstract_CreateGrid::SeparationDistance' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_CreateKeyLock
// 0x0000 (0x0098 - 0x0098)
class UGridFlowTaskAbstract_CreateKeyLock final : public UFlowTaskAbstract_CreateKeyLock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_CreateKeyLock">();
	}
	static class UGridFlowTaskAbstract_CreateKeyLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_CreateKeyLock>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_CreateKeyLock) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_CreateKeyLock");
static_assert(sizeof(UGridFlowTaskAbstract_CreateKeyLock) == 0x000098, "Wrong size on UGridFlowTaskAbstract_CreateKeyLock");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_CreateMainPath
// 0x0010 (0x00E0 - 0x00D0)
class UGridFlowTaskAbstract_CreateMainPath final : public UFlowTaskAbstract_CreateMainPath
{
public:
	bool                                          bOverrideStartGridPosition;                        // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              StartGridPosition;                                 // 0x00D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullSizeStartRoom;                                // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullSizeGoalRoom;                                 // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_CreateMainPath">();
	}
	static class UGridFlowTaskAbstract_CreateMainPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_CreateMainPath>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_CreateMainPath) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_CreateMainPath");
static_assert(sizeof(UGridFlowTaskAbstract_CreateMainPath) == 0x0000E0, "Wrong size on UGridFlowTaskAbstract_CreateMainPath");
static_assert(offsetof(UGridFlowTaskAbstract_CreateMainPath, bOverrideStartGridPosition) == 0x0000D0, "Member 'UGridFlowTaskAbstract_CreateMainPath::bOverrideStartGridPosition' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_CreateMainPath, StartGridPosition) == 0x0000D4, "Member 'UGridFlowTaskAbstract_CreateMainPath::StartGridPosition' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_CreateMainPath, bFullSizeStartRoom) == 0x0000DC, "Member 'UGridFlowTaskAbstract_CreateMainPath::bFullSizeStartRoom' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_CreateMainPath, bFullSizeGoalRoom) == 0x0000DD, "Member 'UGridFlowTaskAbstract_CreateMainPath::bFullSizeGoalRoom' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_CreatePath
// 0x0000 (0x00E8 - 0x00E8)
class UGridFlowTaskAbstract_CreatePath final : public UFlowTaskAbstract_CreatePath
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_CreatePath">();
	}
	static class UGridFlowTaskAbstract_CreatePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_CreatePath>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_CreatePath) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_CreatePath");
static_assert(sizeof(UGridFlowTaskAbstract_CreatePath) == 0x0000E8, "Wrong size on UGridFlowTaskAbstract_CreatePath");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_Finalize
// 0x0008 (0x0068 - 0x0060)
class UGridFlowTaskAbstract_Finalize final : public UFlowTaskAbstract_Finalize
{
public:
	bool                                          bGenerateCorridors;                                // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateCaves;                                    // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxEnemiesPerCaveNode;                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_Finalize">();
	}
	static class UGridFlowTaskAbstract_Finalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_Finalize>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_Finalize) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_Finalize");
static_assert(sizeof(UGridFlowTaskAbstract_Finalize) == 0x000068, "Wrong size on UGridFlowTaskAbstract_Finalize");
static_assert(offsetof(UGridFlowTaskAbstract_Finalize, bGenerateCorridors) == 0x000060, "Member 'UGridFlowTaskAbstract_Finalize::bGenerateCorridors' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_Finalize, bGenerateCaves) == 0x000061, "Member 'UGridFlowTaskAbstract_Finalize::bGenerateCaves' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskAbstract_Finalize, MaxEnemiesPerCaveNode) == 0x000064, "Member 'UGridFlowTaskAbstract_Finalize::MaxEnemiesPerCaveNode' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskAbstract_SpawnItems
// 0x0000 (0x00E8 - 0x00E8)
class UGridFlowTaskAbstract_SpawnItems final : public UFlowTaskAbstract_SpawnItems
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskAbstract_SpawnItems">();
	}
	static class UGridFlowTaskAbstract_SpawnItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskAbstract_SpawnItems>();
	}
};
static_assert(alignof(UGridFlowTaskAbstract_SpawnItems) == 0x000008, "Wrong alignment on UGridFlowTaskAbstract_SpawnItems");
static_assert(sizeof(UGridFlowTaskAbstract_SpawnItems) == 0x0000E8, "Wrong size on UGridFlowTaskAbstract_SpawnItems");

// Class DungeonArchitectRuntime.GridFlowTaskTilemapBase
// 0x0000 (0x0058 - 0x0058)
class UGridFlowTaskTilemapBase : public UFlowExecTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemapBase">();
	}
	static class UGridFlowTaskTilemapBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemapBase>();
	}
};
static_assert(alignof(UGridFlowTaskTilemapBase) == 0x000008, "Wrong alignment on UGridFlowTaskTilemapBase");
static_assert(sizeof(UGridFlowTaskTilemapBase) == 0x000058, "Wrong size on UGridFlowTaskTilemapBase");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_CreateElevations
// 0x0050 (0x00A8 - 0x0058)
class UGridFlowTaskTilemap_CreateElevations final : public UGridFlowTaskTilemapBase
{
public:
	int32                                         NoiseOctaves;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseFrequency;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseValuePower;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSteps;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkerName;                                        // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeight;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeaLevel;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LandColor;                                         // 0x0084(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SeaColor;                                          // 0x0094(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinColorMultiplier;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_CreateElevations">();
	}
	static class UGridFlowTaskTilemap_CreateElevations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_CreateElevations>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_CreateElevations) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_CreateElevations");
static_assert(sizeof(UGridFlowTaskTilemap_CreateElevations) == 0x0000A8, "Wrong size on UGridFlowTaskTilemap_CreateElevations");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, NoiseOctaves) == 0x000058, "Member 'UGridFlowTaskTilemap_CreateElevations::NoiseOctaves' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, NoiseFrequency) == 0x00005C, "Member 'UGridFlowTaskTilemap_CreateElevations::NoiseFrequency' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, NoiseValuePower) == 0x000060, "Member 'UGridFlowTaskTilemap_CreateElevations::NoiseValuePower' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, NumSteps) == 0x000064, "Member 'UGridFlowTaskTilemap_CreateElevations::NumSteps' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, MarkerName) == 0x000068, "Member 'UGridFlowTaskTilemap_CreateElevations::MarkerName' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, MinHeight) == 0x000078, "Member 'UGridFlowTaskTilemap_CreateElevations::MinHeight' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, MaxHeight) == 0x00007C, "Member 'UGridFlowTaskTilemap_CreateElevations::MaxHeight' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, SeaLevel) == 0x000080, "Member 'UGridFlowTaskTilemap_CreateElevations::SeaLevel' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, LandColor) == 0x000084, "Member 'UGridFlowTaskTilemap_CreateElevations::LandColor' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, SeaColor) == 0x000094, "Member 'UGridFlowTaskTilemap_CreateElevations::SeaColor' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateElevations, MinColorMultiplier) == 0x0000A4, "Member 'UGridFlowTaskTilemap_CreateElevations::MinColorMultiplier' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_CreateOverlay
// 0x0058 (0x00B0 - 0x0058)
class UGridFlowTaskTilemap_CreateOverlay final : public UGridFlowTaskTilemapBase
{
public:
	class FString                                 MarkerName;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0068(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayBlocksTile;                                // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowExecNodeTilemapOverlayNoiseSettings NoiseSettings;                                     // 0x007C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGridFlowTilemapCellOverlayMergeConfig MergeConfig;                                       // 0x0098(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_CreateOverlay">();
	}
	static class UGridFlowTaskTilemap_CreateOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_CreateOverlay>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_CreateOverlay) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_CreateOverlay");
static_assert(sizeof(UGridFlowTaskTilemap_CreateOverlay) == 0x0000B0, "Wrong size on UGridFlowTaskTilemap_CreateOverlay");
static_assert(offsetof(UGridFlowTaskTilemap_CreateOverlay, MarkerName) == 0x000058, "Member 'UGridFlowTaskTilemap_CreateOverlay::MarkerName' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateOverlay, Color) == 0x000068, "Member 'UGridFlowTaskTilemap_CreateOverlay::Color' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateOverlay, bOverlayBlocksTile) == 0x000078, "Member 'UGridFlowTaskTilemap_CreateOverlay::bOverlayBlocksTile' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateOverlay, NoiseSettings) == 0x00007C, "Member 'UGridFlowTaskTilemap_CreateOverlay::NoiseSettings' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_CreateOverlay, MergeConfig) == 0x000098, "Member 'UGridFlowTaskTilemap_CreateOverlay::MergeConfig' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_Finalize
// 0x0008 (0x0060 - 0x0058)
class UGridFlowTaskTilemap_Finalize final : public UGridFlowTaskTilemapBase
{
public:
	bool                                          bDebugUnwalkableCells;                             // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_Finalize">();
	}
	static class UGridFlowTaskTilemap_Finalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_Finalize>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_Finalize) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_Finalize");
static_assert(sizeof(UGridFlowTaskTilemap_Finalize) == 0x000060, "Wrong size on UGridFlowTaskTilemap_Finalize");
static_assert(offsetof(UGridFlowTaskTilemap_Finalize, bDebugUnwalkableCells) == 0x000058, "Member 'UGridFlowTaskTilemap_Finalize::bDebugUnwalkableCells' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_Initialize
// 0x0040 (0x0098 - 0x0058)
class UGridFlowTaskTilemap_Initialize final : public UGridFlowTaskTilemapBase
{
public:
	struct FIntPoint                              TilemapSizePerNode;                                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              PerturbAmount;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CorridorLaneWidth;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayoutPadding;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCropTilemapToLayout;                              // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridFlowTilemapWallGenerationMethod          WallGenerationMethod;                              // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CaveThickness;                                     // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaveAutomataNeighbors;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaveAutomataIterations;                            // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomColorSaturation;                               // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomColorBrightness;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLayoutTiles;                                 // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0xF];                                       // 0x0089(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_Initialize">();
	}
	static class UGridFlowTaskTilemap_Initialize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_Initialize>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_Initialize) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_Initialize");
static_assert(sizeof(UGridFlowTaskTilemap_Initialize) == 0x000098, "Wrong size on UGridFlowTaskTilemap_Initialize");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, TilemapSizePerNode) == 0x000058, "Member 'UGridFlowTaskTilemap_Initialize::TilemapSizePerNode' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, PerturbAmount) == 0x000060, "Member 'UGridFlowTaskTilemap_Initialize::PerturbAmount' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, CorridorLaneWidth) == 0x000068, "Member 'UGridFlowTaskTilemap_Initialize::CorridorLaneWidth' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, LayoutPadding) == 0x00006C, "Member 'UGridFlowTaskTilemap_Initialize::LayoutPadding' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, bCropTilemapToLayout) == 0x000070, "Member 'UGridFlowTaskTilemap_Initialize::bCropTilemapToLayout' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, WallGenerationMethod) == 0x000071, "Member 'UGridFlowTaskTilemap_Initialize::WallGenerationMethod' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, CaveThickness) == 0x000074, "Member 'UGridFlowTaskTilemap_Initialize::CaveThickness' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, CaveAutomataNeighbors) == 0x000078, "Member 'UGridFlowTaskTilemap_Initialize::CaveAutomataNeighbors' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, CaveAutomataIterations) == 0x00007C, "Member 'UGridFlowTaskTilemap_Initialize::CaveAutomataIterations' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, RoomColorSaturation) == 0x000080, "Member 'UGridFlowTaskTilemap_Initialize::RoomColorSaturation' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, RoomColorBrightness) == 0x000084, "Member 'UGridFlowTaskTilemap_Initialize::RoomColorBrightness' has a wrong offset!");
static_assert(offsetof(UGridFlowTaskTilemap_Initialize, bDebugLayoutTiles) == 0x000088, "Member 'UGridFlowTaskTilemap_Initialize::bDebugLayoutTiles' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_Merge
// 0x0000 (0x0058 - 0x0058)
class UGridFlowTaskTilemap_Merge final : public UGridFlowTaskTilemapBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_Merge">();
	}
	static class UGridFlowTaskTilemap_Merge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_Merge>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_Merge) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_Merge");
static_assert(sizeof(UGridFlowTaskTilemap_Merge) == 0x000058, "Wrong size on UGridFlowTaskTilemap_Merge");

// Class DungeonArchitectRuntime.GridFlowTaskTilemap_Optimize
// 0x0008 (0x0060 - 0x0058)
class UGridFlowTaskTilemap_Optimize final : public UGridFlowTaskTilemapBase
{
public:
	int32                                         DiscardDistanceFromLayout;                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTaskTilemap_Optimize">();
	}
	static class UGridFlowTaskTilemap_Optimize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTaskTilemap_Optimize>();
	}
};
static_assert(alignof(UGridFlowTaskTilemap_Optimize) == 0x000008, "Wrong alignment on UGridFlowTaskTilemap_Optimize");
static_assert(sizeof(UGridFlowTaskTilemap_Optimize) == 0x000060, "Wrong size on UGridFlowTaskTilemap_Optimize");
static_assert(offsetof(UGridFlowTaskTilemap_Optimize, DiscardDistanceFromLayout) == 0x000058, "Member 'UGridFlowTaskTilemap_Optimize::DiscardDistanceFromLayout' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowTilemap
// 0x00D8 (0x0100 - 0x0028)
class UGridFlowTilemap final : public UObject
{
public:
	TArray<struct FGridFlowTilemapCell>           Cells;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGridFlowTilemapEdge>           EdgesHorizontal;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGridFlowTilemapEdge>           EdgesVertical;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         Width;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Height;                                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGridFlowTilemapCoord, struct FGridFlowTilemapCellWallInfo> WallMetadataMap;                                   // 0x0060(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FGridFlowTilemapCoord, struct FGridFlowTilemapCellDoorInfo> DoorMetadataMap;                                   // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTilemap">();
	}
	static class UGridFlowTilemap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTilemap>();
	}
};
static_assert(alignof(UGridFlowTilemap) == 0x000008, "Wrong alignment on UGridFlowTilemap");
static_assert(sizeof(UGridFlowTilemap) == 0x000100, "Wrong size on UGridFlowTilemap");
static_assert(offsetof(UGridFlowTilemap, Cells) == 0x000028, "Member 'UGridFlowTilemap::Cells' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, EdgesHorizontal) == 0x000038, "Member 'UGridFlowTilemap::EdgesHorizontal' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, EdgesVertical) == 0x000048, "Member 'UGridFlowTilemap::EdgesVertical' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, Width) == 0x000058, "Member 'UGridFlowTilemap::Width' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, Height) == 0x00005C, "Member 'UGridFlowTilemap::Height' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, WallMetadataMap) == 0x000060, "Member 'UGridFlowTilemap::WallMetadataMap' has a wrong offset!");
static_assert(offsetof(UGridFlowTilemap, DoorMetadataMap) == 0x0000B0, "Member 'UGridFlowTilemap::DoorMetadataMap' has a wrong offset!");

// Class DungeonArchitectRuntime.FANodeTilemapDomainData
// 0x0028 (0x0050 - 0x0028)
class UFANodeTilemapDomainData final : public UObject
{
public:
	struct FGridFlowAbstractNodeTilemapMetadata   TilemapMetadata;                                   // 0x0028(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bDisablePerturb;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridFlowAbstractNodeRoomType                 RoomType;                                          // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FANodeTilemapDomainData">();
	}
	static class UFANodeTilemapDomainData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFANodeTilemapDomainData>();
	}
};
static_assert(alignof(UFANodeTilemapDomainData) == 0x000008, "Wrong alignment on UFANodeTilemapDomainData");
static_assert(sizeof(UFANodeTilemapDomainData) == 0x000050, "Wrong size on UFANodeTilemapDomainData");
static_assert(offsetof(UFANodeTilemapDomainData, TilemapMetadata) == 0x000028, "Member 'UFANodeTilemapDomainData::TilemapMetadata' has a wrong offset!");
static_assert(offsetof(UFANodeTilemapDomainData, bDisablePerturb) == 0x000048, "Member 'UFANodeTilemapDomainData::bDisablePerturb' has a wrong offset!");
static_assert(offsetof(UFANodeTilemapDomainData, RoomType) == 0x000049, "Member 'UFANodeTilemapDomainData::RoomType' has a wrong offset!");

// Class DungeonArchitectRuntime.GridFlowToolData
// 0x0000 (0x0028 - 0x0028)
class UGridFlowToolData final : public UDungeonToolData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowToolData">();
	}
	static class UGridFlowToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowToolData>();
	}
};
static_assert(alignof(UGridFlowToolData) == 0x000008, "Wrong alignment on UGridFlowToolData");
static_assert(sizeof(UGridFlowToolData) == 0x000028, "Wrong size on UGridFlowToolData");

// Class DungeonArchitectRuntime.GridFlowTransformLogic
// 0x0000 (0x0028 - 0x0028)
class UGridFlowTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class UGridFlowModel* Model, class UGridFlowConfig* Config, class UGridFlowQuery* Query, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridFlowTransformLogic">();
	}
	static class UGridFlowTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridFlowTransformLogic>();
	}
};
static_assert(alignof(UGridFlowTransformLogic) == 0x000008, "Wrong alignment on UGridFlowTransformLogic");
static_assert(sizeof(UGridFlowTransformLogic) == 0x000028, "Wrong size on UGridFlowTransformLogic");

// Class DungeonArchitectRuntime.GridSpatialConstraint2x2
// 0x0010 (0x0040 - 0x0030)
class UGridSpatialConstraint2x2 final : public UDungeonSpatialConstraint
{
public:
	struct FGridSpatialConstraint2x2Data          Configuration;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridSpatialConstraint2x2">();
	}
	static class UGridSpatialConstraint2x2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridSpatialConstraint2x2>();
	}
};
static_assert(alignof(UGridSpatialConstraint2x2) == 0x000008, "Wrong alignment on UGridSpatialConstraint2x2");
static_assert(sizeof(UGridSpatialConstraint2x2) == 0x000040, "Wrong size on UGridSpatialConstraint2x2");
static_assert(offsetof(UGridSpatialConstraint2x2, Configuration) == 0x000030, "Member 'UGridSpatialConstraint2x2::Configuration' has a wrong offset!");

// Class DungeonArchitectRuntime.GridSpatialConstraint3x3
// 0x0010 (0x0040 - 0x0030)
class UGridSpatialConstraint3x3 final : public UDungeonSpatialConstraint
{
public:
	struct FGridSpatialConstraint3x3Data          Configuration;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridSpatialConstraint3x3">();
	}
	static class UGridSpatialConstraint3x3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridSpatialConstraint3x3>();
	}
};
static_assert(alignof(UGridSpatialConstraint3x3) == 0x000008, "Wrong alignment on UGridSpatialConstraint3x3");
static_assert(sizeof(UGridSpatialConstraint3x3) == 0x000040, "Wrong size on UGridSpatialConstraint3x3");
static_assert(offsetof(UGridSpatialConstraint3x3, Configuration) == 0x000030, "Member 'UGridSpatialConstraint3x3::Configuration' has a wrong offset!");

// Class DungeonArchitectRuntime.GridSpatialConstraintEdge
// 0x0010 (0x0040 - 0x0030)
class UGridSpatialConstraintEdge final : public UDungeonSpatialConstraint
{
public:
	struct FGridSpatialConstraintEdgeData         Configuration;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridSpatialConstraintEdge">();
	}
	static class UGridSpatialConstraintEdge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridSpatialConstraintEdge>();
	}
};
static_assert(alignof(UGridSpatialConstraintEdge) == 0x000008, "Wrong alignment on UGridSpatialConstraintEdge");
static_assert(sizeof(UGridSpatialConstraintEdge) == 0x000040, "Wrong size on UGridSpatialConstraintEdge");
static_assert(offsetof(UGridSpatialConstraintEdge, Configuration) == 0x000030, "Member 'UGridSpatialConstraintEdge::Configuration' has a wrong offset!");

// Class DungeonArchitectRuntime.IsaacDungeonBuilder
// 0x0038 (0x00A8 - 0x0070)
class UIsaacDungeonBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonBuilder">();
	}
	static class UIsaacDungeonBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonBuilder>();
	}
};
static_assert(alignof(UIsaacDungeonBuilder) == 0x000008, "Wrong alignment on UIsaacDungeonBuilder");
static_assert(sizeof(UIsaacDungeonBuilder) == 0x0000A8, "Wrong size on UIsaacDungeonBuilder");

// Class DungeonArchitectRuntime.IsaacDungeonConfig
// 0x0040 (0x0088 - 0x0048)
class UIsaacDungeonConfig final : public UDungeonConfig
{
public:
	int32                                         MinRooms;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRooms;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomWidth;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomLength;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TileSize;                                          // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RoomPadding;                                       // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowForwardProbability;                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowSidewaysProbability;                           // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRoomBranchProbability;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CycleProbability;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIsaacRoomLayoutBuilder*                RoomLayoutBuilder;                                 // 0x0080(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, SimpleDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonConfig">();
	}
	static class UIsaacDungeonConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonConfig>();
	}
};
static_assert(alignof(UIsaacDungeonConfig) == 0x000008, "Wrong alignment on UIsaacDungeonConfig");
static_assert(sizeof(UIsaacDungeonConfig) == 0x000088, "Wrong size on UIsaacDungeonConfig");
static_assert(offsetof(UIsaacDungeonConfig, MinRooms) == 0x000048, "Member 'UIsaacDungeonConfig::MinRooms' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, MaxRooms) == 0x00004C, "Member 'UIsaacDungeonConfig::MaxRooms' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, RoomWidth) == 0x000050, "Member 'UIsaacDungeonConfig::RoomWidth' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, RoomLength) == 0x000054, "Member 'UIsaacDungeonConfig::RoomLength' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, TileSize) == 0x000058, "Member 'UIsaacDungeonConfig::TileSize' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, RoomPadding) == 0x000064, "Member 'UIsaacDungeonConfig::RoomPadding' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, GrowForwardProbability) == 0x000070, "Member 'UIsaacDungeonConfig::GrowForwardProbability' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, GrowSidewaysProbability) == 0x000074, "Member 'UIsaacDungeonConfig::GrowSidewaysProbability' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, SpawnRoomBranchProbability) == 0x000078, "Member 'UIsaacDungeonConfig::SpawnRoomBranchProbability' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, CycleProbability) == 0x00007C, "Member 'UIsaacDungeonConfig::CycleProbability' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonConfig, RoomLayoutBuilder) == 0x000080, "Member 'UIsaacDungeonConfig::RoomLayoutBuilder' has a wrong offset!");

// Class DungeonArchitectRuntime.IsaacDungeonModel
// 0x0020 (0x0048 - 0x0028)
class UIsaacDungeonModel final : public UDungeonModel
{
public:
	TArray<struct FIsaacRoom>                     Rooms;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FIsaacDoor>                     Doors;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void RemoveStylingFromRoom(int32 RoomId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonModel">();
	}
	static class UIsaacDungeonModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonModel>();
	}
};
static_assert(alignof(UIsaacDungeonModel) == 0x000008, "Wrong alignment on UIsaacDungeonModel");
static_assert(sizeof(UIsaacDungeonModel) == 0x000048, "Wrong size on UIsaacDungeonModel");
static_assert(offsetof(UIsaacDungeonModel, Rooms) == 0x000028, "Member 'UIsaacDungeonModel::Rooms' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonModel, Doors) == 0x000038, "Member 'UIsaacDungeonModel::Doors' has a wrong offset!");

// Class DungeonArchitectRuntime.IsaacDungeonQuery
// 0x0010 (0x0070 - 0x0060)
class UIsaacDungeonQuery final : public UDungeonQuery
{
public:
	class UIsaacDungeonConfig*                    Config;                                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIsaacDungeonModel*                     Model;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool ContainsDoorBetween(int32 RoomAId, int32 RoomBId);
	void GetFurthestRooms(int32* OutRoomA, int32* OutRoomB);
	struct FVector GetRandomValidPlatform();
	struct FIsaacRoom GetRoom(int32 RoomId);
	struct FVector GetValidPlatformOnRoom(int32 RoomId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonQuery">();
	}
	static class UIsaacDungeonQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonQuery>();
	}
};
static_assert(alignof(UIsaacDungeonQuery) == 0x000010, "Wrong alignment on UIsaacDungeonQuery");
static_assert(sizeof(UIsaacDungeonQuery) == 0x000070, "Wrong size on UIsaacDungeonQuery");
static_assert(offsetof(UIsaacDungeonQuery, Config) == 0x000060, "Member 'UIsaacDungeonQuery::Config' has a wrong offset!");
static_assert(offsetof(UIsaacDungeonQuery, Model) == 0x000068, "Member 'UIsaacDungeonQuery::Model' has a wrong offset!");

// Class DungeonArchitectRuntime.IsaacDungeonSelectorLogic
// 0x0000 (0x0028 - 0x0028)
class UIsaacDungeonSelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool SelectNode(class UIsaacDungeonModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonSelectorLogic">();
	}
	static class UIsaacDungeonSelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonSelectorLogic>();
	}
};
static_assert(alignof(UIsaacDungeonSelectorLogic) == 0x000008, "Wrong alignment on UIsaacDungeonSelectorLogic");
static_assert(sizeof(UIsaacDungeonSelectorLogic) == 0x000028, "Wrong size on UIsaacDungeonSelectorLogic");

// Class DungeonArchitectRuntime.IsaacDungeonToolData
// 0x0010 (0x0038 - 0x0028)
class UIsaacDungeonToolData final : public UDungeonToolData
{
public:
	TArray<struct FIntVector>                     PaintedCells;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonToolData">();
	}
	static class UIsaacDungeonToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonToolData>();
	}
};
static_assert(alignof(UIsaacDungeonToolData) == 0x000008, "Wrong alignment on UIsaacDungeonToolData");
static_assert(sizeof(UIsaacDungeonToolData) == 0x000038, "Wrong size on UIsaacDungeonToolData");
static_assert(offsetof(UIsaacDungeonToolData, PaintedCells) == 0x000028, "Member 'UIsaacDungeonToolData::PaintedCells' has a wrong offset!");

// Class DungeonArchitectRuntime.IsaacDungeonTransformLogic
// 0x0000 (0x0028 - 0x0028)
class UIsaacDungeonTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class UIsaacDungeonModel* Model, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsaacDungeonTransformLogic">();
	}
	static class UIsaacDungeonTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsaacDungeonTransformLogic>();
	}
};
static_assert(alignof(UIsaacDungeonTransformLogic) == 0x000008, "Wrong alignment on UIsaacDungeonTransformLogic");
static_assert(sizeof(UIsaacDungeonTransformLogic) == 0x000028, "Wrong size on UIsaacDungeonTransformLogic");

// Class DungeonArchitectRuntime.PlaceableMarkerAsset
// 0x0018 (0x0040 - 0x0028)
class UPlaceableMarkerAsset final : public UObject
{
public:
	TArray<class FString>                         MarkerNames;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceableMarkerAsset">();
	}
	static class UPlaceableMarkerAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceableMarkerAsset>();
	}
};
static_assert(alignof(UPlaceableMarkerAsset) == 0x000008, "Wrong alignment on UPlaceableMarkerAsset");
static_assert(sizeof(UPlaceableMarkerAsset) == 0x000040, "Wrong size on UPlaceableMarkerAsset");
static_assert(offsetof(UPlaceableMarkerAsset, MarkerNames) == 0x000028, "Member 'UPlaceableMarkerAsset::MarkerNames' has a wrong offset!");
static_assert(offsetof(UPlaceableMarkerAsset, Version) == 0x000038, "Member 'UPlaceableMarkerAsset::Version' has a wrong offset!");

// Class DungeonArchitectRuntime.PlaceableMarkerComponent
// 0x0000 (0x0200 - 0x0200)
class UPlaceableMarkerComponent final : public USceneComponent
{
public:
	class UPlaceableMarkerAsset*                  MarkerAsset;                                       // 0x01F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceableMarkerComponent">();
	}
	static class UPlaceableMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceableMarkerComponent>();
	}
};
static_assert(alignof(UPlaceableMarkerComponent) == 0x000010, "Wrong alignment on UPlaceableMarkerComponent");
static_assert(sizeof(UPlaceableMarkerComponent) == 0x000200, "Wrong size on UPlaceableMarkerComponent");
static_assert(offsetof(UPlaceableMarkerComponent, MarkerAsset) == 0x0001F8, "Member 'UPlaceableMarkerComponent::MarkerAsset' has a wrong offset!");

// Class DungeonArchitectRuntime.PlaceableMarkerActor
// 0x0008 (0x0230 - 0x0228)
class APlaceableMarkerActor final : public AActor
{
public:
	class UPlaceableMarkerComponent*              PlaceableMarkerComponent;                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceableMarkerActor">();
	}
	static class APlaceableMarkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlaceableMarkerActor>();
	}
};
static_assert(alignof(APlaceableMarkerActor) == 0x000008, "Wrong alignment on APlaceableMarkerActor");
static_assert(sizeof(APlaceableMarkerActor) == 0x000230, "Wrong size on APlaceableMarkerActor");
static_assert(offsetof(APlaceableMarkerActor, PlaceableMarkerComponent) == 0x000228, "Member 'APlaceableMarkerActor::PlaceableMarkerComponent' has a wrong offset!");

// Class DungeonArchitectRuntime.SimpleCityBuilder
// 0x0010 (0x0080 - 0x0070)
class USimpleCityBuilder final : public UDungeonBuilder
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityBuilder">();
	}
	static class USimpleCityBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityBuilder>();
	}
};
static_assert(alignof(USimpleCityBuilder) == 0x000008, "Wrong alignment on USimpleCityBuilder");
static_assert(sizeof(USimpleCityBuilder) == 0x000080, "Wrong size on USimpleCityBuilder");

// Class DungeonArchitectRuntime.SimpleCityConfig
// 0x0030 (0x0078 - 0x0048)
class USimpleCityConfig final : public UDungeonConfig
{
public:
	struct FVector2D                              CellSize;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCitySize;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCitySize;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinBlockSize;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBlockSize;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BiggerHouseProbability;                            // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadEdgeRemovalProbability;                        // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCityBlockDimension>            CityBlockDimensions;                               // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityConfig">();
	}
	static class USimpleCityConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityConfig>();
	}
};
static_assert(alignof(USimpleCityConfig) == 0x000008, "Wrong alignment on USimpleCityConfig");
static_assert(sizeof(USimpleCityConfig) == 0x000078, "Wrong size on USimpleCityConfig");
static_assert(offsetof(USimpleCityConfig, CellSize) == 0x000048, "Member 'USimpleCityConfig::CellSize' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, MinCitySize) == 0x000050, "Member 'USimpleCityConfig::MinCitySize' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, MaxCitySize) == 0x000054, "Member 'USimpleCityConfig::MaxCitySize' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, MinBlockSize) == 0x000058, "Member 'USimpleCityConfig::MinBlockSize' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, MaxBlockSize) == 0x00005C, "Member 'USimpleCityConfig::MaxBlockSize' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, BiggerHouseProbability) == 0x000060, "Member 'USimpleCityConfig::BiggerHouseProbability' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, RoadEdgeRemovalProbability) == 0x000064, "Member 'USimpleCityConfig::RoadEdgeRemovalProbability' has a wrong offset!");
static_assert(offsetof(USimpleCityConfig, CityBlockDimensions) == 0x000068, "Member 'USimpleCityConfig::CityBlockDimensions' has a wrong offset!");

// Class DungeonArchitectRuntime.SimpleCityModel
// 0x0018 (0x0040 - 0x0028)
class USimpleCityModel final : public UDungeonModel
{
public:
	int32                                         CityWidth;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CityLength;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSimpleCityCell>                Cells;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityModel">();
	}
	static class USimpleCityModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityModel>();
	}
};
static_assert(alignof(USimpleCityModel) == 0x000008, "Wrong alignment on USimpleCityModel");
static_assert(sizeof(USimpleCityModel) == 0x000040, "Wrong size on USimpleCityModel");
static_assert(offsetof(USimpleCityModel, CityWidth) == 0x000028, "Member 'USimpleCityModel::CityWidth' has a wrong offset!");
static_assert(offsetof(USimpleCityModel, CityLength) == 0x00002C, "Member 'USimpleCityModel::CityLength' has a wrong offset!");
static_assert(offsetof(USimpleCityModel, Cells) == 0x000030, "Member 'USimpleCityModel::Cells' has a wrong offset!");

// Class DungeonArchitectRuntime.SimpleCityQuery
// 0x0000 (0x0060 - 0x0060)
class USimpleCityQuery final : public UDungeonQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityQuery">();
	}
	static class USimpleCityQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityQuery>();
	}
};
static_assert(alignof(USimpleCityQuery) == 0x000010, "Wrong alignment on USimpleCityQuery");
static_assert(sizeof(USimpleCityQuery) == 0x000060, "Wrong size on USimpleCityQuery");

// Class DungeonArchitectRuntime.SimpleCitySelectorLogic
// 0x0000 (0x0028 - 0x0028)
class USimpleCitySelectorLogic final : public UDungeonSelectorLogic
{
public:
	bool SelectNode(class USimpleCityModel* Model);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCitySelectorLogic">();
	}
	static class USimpleCitySelectorLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCitySelectorLogic>();
	}
};
static_assert(alignof(USimpleCitySelectorLogic) == 0x000008, "Wrong alignment on USimpleCitySelectorLogic");
static_assert(sizeof(USimpleCitySelectorLogic) == 0x000028, "Wrong size on USimpleCitySelectorLogic");

// Class DungeonArchitectRuntime.SimpleCitySpatialConstraint3x3
// 0x0010 (0x0040 - 0x0030)
class USimpleCitySpatialConstraint3x3 final : public UDungeonSpatialConstraint
{
public:
	struct FSimpleCitySpatialConstraint3x3Data    Configuration;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCitySpatialConstraint3x3">();
	}
	static class USimpleCitySpatialConstraint3x3* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCitySpatialConstraint3x3>();
	}
};
static_assert(alignof(USimpleCitySpatialConstraint3x3) == 0x000008, "Wrong alignment on USimpleCitySpatialConstraint3x3");
static_assert(sizeof(USimpleCitySpatialConstraint3x3) == 0x000040, "Wrong size on USimpleCitySpatialConstraint3x3");
static_assert(offsetof(USimpleCitySpatialConstraint3x3, Configuration) == 0x000030, "Member 'USimpleCitySpatialConstraint3x3::Configuration' has a wrong offset!");

// Class DungeonArchitectRuntime.SimpleCityToolData
// 0x0010 (0x0038 - 0x0028)
class USimpleCityToolData final : public UDungeonToolData
{
public:
	TArray<struct FIntVector>                     PaintedCells;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityToolData">();
	}
	static class USimpleCityToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityToolData>();
	}
};
static_assert(alignof(USimpleCityToolData) == 0x000008, "Wrong alignment on USimpleCityToolData");
static_assert(sizeof(USimpleCityToolData) == 0x000038, "Wrong size on USimpleCityToolData");
static_assert(offsetof(USimpleCityToolData, PaintedCells) == 0x000028, "Member 'USimpleCityToolData::PaintedCells' has a wrong offset!");

// Class DungeonArchitectRuntime.SimpleCityTransformLogic
// 0x0000 (0x0028 - 0x0028)
class USimpleCityTransformLogic final : public UDungeonTransformLogic
{
public:
	void GetNodeOffset(class USimpleCityModel* Model, struct FTransform* Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCityTransformLogic">();
	}
	static class USimpleCityTransformLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCityTransformLogic>();
	}
};
static_assert(alignof(USimpleCityTransformLogic) == 0x000008, "Wrong alignment on USimpleCityTransformLogic");
static_assert(sizeof(USimpleCityTransformLogic) == 0x000028, "Wrong size on USimpleCityTransformLogic");

// Class DungeonArchitectRuntime.SimpleIsaacRoomLayoutBuilder
// 0x0000 (0x0028 - 0x0028)
class USimpleIsaacRoomLayoutBuilder final : public UIsaacRoomLayoutBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleIsaacRoomLayoutBuilder">();
	}
	static class USimpleIsaacRoomLayoutBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleIsaacRoomLayoutBuilder>();
	}
};
static_assert(alignof(USimpleIsaacRoomLayoutBuilder) == 0x000008, "Wrong alignment on USimpleIsaacRoomLayoutBuilder");
static_assert(sizeof(USimpleIsaacRoomLayoutBuilder) == 0x000028, "Wrong size on USimpleIsaacRoomLayoutBuilder");

// Class DungeonArchitectRuntime.SnapStreamingChunkActorData
// 0x0010 (0x0038 - 0x0028)
class USnapStreamingChunkActorData final : public UObject
{
public:
	TArray<struct FSnapChunkActorDataEntry>       ActorEntries;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapStreamingChunkActorData">();
	}
	static class USnapStreamingChunkActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapStreamingChunkActorData>();
	}
};
static_assert(alignof(USnapStreamingChunkActorData) == 0x000008, "Wrong alignment on USnapStreamingChunkActorData");
static_assert(sizeof(USnapStreamingChunkActorData) == 0x000038, "Wrong size on USnapStreamingChunkActorData");
static_assert(offsetof(USnapStreamingChunkActorData, ActorEntries) == 0x000028, "Member 'USnapStreamingChunkActorData::ActorEntries' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapSerializable
// 0x0000 (0x0028 - 0x0028)
class ISnapSerializable final : public IInterface
{
public:
	void OnSnapDataLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapSerializable">();
	}
	static class ISnapSerializable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISnapSerializable>();
	}
};
static_assert(alignof(ISnapSerializable) == 0x000008, "Wrong alignment on ISnapSerializable");
static_assert(sizeof(ISnapSerializable) == 0x000028, "Wrong size on ISnapSerializable");

// Class DungeonArchitectRuntime.SnapConnectionActor
// 0x0028 (0x0250 - 0x0228)
class ASnapConnectionActor final : public AActor
{
public:
	class USnapConnectionComponent*               ConnectionComponent;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ConnectionId;                                      // 0x0230(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AActor*> GetSpawnedInstances() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapConnectionActor">();
	}
	static class ASnapConnectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASnapConnectionActor>();
	}
};
static_assert(alignof(ASnapConnectionActor) == 0x000008, "Wrong alignment on ASnapConnectionActor");
static_assert(sizeof(ASnapConnectionActor) == 0x000250, "Wrong size on ASnapConnectionActor");
static_assert(offsetof(ASnapConnectionActor, ConnectionComponent) == 0x000228, "Member 'ASnapConnectionActor::ConnectionComponent' has a wrong offset!");
static_assert(offsetof(ASnapConnectionActor, ConnectionId) == 0x000230, "Member 'ASnapConnectionActor::ConnectionId' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapConnectionComponent
// 0x0060 (0x0260 - 0x0200)
class USnapConnectionComponent final : public USceneComponent
{
public:
	class USnapConnectionInfo*                    ConnectionInfo;                                    // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapConnectionState                          ConnectionState;                                   // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapConnectionDoorType                       DoorType;                                          // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerName;                                        // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnOffset;                                       // 0x0220(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESnapConnectionConstraint                     ConnectionConstraint;                              // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0xF];                                      // 0x0251(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapConnectionComponent">();
	}
	static class USnapConnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapConnectionComponent>();
	}
};
static_assert(alignof(USnapConnectionComponent) == 0x000010, "Wrong alignment on USnapConnectionComponent");
static_assert(sizeof(USnapConnectionComponent) == 0x000260, "Wrong size on USnapConnectionComponent");
static_assert(offsetof(USnapConnectionComponent, ConnectionInfo) == 0x0001F8, "Member 'USnapConnectionComponent::ConnectionInfo' has a wrong offset!");
static_assert(offsetof(USnapConnectionComponent, ConnectionState) == 0x000200, "Member 'USnapConnectionComponent::ConnectionState' has a wrong offset!");
static_assert(offsetof(USnapConnectionComponent, DoorType) == 0x000201, "Member 'USnapConnectionComponent::DoorType' has a wrong offset!");
static_assert(offsetof(USnapConnectionComponent, MarkerName) == 0x000208, "Member 'USnapConnectionComponent::MarkerName' has a wrong offset!");
static_assert(offsetof(USnapConnectionComponent, SpawnOffset) == 0x000220, "Member 'USnapConnectionComponent::SpawnOffset' has a wrong offset!");
static_assert(offsetof(USnapConnectionComponent, ConnectionConstraint) == 0x000250, "Member 'USnapConnectionComponent::ConnectionConstraint' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapConnectionInfo
// 0x0148 (0x0170 - 0x0028)
class USnapConnectionInfo final : public UObject
{
public:
	class FName                                   ConnectionCategory;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalDoor;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonThemeAsset*                     ThemeAsset;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapConnectionVisualInfo_DEPRECATED   WallVisuals;                                       // 0x0050(0x0090)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSnapConnectionVisualInfo_DEPRECATED   DoorVisuals;                                       // 0x00E0(0x0090)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapConnectionInfo">();
	}
	static class USnapConnectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapConnectionInfo>();
	}
};
static_assert(alignof(USnapConnectionInfo) == 0x000010, "Wrong alignment on USnapConnectionInfo");
static_assert(sizeof(USnapConnectionInfo) == 0x000170, "Wrong size on USnapConnectionInfo");
static_assert(offsetof(USnapConnectionInfo, ConnectionCategory) == 0x000028, "Member 'USnapConnectionInfo::ConnectionCategory' has a wrong offset!");
static_assert(offsetof(USnapConnectionInfo, bVerticalDoor) == 0x000030, "Member 'USnapConnectionInfo::bVerticalDoor' has a wrong offset!");
static_assert(offsetof(USnapConnectionInfo, ThemeAsset) == 0x000038, "Member 'USnapConnectionInfo::ThemeAsset' has a wrong offset!");
static_assert(offsetof(USnapConnectionInfo, Version) == 0x000040, "Member 'USnapConnectionInfo::Version' has a wrong offset!");
static_assert(offsetof(USnapConnectionInfo, WallVisuals) == 0x000050, "Member 'USnapConnectionInfo::WallVisuals' has a wrong offset!");
static_assert(offsetof(USnapConnectionInfo, DoorVisuals) == 0x0000E0, "Member 'USnapConnectionInfo::DoorVisuals' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapFlowNodeCategorySelectionOverride
// 0x0000 (0x0028 - 0x0028)
class USnapFlowNodeCategorySelectionOverride final : public UObject
{
public:
	bool TryOverrideCategories(int32 PathIndex, int32 PathLength, const TArray<class FName>& ExistingCategories, TArray<class FName>* OutNewCategories);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapFlowNodeCategorySelectionOverride">();
	}
	static class USnapFlowNodeCategorySelectionOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapFlowNodeCategorySelectionOverride>();
	}
};
static_assert(alignof(USnapFlowNodeCategorySelectionOverride) == 0x000008, "Wrong alignment on USnapFlowNodeCategorySelectionOverride");
static_assert(sizeof(USnapFlowNodeCategorySelectionOverride) == 0x000028, "Wrong size on USnapFlowNodeCategorySelectionOverride");

// Class DungeonArchitectRuntime.SnapGridFlowAsset
// 0x0000 (0x0030 - 0x0030)
class USnapGridFlowAsset final : public UFlowAssetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowAsset">();
	}
	static class USnapGridFlowAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowAsset>();
	}
};
static_assert(alignof(USnapGridFlowAsset) == 0x000008, "Wrong alignment on USnapGridFlowAsset");
static_assert(sizeof(USnapGridFlowAsset) == 0x000030, "Wrong size on USnapGridFlowAsset");

// Class DungeonArchitectRuntime.SnapGridFlowModel
// 0x0028 (0x0050 - 0x0028)
class USnapGridFlowModel final : public UDungeonModel
{
public:
	TArray<struct FSnapConnectionInstance>        Connections;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSnapGridFlowModuleInstanceSerializedData> ModuleInstances;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGridFlowAbstractGraph3D*               AbstractGraph;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowModel">();
	}
	static class USnapGridFlowModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowModel>();
	}
};
static_assert(alignof(USnapGridFlowModel) == 0x000008, "Wrong alignment on USnapGridFlowModel");
static_assert(sizeof(USnapGridFlowModel) == 0x000050, "Wrong size on USnapGridFlowModel");
static_assert(offsetof(USnapGridFlowModel, Connections) == 0x000028, "Member 'USnapGridFlowModel::Connections' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModel, ModuleInstances) == 0x000038, "Member 'USnapGridFlowModel::ModuleInstances' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModel, AbstractGraph) == 0x000048, "Member 'USnapGridFlowModel::AbstractGraph' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapGridFlowToolData
// 0x0000 (0x0028 - 0x0028)
class USnapGridFlowToolData final : public UDungeonToolData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowToolData">();
	}
	static class USnapGridFlowToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowToolData>();
	}
};
static_assert(alignof(USnapGridFlowToolData) == 0x000008, "Wrong alignment on USnapGridFlowToolData");
static_assert(sizeof(USnapGridFlowToolData) == 0x000028, "Wrong size on USnapGridFlowToolData");

// Class DungeonArchitectRuntime.SnapGridFlowModuleBoundsAsset
// 0x0030 (0x0058 - 0x0028)
class USnapGridFlowModuleBoundsAsset final : public UObject
{
public:
	struct FVector                                ChunkSize;                                         // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BoundsWireColor;                                   // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DoorColor;                                         // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorOffsetZ;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowModuleBoundsAsset">();
	}
	static class USnapGridFlowModuleBoundsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapGridFlowModuleBoundsAsset>();
	}
};
static_assert(alignof(USnapGridFlowModuleBoundsAsset) == 0x000008, "Wrong alignment on USnapGridFlowModuleBoundsAsset");
static_assert(sizeof(USnapGridFlowModuleBoundsAsset) == 0x000058, "Wrong size on USnapGridFlowModuleBoundsAsset");
static_assert(offsetof(USnapGridFlowModuleBoundsAsset, ChunkSize) == 0x000028, "Member 'USnapGridFlowModuleBoundsAsset::ChunkSize' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleBoundsAsset, BoundsWireColor) == 0x000034, "Member 'USnapGridFlowModuleBoundsAsset::BoundsWireColor' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleBoundsAsset, DoorColor) == 0x000044, "Member 'USnapGridFlowModuleBoundsAsset::DoorColor' has a wrong offset!");
static_assert(offsetof(USnapGridFlowModuleBoundsAsset, DoorOffsetZ) == 0x000054, "Member 'USnapGridFlowModuleBoundsAsset::DoorOffsetZ' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapGridFlowModuleBoundsActor
// 0x0008 (0x0230 - 0x0228)
class ASnapGridFlowModuleBoundsActor final : public AActor
{
public:
	class USnapGridFlowModuleBoundsComponent*     BoundsComponent;                                   // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapGridFlowModuleBoundsActor">();
	}
	static class ASnapGridFlowModuleBoundsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASnapGridFlowModuleBoundsActor>();
	}
};
static_assert(alignof(ASnapGridFlowModuleBoundsActor) == 0x000008, "Wrong alignment on ASnapGridFlowModuleBoundsActor");
static_assert(sizeof(ASnapGridFlowModuleBoundsActor) == 0x000230, "Wrong size on ASnapGridFlowModuleBoundsActor");
static_assert(offsetof(ASnapGridFlowModuleBoundsActor, BoundsComponent) == 0x000228, "Member 'ASnapGridFlowModuleBoundsActor::BoundsComponent' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapAsset
// 0x0008 (0x0030 - 0x0028)
class USnapMapAsset final : public UObject
{
public:
	class UGraphGrammar*                          MissionGrammar;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapAsset">();
	}
	static class USnapMapAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapAsset>();
	}
};
static_assert(alignof(USnapMapAsset) == 0x000008, "Wrong alignment on USnapMapAsset");
static_assert(sizeof(USnapMapAsset) == 0x000030, "Wrong size on USnapMapAsset");
static_assert(offsetof(USnapMapAsset, MissionGrammar) == 0x000028, "Member 'USnapMapAsset::MissionGrammar' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapDungeonConfig
// 0x0028 (0x0070 - 0x0048)
class USnapMapDungeonConfig final : public UDungeonConfig
{
public:
	class USnapMapModuleDatabase*                 ModuleDatabase;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USnapMapAsset*                          DungeonFlowGraph;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowModuleRotations;                             // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollisionTestContraction;                          // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProcessingTimeSecs;                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportBuildRetries;                              // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumBuildRetries;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonConfig">();
	}
	static class USnapMapDungeonConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonConfig>();
	}
};
static_assert(alignof(USnapMapDungeonConfig) == 0x000008, "Wrong alignment on USnapMapDungeonConfig");
static_assert(sizeof(USnapMapDungeonConfig) == 0x000070, "Wrong size on USnapMapDungeonConfig");
static_assert(offsetof(USnapMapDungeonConfig, ModuleDatabase) == 0x000048, "Member 'USnapMapDungeonConfig::ModuleDatabase' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, DungeonFlowGraph) == 0x000050, "Member 'USnapMapDungeonConfig::DungeonFlowGraph' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, bAllowModuleRotations) == 0x000058, "Member 'USnapMapDungeonConfig::bAllowModuleRotations' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, CollisionTestContraction) == 0x00005C, "Member 'USnapMapDungeonConfig::CollisionTestContraction' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, MaxProcessingTimeSecs) == 0x000060, "Member 'USnapMapDungeonConfig::MaxProcessingTimeSecs' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, bSupportBuildRetries) == 0x000064, "Member 'USnapMapDungeonConfig::bSupportBuildRetries' has a wrong offset!");
static_assert(offsetof(USnapMapDungeonConfig, NumBuildRetries) == 0x000068, "Member 'USnapMapDungeonConfig::NumBuildRetries' has a wrong offset!");

// Class DungeonArchitectRuntime.SnapMapDungeonQuery
// 0x0000 (0x0060 - 0x0060)
class USnapMapDungeonQuery final : public UDungeonQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonQuery">();
	}
	static class USnapMapDungeonQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonQuery>();
	}
};
static_assert(alignof(USnapMapDungeonQuery) == 0x000010, "Wrong alignment on USnapMapDungeonQuery");
static_assert(sizeof(USnapMapDungeonQuery) == 0x000060, "Wrong size on USnapMapDungeonQuery");

// Class DungeonArchitectRuntime.SnapMapDungeonToolData
// 0x0000 (0x0028 - 0x0028)
class USnapMapDungeonToolData final : public UDungeonToolData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapMapDungeonToolData">();
	}
	static class USnapMapDungeonToolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapMapDungeonToolData>();
	}
};
static_assert(alignof(USnapMapDungeonToolData) == 0x000008, "Wrong alignment on USnapMapDungeonToolData");
static_assert(sizeof(USnapMapDungeonToolData) == 0x000028, "Wrong size on USnapMapDungeonToolData");

// Class DungeonArchitectRuntime.SnapStreamingChunk
// 0x0088 (0x0180 - 0x00F8)
class USnapStreamingChunk final : public UDungeonStreamingChunk
{
public:
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ModuleTransform;                                   // 0x0140(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USnapStreamingChunkActorData*           SerializedData;                                    // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapStreamingChunk">();
	}
	static class USnapStreamingChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapStreamingChunk>();
	}
};
static_assert(alignof(USnapStreamingChunk) == 0x000010, "Wrong alignment on USnapStreamingChunk");
static_assert(sizeof(USnapStreamingChunk) == 0x000180, "Wrong size on USnapStreamingChunk");
static_assert(offsetof(USnapStreamingChunk, ModuleTransform) == 0x000140, "Member 'USnapStreamingChunk::ModuleTransform' has a wrong offset!");
static_assert(offsetof(USnapStreamingChunk, SerializedData) == 0x000170, "Member 'USnapStreamingChunk::SerializedData' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameEx

#include "Basic.hpp"

#include "GameCore_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameEx_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameLogicTree_structs.hpp"
#include "GameLogicTree_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class GameEx.GEDrop
// 0x0008 (0x0230 - 0x0228)
class AGEDrop : public AActor
{
public:
	int32                                         DropId;                                            // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MgrNotifyChangeMat();
	void MgrNotifyDestroy();
	void MgrNotifyReset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEDrop">();
	}
	static class AGEDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEDrop>();
	}
};
static_assert(alignof(AGEDrop) == 0x000008, "Wrong alignment on AGEDrop");
static_assert(sizeof(AGEDrop) == 0x000230, "Wrong size on AGEDrop");
static_assert(offsetof(AGEDrop, DropId) == 0x000228, "Member 'AGEDrop::DropId' has a wrong offset!");

// Class GameEx.GERotateBrick
// 0x0060 (0x0290 - 0x0230)
class AGERotateBrick final : public AGEDrop
{
public:
	int32                                         SmoothMaxCount;                                    // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGERotateBrickState                           BrickState;                                        // 0x0234(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              NormalStateDurRange;                               // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CurNormalStateDurRange;                            // 0x0240(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0248(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextActionTime;                                    // 0x024C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngle;                                       // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CumuRotateAngle;                                   // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeMatTime;                                     // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBrickRotateType                            RotateType;                                        // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRepByMgr;                                        // 0x0261(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262[0x2];                                      // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SyncCurveTimeToClientDur;                          // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Client_TargetRot;                                  // 0x0268(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGERotateBrickManager>   Mgr;                                               // 0x0274(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClientFinishRotate;                              // 0x027C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x13];                                     // 0x027D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BrickState();
	void SetBrickState(EGERotateBrickState InState);
	void SetEffectMat(int32 EffectType);
	void SyncRotateFinish(float CurAngle);
	void SyncStartRotateTime(float CurTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GERotateBrick">();
	}
	static class AGERotateBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGERotateBrick>();
	}
};
static_assert(alignof(AGERotateBrick) == 0x000008, "Wrong alignment on AGERotateBrick");
static_assert(sizeof(AGERotateBrick) == 0x000290, "Wrong size on AGERotateBrick");
static_assert(offsetof(AGERotateBrick, SmoothMaxCount) == 0x000230, "Member 'AGERotateBrick::SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, BrickState) == 0x000234, "Member 'AGERotateBrick::BrickState' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, NormalStateDurRange) == 0x000238, "Member 'AGERotateBrick::NormalStateDurRange' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, CurNormalStateDurRange) == 0x000240, "Member 'AGERotateBrick::CurNormalStateDurRange' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, Timer) == 0x000248, "Member 'AGERotateBrick::Timer' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, NextActionTime) == 0x00024C, "Member 'AGERotateBrick::NextActionTime' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, RotateSpeed) == 0x000250, "Member 'AGERotateBrick::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, RotateAngle) == 0x000254, "Member 'AGERotateBrick::RotateAngle' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, CumuRotateAngle) == 0x000258, "Member 'AGERotateBrick::CumuRotateAngle' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, ChangeMatTime) == 0x00025C, "Member 'AGERotateBrick::ChangeMatTime' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, RotateType) == 0x000260, "Member 'AGERotateBrick::RotateType' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, IsRepByMgr) == 0x000261, "Member 'AGERotateBrick::IsRepByMgr' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, SyncCurveTimeToClientDur) == 0x000264, "Member 'AGERotateBrick::SyncCurveTimeToClientDur' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, Client_TargetRot) == 0x000268, "Member 'AGERotateBrick::Client_TargetRot' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, Mgr) == 0x000274, "Member 'AGERotateBrick::Mgr' has a wrong offset!");
static_assert(offsetof(AGERotateBrick, IsClientFinishRotate) == 0x00027C, "Member 'AGERotateBrick::IsClientFinishRotate' has a wrong offset!");

// Class GameEx.AnimNtf_GECharTiming
// 0x0008 (0x0040 - 0x0038)
class UAnimNtf_GECharTiming final : public UAnimNotify
{
public:
	int32                                         TimingId;                                          // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNtf_GECharTiming">();
	}
	static class UAnimNtf_GECharTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNtf_GECharTiming>();
	}
};
static_assert(alignof(UAnimNtf_GECharTiming) == 0x000008, "Wrong alignment on UAnimNtf_GECharTiming");
static_assert(sizeof(UAnimNtf_GECharTiming) == 0x000040, "Wrong size on UAnimNtf_GECharTiming");
static_assert(offsetof(UAnimNtf_GECharTiming, TimingId) == 0x000038, "Member 'UAnimNtf_GECharTiming::TimingId' has a wrong offset!");

// Class GameEx.GEScripteEventMgr
// 0x01E8 (0x0210 - 0x0028)
class UGEScripteEventMgr final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickTSDur;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x88];                                      // 0x0034(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UWorld* InWorld, ETravelFailure FailureType, const class FString& ErrorString)> TravelFailureMessagesDelegate;                     // 0x00BC(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UWorld* InWorld, ENetworkFailure FailureType, const class FString& ErrorString)> NetworkFailureMessagesDelegate;                    // 0x00CC(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UWorld* InWorld, class UNetDriver* NetDriver)> HandleDisconnectDelegate;                          // 0x00DC(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             EngineTickDelegate;                                // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameTickDelegate;                                  // 0x0100(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameShutDownDelegate;                              // 0x0110(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& A)>       MapLoadBeginDelegate;                              // 0x0120(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UWorld* A)>              MapLoadCompleteDelegate;                           // 0x0130(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(float LoadTime, const class FString& MapName)> GameInstanceLoadCompleteDelegate;                  // 0x0140(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventToTsDelegate;                                 // 0x0150(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        TempArr;                                           // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TempVectorArray;                                   // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TempActorArray;                                    // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorBeginPlayToTsDelegate;                      // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorEndPlayToTsDelegate;                        // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class AGEGameModeBase* GameModeBase, const class FString& MapName, const class FString& Options, class FString* ErrorMessage)> InitGameDelegate;                                  // 0x01B0(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, class AActor*>                    GEActorExComActors;                                // 0x01C0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static void DelInstance();
	static class FString GetActorExComLuaTableName();
	static class FString GetGameModeLuaTableName();
	static class UGEScripteEventMgr* GetInstance();
	static class FString GetScripMgrLuaTableName();
	static void SetScripMgrLuaTableName(const class FString& Name_0);

	void ActorBeginPlayToTSDeleagte__DelegateSignature(const class AActor* Actor);
	void ActorEndPlayToTSDeleagte__DelegateSignature(const class AActor* Actor, const EEndPlayReason EndPlayReason);
	void AddGEActor(int32 ServerID, class AActor* Actor);
	void EventToTSDeleagte__DelegateSignature(const class FString& EventCmd, const class FString& Params_0);
	void GameInstanceLoadCompleteDelegate__DelegateSignature(float LoadTime, const class FString& MapName);
	class UGameInstance* GetGameInstance();
	class AActor* GetGEActorByServerID(int32 ServerID, class UWorld* World);
	void HandleDisconnect__DelegateSignature(class UWorld* InWorld, class UNetDriver* NetDriver);
	void InitGameDelegate__DelegateSignature(class AGEGameModeBase* GameModeBase, const class FString& MapName, const class FString& Options, class FString* ErrorMessage);
	void LevelLoadBeginDelgate__DelegateSignature(const class FString& A);
	void LevelLoadEndDelgate__DelegateSignature(class UWorld* A);
	void NotifyToTSEvent(const class FString& Cmd, const class FString& Param);
	void NotifyWithFloat__DelegateSignature(float Deatl);
	void NotifyWithNothing__DelegateSignature();
	void OnActorBeginPlay(class AActor* Actor);
	void OnActorEndPlay(class AActor* Actor, const EEndPlayReason EndPlayReason);
	void OnStart(class UGameInstance* Ins);
	void PeekNetworkFailureMessagesDelegate__DelegateSignature(class UWorld* InWorld, ENetworkFailure FailureType, const class FString& ErrorString);
	void PeekTravelFailureMessagesDelegate__DelegateSignature(class UWorld* InWorld, ETravelFailure FailureType, const class FString& ErrorString);
	void RemoveGEActor(int32 ServerID, class UWorld* World);
	void RemoveLuaTable(const class FString& TableName);
	void SetDebugWaiting();
	void SetLuaTable(const class FString& TableName, const class FString& GetFunName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEScripteEventMgr">();
	}
	static class UGEScripteEventMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEScripteEventMgr>();
	}
};
static_assert(alignof(UGEScripteEventMgr) == 0x000008, "Wrong alignment on UGEScripteEventMgr");
static_assert(sizeof(UGEScripteEventMgr) == 0x000210, "Wrong size on UGEScripteEventMgr");
static_assert(offsetof(UGEScripteEventMgr, TickTSDur) == 0x000030, "Member 'UGEScripteEventMgr::TickTSDur' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, TravelFailureMessagesDelegate) == 0x0000BC, "Member 'UGEScripteEventMgr::TravelFailureMessagesDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, NetworkFailureMessagesDelegate) == 0x0000CC, "Member 'UGEScripteEventMgr::NetworkFailureMessagesDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, HandleDisconnectDelegate) == 0x0000DC, "Member 'UGEScripteEventMgr::HandleDisconnectDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, EngineTickDelegate) == 0x0000F0, "Member 'UGEScripteEventMgr::EngineTickDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, GameTickDelegate) == 0x000100, "Member 'UGEScripteEventMgr::GameTickDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, GameShutDownDelegate) == 0x000110, "Member 'UGEScripteEventMgr::GameShutDownDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, MapLoadBeginDelegate) == 0x000120, "Member 'UGEScripteEventMgr::MapLoadBeginDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, MapLoadCompleteDelegate) == 0x000130, "Member 'UGEScripteEventMgr::MapLoadCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, GameInstanceLoadCompleteDelegate) == 0x000140, "Member 'UGEScripteEventMgr::GameInstanceLoadCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, EventToTsDelegate) == 0x000150, "Member 'UGEScripteEventMgr::EventToTsDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, TempArr) == 0x000160, "Member 'UGEScripteEventMgr::TempArr' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, TempVectorArray) == 0x000170, "Member 'UGEScripteEventMgr::TempVectorArray' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, TempActorArray) == 0x000180, "Member 'UGEScripteEventMgr::TempActorArray' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, OnActorBeginPlayToTsDelegate) == 0x000190, "Member 'UGEScripteEventMgr::OnActorBeginPlayToTsDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, OnActorEndPlayToTsDelegate) == 0x0001A0, "Member 'UGEScripteEventMgr::OnActorEndPlayToTsDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, InitGameDelegate) == 0x0001B0, "Member 'UGEScripteEventMgr::InitGameDelegate' has a wrong offset!");
static_assert(offsetof(UGEScripteEventMgr, GEActorExComActors) == 0x0001C0, "Member 'UGEScripteEventMgr::GEActorExComActors' has a wrong offset!");

// Class GameEx.GEAbilityAttributeSettings
// 0x0198 (0x01C0 - 0x0028)
class UGEAbilityAttributeSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FGEAbilityAttribute> DefaultAbilityAttributes;                          // 0x0030(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TMap<struct FGECharLevelAttributeTemplateKey, struct FGECharLevelAttributeTemplate> CharLevelAttributesTemplates;                      // 0x0080(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	TMap<int32, struct FGEWeaponAttributeTemplate> WeaponAttributesTemplates;                         // 0x00D0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0xA0];                                     // 0x0120(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAbilityAttributeSettings">();
	}
	static class UGEAbilityAttributeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAbilityAttributeSettings>();
	}
};
static_assert(alignof(UGEAbilityAttributeSettings) == 0x000008, "Wrong alignment on UGEAbilityAttributeSettings");
static_assert(sizeof(UGEAbilityAttributeSettings) == 0x0001C0, "Wrong size on UGEAbilityAttributeSettings");
static_assert(offsetof(UGEAbilityAttributeSettings, DefaultAbilityAttributes) == 0x000030, "Member 'UGEAbilityAttributeSettings::DefaultAbilityAttributes' has a wrong offset!");
static_assert(offsetof(UGEAbilityAttributeSettings, CharLevelAttributesTemplates) == 0x000080, "Member 'UGEAbilityAttributeSettings::CharLevelAttributesTemplates' has a wrong offset!");
static_assert(offsetof(UGEAbilityAttributeSettings, WeaponAttributesTemplates) == 0x0000D0, "Member 'UGEAbilityAttributeSettings::WeaponAttributesTemplates' has a wrong offset!");

// Class GameEx.GESideBySideActor
// 0x0028 (0x0250 - 0x0228)
class AGESideBySideActor final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorTag;                                          // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CustomDataArr;                                     // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGESideBySideType                             ActionType;                                        // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LuaImpl_DoSideBySideAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GESideBySideActor">();
	}
	static class AGESideBySideActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGESideBySideActor>();
	}
};
static_assert(alignof(AGESideBySideActor) == 0x000008, "Wrong alignment on AGESideBySideActor");
static_assert(sizeof(AGESideBySideActor) == 0x000250, "Wrong size on AGESideBySideActor");
static_assert(offsetof(AGESideBySideActor, ActorTag) == 0x000230, "Member 'AGESideBySideActor::ActorTag' has a wrong offset!");
static_assert(offsetof(AGESideBySideActor, CustomDataArr) == 0x000238, "Member 'AGESideBySideActor::CustomDataArr' has a wrong offset!");
static_assert(offsetof(AGESideBySideActor, ActionType) == 0x000248, "Member 'AGESideBySideActor::ActionType' has a wrong offset!");

// Class GameEx.GETrapBase
// 0x0020 (0x0248 - 0x0228)
class AGETrapBase : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsActivate;                                        // 0x0238(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  SpawnedBy;                                         // 0x023C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LuaImpl_Activate();
	void LuaImpl_DeActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GETrapBase">();
	}
	static class AGETrapBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGETrapBase>();
	}
};
static_assert(alignof(AGETrapBase) == 0x000008, "Wrong alignment on AGETrapBase");
static_assert(sizeof(AGETrapBase) == 0x000248, "Wrong size on AGETrapBase");
static_assert(offsetof(AGETrapBase, IsActivate) == 0x000238, "Member 'AGETrapBase::IsActivate' has a wrong offset!");
static_assert(offsetof(AGETrapBase, SpawnedBy) == 0x00023C, "Member 'AGETrapBase::SpawnedBy' has a wrong offset!");

// Class GameEx.GESkillLibrary
// 0x0000 (0x0028 - 0x0028)
class UGESkillLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanAddStoreCount(class AController* InController, int32 InIndex);
	static TArray<int32> GetAllBuffIdByCharTeam(class APawn* InPawn);
	static void GetAllSkillInfo(TArray<struct FGESkillInfo>* InArr);
	static TArray<float> GetBuffDesParam(int32 BuffId, int32 Level);
	static TArray<int32> GetBuffFromCount(int32 Count, class APawn* InPawn, bool IsHero);
	static struct FGEBuffInfo GetBuffInfoByID(int32 InId);
	static TArray<int32> GetBuffLevelParam(int32 BuffId, int32 Level);
	static struct FSoftObjectPath GetBuffPath(int32 InId);
	static int32 GetOwnBuffLevel(int32 InBuffId, class APawn* InPawn);
	static struct FGESkillEquipInfo GetSkillEquipData(class AController* InController, int32 InIndex);
	static struct FGESkillInfo GetSkillInfo(int32 InId);
	static struct FSoftObjectPath GetSkillPath(int32 InId);
	static bool IsUseable(class AController* InController, int32 InIndex);
	static void ModifySkillReduceCD(class AGEPlayerState* Ps, int32 InIndex, float InReduceValue);
	static void ModifySkillStoreCount(class AGEGameCharacter* Char, int32 InIndex, int32 InAddCount);
	static void SetIsUsed(class AController* InController, int32 InIndex);
	static void SetSkillEquipData(class AController* InController, int32 InIndex, const struct FGESkillEquipInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GESkillLibrary">();
	}
	static class UGESkillLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGESkillLibrary>();
	}
};
static_assert(alignof(UGESkillLibrary) == 0x000008, "Wrong alignment on UGESkillLibrary");
static_assert(sizeof(UGESkillLibrary) == 0x000028, "Wrong size on UGESkillLibrary");

// Class GameEx.GEAccelerateTrap
// 0x0008 (0x0250 - 0x0248)
class AGEAccelerateTrap final : public AGETrapBase
{
public:
	float                                         AcceleRate;                                        // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAccelerateTrap">();
	}
	static class AGEAccelerateTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEAccelerateTrap>();
	}
};
static_assert(alignof(AGEAccelerateTrap) == 0x000008, "Wrong alignment on AGEAccelerateTrap");
static_assert(sizeof(AGEAccelerateTrap) == 0x000250, "Wrong size on AGEAccelerateTrap");
static_assert(offsetof(AGEAccelerateTrap, AcceleRate) == 0x000248, "Member 'AGEAccelerateTrap::AcceleRate' has a wrong offset!");

// Class GameEx.GESplineConveyorComponent
// 0x0180 (0x0230 - 0x00B0)
class UGESplineConveyorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowLog;                                          // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineLength;                                      // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMoveCD;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveCompleteTime;                                  // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleDes;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSmooth;                                        // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SmoothMaxCount;                                    // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplineComponentName;                               // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SceneComponentName;                                // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncCurveTimeToClientDur;                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurTime;                                           // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanMove;                                           // 0x012C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    MoveActors;                                        // 0x0130(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AttachedActors;                                    // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x8C];                                     // 0x0190(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class AActor* Actor)>          StartmoveDelegate;                                 // 0x021C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMoveActor(class AActor* Actor, float StartLen, bool bCheckRepeat);
	void SetMoveValue(float Time, int64 ServertimeMilli);
	void StartmoveDelegate__DelegateSignature(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GESplineConveyorComponent">();
	}
	static class UGESplineConveyorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGESplineConveyorComponent>();
	}
};
static_assert(alignof(UGESplineConveyorComponent) == 0x000008, "Wrong alignment on UGESplineConveyorComponent");
static_assert(sizeof(UGESplineConveyorComponent) == 0x000230, "Wrong size on UGESplineConveyorComponent");
static_assert(offsetof(UGESplineConveyorComponent, bShowLog) == 0x0000C8, "Member 'UGESplineConveyorComponent::bShowLog' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SplineComponent) == 0x0000D0, "Member 'UGESplineConveyorComponent::SplineComponent' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SceneComponent) == 0x0000D8, "Member 'UGESplineConveyorComponent::SceneComponent' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SplineLength) == 0x0000E0, "Member 'UGESplineConveyorComponent::SplineLength' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, bEnable) == 0x0000E4, "Member 'UGESplineConveyorComponent::bEnable' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, StartMoveCD) == 0x0000E8, "Member 'UGESplineConveyorComponent::StartMoveCD' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, MoveCompleteTime) == 0x0000EC, "Member 'UGESplineConveyorComponent::MoveCompleteTime' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, VisibleDes) == 0x0000F0, "Member 'UGESplineConveyorComponent::VisibleDes' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, bUseSmooth) == 0x0000F4, "Member 'UGESplineConveyorComponent::bUseSmooth' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SmoothMaxCount) == 0x0000F8, "Member 'UGESplineConveyorComponent::SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, bSweep) == 0x0000FC, "Member 'UGESplineConveyorComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, bTeleport) == 0x0000FD, "Member 'UGESplineConveyorComponent::bTeleport' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SplineComponentName) == 0x000100, "Member 'UGESplineConveyorComponent::SplineComponentName' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SceneComponentName) == 0x000110, "Member 'UGESplineConveyorComponent::SceneComponentName' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, SyncCurveTimeToClientDur) == 0x000120, "Member 'UGESplineConveyorComponent::SyncCurveTimeToClientDur' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, CurTime) == 0x000124, "Member 'UGESplineConveyorComponent::CurTime' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, TotalTime) == 0x000128, "Member 'UGESplineConveyorComponent::TotalTime' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, CanMove) == 0x00012C, "Member 'UGESplineConveyorComponent::CanMove' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, MoveActors) == 0x000130, "Member 'UGESplineConveyorComponent::MoveActors' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, AttachedActors) == 0x000180, "Member 'UGESplineConveyorComponent::AttachedActors' has a wrong offset!");
static_assert(offsetof(UGESplineConveyorComponent, StartmoveDelegate) == 0x00021C, "Member 'UGESplineConveyorComponent::StartmoveDelegate' has a wrong offset!");

// Class GameEx.GEActorExComponent
// 0x0168 (0x0218 - 0x00B0)
class UGEActorExComponent final : public UActorComponent
{
public:
	TDelegate<void()>                             BeginPlayDelegate;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(EEndPlayReason Reason)>        EndPlayDelegate;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(float Dt)>                     TickDelegate;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& FunName, const class FString& Param)> OnCallTSFunDelegate;                               // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ServerID;                                          // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CustomDataString;                                  // 0x00F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CustomDataNumber;                                  // 0x0148(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         UserID;                                            // 0x0198(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             UserIDChangeDelegate;                              // 0x019C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CharID;                                            // 0x01AC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             CharIDChangeDelegate;                              // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EntityType;                                        // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfID;                                            // 0x01C4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ConfIDChangeDelegate;                              // 0x01C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 MainID, int32 SubId, const class FString& Data)> FNotifyMsgDelegate;                                // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 TypeId, int32 SubId)>    FNotifyActorMsgDelegate;                           // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 DataIndex, int32 DataValue)> FNotifyActorCustomDataDelegate;                    // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CustomRepData1;                                    // 0x0208(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomRepData2;                                    // 0x020C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomRepData3;                                    // 0x0210(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetAllServerID(int32 ID);

	void CallLuaFun(const class FString& FucName, const class FString& FunParam);
	void CallLuaFunByDelegate(const class FString& FunName, const class FString& Param);
	void CharIDChangeDelegate__DelegateSignature();
	void ConfIDChangeDelegate__DelegateSignature();
	int32 GetCharID();
	int32 GetConfID();
	int32 GetDataInt(const class FString& Key);
	class FString GetDataString(const class FString& Key);
	int32 GetEntityType();
	int32 GetServerID();
	int32 GetUserID();
	void NotifyActorCustomData__DelegateSignature(int32 DataIndex, int32 DataValue);
	void NotifyActorMsg__DelegateSignature(int32 TypeId, int32 SubId);
	void NotifyActorMsg_Client(int32 TypeId, int32 SubId);
	void NotifyActorMsg_Client_Unreliable(int32 TypeId, int32 SubId);
	void NotifyActorMsg_NetMulticast(int32 TypeId, int32 SubId);
	void NotifyActorMsg_NetMulticast_Unreliable(int32 TypeId, int32 SubId);
	void NotifyActorMsg_Server(int32 TypeId, int32 SubId);
	void NotifyActorMsg_Server_Unreliable(int32 TypeId, int32 SubId);
	void NotifyMsg__DelegateSignature(int32 MainID, int32 SubId, const class FString& Data);
	void NotifyMsg_Client(int32 MainID, int32 SubId, const class FString& Data);
	void NotifyMsg_Client_Unreliable(int32 MainID, int32 SubId, const class FString& Data);
	void NotifyMsg_NetMulticast(int32 MainID, int32 SubId, const class FString& Value);
	void NotifyMsg_NetMulticast_Unreliable(int32 MainID, int32 SubId, const class FString& Value);
	void NotifyMsg_Server(int32 MainID, int32 SubId, const class FString& Data);
	void NotifyMsg_Server_Unreliable(int32 MainID, int32 SubId, const class FString& Data);
	void OnCustomChanged1();
	void OnCustomChanged2();
	void OnCustomChanged3();
	void OnRep_CharID();
	void OnRep_ConfID();
	void OnRep_ServerID();
	void OnRep_UserID();
	void PrintID(class FString* Tag);
	void SetCharID(int32 ICharid);
	void SetConfID(int32 IConfID);
	void SetCustomRepData(int32 DataIndex, int32 DataValue);
	void SetDataInt(const class FString& Key, int32 Value);
	void SetDataString(const class FString& Key, const class FString& Value);
	void SetEntityType(int32 IentityType);
	void SetUserID(int32 IUserid);
	void UserIDChangeDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEActorExComponent">();
	}
	static class UGEActorExComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEActorExComponent>();
	}
};
static_assert(alignof(UGEActorExComponent) == 0x000008, "Wrong alignment on UGEActorExComponent");
static_assert(sizeof(UGEActorExComponent) == 0x000218, "Wrong size on UGEActorExComponent");
static_assert(offsetof(UGEActorExComponent, BeginPlayDelegate) == 0x0000B0, "Member 'UGEActorExComponent::BeginPlayDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, EndPlayDelegate) == 0x0000C0, "Member 'UGEActorExComponent::EndPlayDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, TickDelegate) == 0x0000D0, "Member 'UGEActorExComponent::TickDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, OnCallTSFunDelegate) == 0x0000E0, "Member 'UGEActorExComponent::OnCallTSFunDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, ServerID) == 0x0000F0, "Member 'UGEActorExComponent::ServerID' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CustomDataString) == 0x0000F8, "Member 'UGEActorExComponent::CustomDataString' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CustomDataNumber) == 0x000148, "Member 'UGEActorExComponent::CustomDataNumber' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, UserID) == 0x000198, "Member 'UGEActorExComponent::UserID' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, UserIDChangeDelegate) == 0x00019C, "Member 'UGEActorExComponent::UserIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CharID) == 0x0001AC, "Member 'UGEActorExComponent::CharID' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CharIDChangeDelegate) == 0x0001B0, "Member 'UGEActorExComponent::CharIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, EntityType) == 0x0001C0, "Member 'UGEActorExComponent::EntityType' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, ConfID) == 0x0001C4, "Member 'UGEActorExComponent::ConfID' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, ConfIDChangeDelegate) == 0x0001C8, "Member 'UGEActorExComponent::ConfIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, FNotifyMsgDelegate) == 0x0001D8, "Member 'UGEActorExComponent::FNotifyMsgDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, FNotifyActorMsgDelegate) == 0x0001E8, "Member 'UGEActorExComponent::FNotifyActorMsgDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, FNotifyActorCustomDataDelegate) == 0x0001F8, "Member 'UGEActorExComponent::FNotifyActorCustomDataDelegate' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CustomRepData1) == 0x000208, "Member 'UGEActorExComponent::CustomRepData1' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CustomRepData2) == 0x00020C, "Member 'UGEActorExComponent::CustomRepData2' has a wrong offset!");
static_assert(offsetof(UGEActorExComponent, CustomRepData3) == 0x000210, "Member 'UGEActorExComponent::CustomRepData3' has a wrong offset!");

// Class GameEx.GESplineMoveComponent
// 0x01A0 (0x0250 - 0x00B0)
class UGESplineMoveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowLog;                                          // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineComponent*>               SplineComponents;                                  // 0x00C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USceneComponent*                        Mesh;                                              // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FocusActor;                                        // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineLength;                                      // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* Actor)>          MoveCompleteDelegate;                              // 0x00E4(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             SelfMoveCompleteDelegate;                          // 0x00F4(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0104(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoopMove;                                          // 0x0108(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSelfMove;                                        // 0x0109(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopDelay;                                         // 0x010C(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SynThreshold;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateRotate;                                      // 0x0114(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ForceRotation;                                     // 0x0118(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NetWokrDelayOptimize;                              // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseScale;                                          // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x012A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B[0x5];                                      // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SplineComponentName;                               // 0x0130(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SplineComponentNames;                              // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 MoveComponentName;                                 // 0x0150(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncCurveTimeToClientDur;                          // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForward;                                         // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopDelayTimer;                                    // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveValue;                                         // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    MoveActors;                                        // 0x0170(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x90];                                     // 0x01C0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMoveActor(class AActor* Actor, float StartLen, bool bCheckRepeat);
	void MoveCompleteDelegate__DelegateSignature(class AActor* Actor);
	void OnRep_MoveValue();
	void SelfMoveComplete__DelegateSignature();
	void SetisSelfMove(bool Selfmove);
	void SetMoveValue(float Time, int64 ServertimeMilli);
	void UpdateSelfMeshLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GESplineMoveComponent">();
	}
	static class UGESplineMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGESplineMoveComponent>();
	}
};
static_assert(alignof(UGESplineMoveComponent) == 0x000008, "Wrong alignment on UGESplineMoveComponent");
static_assert(sizeof(UGESplineMoveComponent) == 0x000250, "Wrong size on UGESplineMoveComponent");
static_assert(offsetof(UGESplineMoveComponent, bShowLog) == 0x0000B4, "Member 'UGESplineMoveComponent::bShowLog' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SplineComponent) == 0x0000B8, "Member 'UGESplineMoveComponent::SplineComponent' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SplineComponents) == 0x0000C0, "Member 'UGESplineMoveComponent::SplineComponents' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, Mesh) == 0x0000D0, "Member 'UGESplineMoveComponent::Mesh' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, FocusActor) == 0x0000D8, "Member 'UGESplineMoveComponent::FocusActor' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SplineLength) == 0x0000E0, "Member 'UGESplineMoveComponent::SplineLength' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, MoveCompleteDelegate) == 0x0000E4, "Member 'UGESplineMoveComponent::MoveCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SelfMoveCompleteDelegate) == 0x0000F4, "Member 'UGESplineMoveComponent::SelfMoveCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, MoveSpeed) == 0x000104, "Member 'UGESplineMoveComponent::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, LoopMove) == 0x000108, "Member 'UGESplineMoveComponent::LoopMove' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, IsSelfMove) == 0x000109, "Member 'UGESplineMoveComponent::IsSelfMove' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, LoopDelay) == 0x00010C, "Member 'UGESplineMoveComponent::LoopDelay' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SynThreshold) == 0x000110, "Member 'UGESplineMoveComponent::SynThreshold' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, UpdateRotate) == 0x000114, "Member 'UGESplineMoveComponent::UpdateRotate' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, ForceRotation) == 0x000118, "Member 'UGESplineMoveComponent::ForceRotation' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, NetWokrDelayOptimize) == 0x000124, "Member 'UGESplineMoveComponent::NetWokrDelayOptimize' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, UseScale) == 0x000128, "Member 'UGESplineMoveComponent::UseScale' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, bSweep) == 0x000129, "Member 'UGESplineMoveComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, bTeleport) == 0x00012A, "Member 'UGESplineMoveComponent::bTeleport' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SplineComponentName) == 0x000130, "Member 'UGESplineMoveComponent::SplineComponentName' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SplineComponentNames) == 0x000140, "Member 'UGESplineMoveComponent::SplineComponentNames' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, MoveComponentName) == 0x000150, "Member 'UGESplineMoveComponent::MoveComponentName' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, SyncCurveTimeToClientDur) == 0x000160, "Member 'UGESplineMoveComponent::SyncCurveTimeToClientDur' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, IsForward) == 0x000164, "Member 'UGESplineMoveComponent::IsForward' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, LoopDelayTimer) == 0x000168, "Member 'UGESplineMoveComponent::LoopDelayTimer' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, MoveValue) == 0x00016C, "Member 'UGESplineMoveComponent::MoveValue' has a wrong offset!");
static_assert(offsetof(UGESplineMoveComponent, MoveActors) == 0x000170, "Member 'UGESplineMoveComponent::MoveActors' has a wrong offset!");

// Class GameEx.WaterParkCollectAIModifyCom
// 0x0020 (0x04A0 - 0x0480)
#pragma pack(push, 0x1)
class alignas(0x10) UWaterParkCollectAIModifyCom : public UBoxComponent
{
public:
	int32                                         AreaId;                                            // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CalOrder;                                          // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0xF];                                      // 0x0489(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsOverLap(struct FVector* Pos);
	void ModifyMoveVec_Bp(struct FVector* MoveVec, struct FVector* NowPos, bool* CanJump, bool* ShouldJump, float DeltaTime, class AGEAIController* TargetAIController);
	void SetIsValid(bool InNewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterParkCollectAIModifyCom">();
	}
	static class UWaterParkCollectAIModifyCom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterParkCollectAIModifyCom>();
	}
};
#pragma pack(pop)
static_assert(alignof(UWaterParkCollectAIModifyCom) == 0x000010, "Wrong alignment on UWaterParkCollectAIModifyCom");
static_assert(sizeof(UWaterParkCollectAIModifyCom) == 0x0004A0, "Wrong size on UWaterParkCollectAIModifyCom");
static_assert(offsetof(UWaterParkCollectAIModifyCom, AreaId) == 0x000480, "Member 'UWaterParkCollectAIModifyCom::AreaId' has a wrong offset!");
static_assert(offsetof(UWaterParkCollectAIModifyCom, CalOrder) == 0x000484, "Member 'UWaterParkCollectAIModifyCom::CalOrder' has a wrong offset!");
static_assert(offsetof(UWaterParkCollectAIModifyCom, bActive) == 0x000488, "Member 'UWaterParkCollectAIModifyCom::bActive' has a wrong offset!");

// Class GameEx.GESystem
// 0x0018 (0x0048 - 0x0030)
class UGESystem final : public UWorldSubsystem
{
public:
	TWeakObjectPtr<class AGEItemMgr>              ItemMgr;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGEHideAndSeekMgr>       HASMgr;                                            // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGEZBugRunMgr>           ZBugRunMgr;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGESystem* Get(const class UObject* WorldContextObject);

	class AGEHideAndSeekMgr* GetHideAndSeekMgr();
	class AGEItemMgr* GetItemMgr();
	class AGEZBugRunMgr* GetZBugRunMgr();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GESystem">();
	}
	static class UGESystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGESystem>();
	}
};
static_assert(alignof(UGESystem) == 0x000008, "Wrong alignment on UGESystem");
static_assert(sizeof(UGESystem) == 0x000048, "Wrong size on UGESystem");
static_assert(offsetof(UGESystem, ItemMgr) == 0x000030, "Member 'UGESystem::ItemMgr' has a wrong offset!");
static_assert(offsetof(UGESystem, HASMgr) == 0x000038, "Member 'UGESystem::HASMgr' has a wrong offset!");
static_assert(offsetof(UGESystem, ZBugRunMgr) == 0x000040, "Member 'UGESystem::ZBugRunMgr' has a wrong offset!");

// Class GameEx.WaterPark_AIModifyEscape
// 0x0000 (0x04A0 - 0x04A0)
class UWaterPark_AIModifyEscape final : public UWaterParkCollectAIModifyCom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModifyEscape">();
	}
	static class UWaterPark_AIModifyEscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModifyEscape>();
	}
};
static_assert(alignof(UWaterPark_AIModifyEscape) == 0x000010, "Wrong alignment on UWaterPark_AIModifyEscape");
static_assert(sizeof(UWaterPark_AIModifyEscape) == 0x0004A0, "Wrong size on UWaterPark_AIModifyEscape");

// Class GameEx.GEWPLibrary
// 0x0000 (0x0028 - 0x0028)
class UGEWPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetSettlementCamOffsetByTemplateID(int32 InTemplateID, bool IsSuccess);
	static void SetPerformanceMode(bool bOpen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEWPLibrary">();
	}
	static class UGEWPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEWPLibrary>();
	}
};
static_assert(alignof(UGEWPLibrary) == 0x000008, "Wrong alignment on UGEWPLibrary");
static_assert(sizeof(UGEWPLibrary) == 0x000028, "Wrong size on UGEWPLibrary");

// Class GameEx.WaterPark_AIModifyWait
// 0x0000 (0x04A0 - 0x04A0)
class UWaterPark_AIModifyWait final : public UWaterParkCollectAIModifyCom
{
public:
	bool                                          CanJumpInBox;                                      // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModifyWait">();
	}
	static class UWaterPark_AIModifyWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModifyWait>();
	}
};
static_assert(alignof(UWaterPark_AIModifyWait) == 0x000010, "Wrong alignment on UWaterPark_AIModifyWait");
static_assert(sizeof(UWaterPark_AIModifyWait) == 0x0004A0, "Wrong size on UWaterPark_AIModifyWait");
static_assert(offsetof(UWaterPark_AIModifyWait, CanJumpInBox) == 0x000498, "Member 'UWaterPark_AIModifyWait::CanJumpInBox' has a wrong offset!");

// Class GameEx.WaterPark_AIModify_LeaveCenter
// 0x0000 (0x04A0 - 0x04A0)
class UWaterPark_AIModify_LeaveCenter final : public UWaterParkCollectAIModifyCom
{
public:
	bool                                          CanJumpInBox;                                      // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModify_LeaveCenter">();
	}
	static class UWaterPark_AIModify_LeaveCenter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModify_LeaveCenter>();
	}
};
static_assert(alignof(UWaterPark_AIModify_LeaveCenter) == 0x000010, "Wrong alignment on UWaterPark_AIModify_LeaveCenter");
static_assert(sizeof(UWaterPark_AIModify_LeaveCenter) == 0x0004A0, "Wrong size on UWaterPark_AIModify_LeaveCenter");
static_assert(offsetof(UWaterPark_AIModify_LeaveCenter, CanJumpInBox) == 0x000498, "Member 'UWaterPark_AIModify_LeaveCenter::CanJumpInBox' has a wrong offset!");

// Class GameEx.WaterPark_AIModify_CustomVel
// 0x0020 (0x04C0 - 0x04A0)
class UWaterPark_AIModify_CustomVel final : public UWaterParkCollectAIModifyCom
{
public:
	bool                                          CanJumpInBox;                                      // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomVel;                                         // 0x049C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTargetPos;                                      // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x3];                                      // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetWorldPos;                                    // 0x04AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModify_CustomVel">();
	}
	static class UWaterPark_AIModify_CustomVel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModify_CustomVel>();
	}
};
static_assert(alignof(UWaterPark_AIModify_CustomVel) == 0x000010, "Wrong alignment on UWaterPark_AIModify_CustomVel");
static_assert(sizeof(UWaterPark_AIModify_CustomVel) == 0x0004C0, "Wrong size on UWaterPark_AIModify_CustomVel");
static_assert(offsetof(UWaterPark_AIModify_CustomVel, CanJumpInBox) == 0x000498, "Member 'UWaterPark_AIModify_CustomVel::CanJumpInBox' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_CustomVel, CustomVel) == 0x00049C, "Member 'UWaterPark_AIModify_CustomVel::CustomVel' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_CustomVel, UseTargetPos) == 0x0004A8, "Member 'UWaterPark_AIModify_CustomVel::UseTargetPos' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_CustomVel, TargetWorldPos) == 0x0004AC, "Member 'UWaterPark_AIModify_CustomVel::TargetWorldPos' has a wrong offset!");

// Class GameEx.WaterPark_AIModify_JumpMove
// 0x0000 (0x04A0 - 0x04A0)
class UWaterPark_AIModify_JumpMove final : public UWaterParkCollectAIModifyCom
{
public:
	bool                                          CanJumpInBox;                                      // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModify_JumpMove">();
	}
	static class UWaterPark_AIModify_JumpMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModify_JumpMove>();
	}
};
static_assert(alignof(UWaterPark_AIModify_JumpMove) == 0x000010, "Wrong alignment on UWaterPark_AIModify_JumpMove");
static_assert(sizeof(UWaterPark_AIModify_JumpMove) == 0x0004A0, "Wrong size on UWaterPark_AIModify_JumpMove");
static_assert(offsetof(UWaterPark_AIModify_JumpMove, CanJumpInBox) == 0x000498, "Member 'UWaterPark_AIModify_JumpMove::CanJumpInBox' has a wrong offset!");

// Class GameEx.WaterPark_AIModify_CenterLineMove
// 0x0010 (0x04B0 - 0x04A0)
class UWaterPark_AIModify_CenterLineMove final : public UWaterParkCollectAIModifyCom
{
public:
	struct FVector                                LineDir;                                           // 0x0498(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LineLength;                                        // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OffsetScale;                                       // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModify_CenterLineMove">();
	}
	static class UWaterPark_AIModify_CenterLineMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModify_CenterLineMove>();
	}
};
static_assert(alignof(UWaterPark_AIModify_CenterLineMove) == 0x000010, "Wrong alignment on UWaterPark_AIModify_CenterLineMove");
static_assert(sizeof(UWaterPark_AIModify_CenterLineMove) == 0x0004B0, "Wrong size on UWaterPark_AIModify_CenterLineMove");
static_assert(offsetof(UWaterPark_AIModify_CenterLineMove, LineDir) == 0x000498, "Member 'UWaterPark_AIModify_CenterLineMove::LineDir' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_CenterLineMove, LineLength) == 0x0004A4, "Member 'UWaterPark_AIModify_CenterLineMove::LineLength' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_CenterLineMove, OffsetScale) == 0x0004A8, "Member 'UWaterPark_AIModify_CenterLineMove::OffsetScale' has a wrong offset!");

// Class GameEx.WaterPark_AIModify_MoveToRandomPos
// 0x0030 (0x04D0 - 0x04A0)
class UWaterPark_AIModify_MoveToRandomPos final : public UWaterParkCollectAIModifyCom
{
public:
	bool                                          UseRandomTargetPos;                                // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateTargetCD;                                    // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRandomTargetActor;                              // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndMoveDis;                                        // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetActorsCache;                                 // 0x04B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         ResetTargetCD;                                     // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0xC];                                      // 0x04C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_AIModify_MoveToRandomPos">();
	}
	static class UWaterPark_AIModify_MoveToRandomPos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_AIModify_MoveToRandomPos>();
	}
};
static_assert(alignof(UWaterPark_AIModify_MoveToRandomPos) == 0x000010, "Wrong alignment on UWaterPark_AIModify_MoveToRandomPos");
static_assert(sizeof(UWaterPark_AIModify_MoveToRandomPos) == 0x0004D0, "Wrong size on UWaterPark_AIModify_MoveToRandomPos");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, UseRandomTargetPos) == 0x000498, "Member 'UWaterPark_AIModify_MoveToRandomPos::UseRandomTargetPos' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, UpdateTargetCD) == 0x00049C, "Member 'UWaterPark_AIModify_MoveToRandomPos::UpdateTargetCD' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, UseRandomTargetActor) == 0x0004A0, "Member 'UWaterPark_AIModify_MoveToRandomPos::UseRandomTargetActor' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, EndMoveDis) == 0x0004A4, "Member 'UWaterPark_AIModify_MoveToRandomPos::EndMoveDis' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, TargetActorClass) == 0x0004A8, "Member 'UWaterPark_AIModify_MoveToRandomPos::TargetActorClass' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, TargetActorsCache) == 0x0004B0, "Member 'UWaterPark_AIModify_MoveToRandomPos::TargetActorsCache' has a wrong offset!");
static_assert(offsetof(UWaterPark_AIModify_MoveToRandomPos, ResetTargetCD) == 0x0004C0, "Member 'UWaterPark_AIModify_MoveToRandomPos::ResetTargetCD' has a wrong offset!");

// Class GameEx.WP_AIAreaModifyActor
// 0x0010 (0x0238 - 0x0228)
class AWP_AIAreaModifyActor final : public AActor
{
public:
	class UBoxComponent*                          Box;                                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDisToTarget;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WP_AIAreaModifyActor">();
	}
	static class AWP_AIAreaModifyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWP_AIAreaModifyActor>();
	}
};
static_assert(alignof(AWP_AIAreaModifyActor) == 0x000008, "Wrong alignment on AWP_AIAreaModifyActor");
static_assert(sizeof(AWP_AIAreaModifyActor) == 0x000238, "Wrong size on AWP_AIAreaModifyActor");
static_assert(offsetof(AWP_AIAreaModifyActor, Box) == 0x000228, "Member 'AWP_AIAreaModifyActor::Box' has a wrong offset!");
static_assert(offsetof(AWP_AIAreaModifyActor, AreaId) == 0x000230, "Member 'AWP_AIAreaModifyActor::AreaId' has a wrong offset!");
static_assert(offsetof(AWP_AIAreaModifyActor, EndDisToTarget) == 0x000234, "Member 'AWP_AIAreaModifyActor::EndDisToTarget' has a wrong offset!");

// Class GameEx.WP_AITargetModifyActor
// 0x0020 (0x0248 - 0x0228)
class AWP_AITargetModifyActor final : public AActor
{
public:
	class UBoxComponent*                          Box;                                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTargetCenter;                                   // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TendencyMoveDir;                                   // 0x0238(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WP_AITargetModifyActor">();
	}
	static class AWP_AITargetModifyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWP_AITargetModifyActor>();
	}
};
static_assert(alignof(AWP_AITargetModifyActor) == 0x000008, "Wrong alignment on AWP_AITargetModifyActor");
static_assert(sizeof(AWP_AITargetModifyActor) == 0x000248, "Wrong size on AWP_AITargetModifyActor");
static_assert(offsetof(AWP_AITargetModifyActor, Box) == 0x000228, "Member 'AWP_AITargetModifyActor::Box' has a wrong offset!");
static_assert(offsetof(AWP_AITargetModifyActor, AreaId) == 0x000230, "Member 'AWP_AITargetModifyActor::AreaId' has a wrong offset!");
static_assert(offsetof(AWP_AITargetModifyActor, UseTargetCenter) == 0x000234, "Member 'AWP_AITargetModifyActor::UseTargetCenter' has a wrong offset!");
static_assert(offsetof(AWP_AITargetModifyActor, TendencyMoveDir) == 0x000238, "Member 'AWP_AITargetModifyActor::TendencyMoveDir' has a wrong offset!");

// Class GameEx.GECustomPathFollowingComponent
// 0x0000 (0x0250 - 0x0250)
class UGECustomPathFollowingComponent final : public UPathFollowingComponent
{
public:
	bool CheckReachProxyMidPoint(const struct FVector& CurrentLocation, const struct FVector& StartLocation, const struct FVector& TargetLocation);
	void ForceCurLinkFromLua();
	bool UsingCustomLink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GECustomPathFollowingComponent">();
	}
	static class UGECustomPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGECustomPathFollowingComponent>();
	}
};
static_assert(alignof(UGECustomPathFollowingComponent) == 0x000008, "Wrong alignment on UGECustomPathFollowingComponent");
static_assert(sizeof(UGECustomPathFollowingComponent) == 0x000250, "Wrong size on UGECustomPathFollowingComponent");

// Class GameEx.GEAIController
// 0x02B0 (0x05E0 - 0x0330)
class AGEAIController final : public AAIController
{
public:
	TDelegate<void(const class FString& NotifyName, const class FString& NotifyParam)> EventNotifyDelegate;                               // 0x0330(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FloatValueMap;                                     // 0x0340(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     BoolValueMap;                                      // 0x0390(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    IntValueMap;                                       // 0x03E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	int32                                         PlayerID;                                          // 0x0430(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPos;                                         // 0x0438(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProxyMoveDir;                                      // 0x0444(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 OwnWorld;                                          // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       GEGameChar;                                        // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestMoveDir;                                       // 0x0460(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameModeBase*                        GEGameMode;                                        // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameState*                           GEGameState;                                       // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x50];                                     // 0x0480(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowRandomTargetTime;                               // 0x04D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NowRandomTargetPos;                                // 0x04D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasValidTargetPos;                                 // 0x04E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGEHASAIPathPoint>       HAS_CurPathPoint;                                  // 0x04E4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ForceTargetActor;                                  // 0x04EC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceTargetLoc;                                    // 0x04F4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceGoToTargetLocTimer;                           // 0x0500(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceGoToTargetLocDur;                             // 0x0504(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopForceGoToTargetLocDist;                        // 0x0508(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextCanForceGoToTargetLocCD;                       // 0x050C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGoingToForceTargetLoc;                           // 0x0510(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CacheTeamID;                                       // 0x0514(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_PathFindCD;                                    // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_StopDur;                                       // 0x051C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_StopTimer;                                     // 0x0520(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_JumpAddInputTimer;                             // 0x0524(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_JumpAddInputDur;                               // 0x0528(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_AutoFindNextPointTimer;                        // 0x052C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_AutoFindNextPointCD;                           // 0x0530(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_GoingJumpTimer;                                // 0x0534(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_GoingJumpCD;                                   // 0x0538(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HAS_StopPointCount;                                // 0x053C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HAS_StopPointMaxCount;                             // 0x0540(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CurQueryID;                                        // 0x0548(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CacheQueryArrNum;                                  // 0x054C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x80];                                     // 0x0550(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ReceiveMoveCompletedEx;                            // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AbortMoveToAsync(uint32 AsyncQueryID);
	void ClearProxyMoveDir();
	bool GetBoolValue(const class FString& Key);
	float GetFloatValue(const class FString& Key);
	int32 GetIntValue(const class FString& Key);
	struct FVector GetMoveDir(bool* CanJump, bool* ShouldJump, float DeltaSeconds);
	class AGEGameCharacter* GetValidGECharacter(class AActor* LpActor);
	void HAS_EntryPointEvent(class AGEHASAIPathPoint* CurPathPoint);
	void HAS_ExitPointEvent(class AGEHASAIPathPoint* CurPathPoint);
	void HAS_ForceFollowTargetEvent();
	void OnMoveToPointComplete(const struct FAIRequestID& RequestID, EPathFollowingResult Result, class AGEAIController* AIController);
	void SetBoolValue(const class FString& Key, bool Value);
	void SetFloatValue(const class FString& Key, float Value);
	void SetForceTargetActor(class AActor* InActor);
	void SetForceTargetLoc(const struct FVector& InTargetLoc);
	void SetIntValue(const class FString& Key, int32 Value);
	void SetProxyMoveDir(const struct FVector& InModifierDir);
	void SingleEventNotifyDelegate__DelegateSignature(const class FString& NotifyName, const class FString& NotifyParam);
	void TriggerNotify(const class FString& NotifyName, const class FString& NotifyParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAIController">();
	}
	static class AGEAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEAIController>();
	}
};
static_assert(alignof(AGEAIController) == 0x000008, "Wrong alignment on AGEAIController");
static_assert(sizeof(AGEAIController) == 0x0005E0, "Wrong size on AGEAIController");
static_assert(offsetof(AGEAIController, EventNotifyDelegate) == 0x000330, "Member 'AGEAIController::EventNotifyDelegate' has a wrong offset!");
static_assert(offsetof(AGEAIController, FloatValueMap) == 0x000340, "Member 'AGEAIController::FloatValueMap' has a wrong offset!");
static_assert(offsetof(AGEAIController, BoolValueMap) == 0x000390, "Member 'AGEAIController::BoolValueMap' has a wrong offset!");
static_assert(offsetof(AGEAIController, IntValueMap) == 0x0003E0, "Member 'AGEAIController::IntValueMap' has a wrong offset!");
static_assert(offsetof(AGEAIController, PlayerID) == 0x000430, "Member 'AGEAIController::PlayerID' has a wrong offset!");
static_assert(offsetof(AGEAIController, TargetPos) == 0x000438, "Member 'AGEAIController::TargetPos' has a wrong offset!");
static_assert(offsetof(AGEAIController, ProxyMoveDir) == 0x000444, "Member 'AGEAIController::ProxyMoveDir' has a wrong offset!");
static_assert(offsetof(AGEAIController, OwnWorld) == 0x000450, "Member 'AGEAIController::OwnWorld' has a wrong offset!");
static_assert(offsetof(AGEAIController, GEGameChar) == 0x000458, "Member 'AGEAIController::GEGameChar' has a wrong offset!");
static_assert(offsetof(AGEAIController, TestMoveDir) == 0x000460, "Member 'AGEAIController::TestMoveDir' has a wrong offset!");
static_assert(offsetof(AGEAIController, GEGameMode) == 0x000470, "Member 'AGEAIController::GEGameMode' has a wrong offset!");
static_assert(offsetof(AGEAIController, GEGameState) == 0x000478, "Member 'AGEAIController::GEGameState' has a wrong offset!");
static_assert(offsetof(AGEAIController, NowRandomTargetTime) == 0x0004D0, "Member 'AGEAIController::NowRandomTargetTime' has a wrong offset!");
static_assert(offsetof(AGEAIController, NowRandomTargetPos) == 0x0004D4, "Member 'AGEAIController::NowRandomTargetPos' has a wrong offset!");
static_assert(offsetof(AGEAIController, HasValidTargetPos) == 0x0004E0, "Member 'AGEAIController::HasValidTargetPos' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_CurPathPoint) == 0x0004E4, "Member 'AGEAIController::HAS_CurPathPoint' has a wrong offset!");
static_assert(offsetof(AGEAIController, ForceTargetActor) == 0x0004EC, "Member 'AGEAIController::ForceTargetActor' has a wrong offset!");
static_assert(offsetof(AGEAIController, ForceTargetLoc) == 0x0004F4, "Member 'AGEAIController::ForceTargetLoc' has a wrong offset!");
static_assert(offsetof(AGEAIController, ForceGoToTargetLocTimer) == 0x000500, "Member 'AGEAIController::ForceGoToTargetLocTimer' has a wrong offset!");
static_assert(offsetof(AGEAIController, ForceGoToTargetLocDur) == 0x000504, "Member 'AGEAIController::ForceGoToTargetLocDur' has a wrong offset!");
static_assert(offsetof(AGEAIController, StopForceGoToTargetLocDist) == 0x000508, "Member 'AGEAIController::StopForceGoToTargetLocDist' has a wrong offset!");
static_assert(offsetof(AGEAIController, NextCanForceGoToTargetLocCD) == 0x00050C, "Member 'AGEAIController::NextCanForceGoToTargetLocCD' has a wrong offset!");
static_assert(offsetof(AGEAIController, IsGoingToForceTargetLoc) == 0x000510, "Member 'AGEAIController::IsGoingToForceTargetLoc' has a wrong offset!");
static_assert(offsetof(AGEAIController, CacheTeamID) == 0x000514, "Member 'AGEAIController::CacheTeamID' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_PathFindCD) == 0x000518, "Member 'AGEAIController::HAS_PathFindCD' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_StopDur) == 0x00051C, "Member 'AGEAIController::HAS_StopDur' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_StopTimer) == 0x000520, "Member 'AGEAIController::HAS_StopTimer' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_JumpAddInputTimer) == 0x000524, "Member 'AGEAIController::HAS_JumpAddInputTimer' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_JumpAddInputDur) == 0x000528, "Member 'AGEAIController::HAS_JumpAddInputDur' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_AutoFindNextPointTimer) == 0x00052C, "Member 'AGEAIController::HAS_AutoFindNextPointTimer' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_AutoFindNextPointCD) == 0x000530, "Member 'AGEAIController::HAS_AutoFindNextPointCD' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_GoingJumpTimer) == 0x000534, "Member 'AGEAIController::HAS_GoingJumpTimer' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_GoingJumpCD) == 0x000538, "Member 'AGEAIController::HAS_GoingJumpCD' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_StopPointCount) == 0x00053C, "Member 'AGEAIController::HAS_StopPointCount' has a wrong offset!");
static_assert(offsetof(AGEAIController, HAS_StopPointMaxCount) == 0x000540, "Member 'AGEAIController::HAS_StopPointMaxCount' has a wrong offset!");
static_assert(offsetof(AGEAIController, CurQueryID) == 0x000548, "Member 'AGEAIController::CurQueryID' has a wrong offset!");
static_assert(offsetof(AGEAIController, CacheQueryArrNum) == 0x00054C, "Member 'AGEAIController::CacheQueryArrNum' has a wrong offset!");
static_assert(offsetof(AGEAIController, ReceiveMoveCompletedEx) == 0x0005D0, "Member 'AGEAIController::ReceiveMoveCompletedEx' has a wrong offset!");

// Class GameEx.GEAnimEventNotify
// 0x0018 (0x0050 - 0x0038)
class UGEAnimEventNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NotifyParam;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAnimEventNotify">();
	}
	static class UGEAnimEventNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAnimEventNotify>();
	}
};
static_assert(alignof(UGEAnimEventNotify) == 0x000008, "Wrong alignment on UGEAnimEventNotify");
static_assert(sizeof(UGEAnimEventNotify) == 0x000050, "Wrong size on UGEAnimEventNotify");
static_assert(offsetof(UGEAnimEventNotify, NotifyName) == 0x000038, "Member 'UGEAnimEventNotify::NotifyName' has a wrong offset!");
static_assert(offsetof(UGEAnimEventNotify, NotifyParam) == 0x000040, "Member 'UGEAnimEventNotify::NotifyParam' has a wrong offset!");

// Class GameEx.GEAnimInstance
// 0x0190 (0x0450 - 0x02C0)
class UGEAnimInstance final : public UAnimInstance
{
public:
	class ACharacter*                             ArrivalCharacter;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInAir;                                           // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAccelerating;                                    // 0x02C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceleratedSpeed;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FullBody;                                          // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pitch;                                             // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDelta;                                          // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDirection;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotatorZero;                                       // 0x02E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0xC];                                      // 0x02F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    FloatValueMap;                                     // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     BoolValueMap;                                      // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    IntValueMap;                                       // 0x03A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StringValueMap;                                    // 0x03F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	TDelegate<void(class FName NotifyName, const class FString& NotifyParam)> NotifyDelegate;                                    // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool GetBoolValue(const class FString& Key);
	class ACharacter* GetCharacter();
	float GetFloatValue(const class FString& Key);
	int32 GetIntValue(const class FString& Key);
	class FString GetStringValue(const class FString& Key);
	bool HandleNotify(const struct FAnimNotifyEvent& AnimNotifyEvent);
	bool SendNotify(const class FName& NotifyName, const class FString& NotifyParam);
	void SetBoolValue(const class FString& Key, bool Value);
	void SetDirection();
	void SetFloatValue(const class FString& Key, float Value);
	void SetIntValue(const class FString& Key, int32 Value);
	void SetRollPitchAndYaw();
	void SetStringValue(const class FString& Key, const class FString& Value);
	void SetYawDeltaforLeans(float DeltaTimeX);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAnimInstance">();
	}
	static class UGEAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAnimInstance>();
	}
};
static_assert(alignof(UGEAnimInstance) == 0x000010, "Wrong alignment on UGEAnimInstance");
static_assert(sizeof(UGEAnimInstance) == 0x000450, "Wrong size on UGEAnimInstance");
static_assert(offsetof(UGEAnimInstance, ArrivalCharacter) == 0x0002B8, "Member 'UGEAnimInstance::ArrivalCharacter' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, MoveSpeed) == 0x0002C0, "Member 'UGEAnimInstance::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, IsInAir) == 0x0002C4, "Member 'UGEAnimInstance::IsInAir' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, IsAccelerating) == 0x0002C5, "Member 'UGEAnimInstance::IsAccelerating' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, AcceleratedSpeed) == 0x0002C8, "Member 'UGEAnimInstance::AcceleratedSpeed' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, FullBody) == 0x0002CC, "Member 'UGEAnimInstance::FullBody' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, Pitch) == 0x0002D0, "Member 'UGEAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, Yaw) == 0x0002D4, "Member 'UGEAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, YawDelta) == 0x0002D8, "Member 'UGEAnimInstance::YawDelta' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, Roll) == 0x0002DC, "Member 'UGEAnimInstance::Roll' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, Direction) == 0x0002E0, "Member 'UGEAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, StopDirection) == 0x0002E4, "Member 'UGEAnimInstance::StopDirection' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, RotatorZero) == 0x0002E8, "Member 'UGEAnimInstance::RotatorZero' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, FloatValueMap) == 0x000300, "Member 'UGEAnimInstance::FloatValueMap' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, BoolValueMap) == 0x000350, "Member 'UGEAnimInstance::BoolValueMap' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, IntValueMap) == 0x0003A0, "Member 'UGEAnimInstance::IntValueMap' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, StringValueMap) == 0x0003F0, "Member 'UGEAnimInstance::StringValueMap' has a wrong offset!");
static_assert(offsetof(UGEAnimInstance, NotifyDelegate) == 0x000440, "Member 'UGEAnimInstance::NotifyDelegate' has a wrong offset!");

// Class GameEx.GEAttrFormula
// 0x0010 (0x0050 - 0x0040)
class UGEAttrFormula : public ULogicTree_DataFormula
{
public:
	class FName                                   BaseAndResAttrName;                                // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdditionAttrName;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAttrFormula">();
	}
	static class UGEAttrFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAttrFormula>();
	}
};
static_assert(alignof(UGEAttrFormula) == 0x000008, "Wrong alignment on UGEAttrFormula");
static_assert(sizeof(UGEAttrFormula) == 0x000050, "Wrong size on UGEAttrFormula");
static_assert(offsetof(UGEAttrFormula, BaseAndResAttrName) == 0x000040, "Member 'UGEAttrFormula::BaseAndResAttrName' has a wrong offset!");
static_assert(offsetof(UGEAttrFormula, AdditionAttrName) == 0x000048, "Member 'UGEAttrFormula::AdditionAttrName' has a wrong offset!");

// Class GameEx.GEHealthFormula
// 0x0008 (0x0048 - 0x0040)
class UGEHealthFormula final : public ULogicTree_DataFormula
{
public:
	float                                         PreAdditionVal;                                    // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreCurHealthBaseVal;                               // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEHealthFormula">();
	}
	static class UGEHealthFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEHealthFormula>();
	}
};
static_assert(alignof(UGEHealthFormula) == 0x000008, "Wrong alignment on UGEHealthFormula");
static_assert(sizeof(UGEHealthFormula) == 0x000048, "Wrong size on UGEHealthFormula");
static_assert(offsetof(UGEHealthFormula, PreAdditionVal) == 0x000040, "Member 'UGEHealthFormula::PreAdditionVal' has a wrong offset!");
static_assert(offsetof(UGEHealthFormula, PreCurHealthBaseVal) == 0x000044, "Member 'UGEHealthFormula::PreCurHealthBaseVal' has a wrong offset!");

// Class GameEx.GEMagazineCapacityFormula
// 0x0000 (0x0050 - 0x0050)
class UGEMagazineCapacityFormula final : public UGEAttrFormula
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEMagazineCapacityFormula">();
	}
	static class UGEMagazineCapacityFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEMagazineCapacityFormula>();
	}
};
static_assert(alignof(UGEMagazineCapacityFormula) == 0x000008, "Wrong alignment on UGEMagazineCapacityFormula");
static_assert(sizeof(UGEMagazineCapacityFormula) == 0x000050, "Wrong size on UGEMagazineCapacityFormula");

// Class GameEx.GELimitFormula
// 0x0010 (0x0050 - 0x0040)
class UGELimitFormula : public ULogicTree_DataFormula
{
public:
	class FName                                   AttrName;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheMaxValue;                                     // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitAttrFormula(class FName InName, float InMaxValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GELimitFormula">();
	}
	static class UGELimitFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGELimitFormula>();
	}
};
static_assert(alignof(UGELimitFormula) == 0x000008, "Wrong alignment on UGELimitFormula");
static_assert(sizeof(UGELimitFormula) == 0x000050, "Wrong size on UGELimitFormula");
static_assert(offsetof(UGELimitFormula, AttrName) == 0x000040, "Member 'UGELimitFormula::AttrName' has a wrong offset!");
static_assert(offsetof(UGELimitFormula, CacheMaxValue) == 0x000048, "Member 'UGELimitFormula::CacheMaxValue' has a wrong offset!");

// Class GameEx.GELimitHealthFormula
// 0x0008 (0x0058 - 0x0050)
class UGELimitHealthFormula final : public UGELimitFormula
{
public:
	class FName                                   MaxHealthName;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitHealthLimitFormula(class FName CurHealthName, class FName InMaxHealthName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GELimitHealthFormula">();
	}
	static class UGELimitHealthFormula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGELimitHealthFormula>();
	}
};
static_assert(alignof(UGELimitHealthFormula) == 0x000008, "Wrong alignment on UGELimitHealthFormula");
static_assert(sizeof(UGELimitHealthFormula) == 0x000058, "Wrong size on UGELimitHealthFormula");
static_assert(offsetof(UGELimitHealthFormula, MaxHealthName) == 0x000050, "Member 'UGELimitHealthFormula::MaxHealthName' has a wrong offset!");

// Class GameEx.GECurveMoveComponent
// 0x00D8 (0x0188 - 0x00B0)
class UGECurveMoveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             DuringCurveTimeDelegate;                           // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OutCurveTimeDelegate;                              // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveFloat;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTime;                                         // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTimeForRPC;                                   // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictTime;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowValue;                                          // 0x0118(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginDelay;                                        // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeginDelayMove;                                 // 0x0120(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBeginStart;                                      // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeginMove;                                      // 0x0122(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRate;                                         // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateRate;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateCD;                                      // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedRateMultiple;                              // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Rollback;                                          // 0x0134(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x0138(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncCurveTimeToClientDur;                          // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCurveTimeForDelegate;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCurveTimeForDelegate;                           // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDis;                                           // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ComponentName;                                     // 0x0150(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGECurveChangeType                            ChangeType;                                        // 0x0160(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSmooth;                                        // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SmoothMaxCount;                                    // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepOriginRotate;                                 // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeScale;                                      // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCumulativeTimeRep;                              // 0x016A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCurveValue;                                     // 0x016B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OriginRotator;                                     // 0x016C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OriginScale;                                       // 0x0178(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0184(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CurveTimeDelegate__DelegateSignature();
	void RecordCurrentRotator();
	void SetCurveTime(float Time, int64 ServertimeMilli);
	void SetRange(bool Rangev);
	void SetRollback(bool bRollback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GECurveMoveComponent">();
	}
	static class UGECurveMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGECurveMoveComponent>();
	}
};
static_assert(alignof(UGECurveMoveComponent) == 0x000008, "Wrong alignment on UGECurveMoveComponent");
static_assert(sizeof(UGECurveMoveComponent) == 0x000188, "Wrong size on UGECurveMoveComponent");
static_assert(offsetof(UGECurveMoveComponent, DuringCurveTimeDelegate) == 0x0000E0, "Member 'UGECurveMoveComponent::DuringCurveTimeDelegate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, OutCurveTimeDelegate) == 0x0000F0, "Member 'UGECurveMoveComponent::OutCurveTimeDelegate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, CurveFloat) == 0x000100, "Member 'UGECurveMoveComponent::CurveFloat' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, CurveTime) == 0x000108, "Member 'UGECurveMoveComponent::CurveTime' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, CurveTimeForRPC) == 0x00010C, "Member 'UGECurveMoveComponent::CurveTimeForRPC' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, PredictTime) == 0x000110, "Member 'UGECurveMoveComponent::PredictTime' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, LerpSpeed) == 0x000114, "Member 'UGECurveMoveComponent::LerpSpeed' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, NowValue) == 0x000118, "Member 'UGECurveMoveComponent::NowValue' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, BeginDelay) == 0x00011C, "Member 'UGECurveMoveComponent::BeginDelay' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, CanBeginDelayMove) == 0x000120, "Member 'UGECurveMoveComponent::CanBeginDelayMove' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, IsBeginStart) == 0x000121, "Member 'UGECurveMoveComponent::IsBeginStart' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, CanBeginMove) == 0x000122, "Member 'UGECurveMoveComponent::CanBeginMove' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, SpeedRate) == 0x000124, "Member 'UGECurveMoveComponent::SpeedRate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, AccelerateRate) == 0x000128, "Member 'UGECurveMoveComponent::AccelerateRate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, AccelerateCD) == 0x00012C, "Member 'UGECurveMoveComponent::AccelerateCD' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, MaxSpeedRateMultiple) == 0x000130, "Member 'UGECurveMoveComponent::MaxSpeedRateMultiple' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, Rollback) == 0x000134, "Member 'UGECurveMoveComponent::Rollback' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, Range) == 0x000138, "Member 'UGECurveMoveComponent::Range' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, SyncCurveTimeToClientDur) == 0x00013C, "Member 'UGECurveMoveComponent::SyncCurveTimeToClientDur' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, MinCurveTimeForDelegate) == 0x000140, "Member 'UGECurveMoveComponent::MinCurveTimeForDelegate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, MaxCurveTimeForDelegate) == 0x000144, "Member 'UGECurveMoveComponent::MaxCurveTimeForDelegate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, MoveDis) == 0x000148, "Member 'UGECurveMoveComponent::MoveDis' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, ComponentName) == 0x000150, "Member 'UGECurveMoveComponent::ComponentName' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, ChangeType) == 0x000160, "Member 'UGECurveMoveComponent::ChangeType' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, bUseSmooth) == 0x000161, "Member 'UGECurveMoveComponent::bUseSmooth' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, SmoothMaxCount) == 0x000164, "Member 'UGECurveMoveComponent::SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, bKeepOriginRotate) == 0x000168, "Member 'UGECurveMoveComponent::bKeepOriginRotate' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, bChangeScale) == 0x000169, "Member 'UGECurveMoveComponent::bChangeScale' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, UseCumulativeTimeRep) == 0x00016A, "Member 'UGECurveMoveComponent::UseCumulativeTimeRep' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, UseCurveValue) == 0x00016B, "Member 'UGECurveMoveComponent::UseCurveValue' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, OriginRotator) == 0x00016C, "Member 'UGECurveMoveComponent::OriginRotator' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, OriginScale) == 0x000178, "Member 'UGECurveMoveComponent::OriginScale' has a wrong offset!");
static_assert(offsetof(UGECurveMoveComponent, bSweep) == 0x000184, "Member 'UGECurveMoveComponent::bSweep' has a wrong offset!");

// Class GameEx.GEDropManager
// 0x0170 (0x0398 - 0x0228)
class AGEDropManager final : public AActor
{
public:
	struct FWPDropItemArray                       DropArray;                                         // 0x0228(0x0118)(Net, NativeAccessSpecifierPublic)
	TMap<int32, class AGEDrop*>                   DropActorList;                                     // 0x0340(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CurDropID;                                         // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitDropArray();
	void ItemCollision(int32 ItemId);
	void ItemDestroy(int32 ItemId);
	void ItemResetPos(int32 ItemId);
	void NotifyDropCollision(int32 InDropId);
	void NotifyDropDestroy(int32 InDropId);
	void NotifyDropResetPos(int32 InDropId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEDropManager">();
	}
	static class AGEDropManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEDropManager>();
	}
};
static_assert(alignof(AGEDropManager) == 0x000008, "Wrong alignment on AGEDropManager");
static_assert(sizeof(AGEDropManager) == 0x000398, "Wrong size on AGEDropManager");
static_assert(offsetof(AGEDropManager, DropArray) == 0x000228, "Member 'AGEDropManager::DropArray' has a wrong offset!");
static_assert(offsetof(AGEDropManager, DropActorList) == 0x000340, "Member 'AGEDropManager::DropActorList' has a wrong offset!");
static_assert(offsetof(AGEDropManager, CurDropID) == 0x000390, "Member 'AGEDropManager::CurDropID' has a wrong offset!");

// Class GameEx.GEDynamicObject
// 0x0018 (0x0240 - 0x0228)
class AGEDynamicObject final : public AActor
{
public:
	int32                                         RandomMinRange;                                    // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomMaxRange;                                    // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 RandomIndexArr;                                    // 0x0230(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)

public:
	void LuaBeginPlay();
	void OnRep_RandomIndexArr();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEDynamicObject">();
	}
	static class AGEDynamicObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEDynamicObject>();
	}
};
static_assert(alignof(AGEDynamicObject) == 0x000008, "Wrong alignment on AGEDynamicObject");
static_assert(sizeof(AGEDynamicObject) == 0x000240, "Wrong size on AGEDynamicObject");
static_assert(offsetof(AGEDynamicObject, RandomMinRange) == 0x000228, "Member 'AGEDynamicObject::RandomMinRange' has a wrong offset!");
static_assert(offsetof(AGEDynamicObject, RandomMaxRange) == 0x00022C, "Member 'AGEDynamicObject::RandomMaxRange' has a wrong offset!");
static_assert(offsetof(AGEDynamicObject, RandomIndexArr) == 0x000230, "Member 'AGEDynamicObject::RandomIndexArr' has a wrong offset!");

// Class GameEx.GEFightBox
// 0x0028 (0x02F0 - 0x02C8)
class UGEFightBox final : public UGameCoreWidget
{
public:
	class UImage*                                 ImageBox;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleDist;                                       // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckHeight;                                       // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddOffset;                                         // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEPlayerController*                    PC;                                                // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGEGameCharacter>        LocalChar;                                         // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEFightBox">();
	}
	static class UGEFightBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEFightBox>();
	}
};
static_assert(alignof(UGEFightBox) == 0x000008, "Wrong alignment on UGEFightBox");
static_assert(sizeof(UGEFightBox) == 0x0002F0, "Wrong size on UGEFightBox");
static_assert(offsetof(UGEFightBox, ImageBox) == 0x0002C8, "Member 'UGEFightBox::ImageBox' has a wrong offset!");
static_assert(offsetof(UGEFightBox, VisibleDist) == 0x0002D0, "Member 'UGEFightBox::VisibleDist' has a wrong offset!");
static_assert(offsetof(UGEFightBox, CheckHeight) == 0x0002D4, "Member 'UGEFightBox::CheckHeight' has a wrong offset!");
static_assert(offsetof(UGEFightBox, AddOffset) == 0x0002D8, "Member 'UGEFightBox::AddOffset' has a wrong offset!");
static_assert(offsetof(UGEFightBox, PC) == 0x0002E0, "Member 'UGEFightBox::PC' has a wrong offset!");
static_assert(offsetof(UGEFightBox, LocalChar) == 0x0002E8, "Member 'UGEFightBox::LocalChar' has a wrong offset!");

// Class GameEx.GEFightHPBar
// 0x0018 (0x02E0 - 0x02C8)
class UGEFightHPBar final : public UGameCoreWidget
{
public:
	float                                         LowHpRate;                                         // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEPlayerController*                    LpPlayer;                                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGEPlayerState*                         LocalPs;                                           // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshExpBar(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEFightHPBar">();
	}
	static class UGEFightHPBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEFightHPBar>();
	}
};
static_assert(alignof(UGEFightHPBar) == 0x000008, "Wrong alignment on UGEFightHPBar");
static_assert(sizeof(UGEFightHPBar) == 0x0002E0, "Wrong size on UGEFightHPBar");
static_assert(offsetof(UGEFightHPBar, LowHpRate) == 0x0002C8, "Member 'UGEFightHPBar::LowHpRate' has a wrong offset!");
static_assert(offsetof(UGEFightHPBar, LpPlayer) == 0x0002D0, "Member 'UGEFightHPBar::LpPlayer' has a wrong offset!");
static_assert(offsetof(UGEFightHPBar, LocalPs) == 0x0002D8, "Member 'UGEFightHPBar::LocalPs' has a wrong offset!");

// Class GameEx.GEFightEnemyHPBar
// 0x0028 (0x02F0 - 0x02C8)
class UGEFightEnemyHPBar final : public UGameCoreWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueId;                                          // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleTimer;                                      // 0x02D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleDur;                                        // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanVisible;                                        // 0x02DC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextCanVisibleCD;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextCanVisibleTimer;                               // 0x02E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGEGameCharacter>        CachePawn;                                         // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetUniqueID(int32 InUniqueID);
	void SetVisibleOrCollapsed(bool IsVisible_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEFightEnemyHPBar">();
	}
	static class UGEFightEnemyHPBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEFightEnemyHPBar>();
	}
};
static_assert(alignof(UGEFightEnemyHPBar) == 0x000008, "Wrong alignment on UGEFightEnemyHPBar");
static_assert(sizeof(UGEFightEnemyHPBar) == 0x0002F0, "Wrong size on UGEFightEnemyHPBar");
static_assert(offsetof(UGEFightEnemyHPBar, ProgressBar) == 0x0002C8, "Member 'UGEFightEnemyHPBar::ProgressBar' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, UniqueId) == 0x0002D0, "Member 'UGEFightEnemyHPBar::UniqueId' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, VisibleTimer) == 0x0002D4, "Member 'UGEFightEnemyHPBar::VisibleTimer' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, VisibleDur) == 0x0002D8, "Member 'UGEFightEnemyHPBar::VisibleDur' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, CanVisible) == 0x0002DC, "Member 'UGEFightEnemyHPBar::CanVisible' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, NextCanVisibleCD) == 0x0002E0, "Member 'UGEFightEnemyHPBar::NextCanVisibleCD' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, NextCanVisibleTimer) == 0x0002E4, "Member 'UGEFightEnemyHPBar::NextCanVisibleTimer' has a wrong offset!");
static_assert(offsetof(UGEFightEnemyHPBar, CachePawn) == 0x0002E8, "Member 'UGEFightEnemyHPBar::CachePawn' has a wrong offset!");

// Class GameEx.GEFightMemberTitle
// 0x0088 (0x0350 - 0x02C8)
class UGEFightMemberTitle final : public UGameCoreWidget
{
public:
	float                                         ExpressionRange;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalNameRange;                                   // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugNameRange;                                     // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NameRange;                                         // 0x02D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleNameNeedCheckTeam;                          // 0x02D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x6F];                                     // 0x02D9(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocalPlayerTeamID;                                 // 0x0348(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* AllocNewWidget(int64 InRoleID);
	class AGEPlayerState* GetPlayerState(int64 InRoleID);
	void InitPlayers();
	void RegisterRobot(class AGEPlayerState* InActor);
	void SetNameVisibleOrCollapsed(bool IsVisible_0, int64 InRolePID, const class FString& InName);
	void SetPlayerNameToWidget(class UWidget* Widget, const class FString& InName);
	void SetPlayerTeamToWidget(class UWidget* Widget, int32 TeamID);
	void SetPlayerUniqueIDToWidget(class UWidget* Widget, int32 UniqueId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEFightMemberTitle">();
	}
	static class UGEFightMemberTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEFightMemberTitle>();
	}
};
static_assert(alignof(UGEFightMemberTitle) == 0x000008, "Wrong alignment on UGEFightMemberTitle");
static_assert(sizeof(UGEFightMemberTitle) == 0x000350, "Wrong size on UGEFightMemberTitle");
static_assert(offsetof(UGEFightMemberTitle, ExpressionRange) == 0x0002C8, "Member 'UGEFightMemberTitle::ExpressionRange' has a wrong offset!");
static_assert(offsetof(UGEFightMemberTitle, NormalNameRange) == 0x0002CC, "Member 'UGEFightMemberTitle::NormalNameRange' has a wrong offset!");
static_assert(offsetof(UGEFightMemberTitle, ZBugNameRange) == 0x0002D0, "Member 'UGEFightMemberTitle::ZBugNameRange' has a wrong offset!");
static_assert(offsetof(UGEFightMemberTitle, NameRange) == 0x0002D4, "Member 'UGEFightMemberTitle::NameRange' has a wrong offset!");
static_assert(offsetof(UGEFightMemberTitle, VisibleNameNeedCheckTeam) == 0x0002D8, "Member 'UGEFightMemberTitle::VisibleNameNeedCheckTeam' has a wrong offset!");
static_assert(offsetof(UGEFightMemberTitle, LocalPlayerTeamID) == 0x000348, "Member 'UGEFightMemberTitle::LocalPlayerTeamID' has a wrong offset!");

// Class GameEx.WaterParkAnimMetaData
// 0x0010 (0x0038 - 0x0028)
class UWaterParkAnimMetaData final : public UAnimMetaData
{
public:
	bool                                          IsVertical;                                        // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterParkAnimMetaData">();
	}
	static class UWaterParkAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterParkAnimMetaData>();
	}
};
static_assert(alignof(UWaterParkAnimMetaData) == 0x000008, "Wrong alignment on UWaterParkAnimMetaData");
static_assert(sizeof(UWaterParkAnimMetaData) == 0x000038, "Wrong size on UWaterParkAnimMetaData");
static_assert(offsetof(UWaterParkAnimMetaData, IsVertical) == 0x000028, "Member 'UWaterParkAnimMetaData::IsVertical' has a wrong offset!");
static_assert(offsetof(UWaterParkAnimMetaData, Curve) == 0x000030, "Member 'UWaterParkAnimMetaData::Curve' has a wrong offset!");

// Class GameEx.GEGameCharacter
// 0x1030 (0x14F0 - 0x04C0)
class AGEGameCharacter final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    CameraBoom;                                        // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmLengthMax;                                // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmLengthMin;                                // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CamerZoomInFactor;                                 // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationCameraFactor;                              // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchUp;                                     // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchDown;                                   // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FWaterParkCameraInfo> CameraInfos;                                       // 0x04E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector2D>         CameraViewPitchInfos;                              // 0x0538(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MoveWalkToRunMiddleValue;                          // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedLength;                                   // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveForwardValue;                                  // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveForwardValueSetting;                           // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserSettingMoveForwardValue;                      // 0x0598(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveForwardSpeedScale;                             // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRightValue;                                    // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRightValueSetting;                             // 0x05A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserSettingMoveRightValue;                        // 0x05A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveRightSpeedScale;                               // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAtValue;                                       // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAtSpeedScale;                                  // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTurnAt;                                        // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CacheMaxWalkSpeed;                                 // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAtValue;                                     // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAtSpeedScale;                                // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanLookAtUp;                                      // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBindTouch;                                        // 0x05C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTouchRotationCamera;                           // 0x05CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTouchZoomCamera;                               // 0x05CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BeginPlayDelegate;                                 // 0x05CC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             EndPlayDelegate;                                   // 0x05DC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CustomDataString;                                  // 0x05F0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CustomDataNumber;                                  // 0x0640(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0690(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMaxMoveSpeed;                                  // 0x0694(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExMaxMoveSpeed;                                    // 0x0698(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitZBugShootSlowSppedPer;                        // 0x069C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurZBugShootSlowSppedPer;                          // 0x06A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginGravityScale;                                // 0x06A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginFOV;                                         // 0x06A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginScale;                                       // 0x06AC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExMeshScale;                                       // 0x06B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGEAnimInstance>         GEAnimInstance;                                    // 0x06BC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerID;                                          // 0x06C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TemplateId;                                        // 0x06C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRobot;                                           // 0x06CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CD[0x3];                                      // 0x06CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWaterParkCharacterTemplate            CharTemplate;                                      // 0x06D0(0x00D0)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	int32                                         CharTemplateId;                                    // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandUpNeedTime;                                   // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpEndAnimTime;                                   // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpEndOverVel;                                    // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitBackAnimTime;                                   // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PounceAnimTime;                                    // 0x07B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PounceUpAnimTime;                                  // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopPounceSpeedSquared;                            // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopPounce_LowSpeedTime;                           // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C4[0x24];                                     // 0x07C4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnlockJumpTimeInPounceUp;                          // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnlockMoveTimeInPounceUp;                          // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PounceHorizonBeginSpeed;                           // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideEndAnimTime;                                  // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandUpAnimTime;                                   // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomClientPosSmooth;                          // 0x07FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBlockPush;                                      // 0x07FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7FE[0x2];                                      // 0x07FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EWaterParkCharState>                     States_StopMontageOnOver;                          // 0x0800(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          UseOriginJumpLogic;                                // 0x0850(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCameraHitHide;                               // 0x0851(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_852[0x2];                                      // 0x0852(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraHitHideRange;                                // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NextLandResumeGravityScale;                        // 0x0858(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_859[0x7];                                      // 0x0859(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWaterParkCurveMoveInfo                VerticalCurveMoveInfo;                             // 0x0860(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FWaterParkCurveMoveInfo                HorizontalCurveMoveInfo;                           // 0x0898(0x0038)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WalkBeginAnimPlayMaxSpeed;                         // 0x08D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D4[0x4];                                      // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     FrictionCurveByUniformSpeed;                       // 0x08D8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FrictionCurveTickDelta;                            // 0x0960(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomRotationSpeed;                            // 0x0964(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_965[0x3];                                      // 0x0965(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     RotationSpeedCurveByUniformSpeed;                  // 0x0968(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxAccInItem;                                      // 0x09F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalkingInItem;                  // 0x09F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RotationSpeedCurveByUniformSpeed_InItem;           // 0x09F8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxAccInItemRushing;                               // 0x0A80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalkingInItemRushing;           // 0x0A84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RotationSpeedCurveByUniformSpeed_InItemRushing;    // 0x0A88(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FallingWithHeight;                                 // 0x0B10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RampVec;                                           // 0x0B14(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccOnWaterRamp;                                 // 0x0B20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidePitchOffset;                                  // 0x0B24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidePitchChangeSpeed;                             // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowMeshSlidePitch;                                 // 0x0B2C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B30[0x4];                                      // 0x0B30(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowHeightToFloor;                                  // 0x0B34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurWaterRampID;                                    // 0x0B38(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRampSync_Timer;                               // 0x0B3C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRampSync_CD;                                  // 0x0B40(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRamp_NeedSmoothValue;                         // 0x0B44(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaterRamp_RemainSmoothCount;                       // 0x0B48(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaterRamp_SmoothMaxCount;                          // 0x0B4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockPounce;                                       // 0x0B50(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B51[0x3];                                      // 0x0B51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ContinuousSpeedVecOffset;                          // 0x0B54(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ContinuousSpeedVecOffset_ZeroSpeedInValid;         // 0x0B60(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ContinuousSpeedVecOffset_WithFalling;              // 0x0B6C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWaterParkCharacterContinuesVecForward ContinuousSpeedVecOffset_Forward;                  // 0x0B78(0x000C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ContinuesSpeedVecOffset_WaterRamp;                 // 0x0B84(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HaveInstantTempLastSpeed;                          // 0x0B90(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B91[0x3];                                      // 0x0B91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InstantTempLastSpeed;                              // 0x0B94(0x000C)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRamp_CurTime;                                 // 0x0BA0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0x4];                                      // 0x0BA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       WaterRamp_Spline;                                  // 0x0BA8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed_WaterRamp;                                // 0x0BB0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitSpeed_WaterRamp;                               // 0x0BB4(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardVecOffset_CurTick;                          // 0x0BC0(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterRampOffset_Continues;                         // 0x0BCC(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterRampOffset_Input;                             // 0x0BD8(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowCustomGravityScale;                             // 0x0BE4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowCustomGravityTimer;                             // 0x0BE8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowCustomGravityDur;                               // 0x0BEC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSettlement;                                      // 0x0BF0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x3];                                      // 0x0BF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeedPlayAnimIndex;                                 // 0x0BF4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InJump;                                            // 0x0BF8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InFalling;                                         // 0x0BF9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InPushOther;                                       // 0x0BFA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFB[0x15];                                     // 0x0BFB(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	EWaterParkCharState                           Cur3CState;                                        // 0x0C10(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockJump;                                         // 0x0C11(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockAttack;                                       // 0x0C12(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockDoubleJump;                                   // 0x0C13(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockMove;                                         // 0x0C14(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C15[0x3];                                      // 0x0C15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlockMoveBit;                                      // 0x0C18(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockMoveFromUI;                                   // 0x0C1C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockMoveFromSlideEnd;                             // 0x0C1D(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockMoveFromCom;                                  // 0x0C1E(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockJumpFromUI;                                   // 0x0C1F(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockJumpFromPounce;                               // 0x0C20(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C21[0x3];                                      // 0x0C21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Now3CStateTime;                                    // 0x0C24(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWPCharStateMachineComponent*           WPCharStateMachine;                                // 0x0C28(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector>           ContinuesVecMap;                                   // 0x0C30(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FVector>           ContinuesVecMap_WithFalling;                       // 0x0C80(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FWaterParkCharacterContinuesVecForward> ContinuesVecMap_Forward;                           // 0x0CD0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGEZBugRunSpeedModifierDataInfo> ExSpeedMap;                                        // 0x0D20(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    ExScaleMap;                                        // 0x0D70(0x0050)(Transient, NativeAccessSpecifierPublic)
	float                                         CurForwardTotalVecValue;                           // 0x0DC0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientRayCastCD;                                   // 0x0DC4(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC8[0x4];                                      // 0x0DC8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WalkCheckFalling;                                  // 0x0DCC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DCD[0x3];                                      // 0x0DCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkCheckSpeed;                                    // 0x0DD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JumpEndUseHeight;                                  // 0x0DD4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD5[0x6B];                                     // 0x0DD5(0x006B)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DefaultFace;                                       // 0x0E40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFootSocketName;                                // 0x0E48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFootSocketName;                               // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepCheckHeight;                                   // 0x0E58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepCheckRadius;                                   // 0x0E5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepSoundId;                                       // 0x0E60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E64[0xC];                                      // 0x0E64(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      FloorEffect;                                       // 0x0E70(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorEffectHeight;                                 // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E7C[0x4];                                      // 0x0E7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      AccelerateEffect;                                  // 0x0E80(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccelerateLoc;                                     // 0x0E88(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E94[0x4];                                      // 0x0E94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      WaterRampEffect;                                   // 0x0E98(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WaterRampEffect2;                                  // 0x0EA0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterRampLoc;                                      // 0x0EA8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaterRampLoc2;                                     // 0x0EB4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSlope;                                         // 0x0EC0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnWaterRamp;                                     // 0x0EC1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC2[0x2];                                      // 0x0EC2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CumuWaterRampMoveForwardValue;                     // 0x0EC4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CumuWaterRampMoveRightValue;                       // 0x0EC8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRampCollOffset_Horizon;                       // 0x0ECC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterRmapHeight;                                   // 0x0ED0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntryWaterRampBox;                               // 0x0ED4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED5[0x3];                                      // 0x0ED5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ProtectEffect;                                     // 0x0ED8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerateEffectThreshold;                         // 0x0EE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillZ;                                             // 0x0EE4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGEItem>                 CurrentItem;                                       // 0x0EE8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasItemHold;                                       // 0x0EF0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInItemRushing;                                   // 0x0EF1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InItemHoldAnimState;                               // 0x0EF2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsProtecting;                                      // 0x0EF3(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowTargetArea;                                     // 0x0EF4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowArea;                                           // 0x0EF8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFC[0x4];                                      // 0x0EFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AWP_AIAreaModifyActor*                  NowAreaModifyActor;                                // 0x0F00(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    HasHitActors_TimeCache;                            // 0x0F08(0x0050)(Transient, NativeAccessSpecifierPublic)
	float                                         PlayerHitEffShowInternal;                          // 0x0F58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSeesaw;                                        // 0x0F5C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5D[0xB];                                      // 0x0F5D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtituteID;                                       // 0x0F68(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6C[0x54];                                     // 0x0F6C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OriginCapsuleHalfHeight;                           // 0x0FC0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  SubtituteObj;                                      // 0x0FC4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvisible;                                       // 0x0FCC(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FCD[0x3];                                      // 0x0FCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvisibleDuration;                                 // 0x0FD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvisibleTimer;                                    // 0x0FD4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvisibleFadeId;                                   // 0x0FD8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FDC[0x4];                                      // 0x0FDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InvisibleNiagara;                                  // 0x0FE0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE8[0x10];                                     // 0x0FE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsInDuction;                                       // 0x0FF8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF9[0x7];                                      // 0x0FF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InDuctionNiagara;                                  // 0x1000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  NearestEscapeChar;                                 // 0x1008(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDuctionDuration;                                 // 0x1010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDuctionTimer;                                    // 0x1014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRotatingInPlace;                                 // 0x1018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1019[0x3];                                     // 0x1019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SyncRotatingInPlaceTimer;                          // 0x101C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClockWiseTimer;                                    // 0x1020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncRotatingInPlaceCD;                             // 0x1024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemplateSubtituteRotateSpeed;                      // 0x1028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurSubtituteRotateSpeed;                           // 0x102C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x1030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x4];                                     // 0x1034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTree_EntityDataCom*               AbilityDataCom;                                    // 0x1038(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_LogicHandleCom*              LogicSkillHandleCom;                               // 0x1040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_LogicHandleCom*              LogicBuffHandleCom;                                // 0x1048(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGEGameCharacter>        NearestEnemy;                                      // 0x1050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetNearestEnemyTimer;                              // 0x1058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetNearestEnemyCD;                                 // 0x105C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvincibleDurAfterReborn;                          // 0x1060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvincibleTimer;                                   // 0x1064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvincible;                                      // 0x1068(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1069[0x3];                                     // 0x1069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ZBugOriginTag;                                     // 0x106C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurLevelUpCacheBuffCount;                          // 0x1074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CacheNeedRefreshBuffCount;                         // 0x1078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitingClientSelectBuff;                           // 0x107C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_107D[0x3];                                     // 0x107D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           HitEventMeleeTag;                                  // 0x1080(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitEventShootTag;                                  // 0x1088(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GetDamageTag;                                      // 0x1090(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitLauncherEventMeleeTag;                          // 0x1098(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitLauncherEventShootTag;                          // 0x10A0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           KillHelpTag;                                       // 0x10A8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClientOneShootValid;                             // 0x10B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B1[0x27];                                    // 0x10B1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULogicTree_DataFormula*>         Formulas;                                          // 0x10D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGEZBugRunWeaponBase>    PlayerWeapon;                                      // 0x10E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 CacheLevelUpBuffs;                                 // 0x10F0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGECharOwnBuffInfo>             OwnBuffs;                                          // 0x1100(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1110[0xD0];                                    // 0x1110(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          InZBugMode;                                        // 0x11E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZBugRepByRPC;                                      // 0x11E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugThrowBomb;                                   // 0x11E2(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E3[0x1];                                     // 0x11E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBugBombAnimTime;                                  // 0x11E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowZBugAnimPlayTime;                               // 0x11E8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugFiring;                                      // 0x11EC(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugShootAnim;                                   // 0x11ED(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZBugFireRaiseGunComplete;                          // 0x11EE(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZBugFire_InRaiseGun;                               // 0x11EF(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugFireState;                                   // 0x11F0(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugMeleeHit;                                    // 0x11F1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F2[0x2];                                     // 0x11F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBugFireStateRemainTime;                           // 0x11F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeNeedToRaiseGun;                                // 0x11F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0xC];                                     // 0x11FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEPlayerController*                    GEPlayerControllerCache;                           // 0x1208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UswWeaponShootAnimYawOffset;                       // 0x1210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1211[0x3];                                     // 0x1211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponShootAnimYawOffset;                          // 0x1214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponShootAnimYawResumeSpeed;                     // 0x1218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponShootAnimYawRange;                           // 0x121C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowZBugShotYaw;                                    // 0x1220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InMeleeAttackState;                                // 0x1224(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1225[0x3];                                     // 0x1225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZBugMeleeAttackType;                               // 0x1228(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122C[0x4];                                     // 0x122C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ZBugMeleeAttackLogic;                              // 0x1230(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ZBugOutFightBuff;                                  // 0x1248(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ZBugMeleeAttackTag;                                // 0x1260(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugMeleeHitAnimEffTime;                           // 0x1268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126C[0x28];                                    // 0x126C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZBugMeleeAttackId;                                 // 0x1294(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugAimPitch;                                      // 0x1298(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugAimPitch_AI;                                   // 0x129C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugAimPitchSyncCD;                                // 0x12A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A4[0x5];                                     // 0x12A4(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsReloading;                                       // 0x12A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CacheReloadState;                                  // 0x12AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12AB[0x1];                                     // 0x12AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadCD;                                          // 0x12AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDur;                                         // 0x12B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B4[0x4];                                     // 0x12B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PeopleAILogic;                                     // 0x12B8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ZBugAILogic;                                       // 0x12D0(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ZBugGuideAILogic;                                  // 0x12E8(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BanAttackTag;                                      // 0x1300(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1308[0x10];                                    // 0x1308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ZBugNiagara;                                       // 0x1318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ZBugOriginShieldNiagara;                           // 0x1320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ZBugSpeedUpNiagara;                                // 0x1328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ZBugDmgAddRateNiagara;                             // 0x1330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ZBugCureNiagara;                                   // 0x1338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpeedUpNiagaraLevel;                               // 0x1340(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSpeedUpNiagaraLevel;                           // 0x1344(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugSpeedUpPhase1Threshold;                        // 0x1348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DmgAddRateNiagaraLevel;                            // 0x134C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastDmgAddRateNiagaraLevel;                        // 0x1350(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugDmgAddRatePhase1Threshold;                     // 0x1354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignStencil;                                      // 0x1358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyStencil;                                      // 0x135C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutlineStateID;                                    // 0x1360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineDur;                                        // 0x1364(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutlineTimer;                                      // 0x1368(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTickOutline;                                   // 0x136C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136D[0x3];                                     // 0x136D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MeleeDmgTag;                                       // 0x1370(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShoootDmgTag;                                      // 0x1378(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDmg;                                         // 0x1380(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeopleLaunchDmg;                                   // 0x1384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugLaunchDmg;                                     // 0x1388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheToAddExpLaunchDmg;                            // 0x138C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDmg;                                           // 0x1390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeopleTakeDmg;                                     // 0x1394(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugTakeDmg;                                       // 0x1398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheToAddExpTakeDmg;                              // 0x139C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            TakeDmgMap;                                        // 0x13A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	float                                         ZBugLaunchCure;                                    // 0x13F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddKillHelpRate;                                   // 0x13F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDmgToExpThreshold;                           // 0x13F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDmgToExpVal;                                 // 0x13FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDmgToExpThreshold;                             // 0x1400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDmgToExpVal;                                   // 0x1404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeopleLiveToPerformScore;                          // 0x1408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDmgToPerformScore;                           // 0x140C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugLaunchDmgToPerformScore;                       // 0x1410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TakeDmgToPerformScore;                             // 0x1414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            SkillUseInfo;                                      // 0x1418(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            ItemUseInfo;                                       // 0x1468(0x0050)(Transient, NativeAccessSpecifierPublic)
	int32                                         InitWeaponID;                                      // 0x14B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReborning;                                       // 0x14BC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReborningFinish;                                 // 0x14BD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BE[0x2];                                     // 0x14BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RebornTimer;                                       // 0x14C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RebornCD;                                          // 0x14C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RebornTag;                                         // 0x14C8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RebornStartTag;                                    // 0x14D0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RebornTransportTag;                                // 0x14D8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGEFightEnemyHPBar>      EnemyHPBar;                                        // 0x14E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E8[0x8];                                     // 0x14E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBuff(int32 BuffId);
	void ActivateSkill(int32 SkillID);
	void AddBaitToArray(class AActor* InActor, int32 MaxCount);
	void AddBuff(int32 BuffId);
	void AddBuff_MultiCast(int32 BuffId, int32 BuffLevel);
	void AddBuffLevel(int32 BuffId);
	void AddCure(float InCure);
	void AddExMaxMoveSpeed(float InSpeed, const class FString& InKey, float InDuration, bool bOverrideDuration);
	void AddExMeshScale(float InScale, const class FString& InKey);
	void AddGameplayTag(const struct FGameplayTag& InTag);
	void AddHaveSubtituteID(int32 ID);
	void AddItemUseInfo(int32 ItemId, int32 Count);
	void AddLaunchDmg(float InDmg);
	void AddOriginZBugTag();
	void AddOrRemoveRebornTag(bool IsAdd);
	void AddSkillUseInfo(int32 SkillID, int32 Count);
	void AddTakeDmg(float InDmg, int32 LaunchUniqueID);
	void AIDmgHit(const struct FGEZBug_DmgHitInfo& HitInfo, bool NeedRayValidate);
	void AIShootEntityBullet(const struct FVector& FireLoc, const struct FVector& TargetLoc);
	void ApplyCharTemplateDynamic(int32 InTemplateID);
	void ApplyContinuousSpeedVecOffset(const struct FVector& VecOffset, const class FString& InKey);
	void ApplyContinuousSpeedVecOffset_Forward(const struct FWaterParkCharacterContinuesVecForward& VecOffset, const class FString& InKey);
	void ApplyContinuousSpeedVecOffset_WithFalling(const struct FVector& VecOffset, const class FString& InKey);
	void ApplyCustomExGravityScale(float InCustomExGravity, float Duration);
	void ApplyHitBackVec(const struct FVector& HitSpeedVec, float HitBackTime);
	void ApplyHitFlyVec(const struct FVector& HitSpeedVec);
	void ApplyInstantTempLastSpeedVec(const struct FVector& NewVec);
	void ApplyItemEffect_NeedServerTime(int32 ConfigId, float ServertimeMilli);
	void ApplyNewAnimIndexToRep(int32 NewIndex);
	void ApplyNewMoveMode(EMovementMode NewMode);
	void ApplySpeedVec(const struct FVector& NewVec);
	void ApplySpeedVecOffset(const struct FVector& VecOffset);
	void ApplyTemplateAttribute();
	void ApplyWaterParkCharTemplate(const struct FWaterParkCharacterTemplate& InTemplate);
	void AttachAILogicByTeam();
	void AttachGuideAILogic();
	void AttachZBugMeleeLogic();
	void BeAimedByLocalChar();
	void BeInfect();
	void BlockMoveInput();
	void BlockOnlyMoveInput();
	void BroadCastHitBack(const struct FVector& HitSpeedVec, float HitBackTime);
	void BroadCastHitFly(const struct FVector& HitSpeedVec);
	void BroadCastPlayEffect(const class FString& InPath, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	void BroadCastPlayEffectAttachToById(const int32 EffId, class AActor* Parent, const struct FVector& InAttachLoc, const struct FRotator& InRotator, const struct FVector& InScale, class FName AttachName);
	void BroadCastPlayEffectById(const int32 EffId, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	void BroadCastTransport(const struct FVector& TargetLocation);
	void CastSkill(int32 SkillID);
	void CastSkill_MultiCast(int32 SkillID);
	void ChangeCameraInfo(const class FString& InKey);
	void ChangeCamerPitchView(const class FString& InKey);
	bool CheckBuffCanRefresh(int32 BuffId);
	bool CheckBuffIsGet(int32 BuffId);
	bool CheckCanStartAILogic();
	void CheckCurveMoveOnMontagePlay(class UAnimMontage* TargetMontage, class FName MontageName);
	bool CheckHaveSubtituteID(int32 ID);
	bool CheckHaveTag(const struct FGameplayTag& InTag);
	bool CheckMontageIsPlay(class FName TargetName);
	bool CheckNowStateTime(float InTime);
	bool CheckNowStateTimeAndLanding(float InTime, bool NeedLanding);
	void CheckSpawnZBugSpeedUpNiagara(const class FString& InKey);
	void ClearHaveSubtituteID();
	void ClearTakeDmgMap(int32 KillerUniqueID);
	void Client_DamageOther(const struct FGEZBug_DamageRPCInfo& Info);
	void ClientOnDmgAddRateChange(class FName InName, float InValue);
	void DeActiveAllBuffByTeam(EGEBuffTeamType InTeamType);
	void DeActiveBuff(int32 BuffId);
	void DeActiveBuff_MultiCast(int32 BuffId);
	void DeActiveSkill(int32 SkillID);
	void DestroyCurWeapon();
	void EnterWaterRamp(class AActor* InActor);
	void ForceTransport();
	void GenerateEffect(const class FString& InPath, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	class UNiagaraComponent* GenerateEffectAttachTo(const int32 EffId, class AActor* Parent, const struct FVector& InAttachLoc, const struct FRotator& InRotator, const struct FVector& InScale, class FName AttachName);
	class UNiagaraComponent* GenerateEffectById(const int32 EffId, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	float GetAttributeBaseValByName(class FName InName);
	float GetAttributeCurValByName(class FName InName);
	struct FLogicTree_LogicHandle GetBuffHanleByID(int32 BuffId);
	TArray<int32> GetCanLevelUpBuffs();
	class APlayerState* GetCharState();
	class AGEZBugRunWeaponBase* GetCurWeapon();
	class ULogicTree_EntityDataCom* GetDataCom();
	int32 GetHaveSubtituteIDCount();
	struct FVector GetMeshBoundExtend();
	struct FBoxSphereBounds GetMeshBounds();
	class UAnimMontage* GetMontageByName(class FName InName);
	class UCharacterMovementComponent* GetMoveComponent();
	struct FGECharOwnBuffInfo GetOwnBuffInfoById(int32 InBuffId);
	TArray<struct FGECharOwnBuffInfo> GetOwnBuffs();
	struct FVector GetShootPosition();
	struct FLogicTree_LogicHandle GetSkillHandleByID(int32 SkillID);
	class UWaterParkQAnimIns* GetWaterParkAnimIns();
	float GetWeaponShootSpeed();
	EGEZBugRunTeamType GetZBugTeam();
	void HideAllEffect();
	void HitBack(const struct FVector& HitSpeedVec, float HitBackTime);
	void HitFly(const struct FVector& HitSpeedVec);
	void InitLogicComFinish();
	void InitZBugChar();
	void InitZBugLogic();
	bool IsDead();
	bool IsFallEnter();
	bool IsFalling();
	bool IsHitFlyEnd();
	bool IsInAir();
	bool IsInForwardAccelerate();
	bool IsInHitBack();
	bool IsInHitFly();
	bool IsJumpEnd();
	bool IsJumpEndStateEnd();
	bool IsWalk();
	void LockMoveByBit(int32 InBit);
	void LookUpAtRate(float Rate);
	void Lua_PlayAudio(int32 Type);
	void LuaImpl_BecomeHero();
	void LuaImpl_BeInfect();
	void LuaImpl_ClientOnHealthChange(class FName InName, float InValue);
	void LuaImpl_DamageOther(int32 LaunchUniqueID, int32 TargetUniqueID, float InDamage, bool IsCritical, const struct FVector& HitPos);
	void LuaImpl_GetDamage_MultiCast(const struct FGEZBug_DamageRPCInfo& Info);
	void LuaImpl_OnAddedBuff();
	void LuaImpl_OnLevelUp(int32 Level);
	void LuaImpl_RefreshBuff();
	void LuaImpl_SetOutlineOpenOrClose(bool IsOpen, bool IsEnemy, bool NeedTick);
	void LuaImpl_ZBugRebornFinish();
	void LuaImpl_ZBugStartReborn();
	void LuaUpdateOverlaps();
	void MoveForward(float Value);
	void MoveRight(float Value);
	void MoveUp(float Value);
	void Multicast_DoExpression(int32 ExpressionId, int32 InRoleID);
	void MultiCast_GetDamage(const struct FGEZBug_DamageRPCInfo& Info);
	void MultiCast_SubtituteRotateInPlace(float ClockWiseTime);
	void Multicast_ZBugChangeFireState(bool InNewFiring, bool InNewFireState);
	bool NotInWalk();
	void OnClientBeCure();
	void OnLogicStateChange(EWaterParkCharState OldState, EWaterParkCharState NewState);
	void OnRep_CacheLevelUpBuffs();
	void OnRep_HasItemHold();
	void OnRep_InstantTempLastSpeed();
	void OnRep_IsInDuction();
	void OnRep_IsInvisible();
	void OnRep_isProtecting();
	void OnRep_IsReborning();
	void OnRep_NeedPlayAnimState();
	void OnRep_PlayerWeapon();
	void OnRep_SetTemplateId();
	void OnRep_SubtituteID();
	void OnRep_ZBugMeleeAttackType();
	void OnTiming(int32 TimingId);
	void OnWeaponAttached();
	void OnZBugThrowBomb();
	void PlayEffect(const class FString& InPath, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	void PlayEffectAttachToById(const int32 EffId, class AActor* Parent, const struct FVector& InAttachLoc, const struct FRotator& InRotator, const struct FVector& InScale, class FName AttachName);
	void PlayEffectById(const int32 EffId, const struct FVector& InLocation, const struct FRotator& InRotation, const struct FVector& InScale);
	void PlayMontageByName(class FName TargetName, bool ChangeRepIndex);
	void PlayStepEvent();
	void PlayZBugStepEvent();
	void Pounce();
	void RemoveBait(class AActor* InActor);
	void RemoveContinuousSpeedVecOffset(const struct FVector& VecOffset, const class FString& InKey);
	void RemoveContinuousSpeedVecOffset_Forward(const class FString& InKey);
	void RemoveContinuousSpeedVecOffset_WithFalling(const struct FVector& VecOffset, const class FString& InKey);
	void RemoveExMaxMoveSpeed(float InSpeed, const class FString& InKey);
	void RemoveExMeshScale(float InScale, const class FString& InKey);
	void RemoveGameplayTag(const struct FGameplayTag& InTag);
	void ResetInstantTempLastSpeedVec();
	void SendBuffMsg(int32 BuffId, int32 BuffLevel);
	void SetAttributeBaseValByName(class FName InName, float InValue);
	void SetAttributeCurValByName(class FName InName, float InValue);
	void SetBlockDoubleJump(bool NewBlockDoubleJump);
	void SetBlockMoveAndJumpFromUI(bool NewBlockMove, bool NewBlockJump);
	void SetBlockMoveFromCom(bool NewBlockMove);
	void SetDisAbleFloorAdjust(bool bDisable);
	void SetEnterInvisible(float Dur);
	void SetInFalling(bool bFalling);
	void SetInJump(bool bJump);
	void SetInZBugMeleeHit();
	void SetIsRotatingInPlace(bool InValue, bool IsClockWise);
	void SetNextLandResumeGravityScale(bool InValue);
	void SetOriginScale(const struct FVector& InScale);
	void SetPlayerWeapon(class AActor* InWeapon);
	void ShowFace(class UTexture2D* TargetFace, int32 Slot, const class FString& TargetName, int32 LayerIndex);
	void StartReborn();
	void StopAILogic();
	void StopAllMontages();
	void StopAttack();
	void StopMontageByName(class FName TargetName);
	void SyncWaterRampTime_NetMulticast(float InCurTime, int64 InServerTimeMilli);
	void TickCheckWaterRamp();
	void TickContinueVecWaterRamp(float DeltaSeconds);
	void TickItemEffect(float DeltaSeconds);
	void TickRotateInPlace(float DeltaSeconds);
	void Transport(const struct FVector& TargetLocation);
	void TryAttack();
	void TryJump();
	void TryReload();
	void TryUseItem(int32 Index_0, bool IsAttachedItem);
	void TryUseItem1();
	void TryUseItem2();
	void TryUseItem_LuaImpl(int32 Index_0, int32 ConfigId, bool IsAttachedItem);
	void TryUseSkill(int32 InIndex);
	void TurnAtRate(float Rate);
	void UnLockMoveByBit(int32 InBit);
	void UnLockMoveInput();
	void UpdateAILogicByTeam();
	float UpdateVelocityLenth();
	void UseItem_MultiCast(int32 ConfigId, float ServertimeMilli);
	void ZBug_TickGetNearestEnemy(float DeltaSeconds);
	void ZBugRebornSendMsg(int32 Type);

	class UCameraComponent* GetCamera() const;
	class USpringArmComponent* GetCameraBoom() const;
	bool IsInFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEGameCharacter">();
	}
	static class AGEGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEGameCharacter>();
	}
};
static_assert(alignof(AGEGameCharacter) == 0x000010, "Wrong alignment on AGEGameCharacter");
static_assert(sizeof(AGEGameCharacter) == 0x0014F0, "Wrong size on AGEGameCharacter");
static_assert(offsetof(AGEGameCharacter, CameraBoom) == 0x0004C0, "Member 'AGEGameCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FollowCamera) == 0x0004C8, "Member 'AGEGameCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TargetArmLengthMax) == 0x0004D0, "Member 'AGEGameCharacter::TargetArmLengthMax' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TargetArmLengthMin) == 0x0004D4, "Member 'AGEGameCharacter::TargetArmLengthMin' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CamerZoomInFactor) == 0x0004D8, "Member 'AGEGameCharacter::CamerZoomInFactor' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RotationCameraFactor) == 0x0004DC, "Member 'AGEGameCharacter::RotationCameraFactor' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CameraPitchUp) == 0x0004E0, "Member 'AGEGameCharacter::CameraPitchUp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CameraPitchDown) == 0x0004E4, "Member 'AGEGameCharacter::CameraPitchDown' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CameraInfos) == 0x0004E8, "Member 'AGEGameCharacter::CameraInfos' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CameraViewPitchInfos) == 0x000538, "Member 'AGEGameCharacter::CameraViewPitchInfos' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveWalkToRunMiddleValue) == 0x000588, "Member 'AGEGameCharacter::MoveWalkToRunMiddleValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveSpeedLength) == 0x00058C, "Member 'AGEGameCharacter::MoveSpeedLength' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveForwardValue) == 0x000590, "Member 'AGEGameCharacter::MoveForwardValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveForwardValueSetting) == 0x000594, "Member 'AGEGameCharacter::MoveForwardValueSetting' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bUserSettingMoveForwardValue) == 0x000598, "Member 'AGEGameCharacter::bUserSettingMoveForwardValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveForwardSpeedScale) == 0x00059C, "Member 'AGEGameCharacter::MoveForwardSpeedScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveRightValue) == 0x0005A0, "Member 'AGEGameCharacter::MoveRightValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveRightValueSetting) == 0x0005A4, "Member 'AGEGameCharacter::MoveRightValueSetting' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bUserSettingMoveRightValue) == 0x0005A8, "Member 'AGEGameCharacter::bUserSettingMoveRightValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveRightSpeedScale) == 0x0005AC, "Member 'AGEGameCharacter::MoveRightSpeedScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TurnAtValue) == 0x0005B0, "Member 'AGEGameCharacter::TurnAtValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TurnAtSpeedScale) == 0x0005B4, "Member 'AGEGameCharacter::TurnAtSpeedScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bCanTurnAt) == 0x0005B8, "Member 'AGEGameCharacter::bCanTurnAt' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheMaxWalkSpeed) == 0x0005BC, "Member 'AGEGameCharacter::CacheMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LookUpAtValue) == 0x0005C0, "Member 'AGEGameCharacter::LookUpAtValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LookUpAtSpeedScale) == 0x0005C4, "Member 'AGEGameCharacter::LookUpAtSpeedScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bCanLookAtUp) == 0x0005C8, "Member 'AGEGameCharacter::bCanLookAtUp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bBindTouch) == 0x0005C9, "Member 'AGEGameCharacter::bBindTouch' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bCanTouchRotationCamera) == 0x0005CA, "Member 'AGEGameCharacter::bCanTouchRotationCamera' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bCanTouchZoomCamera) == 0x0005CB, "Member 'AGEGameCharacter::bCanTouchZoomCamera' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BeginPlayDelegate) == 0x0005CC, "Member 'AGEGameCharacter::BeginPlayDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, EndPlayDelegate) == 0x0005DC, "Member 'AGEGameCharacter::EndPlayDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CustomDataString) == 0x0005F0, "Member 'AGEGameCharacter::CustomDataString' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CustomDataNumber) == 0x000640, "Member 'AGEGameCharacter::CustomDataNumber' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MoveSpeed) == 0x000690, "Member 'AGEGameCharacter::MoveSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BaseMaxMoveSpeed) == 0x000694, "Member 'AGEGameCharacter::BaseMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ExMaxMoveSpeed) == 0x000698, "Member 'AGEGameCharacter::ExMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LimitZBugShootSlowSppedPer) == 0x00069C, "Member 'AGEGameCharacter::LimitZBugShootSlowSppedPer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurZBugShootSlowSppedPer) == 0x0006A0, "Member 'AGEGameCharacter::CurZBugShootSlowSppedPer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OriginGravityScale) == 0x0006A4, "Member 'AGEGameCharacter::OriginGravityScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OriginFOV) == 0x0006A8, "Member 'AGEGameCharacter::OriginFOV' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OriginScale) == 0x0006AC, "Member 'AGEGameCharacter::OriginScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ExMeshScale) == 0x0006B8, "Member 'AGEGameCharacter::ExMeshScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, GEAnimInstance) == 0x0006BC, "Member 'AGEGameCharacter::GEAnimInstance' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PlayerID) == 0x0006C4, "Member 'AGEGameCharacter::PlayerID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TemplateId) == 0x0006C8, "Member 'AGEGameCharacter::TemplateId' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsRobot) == 0x0006CC, "Member 'AGEGameCharacter::IsRobot' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CharTemplate) == 0x0006D0, "Member 'AGEGameCharacter::CharTemplate' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CharTemplateId) == 0x0007A0, "Member 'AGEGameCharacter::CharTemplateId' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StandUpNeedTime) == 0x0007A4, "Member 'AGEGameCharacter::StandUpNeedTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, JumpEndAnimTime) == 0x0007A8, "Member 'AGEGameCharacter::JumpEndAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, JumpEndOverVel) == 0x0007AC, "Member 'AGEGameCharacter::JumpEndOverVel' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HitBackAnimTime) == 0x0007B0, "Member 'AGEGameCharacter::HitBackAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PounceAnimTime) == 0x0007B4, "Member 'AGEGameCharacter::PounceAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PounceUpAnimTime) == 0x0007B8, "Member 'AGEGameCharacter::PounceUpAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StopPounceSpeedSquared) == 0x0007BC, "Member 'AGEGameCharacter::StopPounceSpeedSquared' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StopPounce_LowSpeedTime) == 0x0007C0, "Member 'AGEGameCharacter::StopPounce_LowSpeedTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UnlockJumpTimeInPounceUp) == 0x0007E8, "Member 'AGEGameCharacter::UnlockJumpTimeInPounceUp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UnlockMoveTimeInPounceUp) == 0x0007EC, "Member 'AGEGameCharacter::UnlockMoveTimeInPounceUp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PounceHorizonBeginSpeed) == 0x0007F0, "Member 'AGEGameCharacter::PounceHorizonBeginSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SlideEndAnimTime) == 0x0007F4, "Member 'AGEGameCharacter::SlideEndAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StandUpAnimTime) == 0x0007F8, "Member 'AGEGameCharacter::StandUpAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UseCustomClientPosSmooth) == 0x0007FC, "Member 'AGEGameCharacter::UseCustomClientPosSmooth' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UseBlockPush) == 0x0007FD, "Member 'AGEGameCharacter::UseBlockPush' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, States_StopMontageOnOver) == 0x000800, "Member 'AGEGameCharacter::States_StopMontageOnOver' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UseOriginJumpLogic) == 0x000850, "Member 'AGEGameCharacter::UseOriginJumpLogic' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, EnableCameraHitHide) == 0x000851, "Member 'AGEGameCharacter::EnableCameraHitHide' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CameraHitHideRange) == 0x000854, "Member 'AGEGameCharacter::CameraHitHideRange' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NextLandResumeGravityScale) == 0x000858, "Member 'AGEGameCharacter::NextLandResumeGravityScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, VerticalCurveMoveInfo) == 0x000860, "Member 'AGEGameCharacter::VerticalCurveMoveInfo' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HorizontalCurveMoveInfo) == 0x000898, "Member 'AGEGameCharacter::HorizontalCurveMoveInfo' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WalkBeginAnimPlayMaxSpeed) == 0x0008D0, "Member 'AGEGameCharacter::WalkBeginAnimPlayMaxSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FrictionCurveByUniformSpeed) == 0x0008D8, "Member 'AGEGameCharacter::FrictionCurveByUniformSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FrictionCurveTickDelta) == 0x000960, "Member 'AGEGameCharacter::FrictionCurveTickDelta' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UseCustomRotationSpeed) == 0x000964, "Member 'AGEGameCharacter::UseCustomRotationSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RotationSpeedCurveByUniformSpeed) == 0x000968, "Member 'AGEGameCharacter::RotationSpeedCurveByUniformSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MaxAccInItem) == 0x0009F0, "Member 'AGEGameCharacter::MaxAccInItem' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BrakingDecelerationWalkingInItem) == 0x0009F4, "Member 'AGEGameCharacter::BrakingDecelerationWalkingInItem' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RotationSpeedCurveByUniformSpeed_InItem) == 0x0009F8, "Member 'AGEGameCharacter::RotationSpeedCurveByUniformSpeed_InItem' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MaxAccInItemRushing) == 0x000A80, "Member 'AGEGameCharacter::MaxAccInItemRushing' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BrakingDecelerationWalkingInItemRushing) == 0x000A84, "Member 'AGEGameCharacter::BrakingDecelerationWalkingInItemRushing' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RotationSpeedCurveByUniformSpeed_InItemRushing) == 0x000A88, "Member 'AGEGameCharacter::RotationSpeedCurveByUniformSpeed_InItemRushing' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FallingWithHeight) == 0x000B10, "Member 'AGEGameCharacter::FallingWithHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RampVec) == 0x000B14, "Member 'AGEGameCharacter::RampVec' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MaxAccOnWaterRamp) == 0x000B20, "Member 'AGEGameCharacter::MaxAccOnWaterRamp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SlidePitchOffset) == 0x000B24, "Member 'AGEGameCharacter::SlidePitchOffset' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SlidePitchChangeSpeed) == 0x000B28, "Member 'AGEGameCharacter::SlidePitchChangeSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowMeshSlidePitch) == 0x000B2C, "Member 'AGEGameCharacter::NowMeshSlidePitch' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowHeightToFloor) == 0x000B34, "Member 'AGEGameCharacter::NowHeightToFloor' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurWaterRampID) == 0x000B38, "Member 'AGEGameCharacter::CurWaterRampID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampSync_Timer) == 0x000B3C, "Member 'AGEGameCharacter::WaterRampSync_Timer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampSync_CD) == 0x000B40, "Member 'AGEGameCharacter::WaterRampSync_CD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRamp_NeedSmoothValue) == 0x000B44, "Member 'AGEGameCharacter::WaterRamp_NeedSmoothValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRamp_RemainSmoothCount) == 0x000B48, "Member 'AGEGameCharacter::WaterRamp_RemainSmoothCount' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRamp_SmoothMaxCount) == 0x000B4C, "Member 'AGEGameCharacter::WaterRamp_SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockPounce) == 0x000B50, "Member 'AGEGameCharacter::BlockPounce' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuousSpeedVecOffset) == 0x000B54, "Member 'AGEGameCharacter::ContinuousSpeedVecOffset' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuousSpeedVecOffset_ZeroSpeedInValid) == 0x000B60, "Member 'AGEGameCharacter::ContinuousSpeedVecOffset_ZeroSpeedInValid' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuousSpeedVecOffset_WithFalling) == 0x000B6C, "Member 'AGEGameCharacter::ContinuousSpeedVecOffset_WithFalling' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuousSpeedVecOffset_Forward) == 0x000B78, "Member 'AGEGameCharacter::ContinuousSpeedVecOffset_Forward' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuesSpeedVecOffset_WaterRamp) == 0x000B84, "Member 'AGEGameCharacter::ContinuesSpeedVecOffset_WaterRamp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HaveInstantTempLastSpeed) == 0x000B90, "Member 'AGEGameCharacter::HaveInstantTempLastSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InstantTempLastSpeed) == 0x000B94, "Member 'AGEGameCharacter::InstantTempLastSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRamp_CurTime) == 0x000BA0, "Member 'AGEGameCharacter::WaterRamp_CurTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRamp_Spline) == 0x000BA8, "Member 'AGEGameCharacter::WaterRamp_Spline' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MaxSpeed_WaterRamp) == 0x000BB0, "Member 'AGEGameCharacter::MaxSpeed_WaterRamp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ExitSpeed_WaterRamp) == 0x000BB4, "Member 'AGEGameCharacter::ExitSpeed_WaterRamp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ForwardVecOffset_CurTick) == 0x000BC0, "Member 'AGEGameCharacter::ForwardVecOffset_CurTick' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampOffset_Continues) == 0x000BCC, "Member 'AGEGameCharacter::WaterRampOffset_Continues' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampOffset_Input) == 0x000BD8, "Member 'AGEGameCharacter::WaterRampOffset_Input' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowCustomGravityScale) == 0x000BE4, "Member 'AGEGameCharacter::NowCustomGravityScale' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowCustomGravityTimer) == 0x000BE8, "Member 'AGEGameCharacter::NowCustomGravityTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowCustomGravityDur) == 0x000BEC, "Member 'AGEGameCharacter::NowCustomGravityDur' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsSettlement) == 0x000BF0, "Member 'AGEGameCharacter::IsSettlement' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NeedPlayAnimIndex) == 0x000BF4, "Member 'AGEGameCharacter::NeedPlayAnimIndex' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InJump) == 0x000BF8, "Member 'AGEGameCharacter::InJump' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InFalling) == 0x000BF9, "Member 'AGEGameCharacter::InFalling' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InPushOther) == 0x000BFA, "Member 'AGEGameCharacter::InPushOther' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, Cur3CState) == 0x000C10, "Member 'AGEGameCharacter::Cur3CState' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bLockJump) == 0x000C11, "Member 'AGEGameCharacter::bLockJump' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockAttack) == 0x000C12, "Member 'AGEGameCharacter::BlockAttack' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockDoubleJump) == 0x000C13, "Member 'AGEGameCharacter::BlockDoubleJump' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, bLockMove) == 0x000C14, "Member 'AGEGameCharacter::bLockMove' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockMoveBit) == 0x000C18, "Member 'AGEGameCharacter::BlockMoveBit' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockMoveFromUI) == 0x000C1C, "Member 'AGEGameCharacter::BlockMoveFromUI' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockMoveFromSlideEnd) == 0x000C1D, "Member 'AGEGameCharacter::BlockMoveFromSlideEnd' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockMoveFromCom) == 0x000C1E, "Member 'AGEGameCharacter::BlockMoveFromCom' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockJumpFromUI) == 0x000C1F, "Member 'AGEGameCharacter::BlockJumpFromUI' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BlockJumpFromPounce) == 0x000C20, "Member 'AGEGameCharacter::BlockJumpFromPounce' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, Now3CStateTime) == 0x000C24, "Member 'AGEGameCharacter::Now3CStateTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WPCharStateMachine) == 0x000C28, "Member 'AGEGameCharacter::WPCharStateMachine' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuesVecMap) == 0x000C30, "Member 'AGEGameCharacter::ContinuesVecMap' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuesVecMap_WithFalling) == 0x000C80, "Member 'AGEGameCharacter::ContinuesVecMap_WithFalling' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ContinuesVecMap_Forward) == 0x000CD0, "Member 'AGEGameCharacter::ContinuesVecMap_Forward' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ExSpeedMap) == 0x000D20, "Member 'AGEGameCharacter::ExSpeedMap' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ExScaleMap) == 0x000D70, "Member 'AGEGameCharacter::ExScaleMap' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurForwardTotalVecValue) == 0x000DC0, "Member 'AGEGameCharacter::CurForwardTotalVecValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ClientRayCastCD) == 0x000DC4, "Member 'AGEGameCharacter::ClientRayCastCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WalkCheckFalling) == 0x000DCC, "Member 'AGEGameCharacter::WalkCheckFalling' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WalkCheckSpeed) == 0x000DD0, "Member 'AGEGameCharacter::WalkCheckSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, JumpEndUseHeight) == 0x000DD4, "Member 'AGEGameCharacter::JumpEndUseHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, DefaultFace) == 0x000E40, "Member 'AGEGameCharacter::DefaultFace' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LeftFootSocketName) == 0x000E48, "Member 'AGEGameCharacter::LeftFootSocketName' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RightFootSocketName) == 0x000E50, "Member 'AGEGameCharacter::RightFootSocketName' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StepCheckHeight) == 0x000E58, "Member 'AGEGameCharacter::StepCheckHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StepCheckRadius) == 0x000E5C, "Member 'AGEGameCharacter::StepCheckRadius' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, StepSoundId) == 0x000E60, "Member 'AGEGameCharacter::StepSoundId' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FloorEffect) == 0x000E70, "Member 'AGEGameCharacter::FloorEffect' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, FloorEffectHeight) == 0x000E78, "Member 'AGEGameCharacter::FloorEffectHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AccelerateEffect) == 0x000E80, "Member 'AGEGameCharacter::AccelerateEffect' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AccelerateLoc) == 0x000E88, "Member 'AGEGameCharacter::AccelerateLoc' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampEffect) == 0x000E98, "Member 'AGEGameCharacter::WaterRampEffect' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampEffect2) == 0x000EA0, "Member 'AGEGameCharacter::WaterRampEffect2' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampLoc) == 0x000EA8, "Member 'AGEGameCharacter::WaterRampLoc' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampLoc2) == 0x000EB4, "Member 'AGEGameCharacter::WaterRampLoc2' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsOnSlope) == 0x000EC0, "Member 'AGEGameCharacter::IsOnSlope' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsOnWaterRamp) == 0x000EC1, "Member 'AGEGameCharacter::IsOnWaterRamp' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CumuWaterRampMoveForwardValue) == 0x000EC4, "Member 'AGEGameCharacter::CumuWaterRampMoveForwardValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CumuWaterRampMoveRightValue) == 0x000EC8, "Member 'AGEGameCharacter::CumuWaterRampMoveRightValue' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRampCollOffset_Horizon) == 0x000ECC, "Member 'AGEGameCharacter::WaterRampCollOffset_Horizon' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaterRmapHeight) == 0x000ED0, "Member 'AGEGameCharacter::WaterRmapHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsEntryWaterRampBox) == 0x000ED4, "Member 'AGEGameCharacter::IsEntryWaterRampBox' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ProtectEffect) == 0x000ED8, "Member 'AGEGameCharacter::ProtectEffect' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AccelerateEffectThreshold) == 0x000EE0, "Member 'AGEGameCharacter::AccelerateEffectThreshold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, KillZ) == 0x000EE4, "Member 'AGEGameCharacter::KillZ' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurrentItem) == 0x000EE8, "Member 'AGEGameCharacter::CurrentItem' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HasItemHold) == 0x000EF0, "Member 'AGEGameCharacter::HasItemHold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsInItemRushing) == 0x000EF1, "Member 'AGEGameCharacter::IsInItemRushing' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InItemHoldAnimState) == 0x000EF2, "Member 'AGEGameCharacter::InItemHoldAnimState' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsProtecting) == 0x000EF3, "Member 'AGEGameCharacter::IsProtecting' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowTargetArea) == 0x000EF4, "Member 'AGEGameCharacter::NowTargetArea' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowArea) == 0x000EF8, "Member 'AGEGameCharacter::NowArea' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowAreaModifyActor) == 0x000F00, "Member 'AGEGameCharacter::NowAreaModifyActor' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HasHitActors_TimeCache) == 0x000F08, "Member 'AGEGameCharacter::HasHitActors_TimeCache' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PlayerHitEffShowInternal) == 0x000F58, "Member 'AGEGameCharacter::PlayerHitEffShowInternal' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsOnSeesaw) == 0x000F5C, "Member 'AGEGameCharacter::IsOnSeesaw' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SubtituteID) == 0x000F68, "Member 'AGEGameCharacter::SubtituteID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OriginCapsuleHalfHeight) == 0x000FC0, "Member 'AGEGameCharacter::OriginCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SubtituteObj) == 0x000FC4, "Member 'AGEGameCharacter::SubtituteObj' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsInvisible) == 0x000FCC, "Member 'AGEGameCharacter::IsInvisible' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvisibleDuration) == 0x000FD0, "Member 'AGEGameCharacter::InvisibleDuration' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvisibleTimer) == 0x000FD4, "Member 'AGEGameCharacter::InvisibleTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvisibleFadeId) == 0x000FD8, "Member 'AGEGameCharacter::InvisibleFadeId' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvisibleNiagara) == 0x000FE0, "Member 'AGEGameCharacter::InvisibleNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsInDuction) == 0x000FF8, "Member 'AGEGameCharacter::IsInDuction' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InDuctionNiagara) == 0x001000, "Member 'AGEGameCharacter::InDuctionNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NearestEscapeChar) == 0x001008, "Member 'AGEGameCharacter::NearestEscapeChar' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InDuctionDuration) == 0x001010, "Member 'AGEGameCharacter::InDuctionDuration' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InDuctionTimer) == 0x001014, "Member 'AGEGameCharacter::InDuctionTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsRotatingInPlace) == 0x001018, "Member 'AGEGameCharacter::IsRotatingInPlace' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SyncRotatingInPlaceTimer) == 0x00101C, "Member 'AGEGameCharacter::SyncRotatingInPlaceTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ClockWiseTimer) == 0x001020, "Member 'AGEGameCharacter::ClockWiseTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SyncRotatingInPlaceCD) == 0x001024, "Member 'AGEGameCharacter::SyncRotatingInPlaceCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TemplateSubtituteRotateSpeed) == 0x001028, "Member 'AGEGameCharacter::TemplateSubtituteRotateSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurSubtituteRotateSpeed) == 0x00102C, "Member 'AGEGameCharacter::CurSubtituteRotateSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TeamID) == 0x001030, "Member 'AGEGameCharacter::TeamID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AbilityDataCom) == 0x001038, "Member 'AGEGameCharacter::AbilityDataCom' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LogicSkillHandleCom) == 0x001040, "Member 'AGEGameCharacter::LogicSkillHandleCom' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LogicBuffHandleCom) == 0x001048, "Member 'AGEGameCharacter::LogicBuffHandleCom' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NearestEnemy) == 0x001050, "Member 'AGEGameCharacter::NearestEnemy' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, GetNearestEnemyTimer) == 0x001058, "Member 'AGEGameCharacter::GetNearestEnemyTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, GetNearestEnemyCD) == 0x00105C, "Member 'AGEGameCharacter::GetNearestEnemyCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvincibleDurAfterReborn) == 0x001060, "Member 'AGEGameCharacter::InvincibleDurAfterReborn' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InvincibleTimer) == 0x001064, "Member 'AGEGameCharacter::InvincibleTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsInvincible) == 0x001068, "Member 'AGEGameCharacter::IsInvincible' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugOriginTag) == 0x00106C, "Member 'AGEGameCharacter::ZBugOriginTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CurLevelUpCacheBuffCount) == 0x001074, "Member 'AGEGameCharacter::CurLevelUpCacheBuffCount' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheNeedRefreshBuffCount) == 0x001078, "Member 'AGEGameCharacter::CacheNeedRefreshBuffCount' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WaitingClientSelectBuff) == 0x00107C, "Member 'AGEGameCharacter::WaitingClientSelectBuff' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HitEventMeleeTag) == 0x001080, "Member 'AGEGameCharacter::HitEventMeleeTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HitEventShootTag) == 0x001088, "Member 'AGEGameCharacter::HitEventShootTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, GetDamageTag) == 0x001090, "Member 'AGEGameCharacter::GetDamageTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HitLauncherEventMeleeTag) == 0x001098, "Member 'AGEGameCharacter::HitLauncherEventMeleeTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, HitLauncherEventShootTag) == 0x0010A0, "Member 'AGEGameCharacter::HitLauncherEventShootTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, KillHelpTag) == 0x0010A8, "Member 'AGEGameCharacter::KillHelpTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsClientOneShootValid) == 0x0010B0, "Member 'AGEGameCharacter::IsClientOneShootValid' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, Formulas) == 0x0010D8, "Member 'AGEGameCharacter::Formulas' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PlayerWeapon) == 0x0010E8, "Member 'AGEGameCharacter::PlayerWeapon' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheLevelUpBuffs) == 0x0010F0, "Member 'AGEGameCharacter::CacheLevelUpBuffs' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OwnBuffs) == 0x001100, "Member 'AGEGameCharacter::OwnBuffs' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugMode) == 0x0011E0, "Member 'AGEGameCharacter::InZBugMode' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugRepByRPC) == 0x0011E1, "Member 'AGEGameCharacter::ZBugRepByRPC' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugThrowBomb) == 0x0011E2, "Member 'AGEGameCharacter::InZBugThrowBomb' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugBombAnimTime) == 0x0011E4, "Member 'AGEGameCharacter::ZBugBombAnimTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowZBugAnimPlayTime) == 0x0011E8, "Member 'AGEGameCharacter::NowZBugAnimPlayTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugFiring) == 0x0011EC, "Member 'AGEGameCharacter::InZBugFiring' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugShootAnim) == 0x0011ED, "Member 'AGEGameCharacter::InZBugShootAnim' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugFireRaiseGunComplete) == 0x0011EE, "Member 'AGEGameCharacter::ZBugFireRaiseGunComplete' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugFire_InRaiseGun) == 0x0011EF, "Member 'AGEGameCharacter::ZBugFire_InRaiseGun' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugFireState) == 0x0011F0, "Member 'AGEGameCharacter::InZBugFireState' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InZBugMeleeHit) == 0x0011F1, "Member 'AGEGameCharacter::InZBugMeleeHit' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugFireStateRemainTime) == 0x0011F4, "Member 'AGEGameCharacter::ZBugFireStateRemainTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TimeNeedToRaiseGun) == 0x0011F8, "Member 'AGEGameCharacter::TimeNeedToRaiseGun' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, GEPlayerControllerCache) == 0x001208, "Member 'AGEGameCharacter::GEPlayerControllerCache' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, UswWeaponShootAnimYawOffset) == 0x001210, "Member 'AGEGameCharacter::UswWeaponShootAnimYawOffset' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WeaponShootAnimYawOffset) == 0x001214, "Member 'AGEGameCharacter::WeaponShootAnimYawOffset' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WeaponShootAnimYawResumeSpeed) == 0x001218, "Member 'AGEGameCharacter::WeaponShootAnimYawResumeSpeed' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, WeaponShootAnimYawRange) == 0x00121C, "Member 'AGEGameCharacter::WeaponShootAnimYawRange' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NowZBugShotYaw) == 0x001220, "Member 'AGEGameCharacter::NowZBugShotYaw' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InMeleeAttackState) == 0x001224, "Member 'AGEGameCharacter::InMeleeAttackState' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugMeleeAttackType) == 0x001228, "Member 'AGEGameCharacter::ZBugMeleeAttackType' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugMeleeAttackLogic) == 0x001230, "Member 'AGEGameCharacter::ZBugMeleeAttackLogic' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugOutFightBuff) == 0x001248, "Member 'AGEGameCharacter::ZBugOutFightBuff' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugMeleeAttackTag) == 0x001260, "Member 'AGEGameCharacter::ZBugMeleeAttackTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugMeleeHitAnimEffTime) == 0x001268, "Member 'AGEGameCharacter::ZBugMeleeHitAnimEffTime' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugMeleeAttackId) == 0x001294, "Member 'AGEGameCharacter::ZBugMeleeAttackId' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugAimPitch) == 0x001298, "Member 'AGEGameCharacter::ZBugAimPitch' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugAimPitch_AI) == 0x00129C, "Member 'AGEGameCharacter::ZBugAimPitch_AI' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugAimPitchSyncCD) == 0x0012A0, "Member 'AGEGameCharacter::ZBugAimPitchSyncCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsReloading) == 0x0012A9, "Member 'AGEGameCharacter::IsReloading' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheReloadState) == 0x0012AA, "Member 'AGEGameCharacter::CacheReloadState' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ReloadCD) == 0x0012AC, "Member 'AGEGameCharacter::ReloadCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ReloadDur) == 0x0012B0, "Member 'AGEGameCharacter::ReloadDur' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PeopleAILogic) == 0x0012B8, "Member 'AGEGameCharacter::PeopleAILogic' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugAILogic) == 0x0012D0, "Member 'AGEGameCharacter::ZBugAILogic' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugGuideAILogic) == 0x0012E8, "Member 'AGEGameCharacter::ZBugGuideAILogic' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, BanAttackTag) == 0x001300, "Member 'AGEGameCharacter::BanAttackTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugNiagara) == 0x001318, "Member 'AGEGameCharacter::ZBugNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugOriginShieldNiagara) == 0x001320, "Member 'AGEGameCharacter::ZBugOriginShieldNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugSpeedUpNiagara) == 0x001328, "Member 'AGEGameCharacter::ZBugSpeedUpNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugDmgAddRateNiagara) == 0x001330, "Member 'AGEGameCharacter::ZBugDmgAddRateNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugCureNiagara) == 0x001338, "Member 'AGEGameCharacter::ZBugCureNiagara' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SpeedUpNiagaraLevel) == 0x001340, "Member 'AGEGameCharacter::SpeedUpNiagaraLevel' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LastSpeedUpNiagaraLevel) == 0x001344, "Member 'AGEGameCharacter::LastSpeedUpNiagaraLevel' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugSpeedUpPhase1Threshold) == 0x001348, "Member 'AGEGameCharacter::ZBugSpeedUpPhase1Threshold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, DmgAddRateNiagaraLevel) == 0x00134C, "Member 'AGEGameCharacter::DmgAddRateNiagaraLevel' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LastDmgAddRateNiagaraLevel) == 0x001350, "Member 'AGEGameCharacter::LastDmgAddRateNiagaraLevel' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugDmgAddRatePhase1Threshold) == 0x001354, "Member 'AGEGameCharacter::ZBugDmgAddRatePhase1Threshold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AlignStencil) == 0x001358, "Member 'AGEGameCharacter::AlignStencil' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, EnemyStencil) == 0x00135C, "Member 'AGEGameCharacter::EnemyStencil' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OutlineStateID) == 0x001360, "Member 'AGEGameCharacter::OutlineStateID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OutlineDur) == 0x001364, "Member 'AGEGameCharacter::OutlineDur' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, OutlineTimer) == 0x001368, "Member 'AGEGameCharacter::OutlineTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, NeedTickOutline) == 0x00136C, "Member 'AGEGameCharacter::NeedTickOutline' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, MeleeDmgTag) == 0x001370, "Member 'AGEGameCharacter::MeleeDmgTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ShoootDmgTag) == 0x001378, "Member 'AGEGameCharacter::ShoootDmgTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LaunchDmg) == 0x001380, "Member 'AGEGameCharacter::LaunchDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PeopleLaunchDmg) == 0x001384, "Member 'AGEGameCharacter::PeopleLaunchDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugLaunchDmg) == 0x001388, "Member 'AGEGameCharacter::ZBugLaunchDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheToAddExpLaunchDmg) == 0x00138C, "Member 'AGEGameCharacter::CacheToAddExpLaunchDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TakeDmg) == 0x001390, "Member 'AGEGameCharacter::TakeDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PeopleTakeDmg) == 0x001394, "Member 'AGEGameCharacter::PeopleTakeDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugTakeDmg) == 0x001398, "Member 'AGEGameCharacter::ZBugTakeDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, CacheToAddExpTakeDmg) == 0x00139C, "Member 'AGEGameCharacter::CacheToAddExpTakeDmg' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TakeDmgMap) == 0x0013A0, "Member 'AGEGameCharacter::TakeDmgMap' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugLaunchCure) == 0x0013F0, "Member 'AGEGameCharacter::ZBugLaunchCure' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, AddKillHelpRate) == 0x0013F4, "Member 'AGEGameCharacter::AddKillHelpRate' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LaunchDmgToExpThreshold) == 0x0013F8, "Member 'AGEGameCharacter::LaunchDmgToExpThreshold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LaunchDmgToExpVal) == 0x0013FC, "Member 'AGEGameCharacter::LaunchDmgToExpVal' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TakeDmgToExpThreshold) == 0x001400, "Member 'AGEGameCharacter::TakeDmgToExpThreshold' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TakeDmgToExpVal) == 0x001404, "Member 'AGEGameCharacter::TakeDmgToExpVal' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, PeopleLiveToPerformScore) == 0x001408, "Member 'AGEGameCharacter::PeopleLiveToPerformScore' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, LaunchDmgToPerformScore) == 0x00140C, "Member 'AGEGameCharacter::LaunchDmgToPerformScore' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ZBugLaunchDmgToPerformScore) == 0x001410, "Member 'AGEGameCharacter::ZBugLaunchDmgToPerformScore' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, TakeDmgToPerformScore) == 0x001414, "Member 'AGEGameCharacter::TakeDmgToPerformScore' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, SkillUseInfo) == 0x001418, "Member 'AGEGameCharacter::SkillUseInfo' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, ItemUseInfo) == 0x001468, "Member 'AGEGameCharacter::ItemUseInfo' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, InitWeaponID) == 0x0014B8, "Member 'AGEGameCharacter::InitWeaponID' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsReborning) == 0x0014BC, "Member 'AGEGameCharacter::IsReborning' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, IsReborningFinish) == 0x0014BD, "Member 'AGEGameCharacter::IsReborningFinish' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RebornTimer) == 0x0014C0, "Member 'AGEGameCharacter::RebornTimer' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RebornCD) == 0x0014C4, "Member 'AGEGameCharacter::RebornCD' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RebornTag) == 0x0014C8, "Member 'AGEGameCharacter::RebornTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RebornStartTag) == 0x0014D0, "Member 'AGEGameCharacter::RebornStartTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, RebornTransportTag) == 0x0014D8, "Member 'AGEGameCharacter::RebornTransportTag' has a wrong offset!");
static_assert(offsetof(AGEGameCharacter, EnemyHPBar) == 0x0014E0, "Member 'AGEGameCharacter::EnemyHPBar' has a wrong offset!");

// Class GameEx.GEGameHelper
// 0x0000 (0x0028 - 0x0028)
class UGEGameHelper final : public UObject
{
public:
	static void ActivateTouchInterface(class APlayerController* PC, const class FString& JoystickSetUpPath);
	static bool CheckLineTrace(class AActor* InActor, const struct FVector& InDir);
	static struct FVector ConvertRotatorToVector(const struct FRotator& InRot);
	static struct FRotator ConvertVectorToOrientRotator(const struct FVector& InVector);
	static struct FRotator ConvertVectorToRotator(const struct FVector& InVector);
	static void CreateTouchInterface(class APlayerController* PC);
	static class UUserWidget* CreateWidget(class UWorld* World, class UClass* Class_0);
	static bool DeleteFile(const class FString& FilePath);
	static bool DeleteFilesWithSuffix(const class FString& Path, const TArray<class FString>& Suffixes);
	static bool FileExist(const class FString& File);
	static class AActor* GetActorByTag(class UObject* Content, class FName Tag);
	static float GetAverageFPS();
	static struct FVector2D GetCursorPos();
	static class UWorld* GetDedicatedServerWorld();
	static class FName GetFName(class UObject* Obj);
	static struct FGameplayTag GetGamePlayTagByName(const class FName& TagName);
	static class AGEHideAndSeekMgr* GetHideAndSeekMgr(const class UObject* WorldContextObject);
	static class FString GetIniConfig(const class FString& _Section, const class FString& _Key, const class FString& Filename);
	static struct FVector2D GetLastCursorPos();
	static float GetLoadProgress(const class FString& PackageName);
	static class AGEPlayerController* GetLocalPlayerController(const class UObject* WorldContextObject);
	static class FString GetMapName(class UObject* Obj);
	static class AActor* GetNearestActorByClass(class AActor* Finder, const TArray<class AActor*>& TargetActors);
	static class AActor* GetNearestCharByTeamID(class AActor* Finder, int32 TeamID);
	static struct FVector2D GetPlatformCursor();
	static class APawn* GetPlayerStatePawn(class APlayerState* State);
	static struct FVector2D GetPointerPosition(uint32 PointerIndex);
	static struct FVector2D GetPreviousPointerPosition(uint32 PointerIndex);
	static TArray<struct FHitResult> GetRecentlyActorByTrace(class AActor* Actor, const struct FVector& Start, const struct FVector& End, float Radius, int32 TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, ECheckTraceType CheckType);
	static EGECampRelation GetRelation(const class AActor* Launcher, const class AActor* Target);
	static uint32 GetSlateAppCursorPointerIndex();
	static int64 GetTimestampMillisecond();
	static int32 GetUniqueID(class UObject* Obj);
	static class UWidget* GetWidgetFromName(class UUserWidget* Widget, const class FName& Name_0);
	static bool IsEditerMode();
	static bool LoadFileToString(const class FString& Filename, class FString* Result);
	static bool LoadLevelAsync(const class FString& InName, const TArray<class FString>& Packages, TDelegate<void()> OnPackageLoaded);
	static class FString MD5(const class FString& FilePath);
	static void RegisterComponent(class UActorComponent* Com);
	static class FString SaveRoot();
	static bool SaveStringToFile(const class FString& Filename, const class FString& String);
	static void SetIniConfig(const class FString& _Section, const class FString& _Key, const class FString& _Value, const class FString& Filename);
	static void SetPlayerState(class APawn* Pawn, class APlayerState* NewPlayerState);
	static EAppReturnType ShowDialog(EAppMsgType Type, const class FString& Str);
	static struct FVector VectorDotHelp(const struct FVector& InVelocity, const struct FVector& InNormal);
	static struct FVector VectorPlaneHelp(const struct FVector& InVelocity, const struct FVector& Normal);

	void OnPackageLoaded__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEGameHelper">();
	}
	static class UGEGameHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEGameHelper>();
	}
};
static_assert(alignof(UGEGameHelper) == 0x000008, "Wrong alignment on UGEGameHelper");
static_assert(sizeof(UGEGameHelper) == 0x000028, "Wrong size on UGEGameHelper");

// Class GameEx.GEGameModeBase
// 0x0390 (0x0658 - 0x02C8)
class AGEGameModeBase final : public AGameModeBase
{
public:
	TDelegate<void(class AGEGameModeBase* GameModeBase, const class FString& MapName, const class FString& Options, class FString* ErrorMessage)> InitGameDelegate;                                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             RspRoomDataDelegate;                               // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             StartPlayDelegate;                                 // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UNetConnection* Connection, class FString* RedirectURL)> GameWelcomePlayerDelegate;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Options, const class FString& Address, struct FUniqueNetIdRepl& UniqueId, class FString* ErrorMessage)> PreLoginDelegate;                                  // 0x0308(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UPlayer* NewPlayer, ENetRole InRemoteRole, const class FString& Portal, const class FString& Options, struct FUniqueNetIdRepl& UniqueId, class FString* ErrorMessage)> LoginDelegate;                                     // 0x0318(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class APlayerController* NewPlayer)> PostLoginDelegate;                                 // 0x0328(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AController* Exiting)>   LogoutDelegate;                                    // 0x0338(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class APlayerController* PlayerController, ENetRole InRemoteRole, const class FString& Options)> SpawnPlayerControllerDelegate;                     // 0x0348(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AController* InController)> GetDefaultPawnClassForControllerDelegate;          // 0x0358(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AController* NewPlayer, struct FTransform& SpawnTransform)> SpawnDefaultPawnAtTransformDelegate;               // 0x0368(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AController* Player)>    ChoosePlayerStartDelegate;                         // 0x0378(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class AController** Controller)> HandleSeamlessTravelPlayerDelegate;                // 0x0388(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PostSeamlessTravelDelegate;                        // 0x0398(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             StartToLeaveMapDelegate;                           // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GamePhaseChangeDelegate;                           // 0x03B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseCustomSpawnCharId;                              // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnCharId;                                       // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitPlayerTime;                                    // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WatiEntryTime;                                     // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x140];                                    // 0x03D8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUniqueNetIdRepl, TWeakObjectPtr<class APlayerController>> ReConnectedPlayerControllersMap;                   // 0x0518(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FUniqueNetIdRepl, TWeakObjectPtr<class UNetConnection>> PlayerId2NetConnectionMap;                         // 0x0568(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FUniqueNetIdRepl, TWeakObjectPtr<class APlayerController>> ReConnectedAIControlPlayerControllersMap;          // 0x05B8(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x4];                                      // 0x0608(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x060C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomId;                                            // 0x0614(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gametype;                                          // 0x0618(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSingleMode;                                      // 0x061C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameOver;                                        // 0x061D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAllPlayerOffline;                                // 0x061E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameProgress;                                    // 0x061F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevelId;                                    // 0x0620(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealMaxPlayerCount;                                // 0x0624(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTestMode;                                        // 0x0628(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FireHitCalcLogicPath;                              // 0x0630(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZBugRunProgressOver;                               // 0x0648(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ZBug_PosLagOffset;                                 // 0x064C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddAIControlReconnectedControlCache(class APlayerState* InPs, class APlayerController* InController);
	void BeforeAllPlayerOffline();
	void CallSuperLogOut(class AController* Exiting);
	bool CheckIsGameStart();
	bool CheckIsZBugGuide();
	class AActor* ChoosePlayerStartDelegate__DelegateSignature(class AController* Player);
	void CloseClientConnection();
	void GameWelcomePlayerDelegate__DelegateSignature(class UNetConnection* Connection, class FString* RedirectURL);
	class UClass* GetDefaultPawnClassForControllerDelegate__DelegateSignature(class AController* InController);
	void HandleCharacterHasEnded(class AGEPlayerController* InController);
	void HandleMatchHasEnded();
	void HandleSeamlessTravelPlayerDelegate__DelegateSignature(class AController** Controller);
	class AGEHASAIPathPoint* HAS_GetRandomTargetPoint(int32 TeamID);
	class AGEHASAIPathPoint* HAS_GetTargetPointByID(int32 TeamID, int32 PointID);
	void InitGameDelegate__DelegateSignature(class AGEGameModeBase* GameModeBase, const class FString& MapName, const class FString& Options, class FString* ErrorMessage);
	void InitZBugLogic();
	bool IsNoTargetPoint();
	class FString LoginDelegate__DelegateSignature(class UPlayer* NewPlayer, ENetRole InRemoteRole, const class FString& Portal, const class FString& Options, const struct FUniqueNetIdRepl& UniqueId, class FString* ErrorMessage);
	void LogoutDelegate__DelegateSignature(class AController* Exiting);
	void LuaImpl_BeforeAllPlayerOffline();
	void OnRspRoomData();
	void OnRspRoomDataDelegate__DelegateSignature();
	void PostLoginDelegate__DelegateSignature(class APlayerController* NewPlayer);
	void PostSeamlessTravelDelegate__DelegateSignature();
	class FString PreLoginDelegate__DelegateSignature(const class FString& Options, const class FString& Address, const struct FUniqueNetIdRepl& UniqueId, class FString* ErrorMessage);
	class APawn* SpawnDefaultPawnAtTransformDelegate__DelegateSignature(class AController* NewPlayer, const struct FTransform& SpawnTransform);
	class UClass* SpawnPlayerControllerDelegate__DelegateSignature(class APlayerController* PlayerController, ENetRole InRemoteRole, const class FString& Options);
	void StartPlayDelegate__DelegateSignature();
	void StartToLeaveMapDelegate__DelegateSignature();
	void StopSession(TMap<class FString, int64>* DataMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEGameModeBase">();
	}
	static class AGEGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEGameModeBase>();
	}
};
static_assert(alignof(AGEGameModeBase) == 0x000008, "Wrong alignment on AGEGameModeBase");
static_assert(sizeof(AGEGameModeBase) == 0x000658, "Wrong size on AGEGameModeBase");
static_assert(offsetof(AGEGameModeBase, InitGameDelegate) == 0x0002C8, "Member 'AGEGameModeBase::InitGameDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, RspRoomDataDelegate) == 0x0002D8, "Member 'AGEGameModeBase::RspRoomDataDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, StartPlayDelegate) == 0x0002E8, "Member 'AGEGameModeBase::StartPlayDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, GameWelcomePlayerDelegate) == 0x0002F8, "Member 'AGEGameModeBase::GameWelcomePlayerDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, PreLoginDelegate) == 0x000308, "Member 'AGEGameModeBase::PreLoginDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, LoginDelegate) == 0x000318, "Member 'AGEGameModeBase::LoginDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, PostLoginDelegate) == 0x000328, "Member 'AGEGameModeBase::PostLoginDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, LogoutDelegate) == 0x000338, "Member 'AGEGameModeBase::LogoutDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, SpawnPlayerControllerDelegate) == 0x000348, "Member 'AGEGameModeBase::SpawnPlayerControllerDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, GetDefaultPawnClassForControllerDelegate) == 0x000358, "Member 'AGEGameModeBase::GetDefaultPawnClassForControllerDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, SpawnDefaultPawnAtTransformDelegate) == 0x000368, "Member 'AGEGameModeBase::SpawnDefaultPawnAtTransformDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, ChoosePlayerStartDelegate) == 0x000378, "Member 'AGEGameModeBase::ChoosePlayerStartDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, HandleSeamlessTravelPlayerDelegate) == 0x000388, "Member 'AGEGameModeBase::HandleSeamlessTravelPlayerDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, PostSeamlessTravelDelegate) == 0x000398, "Member 'AGEGameModeBase::PostSeamlessTravelDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, StartToLeaveMapDelegate) == 0x0003A8, "Member 'AGEGameModeBase::StartToLeaveMapDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, GamePhaseChangeDelegate) == 0x0003B8, "Member 'AGEGameModeBase::GamePhaseChangeDelegate' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, UseCustomSpawnCharId) == 0x0003C8, "Member 'AGEGameModeBase::UseCustomSpawnCharId' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, SpawnCharId) == 0x0003CC, "Member 'AGEGameModeBase::SpawnCharId' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, WaitPlayerTime) == 0x0003D0, "Member 'AGEGameModeBase::WaitPlayerTime' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, WatiEntryTime) == 0x0003D4, "Member 'AGEGameModeBase::WatiEntryTime' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, ReConnectedPlayerControllersMap) == 0x000518, "Member 'AGEGameModeBase::ReConnectedPlayerControllersMap' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, PlayerId2NetConnectionMap) == 0x000568, "Member 'AGEGameModeBase::PlayerId2NetConnectionMap' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, ReConnectedAIControlPlayerControllersMap) == 0x0005B8, "Member 'AGEGameModeBase::ReConnectedAIControlPlayerControllersMap' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, SessionName) == 0x00060C, "Member 'AGEGameModeBase::SessionName' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, RoomId) == 0x000614, "Member 'AGEGameModeBase::RoomId' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, Gametype) == 0x000618, "Member 'AGEGameModeBase::Gametype' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, IsSingleMode) == 0x00061C, "Member 'AGEGameModeBase::IsSingleMode' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, IsGameOver) == 0x00061D, "Member 'AGEGameModeBase::IsGameOver' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, IsAllPlayerOffline) == 0x00061E, "Member 'AGEGameModeBase::IsAllPlayerOffline' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, IsGameProgress) == 0x00061F, "Member 'AGEGameModeBase::IsGameProgress' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, CurrentLevelId) == 0x000620, "Member 'AGEGameModeBase::CurrentLevelId' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, RealMaxPlayerCount) == 0x000624, "Member 'AGEGameModeBase::RealMaxPlayerCount' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, IsTestMode) == 0x000628, "Member 'AGEGameModeBase::IsTestMode' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, FireHitCalcLogicPath) == 0x000630, "Member 'AGEGameModeBase::FireHitCalcLogicPath' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, ZBugRunProgressOver) == 0x000648, "Member 'AGEGameModeBase::ZBugRunProgressOver' has a wrong offset!");
static_assert(offsetof(AGEGameModeBase, ZBug_PosLagOffset) == 0x00064C, "Member 'AGEGameModeBase::ZBug_PosLagOffset' has a wrong offset!");

// Class GameEx.GEGameState
// 0x0050 (0x02C8 - 0x0278)
class AGEGameState final : public AGameStateBase
{
public:
	int32                                         GameState;                                         // 0x0278(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSingleMode;                                      // 0x027C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Gametype;                                          // 0x0280(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePreReadyDur_HAS;                               // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePreReadyCD_HAS;                                // 0x0288(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameWaitStartCD_HAS;                               // 0x028C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameWaitStartDur_HideAndSeek;                      // 0x0290(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HAS_LastPhaseTime;                                 // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHASLastPhase;                                    // 0x0298(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHASHidePreReadyFinish;                           // 0x0299(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamePreReadyDur_ZBugRun;                           // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePreReadyCD_ZBugRun;                            // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameWaitStartCD_ZBugRun;                           // 0x02A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameWaitStartDur_ZBugRun;                          // 0x02A8(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeroLimit_ZBugRun;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsZBugRunHeroArrive;                               // 0x02B0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsZBugLastPhase;                                   // 0x02B1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ZBugProgressOver;                                  // 0x02B2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3[0x1];                                      // 0x02B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBugLastPhaseTimePoint;                            // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugLastPhaseExpMultiplier;                        // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerGameTime;                                    // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientGameTime;                                    // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientRTT;                                         // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class AActor*> GetAllCharByTeam(int32 TeamID);
	TArray<TWeakObjectPtr<class AGEGameCharacter>> GetAllEnemyCharByTeam(int32 TeamID);
	float GetGameTime();
	class APlayerState* GetPlayerStateByGEUniqueID(int32 InUniqueID);
	void OnRep_GameState();
	void OnRep_GameWaitStartCD_HAS();
	void OnRep_GameWaitStartCD_ZBugRun();
	void OnRep_IsHASHidePreReadyFinish();
	void OnRep_IsHASLastPhase();
	void OnRep_IsZBugLastPhase();
	void OnRep_IsZBugRunHeroArrive();
	void OnRep_ZBugProgressOver();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEGameState">();
	}
	static class AGEGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEGameState>();
	}
};
static_assert(alignof(AGEGameState) == 0x000008, "Wrong alignment on AGEGameState");
static_assert(sizeof(AGEGameState) == 0x0002C8, "Wrong size on AGEGameState");
static_assert(offsetof(AGEGameState, GameState) == 0x000278, "Member 'AGEGameState::GameState' has a wrong offset!");
static_assert(offsetof(AGEGameState, IsSingleMode) == 0x00027C, "Member 'AGEGameState::IsSingleMode' has a wrong offset!");
static_assert(offsetof(AGEGameState, Gametype) == 0x000280, "Member 'AGEGameState::Gametype' has a wrong offset!");
static_assert(offsetof(AGEGameState, GamePreReadyDur_HAS) == 0x000284, "Member 'AGEGameState::GamePreReadyDur_HAS' has a wrong offset!");
static_assert(offsetof(AGEGameState, GamePreReadyCD_HAS) == 0x000288, "Member 'AGEGameState::GamePreReadyCD_HAS' has a wrong offset!");
static_assert(offsetof(AGEGameState, GameWaitStartCD_HAS) == 0x00028C, "Member 'AGEGameState::GameWaitStartCD_HAS' has a wrong offset!");
static_assert(offsetof(AGEGameState, GameWaitStartDur_HideAndSeek) == 0x000290, "Member 'AGEGameState::GameWaitStartDur_HideAndSeek' has a wrong offset!");
static_assert(offsetof(AGEGameState, HAS_LastPhaseTime) == 0x000294, "Member 'AGEGameState::HAS_LastPhaseTime' has a wrong offset!");
static_assert(offsetof(AGEGameState, IsHASLastPhase) == 0x000298, "Member 'AGEGameState::IsHASLastPhase' has a wrong offset!");
static_assert(offsetof(AGEGameState, IsHASHidePreReadyFinish) == 0x000299, "Member 'AGEGameState::IsHASHidePreReadyFinish' has a wrong offset!");
static_assert(offsetof(AGEGameState, GamePreReadyDur_ZBugRun) == 0x00029C, "Member 'AGEGameState::GamePreReadyDur_ZBugRun' has a wrong offset!");
static_assert(offsetof(AGEGameState, GamePreReadyCD_ZBugRun) == 0x0002A0, "Member 'AGEGameState::GamePreReadyCD_ZBugRun' has a wrong offset!");
static_assert(offsetof(AGEGameState, GameWaitStartCD_ZBugRun) == 0x0002A4, "Member 'AGEGameState::GameWaitStartCD_ZBugRun' has a wrong offset!");
static_assert(offsetof(AGEGameState, GameWaitStartDur_ZBugRun) == 0x0002A8, "Member 'AGEGameState::GameWaitStartDur_ZBugRun' has a wrong offset!");
static_assert(offsetof(AGEGameState, HeroLimit_ZBugRun) == 0x0002AC, "Member 'AGEGameState::HeroLimit_ZBugRun' has a wrong offset!");
static_assert(offsetof(AGEGameState, IsZBugRunHeroArrive) == 0x0002B0, "Member 'AGEGameState::IsZBugRunHeroArrive' has a wrong offset!");
static_assert(offsetof(AGEGameState, IsZBugLastPhase) == 0x0002B1, "Member 'AGEGameState::IsZBugLastPhase' has a wrong offset!");
static_assert(offsetof(AGEGameState, ZBugProgressOver) == 0x0002B2, "Member 'AGEGameState::ZBugProgressOver' has a wrong offset!");
static_assert(offsetof(AGEGameState, ZBugLastPhaseTimePoint) == 0x0002B4, "Member 'AGEGameState::ZBugLastPhaseTimePoint' has a wrong offset!");
static_assert(offsetof(AGEGameState, ZBugLastPhaseExpMultiplier) == 0x0002B8, "Member 'AGEGameState::ZBugLastPhaseExpMultiplier' has a wrong offset!");
static_assert(offsetof(AGEGameState, ServerGameTime) == 0x0002BC, "Member 'AGEGameState::ServerGameTime' has a wrong offset!");
static_assert(offsetof(AGEGameState, ClientGameTime) == 0x0002C0, "Member 'AGEGameState::ClientGameTime' has a wrong offset!");
static_assert(offsetof(AGEGameState, ClientRTT) == 0x0002C4, "Member 'AGEGameState::ClientRTT' has a wrong offset!");

// Class GameEx.GEGMAttributePreview
// 0x0008 (0x0148 - 0x0140)
class UGEGMAttributePreview final : public UPanelWidget
{
public:
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEGMAttributePreview">();
	}
	static class UGEGMAttributePreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEGMAttributePreview>();
	}
};
static_assert(alignof(UGEGMAttributePreview) == 0x000008, "Wrong alignment on UGEGMAttributePreview");
static_assert(sizeof(UGEGMAttributePreview) == 0x000148, "Wrong size on UGEGMAttributePreview");

// Class GameEx.GEHASAIPathPoint
// 0x0030 (0x0258 - 0x0228)
class AGEHASAIPathPoint final : public AActor
{
public:
	EGEHASTeamType                                Type;                                              // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRandomTime;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomRadius;                                      // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NextPointID;                                       // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsUseItem;                                         // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNextPointID();
	float GetStopTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEHASAIPathPoint">();
	}
	static class AGEHASAIPathPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEHASAIPathPoint>();
	}
};
static_assert(alignof(AGEHASAIPathPoint) == 0x000008, "Wrong alignment on AGEHASAIPathPoint");
static_assert(sizeof(AGEHASAIPathPoint) == 0x000258, "Wrong size on AGEHASAIPathPoint");
static_assert(offsetof(AGEHASAIPathPoint, Type) == 0x000228, "Member 'AGEHASAIPathPoint::Type' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, ID) == 0x00022C, "Member 'AGEHASAIPathPoint::ID' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, StopTime) == 0x000230, "Member 'AGEHASAIPathPoint::StopTime' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, StopRandomTime) == 0x000234, "Member 'AGEHASAIPathPoint::StopRandomTime' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, RandomRadius) == 0x000238, "Member 'AGEHASAIPathPoint::RandomRadius' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, NextPointID) == 0x000240, "Member 'AGEHASAIPathPoint::NextPointID' has a wrong offset!");
static_assert(offsetof(AGEHASAIPathPoint, IsUseItem) == 0x000250, "Member 'AGEHASAIPathPoint::IsUseItem' has a wrong offset!");

// Class GameEx.GEHealTrap
// 0x0068 (0x02B0 - 0x0248)
class AGEHealTrap final : public AGETrapBase
{
public:
	float                                         EffectCD;                                          // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectTimer;                                       // 0x024C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HealTag;                                           // 0x0250(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InHealTrapTag;                                     // 0x0258(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AActor*>            CacheChar;                                         // 0x0260(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddCacheChar(const class FString& InKey, class AActor* InActor);
	void RemoveCacheChar(const class FString& InKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEHealTrap">();
	}
	static class AGEHealTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEHealTrap>();
	}
};
static_assert(alignof(AGEHealTrap) == 0x000008, "Wrong alignment on AGEHealTrap");
static_assert(sizeof(AGEHealTrap) == 0x0002B0, "Wrong size on AGEHealTrap");
static_assert(offsetof(AGEHealTrap, EffectCD) == 0x000248, "Member 'AGEHealTrap::EffectCD' has a wrong offset!");
static_assert(offsetof(AGEHealTrap, EffectTimer) == 0x00024C, "Member 'AGEHealTrap::EffectTimer' has a wrong offset!");
static_assert(offsetof(AGEHealTrap, HealTag) == 0x000250, "Member 'AGEHealTrap::HealTag' has a wrong offset!");
static_assert(offsetof(AGEHealTrap, InHealTrapTag) == 0x000258, "Member 'AGEHealTrap::InHealTrapTag' has a wrong offset!");
static_assert(offsetof(AGEHealTrap, CacheChar) == 0x000260, "Member 'AGEHealTrap::CacheChar' has a wrong offset!");

// Class GameEx.GEHideAndSeekMgr
// 0x00A0 (0x02C8 - 0x0228)
class AGEHideAndSeekMgr final : public AActor
{
public:
	TArray<struct FHASMeshSettings>               MeshGroup;                                         // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CanSwitchCount;                                    // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DObjGroup;                                         // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinRandomDObjCount;                                // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRandomDObjCount;                                // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CanSwitchMeshIndexArr;                             // 0x0258(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<int32>                                 DObjIndexArr;                                      // 0x0268(0x0010)(BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x50];                                     // 0x0278(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetDObjByName(const class FString& InName);
	void OnRep_canSwitchMeshIndexArr();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEHideAndSeekMgr">();
	}
	static class AGEHideAndSeekMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEHideAndSeekMgr>();
	}
};
static_assert(alignof(AGEHideAndSeekMgr) == 0x000008, "Wrong alignment on AGEHideAndSeekMgr");
static_assert(sizeof(AGEHideAndSeekMgr) == 0x0002C8, "Wrong size on AGEHideAndSeekMgr");
static_assert(offsetof(AGEHideAndSeekMgr, MeshGroup) == 0x000228, "Member 'AGEHideAndSeekMgr::MeshGroup' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, CanSwitchCount) == 0x000238, "Member 'AGEHideAndSeekMgr::CanSwitchCount' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, DObjGroup) == 0x000240, "Member 'AGEHideAndSeekMgr::DObjGroup' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, MinRandomDObjCount) == 0x000250, "Member 'AGEHideAndSeekMgr::MinRandomDObjCount' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, MaxRandomDObjCount) == 0x000254, "Member 'AGEHideAndSeekMgr::MaxRandomDObjCount' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, CanSwitchMeshIndexArr) == 0x000258, "Member 'AGEHideAndSeekMgr::CanSwitchMeshIndexArr' has a wrong offset!");
static_assert(offsetof(AGEHideAndSeekMgr, DObjIndexArr) == 0x000268, "Member 'AGEHideAndSeekMgr::DObjIndexArr' has a wrong offset!");

// Class GameEx.GEItem
// 0x0058 (0x0280 - 0x0228)
class AGEItem : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       Character;                                         // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PointOwner;                                        // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckRepeat;                                       // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnPos;                                          // 0x0244(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsed;                                            // 0x0250(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsApplyUsed;                                       // 0x0251(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurOwner;                                          // 0x0258(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CacheOwner;                                        // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDisplaySpeed;                                // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseCD;                                             // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0xC];                                      // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LuaImpl_OnAlloc();
	void LuaImpl_OnFree();
	void LuaOnRep_IsUsed();
	void OnRep_CurOwner();
	void OnRep_IsApplyUsed();
	void OnRep_IsForceDetached();
	void OnRep_IsUsed();
	void OnRep_SpawnPos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItem">();
	}
	static class AGEItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEItem>();
	}
};
static_assert(alignof(AGEItem) == 0x000008, "Wrong alignment on AGEItem");
static_assert(sizeof(AGEItem) == 0x000280, "Wrong size on AGEItem");
static_assert(offsetof(AGEItem, MeshComponent) == 0x000228, "Member 'AGEItem::MeshComponent' has a wrong offset!");
static_assert(offsetof(AGEItem, Character) == 0x000230, "Member 'AGEItem::Character' has a wrong offset!");
static_assert(offsetof(AGEItem, PointOwner) == 0x000238, "Member 'AGEItem::PointOwner' has a wrong offset!");
static_assert(offsetof(AGEItem, CheckRepeat) == 0x000240, "Member 'AGEItem::CheckRepeat' has a wrong offset!");
static_assert(offsetof(AGEItem, SpawnPos) == 0x000244, "Member 'AGEItem::SpawnPos' has a wrong offset!");
static_assert(offsetof(AGEItem, IsUsed) == 0x000250, "Member 'AGEItem::IsUsed' has a wrong offset!");
static_assert(offsetof(AGEItem, IsApplyUsed) == 0x000251, "Member 'AGEItem::IsApplyUsed' has a wrong offset!");
static_assert(offsetof(AGEItem, CurOwner) == 0x000258, "Member 'AGEItem::CurOwner' has a wrong offset!");
static_assert(offsetof(AGEItem, CacheOwner) == 0x000260, "Member 'AGEItem::CacheOwner' has a wrong offset!");
static_assert(offsetof(AGEItem, RotateDisplaySpeed) == 0x000268, "Member 'AGEItem::RotateDisplaySpeed' has a wrong offset!");
static_assert(offsetof(AGEItem, UseCD) == 0x000270, "Member 'AGEItem::UseCD' has a wrong offset!");

// Class GameEx.GEItemBait
// 0x0058 (0x02D8 - 0x0280)
class AGEItemBait final : public AGEItem
{
public:
	int32                                         ItemId;                                            // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x54];                                     // 0x0284(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRotationFromClient_RPC(const struct FRotator& InRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItemBait">();
	}
	static class AGEItemBait* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEItemBait>();
	}
};
static_assert(alignof(AGEItemBait) == 0x000008, "Wrong alignment on AGEItemBait");
static_assert(sizeof(AGEItemBait) == 0x0002D8, "Wrong size on AGEItemBait");
static_assert(offsetof(AGEItemBait, ItemId) == 0x000280, "Member 'AGEItemBait::ItemId' has a wrong offset!");

// Class GameEx.GEItemBomb
// 0x0150 (0x03D0 - 0x0280)
class alignas(0x10) AGEItemBomb final : public AGEItem
{
public:
	bool                                          NeedGenerator;                                     // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x6F];                                     // 0x0281(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      FlashNiagara;                                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TailNiagara;                                       // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPoint;                                        // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PointArriveTangent;                                // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PointLeaveTangent;                                 // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterOffset;                                      // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestDistance;                                      // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestOffsetZ;                                       // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateSpeed;                                       // 0x034C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineLength;                                        // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedZ;                                         // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmoothMaxCount;                                    // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncToClientDur;                                   // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpeedModify;                                    // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomDelay;                                         // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomFlashDelay;                                    // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanTick;                                           // 0x0374(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineLength;                                      // 0x0378(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartMove;                                       // 0x037C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSplineMoveComplete;                              // 0x037D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37E[0x2];                                      // 0x037E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewLen;                                            // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FreelyMoveSpeed;                                   // 0x0384(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeForRPC;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitImpactNormal;                                   // 0x0394(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitTangent;                                       // 0x03A0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaXSpeed;                                     // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardVec;                                        // 0x03B0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineTimer;                                       // 0x03BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEBombState                                  CurState;                                          // 0x03C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Boom();
	void BoomFlash();
	void Generator();
	void HAS_StartSplineMove(const struct FGEItemClientInfo& ClientInfo, int64 ServertimeMilli, const struct FVector& InForwardVec);
	void OnRep_BombState();
	void SetBombState(EGEBombState InState);
	void StartFreelyMove(const struct FVector& InSpeed, int64 ServertimeMilli);
	void StartSplineMove(const struct FGEItemClientInfo& ClientInfo, int64 ServertimeMilli);
	void SyncFreelyMove(const struct FVector& InVel, const struct FVector& InLocation, float InDStartSplineMoveur);
	void SyncFreelySpeed_Collision(const struct FVector& InVel, float InDur);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItemBomb">();
	}
	static class AGEItemBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEItemBomb>();
	}
};
static_assert(alignof(AGEItemBomb) == 0x000010, "Wrong alignment on AGEItemBomb");
static_assert(sizeof(AGEItemBomb) == 0x0003D0, "Wrong size on AGEItemBomb");
static_assert(offsetof(AGEItemBomb, NeedGenerator) == 0x000280, "Member 'AGEItemBomb::NeedGenerator' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, SplineComponent) == 0x0002F0, "Member 'AGEItemBomb::SplineComponent' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, FlashNiagara) == 0x0002F8, "Member 'AGEItemBomb::FlashNiagara' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, TailNiagara) == 0x000300, "Member 'AGEItemBomb::TailNiagara' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, StartPoint) == 0x000308, "Member 'AGEItemBomb::StartPoint' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, PointArriveTangent) == 0x000318, "Member 'AGEItemBomb::PointArriveTangent' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, PointLeaveTangent) == 0x000328, "Member 'AGEItemBomb::PointLeaveTangent' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, Height) == 0x000338, "Member 'AGEItemBomb::Height' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, CenterOffset) == 0x00033C, "Member 'AGEItemBomb::CenterOffset' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, DestDistance) == 0x000340, "Member 'AGEItemBomb::DestDistance' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, DestOffsetZ) == 0x000344, "Member 'AGEItemBomb::DestOffsetZ' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, Speed) == 0x000348, "Member 'AGEItemBomb::Speed' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, RotateSpeed) == 0x00034C, "Member 'AGEItemBomb::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, LineLength) == 0x000358, "Member 'AGEItemBomb::LineLength' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, MinSpeedZ) == 0x00035C, "Member 'AGEItemBomb::MinSpeedZ' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, SmoothMaxCount) == 0x000360, "Member 'AGEItemBomb::SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, SyncToClientDur) == 0x000364, "Member 'AGEItemBomb::SyncToClientDur' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, MaxSpeedModify) == 0x000368, "Member 'AGEItemBomb::MaxSpeedModify' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, BoomDelay) == 0x00036C, "Member 'AGEItemBomb::BoomDelay' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, BoomFlashDelay) == 0x000370, "Member 'AGEItemBomb::BoomFlashDelay' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, CanTick) == 0x000374, "Member 'AGEItemBomb::CanTick' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, SplineLength) == 0x000378, "Member 'AGEItemBomb::SplineLength' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, IsStartMove) == 0x00037C, "Member 'AGEItemBomb::IsStartMove' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, IsSplineMoveComplete) == 0x00037D, "Member 'AGEItemBomb::IsSplineMoveComplete' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, NewLen) == 0x000380, "Member 'AGEItemBomb::NewLen' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, FreelyMoveSpeed) == 0x000384, "Member 'AGEItemBomb::FreelyMoveSpeed' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, LifeTimeForRPC) == 0x000390, "Member 'AGEItemBomb::LifeTimeForRPC' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, HitImpactNormal) == 0x000394, "Member 'AGEItemBomb::HitImpactNormal' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, InitTangent) == 0x0003A0, "Member 'AGEItemBomb::InitTangent' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, InertiaXSpeed) == 0x0003AC, "Member 'AGEItemBomb::InertiaXSpeed' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, ForwardVec) == 0x0003B0, "Member 'AGEItemBomb::ForwardVec' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, SplineTimer) == 0x0003BC, "Member 'AGEItemBomb::SplineTimer' has a wrong offset!");
static_assert(offsetof(AGEItemBomb, CurState) == 0x0003C0, "Member 'AGEItemBomb::CurState' has a wrong offset!");

// Class GameEx.GEItemLibrary
// 0x0000 (0x0028 - 0x0028)
class UGEItemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyUseItem(class AGEGameCharacter* InCharacter, int32 InIndex, bool IsAttachedItem, const struct FGEItemClientInfo& ItemInfo_Client);
	static bool CanAddStoreCount(class AController* InController, int32 InIndex, bool IsAttachedItem);
	static struct FGEItemInfo GetItemData(class AController* InController, int32 InIndex, bool IsAttachedItem);
	static class AGEItemMgr* GetItemMgr(class UObject* WorldContextObject);
	static bool IsUseable(class AController* InController, int32 InIndex, bool IsAttachedItem);
	static void SetIsUsed(class AController* InController, int32 InIndex, bool IsAttachedItem);
	static void SetItemData(class AController* InController, int32 InIndex, const struct FGEItemInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItemLibrary">();
	}
	static class UGEItemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEItemLibrary>();
	}
};
static_assert(alignof(UGEItemLibrary) == 0x000008, "Wrong alignment on UGEItemLibrary");
static_assert(sizeof(UGEItemLibrary) == 0x000028, "Wrong size on UGEItemLibrary");

// Class GameEx.GEItemMgr
// 0x0058 (0x0280 - 0x0228)
class AGEItemMgr final : public AActor
{
public:
	uint8                                         Pad_228[0x58];                                     // 0x0228(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AGEItem* AllocItem(const class FName& Path, const struct FVector& Position, const struct FRotator& Rotator);
	void FreeItem(class AGEItem* Item);
	bool LuaImpl_ApplyUseItem(class AGEGameCharacter* InCharacter, const struct FGEItemInfo& Info, const struct FGEItemClientInfo& ItemClientInfo);
	void LuaImpl_NotifyEquipItem(class AGEGameCharacter* InCharacter, const struct FGEItemInfo& Info);
	void LuaImpl_NotifyUnloadItem(class AGEGameCharacter* InCharacter);
	void LuaImpl_SetIsUseable(class AGEGameCharacter* InCharacter, struct FGEItemInfo* Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItemMgr">();
	}
	static class AGEItemMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEItemMgr>();
	}
};
static_assert(alignof(AGEItemMgr) == 0x000008, "Wrong alignment on AGEItemMgr");
static_assert(sizeof(AGEItemMgr) == 0x000280, "Wrong size on AGEItemMgr");

// Class GameEx.GEItemScan
// 0x0068 (0x02E8 - 0x0280)
class AGEItemScan final : public AGEItem
{
public:
	class UNiagaraComponent*                      CheckNiagara;                                      // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivate;                                        // 0x0288(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckDuration;                                     // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateTimer;                                     // 0x0290(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x50];                                     // 0x0298(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterEntryBox(const class FString& InName, class AActor* InActor);
	void CharacterExitBox(const class FString& InName);
	void OnRep_IsActivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEItemScan">();
	}
	static class AGEItemScan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEItemScan>();
	}
};
static_assert(alignof(AGEItemScan) == 0x000008, "Wrong alignment on AGEItemScan");
static_assert(sizeof(AGEItemScan) == 0x0002E8, "Wrong size on AGEItemScan");
static_assert(offsetof(AGEItemScan, CheckNiagara) == 0x000280, "Member 'AGEItemScan::CheckNiagara' has a wrong offset!");
static_assert(offsetof(AGEItemScan, IsActivate) == 0x000288, "Member 'AGEItemScan::IsActivate' has a wrong offset!");
static_assert(offsetof(AGEItemScan, CheckDuration) == 0x00028C, "Member 'AGEItemScan::CheckDuration' has a wrong offset!");
static_assert(offsetof(AGEItemScan, ActivateTimer) == 0x000290, "Member 'AGEItemScan::ActivateTimer' has a wrong offset!");
static_assert(offsetof(AGEItemScan, ItemId) == 0x000294, "Member 'AGEItemScan::ItemId' has a wrong offset!");

// Class GameEx.GELatentActionState
// 0x0010 (0x0038 - 0x0028)
class UGELatentActionState final : public UObject
{
public:
	TDelegate<void()>                             LatentActionCallback;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	struct FLatentActionInfo GetLatentActionInfo();
	void OnLatentActionCompleted(int32 LinkID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GELatentActionState">();
	}
	static class UGELatentActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGELatentActionState>();
	}
};
static_assert(alignof(UGELatentActionState) == 0x000008, "Wrong alignment on UGELatentActionState");
static_assert(sizeof(UGELatentActionState) == 0x000038, "Wrong size on UGELatentActionState");
static_assert(offsetof(UGELatentActionState, LatentActionCallback) == 0x000028, "Member 'UGELatentActionState::LatentActionCallback' has a wrong offset!");

// Class GameEx.GENetRPCComponent
// 0x0138 (0x01E8 - 0x00B0)
class UGENetRPCComponent final : public UActorComponent
{
public:
	TDelegate<void()>                             BeginPlayDelegate;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(EEndPlayReason Reason)>        EndPlayDelegate;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(float Dt)>                     TickDelegate;                                      // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& FunName, const class FString& Param)> OnCallTSFunDelegate;                               // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ServerID;                                          // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CustomDataString;                                  // 0x00F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CustomDataNumber;                                  // 0x0148(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         UserID;                                            // 0x0198(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             UserIDChangeDelegate;                              // 0x019C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CharID;                                            // 0x01AC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             CharIDChangeDelegate;                              // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EntityType;                                        // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfID;                                            // 0x01C4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ConfIDChangeDelegate;                              // 0x01C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& MainID, const class FString& Data)> FNotifyMsgDelegate;                                // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static void SetAllServerID(int32 ID);

	void CallLuaFun(const class FString& FucName, const class FString& FunParam);
	void CallLuaFunByDelegate(const class FString& FunName, const class FString& Param);
	void CallTSFunDelegate__DelegateSignature(const class FString& FunName, const class FString& Param);
	void CharIDChangeDelegate__DelegateSignature();
	void ComBeginPlayDelegate__DelegateSignature();
	void ComEndPlayDelegate__DelegateSignature(const EEndPlayReason Reason);
	void ComTickDelegate__DelegateSignature(float Dt);
	void ConfIDChangeDelegate__DelegateSignature();
	int32 GetCharID();
	int32 GetConfID();
	int32 GetDataInt(const class FString& Key);
	class FString GetDataString(const class FString& Key);
	int32 GetEntityType();
	int32 GetServerID();
	int32 GetUserID();
	void NotifyMsg__DelegateSignature(const class FString& MainID, const class FString& Data);
	void NotifyMsg_Client(const class FString& MainID, const class FString& Data);
	void NotifyMsg_Client_Unreliable(const class FString& MainID, const class FString& Data);
	void NotifyMsg_NetMulticast(const class FString& MainID, const class FString& Value);
	void NotifyMsg_NetMulticast_Unreliable(const class FString& MainID, const class FString& Value);
	void NotifyMsg_Server(const class FString& MainID, const class FString& Data);
	void NotifyMsg_Server_Unreliable(const class FString& MainID, const class FString& Data);
	void OnRep_CharID();
	void OnRep_ConfID();
	void OnRep_ServerID();
	void OnRep_UserID();
	void PrintID(class FString* Tag);
	void SetCharID(int32 ICharid);
	void SetConfID(int32 IConfID);
	void SetDataInt(const class FString& Key, int32 Value);
	void SetDataString(const class FString& Key, const class FString& Value);
	void SetEntityType(int32 IentityType);
	void SetUserID(int32 IUserid);
	void UserIDChangeDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GENetRPCComponent">();
	}
	static class UGENetRPCComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGENetRPCComponent>();
	}
};
static_assert(alignof(UGENetRPCComponent) == 0x000008, "Wrong alignment on UGENetRPCComponent");
static_assert(sizeof(UGENetRPCComponent) == 0x0001E8, "Wrong size on UGENetRPCComponent");
static_assert(offsetof(UGENetRPCComponent, BeginPlayDelegate) == 0x0000B0, "Member 'UGENetRPCComponent::BeginPlayDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, EndPlayDelegate) == 0x0000C0, "Member 'UGENetRPCComponent::EndPlayDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, TickDelegate) == 0x0000D0, "Member 'UGENetRPCComponent::TickDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, OnCallTSFunDelegate) == 0x0000E0, "Member 'UGENetRPCComponent::OnCallTSFunDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, ServerID) == 0x0000F0, "Member 'UGENetRPCComponent::ServerID' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, CustomDataString) == 0x0000F8, "Member 'UGENetRPCComponent::CustomDataString' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, CustomDataNumber) == 0x000148, "Member 'UGENetRPCComponent::CustomDataNumber' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, UserID) == 0x000198, "Member 'UGENetRPCComponent::UserID' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, UserIDChangeDelegate) == 0x00019C, "Member 'UGENetRPCComponent::UserIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, CharID) == 0x0001AC, "Member 'UGENetRPCComponent::CharID' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, CharIDChangeDelegate) == 0x0001B0, "Member 'UGENetRPCComponent::CharIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, EntityType) == 0x0001C0, "Member 'UGENetRPCComponent::EntityType' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, ConfID) == 0x0001C4, "Member 'UGENetRPCComponent::ConfID' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, ConfIDChangeDelegate) == 0x0001C8, "Member 'UGENetRPCComponent::ConfIDChangeDelegate' has a wrong offset!");
static_assert(offsetof(UGENetRPCComponent, FNotifyMsgDelegate) == 0x0001D8, "Member 'UGENetRPCComponent::FNotifyMsgDelegate' has a wrong offset!");

// Class GameEx.GEPeopleBuffTrap
// 0x0080 (0x02C8 - 0x0248)
class AGEPeopleBuffTrap final : public AGETrapBase
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallRadius;                                       // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediusRadius;                                      // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateDur;                                         // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTimer;                                       // 0x0260(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UpdateTag;                                         // 0x0264(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CharDeadInTrapTag;                                 // 0x026C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AActor*>                    InTrapActors;                                      // 0x0278(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddCacheChar(int32 InId, class AActor* InActor);
	TArray<class AActor*> GetAllInTrapActors();
	void RemoveCacheChar(int32 InId);
	void UpdatePeopleInTrap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEPeopleBuffTrap">();
	}
	static class AGEPeopleBuffTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEPeopleBuffTrap>();
	}
};
static_assert(alignof(AGEPeopleBuffTrap) == 0x000008, "Wrong alignment on AGEPeopleBuffTrap");
static_assert(sizeof(AGEPeopleBuffTrap) == 0x0002C8, "Wrong size on AGEPeopleBuffTrap");
static_assert(offsetof(AGEPeopleBuffTrap, SphereComponent) == 0x000248, "Member 'AGEPeopleBuffTrap::SphereComponent' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, SmallRadius) == 0x000250, "Member 'AGEPeopleBuffTrap::SmallRadius' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, MediusRadius) == 0x000254, "Member 'AGEPeopleBuffTrap::MediusRadius' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, MaxRadius) == 0x000258, "Member 'AGEPeopleBuffTrap::MaxRadius' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, UpdateDur) == 0x00025C, "Member 'AGEPeopleBuffTrap::UpdateDur' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, UpdateTimer) == 0x000260, "Member 'AGEPeopleBuffTrap::UpdateTimer' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, UpdateTag) == 0x000264, "Member 'AGEPeopleBuffTrap::UpdateTag' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, CharDeadInTrapTag) == 0x00026C, "Member 'AGEPeopleBuffTrap::CharDeadInTrapTag' has a wrong offset!");
static_assert(offsetof(AGEPeopleBuffTrap, InTrapActors) == 0x000278, "Member 'AGEPeopleBuffTrap::InTrapActors' has a wrong offset!");

// Class GameEx.GEPhysicsReqComponent
// 0x00F8 (0x01A8 - 0x00B0)
class UGEPhysicsReqComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowLog;                                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ComponentName;                                     // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Mesh;                                              // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftCharCount;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightCharCount;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationAngle;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSeeSaw;                                          // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurAngle;                                          // 0x00F0(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurLocation;                                       // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurRotate;                                         // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaAngle;                                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncCurveTimeToClientDur;                          // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x90];                                     // 0x0118(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCharCount(int32 IsLeft);
	void RemoveCharCount(int32 IsLeft);
	void SetCurAngle(float InAngle, int32 LifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEPhysicsReqComponent">();
	}
	static class UGEPhysicsReqComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEPhysicsReqComponent>();
	}
};
static_assert(alignof(UGEPhysicsReqComponent) == 0x000008, "Wrong alignment on UGEPhysicsReqComponent");
static_assert(sizeof(UGEPhysicsReqComponent) == 0x0001A8, "Wrong size on UGEPhysicsReqComponent");
static_assert(offsetof(UGEPhysicsReqComponent, bShowLog) == 0x0000C0, "Member 'UGEPhysicsReqComponent::bShowLog' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, bSweep) == 0x0000C1, "Member 'UGEPhysicsReqComponent::bSweep' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, bTeleport) == 0x0000C2, "Member 'UGEPhysicsReqComponent::bTeleport' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, ComponentName) == 0x0000C8, "Member 'UGEPhysicsReqComponent::ComponentName' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, Mesh) == 0x0000D8, "Member 'UGEPhysicsReqComponent::Mesh' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, LeftCharCount) == 0x0000E0, "Member 'UGEPhysicsReqComponent::LeftCharCount' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, RightCharCount) == 0x0000E4, "Member 'UGEPhysicsReqComponent::RightCharCount' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, MaxRotationAngle) == 0x0000E8, "Member 'UGEPhysicsReqComponent::MaxRotationAngle' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, IsSeeSaw) == 0x0000EC, "Member 'UGEPhysicsReqComponent::IsSeeSaw' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, CurAngle) == 0x0000F0, "Member 'UGEPhysicsReqComponent::CurAngle' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, CurLocation) == 0x0000F4, "Member 'UGEPhysicsReqComponent::CurLocation' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, CurRotate) == 0x000100, "Member 'UGEPhysicsReqComponent::CurRotate' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, DeltaAngle) == 0x00010C, "Member 'UGEPhysicsReqComponent::DeltaAngle' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, InterpSpeed) == 0x000110, "Member 'UGEPhysicsReqComponent::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UGEPhysicsReqComponent, SyncCurveTimeToClientDur) == 0x000114, "Member 'UGEPhysicsReqComponent::SyncCurveTimeToClientDur' has a wrong offset!");

// Class GameEx.GEPicWaveMgr
// 0x00B0 (0x02D8 - 0x0228)
class AGEPicWaveMgr final : public AActor
{
public:
	TArray<struct FPicWave>                       WaveGroups;                                        // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DropDelay;                                         // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstance*>              MatGroup;                                          // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    MeshGroup;                                         // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CurTimer;                                          // 0x0260(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPicWave                               CurWave;                                           // 0x0268(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPicWaveTimePoint                      CurTimePoint;                                      // 0x02A8(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurWaveCount;                                      // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurTimePointCount;                                 // 0x02B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurWaveMatCount;                                   // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenMatIndex;                                    // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DropGroup;                                         // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastPointCountDown;                                // 0x02D0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurTimePoint();
	void SetCurWave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEPicWaveMgr">();
	}
	static class AGEPicWaveMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEPicWaveMgr>();
	}
};
static_assert(alignof(AGEPicWaveMgr) == 0x000008, "Wrong alignment on AGEPicWaveMgr");
static_assert(sizeof(AGEPicWaveMgr) == 0x0002D8, "Wrong size on AGEPicWaveMgr");
static_assert(offsetof(AGEPicWaveMgr, WaveGroups) == 0x000228, "Member 'AGEPicWaveMgr::WaveGroups' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, DropDelay) == 0x000238, "Member 'AGEPicWaveMgr::DropDelay' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, MatGroup) == 0x000240, "Member 'AGEPicWaveMgr::MatGroup' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, MeshGroup) == 0x000250, "Member 'AGEPicWaveMgr::MeshGroup' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurTimer) == 0x000260, "Member 'AGEPicWaveMgr::CurTimer' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurWave) == 0x000268, "Member 'AGEPicWaveMgr::CurWave' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurTimePoint) == 0x0002A8, "Member 'AGEPicWaveMgr::CurTimePoint' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurWaveCount) == 0x0002B0, "Member 'AGEPicWaveMgr::CurWaveCount' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurTimePointCount) == 0x0002B4, "Member 'AGEPicWaveMgr::CurTimePointCount' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, CurWaveMatCount) == 0x0002B8, "Member 'AGEPicWaveMgr::CurWaveMatCount' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, ScreenMatIndex) == 0x0002BC, "Member 'AGEPicWaveMgr::ScreenMatIndex' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, DropGroup) == 0x0002C0, "Member 'AGEPicWaveMgr::DropGroup' has a wrong offset!");
static_assert(offsetof(AGEPicWaveMgr, LastPointCountDown) == 0x0002D0, "Member 'AGEPicWaveMgr::LastPointCountDown' has a wrong offset!");

// Class GameEx.GEPlayerController
// 0x0280 (0x07F8 - 0x0578)
class AGEPlayerController : public APlayerController
{
public:
	TMap<class FString, class FString>            CustomDataString;                                  // 0x0578(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    CustomDataNumber;                                  // 0x05C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraRange;                                       // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerID;                                          // 0x0620(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_624[0x28];                                     // 0x0624(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Team1EquipSkillID;                                 // 0x064C(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Team2EquipSkillID;                                 // 0x064E(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLog;                                          // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_651[0x3];                                      // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickSyncServertimeInterval;                        // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RomoteTime;                                        // 0x0660(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RecordRomoteTime;                                  // 0x0668(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PingSimulate;                                      // 0x0670(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ping;                                              // 0x0674(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreEsc;                                        // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_679[0x7];                                      // 0x0679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           SpectateState;                                     // 0x0680(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectatingTime;                                    // 0x0688(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68C[0x8];                                      // 0x068C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastInputTime;                                     // 0x0694(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWorldTimeAsync;                                 // 0x0698(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_699[0x3];                                      // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateRTTDelta;                                    // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidMaxDelay;                                     // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWPClientGameTimeUpdateMode                   ClientGameTimeUpdateMode;                          // 0x06A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A5[0x3];                                      // 0x06A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientTimeMustUpdateDelay;                         // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AC[0x4];                                      // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShootTargetActor;                                  // 0x06B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayStart;                                          // 0x06B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadFollow;                                    // 0x06C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoFire;                                   // 0x06C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C6[0x2];                                      // 0x06C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewTargetPosition;                                // 0x06C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ViewTargetComponent;                               // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShootTargetPosition;                               // 0x06E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6EC[0xC];                                      // 0x06EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAimTargetLocked : 1;                              // 0x06F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ShootCameraRotation;                               // 0x06FC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SelectTargetPosition;                              // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLeisureFire : 1;                                // 0x0710(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_711[0x3];                                      // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartAdsorbent;                                   // 0x0714(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOneFollow;                                  // 0x0715(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_716[0x2];                                      // 0x0716(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAdsorbentTime;                                // 0x0718(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71C[0x70];                                     // 0x071C(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AutoControlRotation;                               // 0x078C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               WeaponRecoil;                                      // 0x0798(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TotalWeaponRecoil;                                 // 0x07A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         RecoilFlag;                                        // 0x07B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReloadWeapon;                                    // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          CacheFireInput;                                    // 0x07C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C9[0x3];                                      // 0x07C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetThreshold;                                // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAimOffsetThreshold;                            // 0x07D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x3];                                      // 0x07D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MeleeDmgTag;                                       // 0x07D4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShoootDmgTag;                                      // 0x07DC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E4[0x4];                                      // 0x07E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            ReplaceAIController;                               // 0x07E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  CacheRealChar;                                     // 0x07F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeSpectateState();
	bool CheckIsSpectating();
	void Client_ResponseServerTime_Reliable(int32 InUpdateIndex, float InServerTime);
	void Client_ResponseServerTime_UnReliable(int32 InUpdateIndex, float InServerTime);
	void ClientShowDSDebugInfo(const struct FGEDSDebugInfo& DSDebugInfo);
	void CreateTouchInterface();
	struct FVector2D GetExactRange();
	void GetMoveForwardDirection(struct FVector* Vector);
	void GetMoveRightDirection(struct FVector* Vector);
	void GetServerTime_Client(int64 ClientTimeStamp, int64 ServerTimestamp);
	void GetServerTime_Server(int64 ClientTimeStamp);
	float GetServerWorldTime();
	int32 GetSimulateNetDelay();
	int64 GetSmluateRemoteTime();
	class AGEGameCharacter* GetValidGECharacter(class AActor* LpActor);
	void GMServerCall(const class FString& FuncName, const class FString& InParam);
	void LuaImpl_SetAnimationAlwaysTickPoseEnableOnDS(class APawn* InPawn, bool bEnable);
	void MoveForward(float FVal);
	void MoveRight(float FVal);
	void OnRep_SpectateState();
	void OnSpectateStateChange();
	void ResetLastInputTime();
	void Server_AllocateWeapon(int32 WeaponID);
	void Server_ApplyUseItem(int32 Index_0, bool IsAttachedItem, const struct FGEItemClientInfo& ItemInfo);
	void Server_ApplyUsePounce(int32 Index_0, bool IsAttachedItem, const struct FVector& InputVec);
	void Server_CastSkill(int32 SkillID, int32 InIndex);
	void Server_DmgHit(const struct FGEZBug_DmgHitInfo& HitInfos);
	void Server_RequestExpression(int32 ExpressionId);
	void Server_RequestServerTime_Reliable(int32 InUpdateIndex);
	void Server_RequestServerTime_UnReliable(int32 InUpdateIndex);
	void Server_SelectBuff(int32 BuffId);
	void Server_SetFire(bool IsStart);
	void Server_SetPerformanceMode(bool bOpen);
	void Server_SetZBugID(int32 ID);
	void Server_ShootEntityBullet(const struct FVector& FireLoc, const struct FVector& TargetLoc);
	void Server_ShootTargetActor(class AActor* Target, const struct FVector& AimPosition);
	void Server_ShootTargetPosition(const struct FVector& TargetPosition, const struct FRotator& InCameraRot);
	void Server_SubtituteRotateInPlace(float ClockWiseTime);
	void Server_ZBugChangeFireState(bool InNewFiring, bool InNewFireState);
	void Server_ZBugChangeMeleeState(bool InNewState);
	void StartAIControlLogic();
	void StopAIControlLogic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEPlayerController">();
	}
	static class AGEPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEPlayerController>();
	}
};
static_assert(alignof(AGEPlayerController) == 0x000008, "Wrong alignment on AGEPlayerController");
static_assert(sizeof(AGEPlayerController) == 0x0007F8, "Wrong size on AGEPlayerController");
static_assert(offsetof(AGEPlayerController, CustomDataString) == 0x000578, "Member 'AGEPlayerController::CustomDataString' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, CustomDataNumber) == 0x0005C8, "Member 'AGEPlayerController::CustomDataNumber' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, CameraRange) == 0x000618, "Member 'AGEPlayerController::CameraRange' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, PlayerID) == 0x000620, "Member 'AGEPlayerController::PlayerID' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, Team1EquipSkillID) == 0x00064C, "Member 'AGEPlayerController::Team1EquipSkillID' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, Team2EquipSkillID) == 0x00064E, "Member 'AGEPlayerController::Team2EquipSkillID' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bShowLog) == 0x000650, "Member 'AGEPlayerController::bShowLog' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, TickSyncServertimeInterval) == 0x000654, "Member 'AGEPlayerController::TickSyncServertimeInterval' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, RomoteTime) == 0x000660, "Member 'AGEPlayerController::RomoteTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, RecordRomoteTime) == 0x000668, "Member 'AGEPlayerController::RecordRomoteTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, PingSimulate) == 0x000670, "Member 'AGEPlayerController::PingSimulate' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, Ping) == 0x000674, "Member 'AGEPlayerController::Ping' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bIgnoreEsc) == 0x000678, "Member 'AGEPlayerController::bIgnoreEsc' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, SpectateState) == 0x000680, "Member 'AGEPlayerController::SpectateState' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, SpectatingTime) == 0x000688, "Member 'AGEPlayerController::SpectatingTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, LastInputTime) == 0x000694, "Member 'AGEPlayerController::LastInputTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, UseWorldTimeAsync) == 0x000698, "Member 'AGEPlayerController::UseWorldTimeAsync' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, UpdateRTTDelta) == 0x00069C, "Member 'AGEPlayerController::UpdateRTTDelta' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ValidMaxDelay) == 0x0006A0, "Member 'AGEPlayerController::ValidMaxDelay' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ClientGameTimeUpdateMode) == 0x0006A4, "Member 'AGEPlayerController::ClientGameTimeUpdateMode' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ClientTimeMustUpdateDelay) == 0x0006A8, "Member 'AGEPlayerController::ClientTimeMustUpdateDelay' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ShootTargetActor) == 0x0006B0, "Member 'AGEPlayerController::ShootTargetActor' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, RayStart) == 0x0006B8, "Member 'AGEPlayerController::RayStart' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bGamepadFollow) == 0x0006C4, "Member 'AGEPlayerController::bGamepadFollow' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bEnableAutoFire) == 0x0006C5, "Member 'AGEPlayerController::bEnableAutoFire' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ViewTargetPosition) == 0x0006C8, "Member 'AGEPlayerController::ViewTargetPosition' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ViewTargetComponent) == 0x0006D8, "Member 'AGEPlayerController::ViewTargetComponent' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ShootTargetPosition) == 0x0006E0, "Member 'AGEPlayerController::ShootTargetPosition' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ShootCameraRotation) == 0x0006FC, "Member 'AGEPlayerController::ShootCameraRotation' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, SelectTargetPosition) == 0x000708, "Member 'AGEPlayerController::SelectTargetPosition' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bStartAdsorbent) == 0x000714, "Member 'AGEPlayerController::bStartAdsorbent' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bEnableOneFollow) == 0x000715, "Member 'AGEPlayerController::bEnableOneFollow' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, StartAdsorbentTime) == 0x000718, "Member 'AGEPlayerController::StartAdsorbentTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, AutoControlRotation) == 0x00078C, "Member 'AGEPlayerController::AutoControlRotation' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, WeaponRecoil) == 0x000798, "Member 'AGEPlayerController::WeaponRecoil' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, TotalWeaponRecoil) == 0x0007A4, "Member 'AGEPlayerController::TotalWeaponRecoil' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, RecoilFlag) == 0x0007B0, "Member 'AGEPlayerController::RecoilFlag' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, OnReloadWeapon) == 0x0007B8, "Member 'AGEPlayerController::OnReloadWeapon' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, CacheFireInput) == 0x0007C8, "Member 'AGEPlayerController::CacheFireInput' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, AimOffsetThreshold) == 0x0007CC, "Member 'AGEPlayerController::AimOffsetThreshold' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, bUseAimOffsetThreshold) == 0x0007D0, "Member 'AGEPlayerController::bUseAimOffsetThreshold' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, MeleeDmgTag) == 0x0007D4, "Member 'AGEPlayerController::MeleeDmgTag' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ShoootDmgTag) == 0x0007DC, "Member 'AGEPlayerController::ShoootDmgTag' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, ReplaceAIController) == 0x0007E8, "Member 'AGEPlayerController::ReplaceAIController' has a wrong offset!");
static_assert(offsetof(AGEPlayerController, CacheRealChar) == 0x0007F0, "Member 'AGEPlayerController::CacheRealChar' has a wrong offset!");

// Class GameEx.GEPlayerState
// 0x00D8 (0x0400 - 0x0328)
class AGEPlayerState final : public APlayerState
{
public:
	int64                                         RolePID;                                           // 0x0328(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GEUniqueID;                                        // 0x0330(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamID;                                            // 0x0334(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerNickName;                                    // 0x0338(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGEItemInfo>                    Items;                                             // 0x0348(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FGEItemInfo>                    AttachedItems;                                     // 0x0358(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<struct FGESkillEquipInfo>              Skills;                                            // 0x0368(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          IsOnline;                                          // 0x0378(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassGame;                                        // 0x0379(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OfflineCD;                                         // 0x037C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OfflineTimer;                                      // 0x0380(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMidWayExit;                                      // 0x0384(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeathCount;                                        // 0x0388(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CatchPlayerNum;                                    // 0x038C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HAS_UseSkillCount;                                 // 0x0390(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HAS_UseNormalSkillCount;                           // 0x0394(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGEZBugRunBugType                             ZBugID;                                            // 0x0398(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfectNum;                                         // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillNum;                                           // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillHelpNum;                                       // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZBugExp;                                           // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugPerformScore;                                  // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastZBugLevel;                                     // 0x03B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZBugLevelLimit;                                    // 0x03B8(0x0004)(Edit, Net, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeopleTime;                                        // 0x03BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHero;                                            // 0x03C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BecomedHero;                                       // 0x03C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C2[0x2];                                      // 0x03C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBug_PeopleAddExpCD;                               // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBug_PeopleAddExpVal;                              // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBug_ZBugAddExpCD;                                 // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBug_ZBugAddExpVal;                                // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugAddExpMultiplier;                              // 0x03D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickAddExpCD;                                      // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickAddExpValue;                                   // 0x03DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickAddExpTimer;                                   // 0x03E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAddZBugExp;                                     // 0x03E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnClientExpChange;                                 // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          GMBanExpAdd;                                       // 0x03F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInfectNum(int32 Num);
	void AddKillHelpNum(int32 Num);
	void AddKillNum(int32 Num);
	void AddLevelLimit(int32 Count);
	void AddZBugExp(int32 InAddValue);
	void AddZBugPerformScore(float Num);
	int32 GetNextLevelNeedExp();
	void HAS_AddNormalUseSkillCount(int32 Num);
	void HAS_AddUseSkillCount(int32 Num);
	void LevelUp(int32 Count);
	void LuaImpl_ZBugIDChange(EGEZBugRunBugType Type);
	void NotifyLocalPlayerAttachedItemsChanged();
	void NotifyLocalPlayerItemsChanged();
	void NotifyLocalPlayerSkillChanged();
	void OnRep_AttachedItems();
	void OnRep_CatchPlayerNum();
	void OnRep_InfectNum();
	void OnRep_isHero();
	void OnRep_Items();
	void OnRep_KillHelpNum();
	void OnRep_KillNum();
	void OnRep_Level();
	void OnRep_RolePID();
	void OnRep_Skills();
	void OnRep_TeamID();
	void OnRep_ZBugExp();
	void OnRep_ZBugID();
	void OnRep_ZBugPerformScore();
	void SetZBugID(EGEZBugRunBugType Type);
	void UpdateTickAddZBugExpByTeam();

	uint8 GEGetPing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEPlayerState">();
	}
	static class AGEPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEPlayerState>();
	}
};
static_assert(alignof(AGEPlayerState) == 0x000008, "Wrong alignment on AGEPlayerState");
static_assert(sizeof(AGEPlayerState) == 0x000400, "Wrong size on AGEPlayerState");
static_assert(offsetof(AGEPlayerState, RolePID) == 0x000328, "Member 'AGEPlayerState::RolePID' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, GEUniqueID) == 0x000330, "Member 'AGEPlayerState::GEUniqueID' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, TeamID) == 0x000334, "Member 'AGEPlayerState::TeamID' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, PlayerNickName) == 0x000338, "Member 'AGEPlayerState::PlayerNickName' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, Items) == 0x000348, "Member 'AGEPlayerState::Items' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, AttachedItems) == 0x000358, "Member 'AGEPlayerState::AttachedItems' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, Skills) == 0x000368, "Member 'AGEPlayerState::Skills' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, IsOnline) == 0x000378, "Member 'AGEPlayerState::IsOnline' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, IsPassGame) == 0x000379, "Member 'AGEPlayerState::IsPassGame' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, OfflineCD) == 0x00037C, "Member 'AGEPlayerState::OfflineCD' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, OfflineTimer) == 0x000380, "Member 'AGEPlayerState::OfflineTimer' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, IsMidWayExit) == 0x000384, "Member 'AGEPlayerState::IsMidWayExit' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, DeathCount) == 0x000388, "Member 'AGEPlayerState::DeathCount' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, CatchPlayerNum) == 0x00038C, "Member 'AGEPlayerState::CatchPlayerNum' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, HAS_UseSkillCount) == 0x000390, "Member 'AGEPlayerState::HAS_UseSkillCount' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, HAS_UseNormalSkillCount) == 0x000394, "Member 'AGEPlayerState::HAS_UseNormalSkillCount' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBugID) == 0x000398, "Member 'AGEPlayerState::ZBugID' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, InfectNum) == 0x00039C, "Member 'AGEPlayerState::InfectNum' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, KillNum) == 0x0003A0, "Member 'AGEPlayerState::KillNum' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, KillHelpNum) == 0x0003A4, "Member 'AGEPlayerState::KillHelpNum' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, Level) == 0x0003A8, "Member 'AGEPlayerState::Level' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBugExp) == 0x0003AC, "Member 'AGEPlayerState::ZBugExp' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBugPerformScore) == 0x0003B0, "Member 'AGEPlayerState::ZBugPerformScore' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, LastZBugLevel) == 0x0003B4, "Member 'AGEPlayerState::LastZBugLevel' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBugLevelLimit) == 0x0003B8, "Member 'AGEPlayerState::ZBugLevelLimit' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, PeopleTime) == 0x0003BC, "Member 'AGEPlayerState::PeopleTime' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, IsHero) == 0x0003C0, "Member 'AGEPlayerState::IsHero' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, BecomedHero) == 0x0003C1, "Member 'AGEPlayerState::BecomedHero' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBug_PeopleAddExpCD) == 0x0003C4, "Member 'AGEPlayerState::ZBug_PeopleAddExpCD' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBug_PeopleAddExpVal) == 0x0003C8, "Member 'AGEPlayerState::ZBug_PeopleAddExpVal' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBug_ZBugAddExpCD) == 0x0003CC, "Member 'AGEPlayerState::ZBug_ZBugAddExpCD' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBug_ZBugAddExpVal) == 0x0003D0, "Member 'AGEPlayerState::ZBug_ZBugAddExpVal' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, ZBugAddExpMultiplier) == 0x0003D4, "Member 'AGEPlayerState::ZBugAddExpMultiplier' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, TickAddExpCD) == 0x0003D8, "Member 'AGEPlayerState::TickAddExpCD' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, TickAddExpValue) == 0x0003DC, "Member 'AGEPlayerState::TickAddExpValue' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, TickAddExpTimer) == 0x0003E0, "Member 'AGEPlayerState::TickAddExpTimer' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, CanAddZBugExp) == 0x0003E4, "Member 'AGEPlayerState::CanAddZBugExp' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, OnClientExpChange) == 0x0003E8, "Member 'AGEPlayerState::OnClientExpChange' has a wrong offset!");
static_assert(offsetof(AGEPlayerState, GMBanExpAdd) == 0x0003F8, "Member 'AGEPlayerState::GMBanExpAdd' has a wrong offset!");

// Class GameEx.GERoll
// 0x0038 (0x0260 - 0x0228)
class AGERoll final : public AActor
{
public:
	float                                         LerpAlpha;                                         // 0x0228(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x022C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeForRPC;                                    // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictTime;                                       // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargerPos;                                         // 0x0240(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocityZ;                                   // 0x024C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWwiseComponent>         WwiseComponent;                                    // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      TailNiagara;                                       // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHitFloor(const struct FVector& InVec, class AActor* InActor);
	void SetLocation(const struct FVector& InVec);
	void SetSyncInfo(const struct FVector& InPos, float InLifeTime, float InVelZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GERoll">();
	}
	static class AGERoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGERoll>();
	}
};
static_assert(alignof(AGERoll) == 0x000008, "Wrong alignment on AGERoll");
static_assert(sizeof(AGERoll) == 0x000260, "Wrong size on AGERoll");
static_assert(offsetof(AGERoll, LerpAlpha) == 0x000228, "Member 'AGERoll::LerpAlpha' has a wrong offset!");
static_assert(offsetof(AGERoll, Velocity) == 0x00022C, "Member 'AGERoll::Velocity' has a wrong offset!");
static_assert(offsetof(AGERoll, LifeTimeForRPC) == 0x000238, "Member 'AGERoll::LifeTimeForRPC' has a wrong offset!");
static_assert(offsetof(AGERoll, PredictTime) == 0x00023C, "Member 'AGERoll::PredictTime' has a wrong offset!");
static_assert(offsetof(AGERoll, TargerPos) == 0x000240, "Member 'AGERoll::TargerPos' has a wrong offset!");
static_assert(offsetof(AGERoll, TargetVelocityZ) == 0x00024C, "Member 'AGERoll::TargetVelocityZ' has a wrong offset!");
static_assert(offsetof(AGERoll, WwiseComponent) == 0x000250, "Member 'AGERoll::WwiseComponent' has a wrong offset!");
static_assert(offsetof(AGERoll, TailNiagara) == 0x000258, "Member 'AGERoll::TailNiagara' has a wrong offset!");

// Class GameEx.GERotateBrickManager
// 0x01F8 (0x0420 - 0x0228)
class AGERotateBrickManager final : public AActor
{
public:
	struct FWPRotateBrickArray                    BrickArray;                                        // 0x0228(0x0118)(Net, NativeAccessSpecifierPublic)
	TMap<int32, class AGERotateBrick*>            BrickList;                                         // 0x0340(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, bool>                             CacheBrickList;                                    // 0x0390(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 CacheWillRotateBrickList;                          // 0x03E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGERotateBrickSequence>         Sequences;                                         // 0x03F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CanTick;                                           // 0x0400(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer;                                             // 0x0404(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextRotateTime;                                    // 0x0408(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangeMatBefore;                                   // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextRotateCount;                                   // 0x0410(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurSequenceIndex;                                  // 0x0414(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitBrickArray();
	bool SetBrickCanRotate(int32 InId);
	void SetNextRotateTime();
	void TriggerBrickChangeRotate(EGERotateBrickState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GERotateBrickManager">();
	}
	static class AGERotateBrickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGERotateBrickManager>();
	}
};
static_assert(alignof(AGERotateBrickManager) == 0x000008, "Wrong alignment on AGERotateBrickManager");
static_assert(sizeof(AGERotateBrickManager) == 0x000420, "Wrong size on AGERotateBrickManager");
static_assert(offsetof(AGERotateBrickManager, BrickArray) == 0x000228, "Member 'AGERotateBrickManager::BrickArray' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, BrickList) == 0x000340, "Member 'AGERotateBrickManager::BrickList' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, CacheBrickList) == 0x000390, "Member 'AGERotateBrickManager::CacheBrickList' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, CacheWillRotateBrickList) == 0x0003E0, "Member 'AGERotateBrickManager::CacheWillRotateBrickList' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, Sequences) == 0x0003F0, "Member 'AGERotateBrickManager::Sequences' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, CanTick) == 0x000400, "Member 'AGERotateBrickManager::CanTick' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, Timer) == 0x000404, "Member 'AGERotateBrickManager::Timer' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, NextRotateTime) == 0x000408, "Member 'AGERotateBrickManager::NextRotateTime' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, ChangeMatBefore) == 0x00040C, "Member 'AGERotateBrickManager::ChangeMatBefore' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, NextRotateCount) == 0x000410, "Member 'AGERotateBrickManager::NextRotateCount' has a wrong offset!");
static_assert(offsetof(AGERotateBrickManager, CurSequenceIndex) == 0x000414, "Member 'AGERotateBrickManager::CurSequenceIndex' has a wrong offset!");

// Class GameEx.GEZBugRunBulletBase
// 0x02C8 (0x04F0 - 0x0228)
class AGEZBugRunBulletBase : public AActor
{
public:
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGEBulletInfo                          BulletInfo;                                        // 0x0240(0x02A0)(Transient, NativeAccessSpecifierPublic)
	TArray<class UFXSystemComponent*>             TailParticleComps;                                 // 0x04E0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunBulletBase">();
	}
	static class AGEZBugRunBulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEZBugRunBulletBase>();
	}
};
static_assert(alignof(AGEZBugRunBulletBase) == 0x000010, "Wrong alignment on AGEZBugRunBulletBase");
static_assert(sizeof(AGEZBugRunBulletBase) == 0x0004F0, "Wrong size on AGEZBugRunBulletBase");
static_assert(offsetof(AGEZBugRunBulletBase, BulletInfo) == 0x000240, "Member 'AGEZBugRunBulletBase::BulletInfo' has a wrong offset!");
static_assert(offsetof(AGEZBugRunBulletBase, TailParticleComps) == 0x0004E0, "Member 'AGEZBugRunBulletBase::TailParticleComps' has a wrong offset!");

// Class GameEx.GEZBugRunEntityBullet
// 0x0070 (0x0560 - 0x04F0)
class AGEZBugRunEntityBullet : public AGEZBugRunBulletBase
{
public:
	class USphereComponent*                       SphereCollision;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BombCollision;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             RayCheckBombChannel;                               // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveVelocity;                                      // 0x0504(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityFactor;                                     // 0x0510(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimer;                                         // 0x0514(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeForRPC;                                    // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmoothMaxCount;                                    // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncToClientDur;                                   // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyDelayCD;                                    // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClientHaveGenerateBombNiagara;                     // 0x0528(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_529[0x2B];                                     // 0x0529(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HaveCollToOthers;                                  // 0x0554(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_555[0xB];                                      // 0x0555(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BulletBomb(const struct FVector& InDir, class AActor* Caster);
	void InitBullet_MultiCast(const struct FVector& InVel, int32 ID, int32 OwnCharUniqueID);
	void OnBombComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSphereComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSphereComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SpawnInit(const struct FVector& AimLoc, class AGEGameCharacter* InChar);
	void SyncMove(const struct FVector& InVel, const struct FVector& InLocation, float InDStartSplineMoveur);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunEntityBullet">();
	}
	static class AGEZBugRunEntityBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEZBugRunEntityBullet>();
	}
};
static_assert(alignof(AGEZBugRunEntityBullet) == 0x000010, "Wrong alignment on AGEZBugRunEntityBullet");
static_assert(sizeof(AGEZBugRunEntityBullet) == 0x000560, "Wrong size on AGEZBugRunEntityBullet");
static_assert(offsetof(AGEZBugRunEntityBullet, SphereCollision) == 0x0004F0, "Member 'AGEZBugRunEntityBullet::SphereCollision' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, BombCollision) == 0x0004F8, "Member 'AGEZBugRunEntityBullet::BombCollision' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, RayCheckBombChannel) == 0x000500, "Member 'AGEZBugRunEntityBullet::RayCheckBombChannel' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, MoveVelocity) == 0x000504, "Member 'AGEZBugRunEntityBullet::MoveVelocity' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, GravityFactor) == 0x000510, "Member 'AGEZBugRunEntityBullet::GravityFactor' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, LifeTimer) == 0x000514, "Member 'AGEZBugRunEntityBullet::LifeTimer' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, LifeTimeForRPC) == 0x000518, "Member 'AGEZBugRunEntityBullet::LifeTimeForRPC' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, SmoothMaxCount) == 0x00051C, "Member 'AGEZBugRunEntityBullet::SmoothMaxCount' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, SyncToClientDur) == 0x000520, "Member 'AGEZBugRunEntityBullet::SyncToClientDur' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, DestroyDelayCD) == 0x000524, "Member 'AGEZBugRunEntityBullet::DestroyDelayCD' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, ClientHaveGenerateBombNiagara) == 0x000528, "Member 'AGEZBugRunEntityBullet::ClientHaveGenerateBombNiagara' has a wrong offset!");
static_assert(offsetof(AGEZBugRunEntityBullet, HaveCollToOthers) == 0x000554, "Member 'AGEZBugRunEntityBullet::HaveCollToOthers' has a wrong offset!");

// Class GameEx.GEZBugRunLibrary
// 0x0000 (0x0028 - 0x0028)
class UGEZBugRunLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckShootRatIsValidHit(class AActor* WorldContextActor, const struct FVector& StartPos, const struct FVector& EndPos, ECollisionChannel CollisionChannel);
	static TArray<struct FGEWeaponInfo> GetAllWeaponInfoByTeam(EGEZBugRunTeamType Type);
	static struct FGEBulletInfo GetBulletInfo(int32 BulletID);
	static struct FGEWeaponInfo GetWeaponInfo(int32 WeaponID);
	static class AGEZBugRunMgr* GetZBugRunMgr(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunLibrary">();
	}
	static class UGEZBugRunLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEZBugRunLibrary>();
	}
};
static_assert(alignof(UGEZBugRunLibrary) == 0x000008, "Wrong alignment on UGEZBugRunLibrary");
static_assert(sizeof(UGEZBugRunLibrary) == 0x000028, "Wrong size on UGEZBugRunLibrary");

// Class GameEx.GEZBugRunMgr
// 0x0058 (0x0280 - 0x0228)
class AGEZBugRunMgr final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillZBugExp;                                       // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillOriginZBugExp;                                 // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfectPeopleExp;                                   // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfectHeroExp;                                     // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillZBugPerformScore;                              // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillOriginZBugPerformScore;                        // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfectPeoplePerformScore;                          // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfectHeroPerformScore;                            // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedRayValidate;                                   // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedPosLag;                                        // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedShootRangeValidate;                            // 0x0252(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253[0x1];                                      // 0x0253(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CharDeathTag;                                      // 0x0254(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeroPriorityBuffCount;                             // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                PreLoadList;                                       // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsCRTTestMode;                                     // 0x0270(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWPZBugTestCRT                         TestCRTStruct;                                     // 0x0274(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCRTTestData(bool IsCritical);
	void AllocateWeaponToChar(int32 WeaponID, class AActor* InChar);
	int32 GetAddExpByDeadTarget(class AGEPlayerState* InState);
	float GetAddPerformScoreByDeadTarget(class AGEPlayerState* InState);
	TArray<class FString> GetAllPreloadStr();
	void GM_ForceKillPeople(class AActor* Killer, class AActor* Target);
	void LuaImpl_ApplyInfect(class AActor* Launcher, class AActor* Target);
	void LuaImpl_CompositeAtLocationByID(int32 EffectId, const struct FVector& InLoc, const struct FVector& InDir, class AActor* Caster);
	void LuaImpl_GM_ForceKillPeople(class AActor* Killer, class AActor* Target);
	void LuaImpl_InfectOthers_Multicast(int32 LauncherGEUniqueID, int32 TargetGEUniqueID, int32 ZBugCount);
	void LuaImpl_KillOthers(class AActor* Killer, class AActor* Target);
	void LuaImpl_KillOthers_Multicast(int32 KillerGEUniqueID, int32 TargetGEUniqueID);
	void LuaImpl_TickCheckInitForPlayer();
	void MultiCast_InfectOthers(int32 LauncherGEUniqueID, int32 TargetGEUniqueID, int32 ZBugCount);
	void MultiCast_KillOthers(int32 KillerGEUniqueID, int32 TargetGEUniqueID);
	void OpenOrCloseCRTTestMode(bool IsOpen);
	void PeopleKillOther(class AActor* Launcher, class AActor* Target);
	void SendCharDeathMsg(class AActor* Launcher, class AActor* Target);
	void ZBugInfectOther(class AActor* Launcher, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunMgr">();
	}
	static class AGEZBugRunMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEZBugRunMgr>();
	}
};
static_assert(alignof(AGEZBugRunMgr) == 0x000008, "Wrong alignment on AGEZBugRunMgr");
static_assert(sizeof(AGEZBugRunMgr) == 0x000280, "Wrong size on AGEZBugRunMgr");
static_assert(offsetof(AGEZBugRunMgr, KillZBugExp) == 0x000230, "Member 'AGEZBugRunMgr::KillZBugExp' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, KillOriginZBugExp) == 0x000234, "Member 'AGEZBugRunMgr::KillOriginZBugExp' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, InfectPeopleExp) == 0x000238, "Member 'AGEZBugRunMgr::InfectPeopleExp' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, InfectHeroExp) == 0x00023C, "Member 'AGEZBugRunMgr::InfectHeroExp' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, KillZBugPerformScore) == 0x000240, "Member 'AGEZBugRunMgr::KillZBugPerformScore' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, KillOriginZBugPerformScore) == 0x000244, "Member 'AGEZBugRunMgr::KillOriginZBugPerformScore' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, InfectPeoplePerformScore) == 0x000248, "Member 'AGEZBugRunMgr::InfectPeoplePerformScore' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, InfectHeroPerformScore) == 0x00024C, "Member 'AGEZBugRunMgr::InfectHeroPerformScore' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, NeedRayValidate) == 0x000250, "Member 'AGEZBugRunMgr::NeedRayValidate' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, NeedPosLag) == 0x000251, "Member 'AGEZBugRunMgr::NeedPosLag' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, NeedShootRangeValidate) == 0x000252, "Member 'AGEZBugRunMgr::NeedShootRangeValidate' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, CharDeathTag) == 0x000254, "Member 'AGEZBugRunMgr::CharDeathTag' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, HeroPriorityBuffCount) == 0x00025C, "Member 'AGEZBugRunMgr::HeroPriorityBuffCount' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, PreLoadList) == 0x000260, "Member 'AGEZBugRunMgr::PreLoadList' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, IsCRTTestMode) == 0x000270, "Member 'AGEZBugRunMgr::IsCRTTestMode' has a wrong offset!");
static_assert(offsetof(AGEZBugRunMgr, TestCRTStruct) == 0x000274, "Member 'AGEZBugRunMgr::TestCRTStruct' has a wrong offset!");

// Class GameEx.GEZBugRunRayBullet
// 0x0020 (0x0510 - 0x04F0)
class AGEZBugRunRayBullet final : public AGEZBugRunBulletBase
{
public:
	struct FVector                                TargetLoc;                                         // 0x04F0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeltaOffset;                                       // 0x04FC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTimer;                                          // 0x0508(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyDur;                                            // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetTargetLoc(const struct FVector& InTargetVec, const struct FVector& InStartPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunRayBullet">();
	}
	static class AGEZBugRunRayBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEZBugRunRayBullet>();
	}
};
static_assert(alignof(AGEZBugRunRayBullet) == 0x000010, "Wrong alignment on AGEZBugRunRayBullet");
static_assert(sizeof(AGEZBugRunRayBullet) == 0x000510, "Wrong size on AGEZBugRunRayBullet");
static_assert(offsetof(AGEZBugRunRayBullet, TargetLoc) == 0x0004F0, "Member 'AGEZBugRunRayBullet::TargetLoc' has a wrong offset!");
static_assert(offsetof(AGEZBugRunRayBullet, DeltaOffset) == 0x0004FC, "Member 'AGEZBugRunRayBullet::DeltaOffset' has a wrong offset!");
static_assert(offsetof(AGEZBugRunRayBullet, FlyTimer) == 0x000508, "Member 'AGEZBugRunRayBullet::FlyTimer' has a wrong offset!");
static_assert(offsetof(AGEZBugRunRayBullet, FlyDur) == 0x00050C, "Member 'AGEZBugRunRayBullet::FlyDur' has a wrong offset!");

// Class GameEx.GEZBugRunWeaponBase
// 0x0988 (0x0BB0 - 0x0228)
class AGEZBugRunWeaponBase : public AActor
{
public:
	uint8                                         Pad_228[0xC0];                                     // 0x0228(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletNum;                                         // 0x02E8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x8];                                      // 0x02EC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WeaponScatterRange;                                // 0x02F4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               TmpWeaponScatterRange;                             // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               CurrentWeaponScatter;                              // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGEWeaponScatterSigma>          WeaponScatterSigma;                                // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CurShootScatterValue;                              // 0x0330(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurShootScatterAddTime;                            // 0x0334(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurShootScatterWaitTime;                           // 0x0338(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurShootScatterRecoverTime;                        // 0x033C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShootScatterAddCurve;                              // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShootScatterRecoverCurve;                          // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0xC];                                      // 0x0350(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentShootBullet;                                // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGEZBug_Recoil                         Recoil;                                            // 0x0360(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LastRecoil;                                        // 0x0390(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        RecoilRecoveryPath;                                // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           RecoilRecovery;                                    // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         M_lpWeaponMesh;                                    // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_EntityDataCom*               AbilityDataCom;                                    // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_LogicHandleCom*              BuffHandleCom;                                     // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponID;                                          // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGEWeaponInfo                          WeaponInfo;                                        // 0x03F8(0x0478)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FName                                   FireSocketName;                                    // 0x0870(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGEBulletInfo                          BulletInfo;                                        // 0x0880(0x02A0)(Transient, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RecoilForcePitchRateCurve;                         // 0x0B20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatineeCameraShake*                    M_lpCameraShake;                                   // 0x0B28(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CameraShakeCurve;                                  // 0x0B30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseComponent*                        HitWiseComp;                                       // 0x0B38(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemComponent*                     PathRef;                                           // 0x0B40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       OwnChar;                                           // 0x0B48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B50[0x10];                                     // 0x0B50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULogicTree_DataFormula*>         Formulas;                                          // 0x0B60(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        MeleeHitCalcLogicPath;                             // 0x0B70(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      MeleeDetectCapsule;                                // 0x0B88(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeleeHitEffectID;                                  // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIShootRayTag;                                     // 0x0B94(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIShootEntityTag;                                  // 0x0B9C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0xC];                                      // 0x0BA4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GaussRand(float DExpect, float DVariance, float DRange);
	static struct FVector LimitVRandCone(const struct FVector& Dir, float ConeHalfAngle, float DVariance, float GaussRange);

	void AddBulletNum(int32 AddNum);
	void ApplyWaterParkWeaponTemplate(const struct FGEWeaponInfo& InTemplate);
	bool CheckIsMeleeWeapon();
	void FireCamerShake();
	class AGEGameCharacter* GetOwnChar();
	struct FVector GetShootPosition();
	struct FVector GetShootTargetPosition();
	struct FGEWeaponInfo GetWeaponInfo();
	void InitWeaponRecoil();
	void OnMeleeHitOther(class AGEGameCharacter* InTarget, const struct FVector& HitLoc);
	void SendOneMeleeHitInfoToServer(const struct FVector& HitPos, class AGEGameCharacter* TargetChar);
	void SetDetectAttack(bool InNewState);
	void SetMeleeDetectCapsule(class UCapsuleComponent* InCapCom);
	void SetOwnChar(class AGEGameCharacter* InChar);
	void SetWeaponBulletId(int32 NWeaponBulletId);

	struct FVector2D GetAmmunitionUIOffset() const;
	struct FSoftClassPath GetAmmunitionUIWidget() const;
	struct FSoftClassPath GetCrossHairUIWidget() const;
	void GetWeaponScatterSigma(float* OutSigma, float* OutRange) const;
	bool IsScattering() const;
	void RandomShootTarets(const struct FVector& ShootDir, int32 ShootBulletCount, TArray<struct FVector>* OutShootPositions) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEZBugRunWeaponBase">();
	}
	static class AGEZBugRunWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGEZBugRunWeaponBase>();
	}
};
static_assert(alignof(AGEZBugRunWeaponBase) == 0x000010, "Wrong alignment on AGEZBugRunWeaponBase");
static_assert(sizeof(AGEZBugRunWeaponBase) == 0x000BB0, "Wrong size on AGEZBugRunWeaponBase");
static_assert(offsetof(AGEZBugRunWeaponBase, BulletNum) == 0x0002E8, "Member 'AGEZBugRunWeaponBase::BulletNum' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, WeaponScatterRange) == 0x0002F4, "Member 'AGEZBugRunWeaponBase::WeaponScatterRange' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, TmpWeaponScatterRange) == 0x000300, "Member 'AGEZBugRunWeaponBase::TmpWeaponScatterRange' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurrentWeaponScatter) == 0x000310, "Member 'AGEZBugRunWeaponBase::CurrentWeaponScatter' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, WeaponScatterSigma) == 0x000320, "Member 'AGEZBugRunWeaponBase::WeaponScatterSigma' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurShootScatterValue) == 0x000330, "Member 'AGEZBugRunWeaponBase::CurShootScatterValue' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurShootScatterAddTime) == 0x000334, "Member 'AGEZBugRunWeaponBase::CurShootScatterAddTime' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurShootScatterWaitTime) == 0x000338, "Member 'AGEZBugRunWeaponBase::CurShootScatterWaitTime' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurShootScatterRecoverTime) == 0x00033C, "Member 'AGEZBugRunWeaponBase::CurShootScatterRecoverTime' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, ShootScatterAddCurve) == 0x000340, "Member 'AGEZBugRunWeaponBase::ShootScatterAddCurve' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, ShootScatterRecoverCurve) == 0x000348, "Member 'AGEZBugRunWeaponBase::ShootScatterRecoverCurve' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CurrentShootBullet) == 0x00035C, "Member 'AGEZBugRunWeaponBase::CurrentShootBullet' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, Recoil) == 0x000360, "Member 'AGEZBugRunWeaponBase::Recoil' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, LastRecoil) == 0x000390, "Member 'AGEZBugRunWeaponBase::LastRecoil' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, RecoilRecoveryPath) == 0x0003A0, "Member 'AGEZBugRunWeaponBase::RecoilRecoveryPath' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, RecoilRecovery) == 0x0003B8, "Member 'AGEZBugRunWeaponBase::RecoilRecovery' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, M_lpWeaponMesh) == 0x0003D8, "Member 'AGEZBugRunWeaponBase::M_lpWeaponMesh' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, AbilityDataCom) == 0x0003E0, "Member 'AGEZBugRunWeaponBase::AbilityDataCom' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, BuffHandleCom) == 0x0003E8, "Member 'AGEZBugRunWeaponBase::BuffHandleCom' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, WeaponID) == 0x0003F0, "Member 'AGEZBugRunWeaponBase::WeaponID' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, WeaponInfo) == 0x0003F8, "Member 'AGEZBugRunWeaponBase::WeaponInfo' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, FireSocketName) == 0x000870, "Member 'AGEZBugRunWeaponBase::FireSocketName' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, BulletInfo) == 0x000880, "Member 'AGEZBugRunWeaponBase::BulletInfo' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, RecoilForcePitchRateCurve) == 0x000B20, "Member 'AGEZBugRunWeaponBase::RecoilForcePitchRateCurve' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, M_lpCameraShake) == 0x000B28, "Member 'AGEZBugRunWeaponBase::M_lpCameraShake' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, CameraShakeCurve) == 0x000B30, "Member 'AGEZBugRunWeaponBase::CameraShakeCurve' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, HitWiseComp) == 0x000B38, "Member 'AGEZBugRunWeaponBase::HitWiseComp' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, PathRef) == 0x000B40, "Member 'AGEZBugRunWeaponBase::PathRef' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, OwnChar) == 0x000B48, "Member 'AGEZBugRunWeaponBase::OwnChar' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, Formulas) == 0x000B60, "Member 'AGEZBugRunWeaponBase::Formulas' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, MeleeHitCalcLogicPath) == 0x000B70, "Member 'AGEZBugRunWeaponBase::MeleeHitCalcLogicPath' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, MeleeDetectCapsule) == 0x000B88, "Member 'AGEZBugRunWeaponBase::MeleeDetectCapsule' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, MeleeHitEffectID) == 0x000B90, "Member 'AGEZBugRunWeaponBase::MeleeHitEffectID' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, AIShootRayTag) == 0x000B94, "Member 'AGEZBugRunWeaponBase::AIShootRayTag' has a wrong offset!");
static_assert(offsetof(AGEZBugRunWeaponBase, AIShootEntityTag) == 0x000B9C, "Member 'AGEZBugRunWeaponBase::AIShootEntityTag' has a wrong offset!");

// Class GameEx.LogicTree_AddCharSpeedNode
// 0x00A8 (0x0148 - 0x00A0)
class ULogicTree_AddCharSpeedNode final : public ULogicTree_TaskNode
{
public:
	EAddCharSpeedType                             AddType;                                           // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x00C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          NeedReset;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetByTime;                                       // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                TimeDataAccessor;                                  // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CacheBBValue;                                      // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0xC];                                      // 0x013C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_AddCharSpeedNode">();
	}
	static class ULogicTree_AddCharSpeedNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_AddCharSpeedNode>();
	}
};
static_assert(alignof(ULogicTree_AddCharSpeedNode) == 0x000008, "Wrong alignment on ULogicTree_AddCharSpeedNode");
static_assert(sizeof(ULogicTree_AddCharSpeedNode) == 0x000148, "Wrong size on ULogicTree_AddCharSpeedNode");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, AddType) == 0x0000A0, "Member 'ULogicTree_AddCharSpeedNode::AddType' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, Key) == 0x0000A8, "Member 'ULogicTree_AddCharSpeedNode::Key' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, Value) == 0x0000B8, "Member 'ULogicTree_AddCharSpeedNode::Value' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, DataAccessor) == 0x0000C0, "Member 'ULogicTree_AddCharSpeedNode::DataAccessor' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, NeedReset) == 0x0000F8, "Member 'ULogicTree_AddCharSpeedNode::NeedReset' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, ResetByTime) == 0x0000F9, "Member 'ULogicTree_AddCharSpeedNode::ResetByTime' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, TimeDataAccessor) == 0x000100, "Member 'ULogicTree_AddCharSpeedNode::TimeDataAccessor' has a wrong offset!");
static_assert(offsetof(ULogicTree_AddCharSpeedNode, CacheBBValue) == 0x000138, "Member 'ULogicTree_AddCharSpeedNode::CacheBBValue' has a wrong offset!");

// Class GameEx.LogicTree_CharChangeScaleNode
// 0x0018 (0x00B8 - 0x00A0)
class ULogicTree_CharChangeScaleNode final : public ULogicTree_TaskNode
{
public:
	float                                         AddValue;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_CharChangeScaleNode">();
	}
	static class ULogicTree_CharChangeScaleNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_CharChangeScaleNode>();
	}
};
static_assert(alignof(ULogicTree_CharChangeScaleNode) == 0x000008, "Wrong alignment on ULogicTree_CharChangeScaleNode");
static_assert(sizeof(ULogicTree_CharChangeScaleNode) == 0x0000B8, "Wrong size on ULogicTree_CharChangeScaleNode");
static_assert(offsetof(ULogicTree_CharChangeScaleNode, AddValue) == 0x0000A0, "Member 'ULogicTree_CharChangeScaleNode::AddValue' has a wrong offset!");
static_assert(offsetof(ULogicTree_CharChangeScaleNode, Key) == 0x0000A8, "Member 'ULogicTree_CharChangeScaleNode::Key' has a wrong offset!");

// Class GameEx.LogicTree_CharInvisibleAction
// 0x0008 (0x0038 - 0x0030)
class ULogicTree_CharInvisibleAction final : public ULogicTree_ActionBase
{
public:
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_CharInvisibleAction">();
	}
	static class ULogicTree_CharInvisibleAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_CharInvisibleAction>();
	}
};
static_assert(alignof(ULogicTree_CharInvisibleAction) == 0x000008, "Wrong alignment on ULogicTree_CharInvisibleAction");
static_assert(sizeof(ULogicTree_CharInvisibleAction) == 0x000038, "Wrong size on ULogicTree_CharInvisibleAction");
static_assert(offsetof(ULogicTree_CharInvisibleAction, Duration) == 0x000030, "Member 'ULogicTree_CharInvisibleAction::Duration' has a wrong offset!");

// Class GameEx.LogicTree_SpawnTrapAction
// 0x0018 (0x0090 - 0x0078)
class ULogicTree_SpawnTrapAction final : public ULogicTree_SpawnAction
{
public:
	TSubclassOf<class AGETrapBase>                TargetClass;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x0080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_SpawnTrapAction">();
	}
	static class ULogicTree_SpawnTrapAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_SpawnTrapAction>();
	}
};
static_assert(alignof(ULogicTree_SpawnTrapAction) == 0x000008, "Wrong alignment on ULogicTree_SpawnTrapAction");
static_assert(sizeof(ULogicTree_SpawnTrapAction) == 0x000090, "Wrong size on ULogicTree_SpawnTrapAction");
static_assert(offsetof(ULogicTree_SpawnTrapAction, TargetClass) == 0x000078, "Member 'ULogicTree_SpawnTrapAction::TargetClass' has a wrong offset!");
static_assert(offsetof(ULogicTree_SpawnTrapAction, SpawnOffset) == 0x000080, "Member 'ULogicTree_SpawnTrapAction::SpawnOffset' has a wrong offset!");

// Class GameEx.LogicTree_Task_GetWaterParkMontage
// 0x0040 (0x00E0 - 0x00A0)
class ULogicTree_Task_GetWaterParkMontage final : public ULogicTree_TaskNode
{
public:
	class FName                                   MontageName;                                       // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                AssetOutPut;                                       // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Task_GetWaterParkMontage">();
	}
	static class ULogicTree_Task_GetWaterParkMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Task_GetWaterParkMontage>();
	}
};
static_assert(alignof(ULogicTree_Task_GetWaterParkMontage) == 0x000008, "Wrong alignment on ULogicTree_Task_GetWaterParkMontage");
static_assert(sizeof(ULogicTree_Task_GetWaterParkMontage) == 0x0000E0, "Wrong size on ULogicTree_Task_GetWaterParkMontage");
static_assert(offsetof(ULogicTree_Task_GetWaterParkMontage, MontageName) == 0x0000A0, "Member 'ULogicTree_Task_GetWaterParkMontage::MontageName' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_GetWaterParkMontage, AssetOutPut) == 0x0000A8, "Member 'ULogicTree_Task_GetWaterParkMontage::AssetOutPut' has a wrong offset!");

// Class GameEx.LogicTree_Task_WaitAndSetWeapon
// 0x0038 (0x00D8 - 0x00A0)
class ULogicTree_Task_WaitAndSetWeapon final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                WeaponOut;                                         // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Task_WaitAndSetWeapon">();
	}
	static class ULogicTree_Task_WaitAndSetWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Task_WaitAndSetWeapon>();
	}
};
static_assert(alignof(ULogicTree_Task_WaitAndSetWeapon) == 0x000008, "Wrong alignment on ULogicTree_Task_WaitAndSetWeapon");
static_assert(sizeof(ULogicTree_Task_WaitAndSetWeapon) == 0x0000D8, "Wrong size on ULogicTree_Task_WaitAndSetWeapon");
static_assert(offsetof(ULogicTree_Task_WaitAndSetWeapon, WeaponOut) == 0x0000A0, "Member 'ULogicTree_Task_WaitAndSetWeapon::WeaponOut' has a wrong offset!");

// Class GameEx.LogicTree_Task_WPClearEnmity
// 0x0038 (0x00D8 - 0x00A0)
class ULogicTree_Task_WPClearEnmity final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                ChasedTarget;                                      // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Task_WPClearEnmity">();
	}
	static class ULogicTree_Task_WPClearEnmity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Task_WPClearEnmity>();
	}
};
static_assert(alignof(ULogicTree_Task_WPClearEnmity) == 0x000008, "Wrong alignment on ULogicTree_Task_WPClearEnmity");
static_assert(sizeof(ULogicTree_Task_WPClearEnmity) == 0x0000D8, "Wrong size on ULogicTree_Task_WPClearEnmity");
static_assert(offsetof(ULogicTree_Task_WPClearEnmity, ChasedTarget) == 0x0000A0, "Member 'ULogicTree_Task_WPClearEnmity::ChasedTarget' has a wrong offset!");

// Class GameEx.LogicTree_Task_WPMeleeSweep
// 0x0100 (0x01A0 - 0x00A0)
class ULogicTree_Task_WPMeleeSweep final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                CapsuleHalfHeight;                                 // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FWaterPark_MeleeSweepInfo>      SweepSequences;                                    // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AllSweepNum;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepInterval;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BySweep;                                           // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBeginRotPerSweep;                               // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_MsgContext                  TargetMsgCxt;                                      // 0x00F8(0x0058)(Edit, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HitActorsCache;                                    // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AGEZBugRunWeaponBase*                   WeaponCache;                                       // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastCapsulePos;                                    // 0x0168(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0xC];                                      // 0x0174(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LastCapsuleRoa;                                    // 0x0180(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x10];                                     // 0x0190(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_Task_WPMeleeSweep">();
	}
	static class ULogicTree_Task_WPMeleeSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_Task_WPMeleeSweep>();
	}
};
static_assert(alignof(ULogicTree_Task_WPMeleeSweep) == 0x000010, "Wrong alignment on ULogicTree_Task_WPMeleeSweep");
static_assert(sizeof(ULogicTree_Task_WPMeleeSweep) == 0x0001A0, "Wrong size on ULogicTree_Task_WPMeleeSweep");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, CapsuleHalfHeight) == 0x0000A0, "Member 'ULogicTree_Task_WPMeleeSweep::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, SweepSequences) == 0x0000D8, "Member 'ULogicTree_Task_WPMeleeSweep::SweepSequences' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, AllSweepNum) == 0x0000E8, "Member 'ULogicTree_Task_WPMeleeSweep::AllSweepNum' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, SweepInterval) == 0x0000EC, "Member 'ULogicTree_Task_WPMeleeSweep::SweepInterval' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, BySweep) == 0x0000F0, "Member 'ULogicTree_Task_WPMeleeSweep::BySweep' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, UseBeginRotPerSweep) == 0x0000F1, "Member 'ULogicTree_Task_WPMeleeSweep::UseBeginRotPerSweep' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, TargetMsgCxt) == 0x0000F8, "Member 'ULogicTree_Task_WPMeleeSweep::TargetMsgCxt' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, HitActorsCache) == 0x000150, "Member 'ULogicTree_Task_WPMeleeSweep::HitActorsCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, WeaponCache) == 0x000160, "Member 'ULogicTree_Task_WPMeleeSweep::WeaponCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, LastCapsulePos) == 0x000168, "Member 'ULogicTree_Task_WPMeleeSweep::LastCapsulePos' has a wrong offset!");
static_assert(offsetof(ULogicTree_Task_WPMeleeSweep, LastCapsuleRoa) == 0x000180, "Member 'ULogicTree_Task_WPMeleeSweep::LastCapsuleRoa' has a wrong offset!");

// Class GameEx.LogicTree_WaterPark_AIMoveToTarget
// 0x0088 (0x0128 - 0x00A0)
class ULogicTree_WaterPark_AIMoveToTarget final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                TargetActor;                                       // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         UpdateNavPathInterval;                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTargetInterval;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveByActorDisSq;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishMoveDis;                                     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateOutNavInterval;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0xC];                                       // 0x00EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameCharacter*                       OwnGECharCache;                                    // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetCache;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DontFinish;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutNavCustomMoveDisSq;                             // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TryProjectNavDisWhenOutNav;                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x14];                                     // 0x0114(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_WaterPark_AIMoveToTarget">();
	}
	static class ULogicTree_WaterPark_AIMoveToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_WaterPark_AIMoveToTarget>();
	}
};
static_assert(alignof(ULogicTree_WaterPark_AIMoveToTarget) == 0x000008, "Wrong alignment on ULogicTree_WaterPark_AIMoveToTarget");
static_assert(sizeof(ULogicTree_WaterPark_AIMoveToTarget) == 0x000128, "Wrong size on ULogicTree_WaterPark_AIMoveToTarget");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, TargetActor) == 0x0000A0, "Member 'ULogicTree_WaterPark_AIMoveToTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, UpdateNavPathInterval) == 0x0000D8, "Member 'ULogicTree_WaterPark_AIMoveToTarget::UpdateNavPathInterval' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, UpdateTargetInterval) == 0x0000DC, "Member 'ULogicTree_WaterPark_AIMoveToTarget::UpdateTargetInterval' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, MoveByActorDisSq) == 0x0000E0, "Member 'ULogicTree_WaterPark_AIMoveToTarget::MoveByActorDisSq' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, FinishMoveDis) == 0x0000E4, "Member 'ULogicTree_WaterPark_AIMoveToTarget::FinishMoveDis' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, UpdateOutNavInterval) == 0x0000E8, "Member 'ULogicTree_WaterPark_AIMoveToTarget::UpdateOutNavInterval' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, OwnGECharCache) == 0x0000F8, "Member 'ULogicTree_WaterPark_AIMoveToTarget::OwnGECharCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, TargetCache) == 0x000100, "Member 'ULogicTree_WaterPark_AIMoveToTarget::TargetCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, DontFinish) == 0x000108, "Member 'ULogicTree_WaterPark_AIMoveToTarget::DontFinish' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, OutNavCustomMoveDisSq) == 0x00010C, "Member 'ULogicTree_WaterPark_AIMoveToTarget::OutNavCustomMoveDisSq' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_AIMoveToTarget, TryProjectNavDisWhenOutNav) == 0x000110, "Member 'ULogicTree_WaterPark_AIMoveToTarget::TryProjectNavDisWhenOutNav' has a wrong offset!");

// Class GameEx.LogicTree_WaterPark_ChangeControlRotation
// 0x0078 (0x0118 - 0x00A0)
class ULogicTree_WaterPark_ChangeControlRotation final : public ULogicTree_TaskNode
{
public:
	float                                         RandomDis;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeRotateInterval;                              // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpeed;                                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                FaceTarget;                                        // 0x00B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       TargetCache;                                       // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       OwnCharCache;                                      // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAIController*                          OwnControllerCache;                                // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NowTargetRotator;                                  // 0x0100(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0xC];                                      // 0x010C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_WaterPark_ChangeControlRotation">();
	}
	static class ULogicTree_WaterPark_ChangeControlRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_WaterPark_ChangeControlRotation>();
	}
};
static_assert(alignof(ULogicTree_WaterPark_ChangeControlRotation) == 0x000008, "Wrong alignment on ULogicTree_WaterPark_ChangeControlRotation");
static_assert(sizeof(ULogicTree_WaterPark_ChangeControlRotation) == 0x000118, "Wrong size on ULogicTree_WaterPark_ChangeControlRotation");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, RandomDis) == 0x0000A0, "Member 'ULogicTree_WaterPark_ChangeControlRotation::RandomDis' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, ChangeRotateInterval) == 0x0000A4, "Member 'ULogicTree_WaterPark_ChangeControlRotation::ChangeRotateInterval' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, BlendSpeed) == 0x0000A8, "Member 'ULogicTree_WaterPark_ChangeControlRotation::BlendSpeed' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, FaceTarget) == 0x0000B0, "Member 'ULogicTree_WaterPark_ChangeControlRotation::FaceTarget' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, TargetCache) == 0x0000E8, "Member 'ULogicTree_WaterPark_ChangeControlRotation::TargetCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, OwnCharCache) == 0x0000F0, "Member 'ULogicTree_WaterPark_ChangeControlRotation::OwnCharCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, OwnControllerCache) == 0x0000F8, "Member 'ULogicTree_WaterPark_ChangeControlRotation::OwnControllerCache' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_ChangeControlRotation, NowTargetRotator) == 0x000100, "Member 'ULogicTree_WaterPark_ChangeControlRotation::NowTargetRotator' has a wrong offset!");

// Class GameEx.LogicTree_WaterPark_ChangeZBugMeleeAttackType
// 0x0008 (0x00A8 - 0x00A0)
class ULogicTree_WaterPark_ChangeZBugMeleeAttackType final : public ULogicTree_TaskNode
{
public:
	int32                                         NewAttackType;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_WaterPark_ChangeZBugMeleeAttackType">();
	}
	static class ULogicTree_WaterPark_ChangeZBugMeleeAttackType* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_WaterPark_ChangeZBugMeleeAttackType>();
	}
};
static_assert(alignof(ULogicTree_WaterPark_ChangeZBugMeleeAttackType) == 0x000008, "Wrong alignment on ULogicTree_WaterPark_ChangeZBugMeleeAttackType");
static_assert(sizeof(ULogicTree_WaterPark_ChangeZBugMeleeAttackType) == 0x0000A8, "Wrong size on ULogicTree_WaterPark_ChangeZBugMeleeAttackType");
static_assert(offsetof(ULogicTree_WaterPark_ChangeZBugMeleeAttackType, NewAttackType) == 0x0000A0, "Member 'ULogicTree_WaterPark_ChangeZBugMeleeAttackType::NewAttackType' has a wrong offset!");

// Class GameEx.LogicTree_WaterPark_CheckTargetCanHit
// 0x0090 (0x0130 - 0x00A0)
class ULogicTree_WaterPark_CheckTargetCanHit final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                AttackTarget;                                      // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                CanHitTarget;                                      // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogicTree_WaterPark_CheckTargetCanHit">();
	}
	static class ULogicTree_WaterPark_CheckTargetCanHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogicTree_WaterPark_CheckTargetCanHit>();
	}
};
static_assert(alignof(ULogicTree_WaterPark_CheckTargetCanHit) == 0x000008, "Wrong alignment on ULogicTree_WaterPark_CheckTargetCanHit");
static_assert(sizeof(ULogicTree_WaterPark_CheckTargetCanHit) == 0x000130, "Wrong size on ULogicTree_WaterPark_CheckTargetCanHit");
static_assert(offsetof(ULogicTree_WaterPark_CheckTargetCanHit, AttackTarget) == 0x0000A0, "Member 'ULogicTree_WaterPark_CheckTargetCanHit::AttackTarget' has a wrong offset!");
static_assert(offsetof(ULogicTree_WaterPark_CheckTargetCanHit, CanHitTarget) == 0x0000D8, "Member 'ULogicTree_WaterPark_CheckTargetCanHit::CanHitTarget' has a wrong offset!");

// Class GameEx.LT_DataHandler_Fire
// 0x04D0 (0x0530 - 0x0060)
class ULT_DataHandler_Fire final : public UGameLogic_DataHandler
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULogicTreeNode*                         CacheNode;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGEZBugRunWeaponBase*                   WeaponCache;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FireOnceOnActive;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                FireSpeed;                                         // 0x0080(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x478];                                     // 0x00B8(0x0478)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DataHandler_Fire">();
	}
	static class ULT_DataHandler_Fire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DataHandler_Fire>();
	}
};
static_assert(alignof(ULT_DataHandler_Fire) == 0x000008, "Wrong alignment on ULT_DataHandler_Fire");
static_assert(sizeof(ULT_DataHandler_Fire) == 0x000530, "Wrong size on ULT_DataHandler_Fire");
static_assert(offsetof(ULT_DataHandler_Fire, CacheNode) == 0x000068, "Member 'ULT_DataHandler_Fire::CacheNode' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_Fire, WeaponCache) == 0x000070, "Member 'ULT_DataHandler_Fire::WeaponCache' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_Fire, FireOnceOnActive) == 0x000078, "Member 'ULT_DataHandler_Fire::FireOnceOnActive' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_Fire, FireSpeed) == 0x000080, "Member 'ULT_DataHandler_Fire::FireSpeed' has a wrong offset!");

// Class GameEx.LT_DataHandler_UpdateNearestActor
// 0x0078 (0x00D8 - 0x0060)
class ULT_DataHandler_UpdateNearestActor final : public UGameLogic_DataHandler
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                IgnoreActorArray;                                  // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                OutRes;                                            // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DataHandler_UpdateNearestActor">();
	}
	static class ULT_DataHandler_UpdateNearestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DataHandler_UpdateNearestActor>();
	}
};
static_assert(alignof(ULT_DataHandler_UpdateNearestActor) == 0x000008, "Wrong alignment on ULT_DataHandler_UpdateNearestActor");
static_assert(sizeof(ULT_DataHandler_UpdateNearestActor) == 0x0000D8, "Wrong size on ULT_DataHandler_UpdateNearestActor");
static_assert(offsetof(ULT_DataHandler_UpdateNearestActor, ActorClass) == 0x000060, "Member 'ULT_DataHandler_UpdateNearestActor::ActorClass' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_UpdateNearestActor, IgnoreActorArray) == 0x000068, "Member 'ULT_DataHandler_UpdateNearestActor::IgnoreActorArray' has a wrong offset!");
static_assert(offsetof(ULT_DataHandler_UpdateNearestActor, OutRes) == 0x0000A0, "Member 'ULT_DataHandler_UpdateNearestActor::OutRes' has a wrong offset!");

// Class GameEx.LT_DataHandler_WPClearEnmity
// 0x0038 (0x0098 - 0x0060)
class ULT_DataHandler_WPClearEnmity final : public UGameLogic_DataHandler
{
public:
	struct FLogicTree_DataAccessor                ChasedTarget;                                      // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DataHandler_WPClearEnmity">();
	}
	static class ULT_DataHandler_WPClearEnmity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DataHandler_WPClearEnmity>();
	}
};
static_assert(alignof(ULT_DataHandler_WPClearEnmity) == 0x000008, "Wrong alignment on ULT_DataHandler_WPClearEnmity");
static_assert(sizeof(ULT_DataHandler_WPClearEnmity) == 0x000098, "Wrong size on ULT_DataHandler_WPClearEnmity");
static_assert(offsetof(ULT_DataHandler_WPClearEnmity, ChasedTarget) == 0x000060, "Member 'ULT_DataHandler_WPClearEnmity::ChasedTarget' has a wrong offset!");

// Class GameEx.LT_DataHandler_WPSearchEnemy
// 0x0038 (0x0098 - 0x0060)
class ULT_DataHandler_WPSearchEnemy final : public UGameLogic_DataHandler
{
public:
	struct FLogicTree_DataAccessor                ChasedTarget;                                      // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_DataHandler_WPSearchEnemy">();
	}
	static class ULT_DataHandler_WPSearchEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_DataHandler_WPSearchEnemy>();
	}
};
static_assert(alignof(ULT_DataHandler_WPSearchEnemy) == 0x000008, "Wrong alignment on ULT_DataHandler_WPSearchEnemy");
static_assert(sizeof(ULT_DataHandler_WPSearchEnemy) == 0x000098, "Wrong size on ULT_DataHandler_WPSearchEnemy");
static_assert(offsetof(ULT_DataHandler_WPSearchEnemy, ChasedTarget) == 0x000060, "Member 'ULT_DataHandler_WPSearchEnemy::ChasedTarget' has a wrong offset!");

// Class GameEx.LT_Decorator_WaterParkIsGameStart
// 0x0000 (0x0038 - 0x0038)
class ULT_Decorator_WaterParkIsGameStart final : public ULogicTree_Decorator
{
public:
	void OnGameStageChange(int32 NewStage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Decorator_WaterParkIsGameStart">();
	}
	static class ULT_Decorator_WaterParkIsGameStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Decorator_WaterParkIsGameStart>();
	}
};
static_assert(alignof(ULT_Decorator_WaterParkIsGameStart) == 0x000008, "Wrong alignment on ULT_Decorator_WaterParkIsGameStart");
static_assert(sizeof(ULT_Decorator_WaterParkIsGameStart) == 0x000038, "Wrong size on ULT_Decorator_WaterParkIsGameStart");

// Class GameEx.LT_Task_GetRandomActor
// 0x0040 (0x00E0 - 0x00A0)
class ULT_Task_GetRandomActor final : public ULogicTree_TaskNode
{
public:
	class UClass*                                 ActorClass;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                OutRes;                                            // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_GetRandomActor">();
	}
	static class ULT_Task_GetRandomActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_GetRandomActor>();
	}
};
static_assert(alignof(ULT_Task_GetRandomActor) == 0x000008, "Wrong alignment on ULT_Task_GetRandomActor");
static_assert(sizeof(ULT_Task_GetRandomActor) == 0x0000E0, "Wrong size on ULT_Task_GetRandomActor");
static_assert(offsetof(ULT_Task_GetRandomActor, ActorClass) == 0x0000A0, "Member 'ULT_Task_GetRandomActor::ActorClass' has a wrong offset!");
static_assert(offsetof(ULT_Task_GetRandomActor, OutRes) == 0x0000A8, "Member 'ULT_Task_GetRandomActor::OutRes' has a wrong offset!");

// Class GameEx.LT_Task_WaterPark_DmgRpc
// 0x0140 (0x01E0 - 0x00A0)
class ULT_Task_WaterPark_DmgRpc final : public ULogicTree_TaskNode
{
public:
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                AttackTarget;                                      // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         BulletType;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiBulletsHitRateMin;                            // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiBulletsHitRateMax;                            // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                WeaponID;                                          // 0x0130(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                BulletNum;                                         // 0x0168(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                BulletID;                                          // 0x01A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       OwnGECharCache;                                    // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterPark_DmgRpc">();
	}
	static class ULT_Task_WaterPark_DmgRpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterPark_DmgRpc>();
	}
};
static_assert(alignof(ULT_Task_WaterPark_DmgRpc) == 0x000008, "Wrong alignment on ULT_Task_WaterPark_DmgRpc");
static_assert(sizeof(ULT_Task_WaterPark_DmgRpc) == 0x0001E0, "Wrong size on ULT_Task_WaterPark_DmgRpc");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, AttackTarget) == 0x0000E8, "Member 'ULT_Task_WaterPark_DmgRpc::AttackTarget' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, BulletType) == 0x000120, "Member 'ULT_Task_WaterPark_DmgRpc::BulletType' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, MultiBulletsHitRateMin) == 0x000124, "Member 'ULT_Task_WaterPark_DmgRpc::MultiBulletsHitRateMin' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, MultiBulletsHitRateMax) == 0x000128, "Member 'ULT_Task_WaterPark_DmgRpc::MultiBulletsHitRateMax' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, WeaponID) == 0x000130, "Member 'ULT_Task_WaterPark_DmgRpc::WeaponID' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, BulletNum) == 0x000168, "Member 'ULT_Task_WaterPark_DmgRpc::BulletNum' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, BulletID) == 0x0001A0, "Member 'ULT_Task_WaterPark_DmgRpc::BulletID' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterPark_DmgRpc, OwnGECharCache) == 0x0001D8, "Member 'ULT_Task_WaterPark_DmgRpc::OwnGECharCache' has a wrong offset!");

// Class GameEx.LT_Task_WaterParkAIMeleeSweep
// 0x00D0 (0x0170 - 0x00A0)
class ULT_Task_WaterParkAIMeleeSweep final : public ULogicTree_TaskNode
{
public:
	struct FLogicTree_DataAccessor                AttackTarget;                                      // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                CheckRange;                                        // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         HeightOffsetBegin;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffsetEnd;                                   // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleBegin;                                        // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleEnd;                                          // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                OutRes;                                            // 0x0120(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SweepInterval;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SweepNum;                                          // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationPerTick;                                  // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0xC];                                      // 0x0164(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterParkAIMeleeSweep">();
	}
	static class ULT_Task_WaterParkAIMeleeSweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterParkAIMeleeSweep>();
	}
};
static_assert(alignof(ULT_Task_WaterParkAIMeleeSweep) == 0x000008, "Wrong alignment on ULT_Task_WaterParkAIMeleeSweep");
static_assert(sizeof(ULT_Task_WaterParkAIMeleeSweep) == 0x000170, "Wrong size on ULT_Task_WaterParkAIMeleeSweep");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, AttackTarget) == 0x0000A0, "Member 'ULT_Task_WaterParkAIMeleeSweep::AttackTarget' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, CheckRange) == 0x0000D8, "Member 'ULT_Task_WaterParkAIMeleeSweep::CheckRange' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, HeightOffsetBegin) == 0x000110, "Member 'ULT_Task_WaterParkAIMeleeSweep::HeightOffsetBegin' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, HeightOffsetEnd) == 0x000114, "Member 'ULT_Task_WaterParkAIMeleeSweep::HeightOffsetEnd' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, AngleBegin) == 0x000118, "Member 'ULT_Task_WaterParkAIMeleeSweep::AngleBegin' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, AngleEnd) == 0x00011C, "Member 'ULT_Task_WaterParkAIMeleeSweep::AngleEnd' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, OutRes) == 0x000120, "Member 'ULT_Task_WaterParkAIMeleeSweep::OutRes' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, SweepInterval) == 0x000158, "Member 'ULT_Task_WaterParkAIMeleeSweep::SweepInterval' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, SweepNum) == 0x00015C, "Member 'ULT_Task_WaterParkAIMeleeSweep::SweepNum' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkAIMeleeSweep, IterationPerTick) == 0x000160, "Member 'ULT_Task_WaterParkAIMeleeSweep::IterationPerTick' has a wrong offset!");

// Class GameEx.LT_Task_WaterParkChangeAttackBase
// 0x0010 (0x00B0 - 0x00A0)
class ULT_Task_WaterParkChangeAttackBase : public ULogicTree_TaskNode
{
public:
	bool                                          NewState;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameCharacter*                       OwnGECharCache;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterParkChangeAttackBase">();
	}
	static class ULT_Task_WaterParkChangeAttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterParkChangeAttackBase>();
	}
};
static_assert(alignof(ULT_Task_WaterParkChangeAttackBase) == 0x000008, "Wrong alignment on ULT_Task_WaterParkChangeAttackBase");
static_assert(sizeof(ULT_Task_WaterParkChangeAttackBase) == 0x0000B0, "Wrong size on ULT_Task_WaterParkChangeAttackBase");
static_assert(offsetof(ULT_Task_WaterParkChangeAttackBase, NewState) == 0x0000A0, "Member 'ULT_Task_WaterParkChangeAttackBase::NewState' has a wrong offset!");
static_assert(offsetof(ULT_Task_WaterParkChangeAttackBase, OwnGECharCache) == 0x0000A8, "Member 'ULT_Task_WaterParkChangeAttackBase::OwnGECharCache' has a wrong offset!");

// Class GameEx.LT_Task_WaterParkChangeShootFiring
// 0x0000 (0x00B0 - 0x00B0)
class ULT_Task_WaterParkChangeShootFiring final : public ULT_Task_WaterParkChangeAttackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterParkChangeShootFiring">();
	}
	static class ULT_Task_WaterParkChangeShootFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterParkChangeShootFiring>();
	}
};
static_assert(alignof(ULT_Task_WaterParkChangeShootFiring) == 0x000008, "Wrong alignment on ULT_Task_WaterParkChangeShootFiring");
static_assert(sizeof(ULT_Task_WaterParkChangeShootFiring) == 0x0000B0, "Wrong size on ULT_Task_WaterParkChangeShootFiring");

// Class GameEx.LT_Task_WaterParkChangeShootFireState
// 0x0000 (0x00B0 - 0x00B0)
class ULT_Task_WaterParkChangeShootFireState final : public ULT_Task_WaterParkChangeAttackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterParkChangeShootFireState">();
	}
	static class ULT_Task_WaterParkChangeShootFireState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterParkChangeShootFireState>();
	}
};
static_assert(alignof(ULT_Task_WaterParkChangeShootFireState) == 0x000008, "Wrong alignment on ULT_Task_WaterParkChangeShootFireState");
static_assert(sizeof(ULT_Task_WaterParkChangeShootFireState) == 0x0000B0, "Wrong size on ULT_Task_WaterParkChangeShootFireState");

// Class GameEx.LT_Task_WaterParkChangeMeleeAttack
// 0x0000 (0x00B0 - 0x00B0)
class ULT_Task_WaterParkChangeMeleeAttack final : public ULT_Task_WaterParkChangeAttackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_Task_WaterParkChangeMeleeAttack">();
	}
	static class ULT_Task_WaterParkChangeMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_Task_WaterParkChangeMeleeAttack>();
	}
};
static_assert(alignof(ULT_Task_WaterParkChangeMeleeAttack) == 0x000008, "Wrong alignment on ULT_Task_WaterParkChangeMeleeAttack");
static_assert(sizeof(ULT_Task_WaterParkChangeMeleeAttack) == 0x0000B0, "Wrong size on ULT_Task_WaterParkChangeMeleeAttack");

// Class GameEx.LT_WP_AddBulletNumAction
// 0x0078 (0x00A8 - 0x0030)
class ULT_WP_AddBulletNumAction final : public ULogicTree_ActionBase
{
public:
	struct FLogicTree_DataAccessor                ProbabilityAccessor;                               // 0x0030(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                PercentAccessor;                                   // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsAddPercent;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_AddBulletNumAction">();
	}
	static class ULT_WP_AddBulletNumAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_AddBulletNumAction>();
	}
};
static_assert(alignof(ULT_WP_AddBulletNumAction) == 0x000008, "Wrong alignment on ULT_WP_AddBulletNumAction");
static_assert(sizeof(ULT_WP_AddBulletNumAction) == 0x0000A8, "Wrong size on ULT_WP_AddBulletNumAction");
static_assert(offsetof(ULT_WP_AddBulletNumAction, ProbabilityAccessor) == 0x000030, "Member 'ULT_WP_AddBulletNumAction::ProbabilityAccessor' has a wrong offset!");
static_assert(offsetof(ULT_WP_AddBulletNumAction, PercentAccessor) == 0x000068, "Member 'ULT_WP_AddBulletNumAction::PercentAccessor' has a wrong offset!");
static_assert(offsetof(ULT_WP_AddBulletNumAction, IsAddPercent) == 0x0000A0, "Member 'ULT_WP_AddBulletNumAction::IsAddPercent' has a wrong offset!");

// Class GameEx.LT_WP_AddCharLevelLimitAction
// 0x0038 (0x0068 - 0x0030)
class ULT_WP_AddCharLevelLimitAction final : public ULogicTree_ActionBase
{
public:
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0030(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_AddCharLevelLimitAction">();
	}
	static class ULT_WP_AddCharLevelLimitAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_AddCharLevelLimitAction>();
	}
};
static_assert(alignof(ULT_WP_AddCharLevelLimitAction) == 0x000008, "Wrong alignment on ULT_WP_AddCharLevelLimitAction");
static_assert(sizeof(ULT_WP_AddCharLevelLimitAction) == 0x000068, "Wrong size on ULT_WP_AddCharLevelLimitAction");
static_assert(offsetof(ULT_WP_AddCharLevelLimitAction, DataAccessor) == 0x000030, "Member 'ULT_WP_AddCharLevelLimitAction::DataAccessor' has a wrong offset!");

// Class GameEx.LT_WP_ModifySkillAction
// 0x0078 (0x00A8 - 0x0030)
class ULT_WP_ModifySkillAction final : public ULogicTree_ActionBase
{
public:
	EWPModifySkillType                            ModifyType;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0038(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLogicTree_DataAccessor                SkillDataAccessor;                                 // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_ModifySkillAction">();
	}
	static class ULT_WP_ModifySkillAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_ModifySkillAction>();
	}
};
static_assert(alignof(ULT_WP_ModifySkillAction) == 0x000008, "Wrong alignment on ULT_WP_ModifySkillAction");
static_assert(sizeof(ULT_WP_ModifySkillAction) == 0x0000A8, "Wrong size on ULT_WP_ModifySkillAction");
static_assert(offsetof(ULT_WP_ModifySkillAction, ModifyType) == 0x000030, "Member 'ULT_WP_ModifySkillAction::ModifyType' has a wrong offset!");
static_assert(offsetof(ULT_WP_ModifySkillAction, DataAccessor) == 0x000038, "Member 'ULT_WP_ModifySkillAction::DataAccessor' has a wrong offset!");
static_assert(offsetof(ULT_WP_ModifySkillAction, SkillDataAccessor) == 0x000070, "Member 'ULT_WP_ModifySkillAction::SkillDataAccessor' has a wrong offset!");

// Class GameEx.LT_WP_RecordZBugCureAction
// 0x0038 (0x0068 - 0x0030)
class ULT_WP_RecordZBugCureAction final : public ULogicTree_ActionBase
{
public:
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0030(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_RecordZBugCureAction">();
	}
	static class ULT_WP_RecordZBugCureAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_RecordZBugCureAction>();
	}
};
static_assert(alignof(ULT_WP_RecordZBugCureAction) == 0x000008, "Wrong alignment on ULT_WP_RecordZBugCureAction");
static_assert(sizeof(ULT_WP_RecordZBugCureAction) == 0x000068, "Wrong size on ULT_WP_RecordZBugCureAction");
static_assert(offsetof(ULT_WP_RecordZBugCureAction, DataAccessor) == 0x000030, "Member 'ULT_WP_RecordZBugCureAction::DataAccessor' has a wrong offset!");

// Class GameEx.LT_WP_SetCameraInfoAction
// 0x0010 (0x0040 - 0x0030)
class ULT_WP_SetCameraInfoAction final : public ULogicTree_ActionBase
{
public:
	class FString                                 Key;                                               // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_SetCameraInfoAction">();
	}
	static class ULT_WP_SetCameraInfoAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_SetCameraInfoAction>();
	}
};
static_assert(alignof(ULT_WP_SetCameraInfoAction) == 0x000008, "Wrong alignment on ULT_WP_SetCameraInfoAction");
static_assert(sizeof(ULT_WP_SetCameraInfoAction) == 0x000040, "Wrong size on ULT_WP_SetCameraInfoAction");
static_assert(offsetof(ULT_WP_SetCameraInfoAction, Key) == 0x000030, "Member 'ULT_WP_SetCameraInfoAction::Key' has a wrong offset!");

// Class GameEx.LT_WP_SpawnNiagaraAction
// 0x0108 (0x0138 - 0x0030)
class ULT_WP_SpawnNiagaraAction final : public ULogicTree_ActionBase
{
public:
	int32                                         EffectId;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAttach;                                          // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAccessorRotate;                                 // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotate;                                            // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                RotateAccessor;                                    // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0098(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    NiagaraParam;                                      // 0x00A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          NeedDestroy;                                       // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedSetAbsoluteSize;                              // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicTree_DataAccessor                DataAccessor;                                      // 0x0100(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_WP_SpawnNiagaraAction">();
	}
	static class ULT_WP_SpawnNiagaraAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_WP_SpawnNiagaraAction>();
	}
};
static_assert(alignof(ULT_WP_SpawnNiagaraAction) == 0x000008, "Wrong alignment on ULT_WP_SpawnNiagaraAction");
static_assert(sizeof(ULT_WP_SpawnNiagaraAction) == 0x000138, "Wrong size on ULT_WP_SpawnNiagaraAction");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, EffectId) == 0x000030, "Member 'ULT_WP_SpawnNiagaraAction::EffectId' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, IsAttach) == 0x000034, "Member 'ULT_WP_SpawnNiagaraAction::IsAttach' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, AttachSocket) == 0x000038, "Member 'ULT_WP_SpawnNiagaraAction::AttachSocket' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, Offset) == 0x000040, "Member 'ULT_WP_SpawnNiagaraAction::Offset' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, UseAccessorRotate) == 0x00004C, "Member 'ULT_WP_SpawnNiagaraAction::UseAccessorRotate' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, Rotate) == 0x000050, "Member 'ULT_WP_SpawnNiagaraAction::Rotate' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, RotateAccessor) == 0x000060, "Member 'ULT_WP_SpawnNiagaraAction::RotateAccessor' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, Scale) == 0x000098, "Member 'ULT_WP_SpawnNiagaraAction::Scale' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, NiagaraParam) == 0x0000A8, "Member 'ULT_WP_SpawnNiagaraAction::NiagaraParam' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, NeedDestroy) == 0x0000F8, "Member 'ULT_WP_SpawnNiagaraAction::NeedDestroy' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, bNeedSetAbsoluteSize) == 0x0000F9, "Member 'ULT_WP_SpawnNiagaraAction::bNeedSetAbsoluteSize' has a wrong offset!");
static_assert(offsetof(ULT_WP_SpawnNiagaraAction, DataAccessor) == 0x000100, "Member 'ULT_WP_SpawnNiagaraAction::DataAccessor' has a wrong offset!");

// Class GameEx.LT_ZBugDmgCalcAction
// 0x0030 (0x0060 - 0x0030)
class ULT_ZBugDmgCalcAction final : public ULogicTree_ActionBase
{
public:
	class FName                                   LauncherName;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetName;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FireEndPosName;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FireStartPosName;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       Launcher;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       Target;                                            // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_ZBugDmgCalcAction">();
	}
	static class ULT_ZBugDmgCalcAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_ZBugDmgCalcAction>();
	}
};
static_assert(alignof(ULT_ZBugDmgCalcAction) == 0x000008, "Wrong alignment on ULT_ZBugDmgCalcAction");
static_assert(sizeof(ULT_ZBugDmgCalcAction) == 0x000060, "Wrong size on ULT_ZBugDmgCalcAction");
static_assert(offsetof(ULT_ZBugDmgCalcAction, LauncherName) == 0x000030, "Member 'ULT_ZBugDmgCalcAction::LauncherName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgCalcAction, TargetName) == 0x000038, "Member 'ULT_ZBugDmgCalcAction::TargetName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgCalcAction, FireEndPosName) == 0x000040, "Member 'ULT_ZBugDmgCalcAction::FireEndPosName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgCalcAction, FireStartPosName) == 0x000048, "Member 'ULT_ZBugDmgCalcAction::FireStartPosName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgCalcAction, Launcher) == 0x000050, "Member 'ULT_ZBugDmgCalcAction::Launcher' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgCalcAction, Target) == 0x000058, "Member 'ULT_ZBugDmgCalcAction::Target' has a wrong offset!");

// Class GameEx.LT_ZBugDmgRPCAction
// 0x0058 (0x0088 - 0x0030)
class ULT_ZBugDmgRPCAction final : public ULogicTree_ActionBase
{
public:
	class FName                                   LauncherName;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetName;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageName;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CriticalName;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponTypeName;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponIDName;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectIDName;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitPosName;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitStartPosName;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       Launcher;                                          // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEGameCharacter*                       Target;                                            // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LT_ZBugDmgRPCAction">();
	}
	static class ULT_ZBugDmgRPCAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULT_ZBugDmgRPCAction>();
	}
};
static_assert(alignof(ULT_ZBugDmgRPCAction) == 0x000008, "Wrong alignment on ULT_ZBugDmgRPCAction");
static_assert(sizeof(ULT_ZBugDmgRPCAction) == 0x000088, "Wrong size on ULT_ZBugDmgRPCAction");
static_assert(offsetof(ULT_ZBugDmgRPCAction, LauncherName) == 0x000030, "Member 'ULT_ZBugDmgRPCAction::LauncherName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, TargetName) == 0x000038, "Member 'ULT_ZBugDmgRPCAction::TargetName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, DamageName) == 0x000040, "Member 'ULT_ZBugDmgRPCAction::DamageName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, CriticalName) == 0x000048, "Member 'ULT_ZBugDmgRPCAction::CriticalName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, WeaponTypeName) == 0x000050, "Member 'ULT_ZBugDmgRPCAction::WeaponTypeName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, WeaponIDName) == 0x000058, "Member 'ULT_ZBugDmgRPCAction::WeaponIDName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, EffectIDName) == 0x000060, "Member 'ULT_ZBugDmgRPCAction::EffectIDName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, HitPosName) == 0x000068, "Member 'ULT_ZBugDmgRPCAction::HitPosName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, HitStartPosName) == 0x000070, "Member 'ULT_ZBugDmgRPCAction::HitStartPosName' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, Launcher) == 0x000078, "Member 'ULT_ZBugDmgRPCAction::Launcher' has a wrong offset!");
static_assert(offsetof(ULT_ZBugDmgRPCAction, Target) == 0x000080, "Member 'ULT_ZBugDmgRPCAction::Target' has a wrong offset!");

// Class GameEx.WaterPark_BlockPushCapsuleComponent
// 0x0070 (0x04F0 - 0x0480)
class UWaterPark_BlockPushCapsuleComponent final : public UCapsuleComponent
{
public:
	float                                         MinPushDis;                                        // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushScale;                                         // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OldTransform;                                      // 0x0480(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             CurrentTransform;                                  // 0x04B0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class AGEGameCharacter*                       OwnerCharacter;                                    // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWPCharMoveComponent*                   OwnerBaseMoveComponent;                            // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_BlockPushCapsuleComponent">();
	}
	static class UWaterPark_BlockPushCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_BlockPushCapsuleComponent>();
	}
};
static_assert(alignof(UWaterPark_BlockPushCapsuleComponent) == 0x000010, "Wrong alignment on UWaterPark_BlockPushCapsuleComponent");
static_assert(sizeof(UWaterPark_BlockPushCapsuleComponent) == 0x0004F0, "Wrong size on UWaterPark_BlockPushCapsuleComponent");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, MinPushDis) == 0x000478, "Member 'UWaterPark_BlockPushCapsuleComponent::MinPushDis' has a wrong offset!");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, PushScale) == 0x00047C, "Member 'UWaterPark_BlockPushCapsuleComponent::PushScale' has a wrong offset!");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, OldTransform) == 0x000480, "Member 'UWaterPark_BlockPushCapsuleComponent::OldTransform' has a wrong offset!");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, CurrentTransform) == 0x0004B0, "Member 'UWaterPark_BlockPushCapsuleComponent::CurrentTransform' has a wrong offset!");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, OwnerCharacter) == 0x0004E0, "Member 'UWaterPark_BlockPushCapsuleComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UWaterPark_BlockPushCapsuleComponent, OwnerBaseMoveComponent) == 0x0004E8, "Member 'UWaterPark_BlockPushCapsuleComponent::OwnerBaseMoveComponent' has a wrong offset!");

// Class GameEx.WaterPark_LinerPushComponent
// 0x0000 (0x0480 - 0x0480)
class UWaterPark_LinerPushComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_LinerPushComponent">();
	}
	static class UWaterPark_LinerPushComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_LinerPushComponent>();
	}
};
static_assert(alignof(UWaterPark_LinerPushComponent) == 0x000010, "Wrong alignment on UWaterPark_LinerPushComponent");
static_assert(sizeof(UWaterPark_LinerPushComponent) == 0x000480, "Wrong size on UWaterPark_LinerPushComponent");

// Class GameEx.WaterPark_NtfState_MeleeState
// 0x0000 (0x0030 - 0x0030)
class UWaterPark_NtfState_MeleeState final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterPark_NtfState_MeleeState">();
	}
	static class UWaterPark_NtfState_MeleeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterPark_NtfState_MeleeState>();
	}
};
static_assert(alignof(UWaterPark_NtfState_MeleeState) == 0x000008, "Wrong alignment on UWaterPark_NtfState_MeleeState");
static_assert(sizeof(UWaterPark_NtfState_MeleeState) == 0x000030, "Wrong size on UWaterPark_NtfState_MeleeState");

// Class GameEx.WaterParkPlayerCameraManager
// 0x0040 (0x2860 - 0x2820)
class AWaterParkPlayerCameraManager final : public APlayerCameraManager
{
public:
	bool                                          InCustomRot;                                       // 0x2820(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2821[0x3];                                     // 0x2821(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CustomRotator;                                     // 0x2824(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CustomLength;                                      // 0x2830(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtituteArmTargetLength;                          // 0x2834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginArmTargetLength;                             // 0x2838(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_283C[0x24];                                    // 0x283C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCustomCamRotAndLength(bool InCustom, float InLength, const struct FRotator& InRotator);
	void SetIsOnRotatingPlatform(bool InIsOnPlatform, const struct FRotator& InRotator, class AGEGameCharacter* InCharacter);
	void SetIsSpectating(const struct FRotator& InRotator);
	void SetSubtituteCamera(bool IsInSubtitute);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterParkPlayerCameraManager">();
	}
	static class AWaterParkPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterParkPlayerCameraManager>();
	}
};
static_assert(alignof(AWaterParkPlayerCameraManager) == 0x000010, "Wrong alignment on AWaterParkPlayerCameraManager");
static_assert(sizeof(AWaterParkPlayerCameraManager) == 0x002860, "Wrong size on AWaterParkPlayerCameraManager");
static_assert(offsetof(AWaterParkPlayerCameraManager, InCustomRot) == 0x002820, "Member 'AWaterParkPlayerCameraManager::InCustomRot' has a wrong offset!");
static_assert(offsetof(AWaterParkPlayerCameraManager, CustomRotator) == 0x002824, "Member 'AWaterParkPlayerCameraManager::CustomRotator' has a wrong offset!");
static_assert(offsetof(AWaterParkPlayerCameraManager, CustomLength) == 0x002830, "Member 'AWaterParkPlayerCameraManager::CustomLength' has a wrong offset!");
static_assert(offsetof(AWaterParkPlayerCameraManager, SubtituteArmTargetLength) == 0x002834, "Member 'AWaterParkPlayerCameraManager::SubtituteArmTargetLength' has a wrong offset!");
static_assert(offsetof(AWaterParkPlayerCameraManager, OriginArmTargetLength) == 0x002838, "Member 'AWaterParkPlayerCameraManager::OriginArmTargetLength' has a wrong offset!");

// Class GameEx.WaterParkQAnimIns
// 0x0130 (0x03F0 - 0x02C0)
class UWaterParkQAnimIns final : public UAnimInstance
{
public:
	class UAnimMontage*                           JumpMontage;                                       // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpSecondMontage;                                 // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FallingMontage;                                    // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpEndMontage;                                    // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StandSequence;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunSequence;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RushLoopSequence;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            LeanBlendSpace;                                    // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanLevelAngle;                                    // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameCharacter*                       LpCharacter;                                       // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGEPlayerController*                    LpController;                                      // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_EntityDataCom*               LpCharDataCom;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InWalk;                                            // 0x031C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FallingWithHeight;                                 // 0x031D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InItemHold;                                        // 0x031E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InItemHold_AnimState;                              // 0x031F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInItemRush;                                      // 0x0320(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAnimMontage*>        LoadedMontageMap;                                  // 0x0328(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	bool                                          IsHoldGun;                                         // 0x0378(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldMelee;                                       // 0x0379(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsZBugRush;                                        // 0x037A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInShotState;                                     // 0x037B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShooting;                                        // 0x037C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShootingAnim;                                    // 0x037D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GetMeleeHit;                                       // 0x037E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37F[0x1];                                      // 0x037F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBug_AimPitch;                                     // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InZBugThrowBomb;                                   // 0x0384(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZBugShotYaw;                                       // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugMoveAngle;                                     // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeHitTimeScale;                                 // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZBugExSpeedRate;                                   // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULogicTree_EntityDataCom*               PawnDataCom;                                       // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_GunShootStand;                                // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_GunStand;                                     // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          ZBug_ShootMove;                                    // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_GunRush;                                      // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          ZBug_AimOffset;                                    // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_MeleeHit;                                     // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_Shoot;                                        // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ZBug_GunHit;                                       // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZBugPeapleWeaponType;                              // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0xC];                                      // 0x03E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckMontagePlayingByName(class FName InName);
	class UAnimMontage* GetMontageByName(class FName InName);
	void InitAssets();
	void InitZBugRunInfo(bool IsMelee);
	void InitZBugWeaponAsset();
	void PlayMontageByName(class FName InName, bool CheckIsPlaying, bool ChangeRepIndex);
	void StopMontageByName(class FName InName, float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterParkQAnimIns">();
	}
	static class UWaterParkQAnimIns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterParkQAnimIns>();
	}
};
static_assert(alignof(UWaterParkQAnimIns) == 0x000010, "Wrong alignment on UWaterParkQAnimIns");
static_assert(sizeof(UWaterParkQAnimIns) == 0x0003F0, "Wrong size on UWaterParkQAnimIns");
static_assert(offsetof(UWaterParkQAnimIns, JumpMontage) == 0x0002B8, "Member 'UWaterParkQAnimIns::JumpMontage' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, JumpSecondMontage) == 0x0002C0, "Member 'UWaterParkQAnimIns::JumpSecondMontage' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, FallingMontage) == 0x0002C8, "Member 'UWaterParkQAnimIns::FallingMontage' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, JumpEndMontage) == 0x0002D0, "Member 'UWaterParkQAnimIns::JumpEndMontage' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, StandSequence) == 0x0002D8, "Member 'UWaterParkQAnimIns::StandSequence' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, RunSequence) == 0x0002E0, "Member 'UWaterParkQAnimIns::RunSequence' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, RushLoopSequence) == 0x0002E8, "Member 'UWaterParkQAnimIns::RushLoopSequence' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LeanBlendSpace) == 0x0002F0, "Member 'UWaterParkQAnimIns::LeanBlendSpace' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LeanLevelAngle) == 0x0002F8, "Member 'UWaterParkQAnimIns::LeanLevelAngle' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LpCharacter) == 0x000300, "Member 'UWaterParkQAnimIns::LpCharacter' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LpController) == 0x000308, "Member 'UWaterParkQAnimIns::LpController' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LpCharDataCom) == 0x000310, "Member 'UWaterParkQAnimIns::LpCharDataCom' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, MoveSpeed) == 0x000318, "Member 'UWaterParkQAnimIns::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, InWalk) == 0x00031C, "Member 'UWaterParkQAnimIns::InWalk' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, FallingWithHeight) == 0x00031D, "Member 'UWaterParkQAnimIns::FallingWithHeight' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, InItemHold) == 0x00031E, "Member 'UWaterParkQAnimIns::InItemHold' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, InItemHold_AnimState) == 0x00031F, "Member 'UWaterParkQAnimIns::InItemHold_AnimState' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsInItemRush) == 0x000320, "Member 'UWaterParkQAnimIns::IsInItemRush' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, LoadedMontageMap) == 0x000328, "Member 'UWaterParkQAnimIns::LoadedMontageMap' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsHoldGun) == 0x000378, "Member 'UWaterParkQAnimIns::IsHoldGun' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsHoldMelee) == 0x000379, "Member 'UWaterParkQAnimIns::IsHoldMelee' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsZBugRush) == 0x00037A, "Member 'UWaterParkQAnimIns::IsZBugRush' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsInShotState) == 0x00037B, "Member 'UWaterParkQAnimIns::IsInShotState' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsShooting) == 0x00037C, "Member 'UWaterParkQAnimIns::IsShooting' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, IsShootingAnim) == 0x00037D, "Member 'UWaterParkQAnimIns::IsShootingAnim' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, GetMeleeHit) == 0x00037E, "Member 'UWaterParkQAnimIns::GetMeleeHit' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_AimPitch) == 0x000380, "Member 'UWaterParkQAnimIns::ZBug_AimPitch' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, InZBugThrowBomb) == 0x000384, "Member 'UWaterParkQAnimIns::InZBugThrowBomb' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBugShotYaw) == 0x000388, "Member 'UWaterParkQAnimIns::ZBugShotYaw' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBugMoveAngle) == 0x00038C, "Member 'UWaterParkQAnimIns::ZBugMoveAngle' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, MeleeHitTimeScale) == 0x000390, "Member 'UWaterParkQAnimIns::MeleeHitTimeScale' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBugExSpeedRate) == 0x000394, "Member 'UWaterParkQAnimIns::ZBugExSpeedRate' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, PawnDataCom) == 0x000398, "Member 'UWaterParkQAnimIns::PawnDataCom' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_GunShootStand) == 0x0003A0, "Member 'UWaterParkQAnimIns::ZBug_GunShootStand' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_GunStand) == 0x0003A8, "Member 'UWaterParkQAnimIns::ZBug_GunStand' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_ShootMove) == 0x0003B0, "Member 'UWaterParkQAnimIns::ZBug_ShootMove' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_GunRush) == 0x0003B8, "Member 'UWaterParkQAnimIns::ZBug_GunRush' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_AimOffset) == 0x0003C0, "Member 'UWaterParkQAnimIns::ZBug_AimOffset' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_MeleeHit) == 0x0003C8, "Member 'UWaterParkQAnimIns::ZBug_MeleeHit' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_Shoot) == 0x0003D0, "Member 'UWaterParkQAnimIns::ZBug_Shoot' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBug_GunHit) == 0x0003D8, "Member 'UWaterParkQAnimIns::ZBug_GunHit' has a wrong offset!");
static_assert(offsetof(UWaterParkQAnimIns, ZBugPeapleWeaponType) == 0x0003E0, "Member 'UWaterParkQAnimIns::ZBugPeapleWeaponType' has a wrong offset!");

// Class GameEx.WPCharMoveComponent
// 0x0030 (0x0B30 - 0x0B00)
class UWPCharMoveComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B00[0x4];                                      // 0x0B00(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpZSpeed;                                        // 0x0B04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZSpeedSec;                                     // 0x0B08(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0C[0x4];                                      // 0x0B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameCharacter*                       Lp_WpCharacter;                                    // 0x0B10(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B18[0x18];                                     // 0x0B18(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetNowAcceleration();
	void K2_OnMoveBlockPush(const struct FVector& Delta, const struct FRotator& NewRotation, bool bSweep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WPCharMoveComponent">();
	}
	static class UWPCharMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWPCharMoveComponent>();
	}
};
static_assert(alignof(UWPCharMoveComponent) == 0x000010, "Wrong alignment on UWPCharMoveComponent");
static_assert(sizeof(UWPCharMoveComponent) == 0x000B30, "Wrong size on UWPCharMoveComponent");
static_assert(offsetof(UWPCharMoveComponent, JumpZSpeed) == 0x000B04, "Member 'UWPCharMoveComponent::JumpZSpeed' has a wrong offset!");
static_assert(offsetof(UWPCharMoveComponent, JumpZSpeedSec) == 0x000B08, "Member 'UWPCharMoveComponent::JumpZSpeedSec' has a wrong offset!");
static_assert(offsetof(UWPCharMoveComponent, Lp_WpCharacter) == 0x000B10, "Member 'UWPCharMoveComponent::Lp_WpCharacter' has a wrong offset!");

// Class GameEx.WPCharStateMachineComponent
// 0x0060 (0x0110 - 0x00B0)
class UWPCharStateMachineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x58];                                      // 0x00B0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AGEGameCharacter*                       OwnGEChar;                                         // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EWaterParkCharState GetNowState();
	void JumpToState(const EWaterParkCharState NextState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WPCharStateMachineComponent">();
	}
	static class UWPCharStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWPCharStateMachineComponent>();
	}
};
static_assert(alignof(UWPCharStateMachineComponent) == 0x000008, "Wrong alignment on UWPCharStateMachineComponent");
static_assert(sizeof(UWPCharStateMachineComponent) == 0x000110, "Wrong size on UWPCharStateMachineComponent");
static_assert(offsetof(UWPCharStateMachineComponent, OwnGEChar) == 0x000108, "Member 'UWPCharStateMachineComponent::OwnGEChar' has a wrong offset!");

// Class GameEx.WPLogicSkillHandleComponent
// 0x0000 (0x04C8 - 0x04C8)
class UWPLogicSkillHandleComponent final : public ULogicTree_LogicHandleCom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WPLogicSkillHandleComponent">();
	}
	static class UWPLogicSkillHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWPLogicSkillHandleComponent>();
	}
};
static_assert(alignof(UWPLogicSkillHandleComponent) == 0x000008, "Wrong alignment on UWPLogicSkillHandleComponent");
static_assert(sizeof(UWPLogicSkillHandleComponent) == 0x0004C8, "Wrong size on UWPLogicSkillHandleComponent");

// Class GameEx.WPLogicBuffHandleComponent
// 0x0000 (0x04C8 - 0x04C8)
class UWPLogicBuffHandleComponent final : public ULogicTree_LogicHandleCom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WPLogicBuffHandleComponent">();
	}
	static class UWPLogicBuffHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWPLogicBuffHandleComponent>();
	}
};
static_assert(alignof(UWPLogicBuffHandleComponent) == 0x000008, "Wrong alignment on UWPLogicBuffHandleComponent");
static_assert(sizeof(UWPLogicBuffHandleComponent) == 0x0004C8, "Wrong size on UWPLogicBuffHandleComponent");

}


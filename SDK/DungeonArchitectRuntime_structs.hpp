#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonArchitectRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum DungeonArchitectRuntime.EDungeonLevelStreamChunkSelection
// NumValues: 0x0003
enum class EDungeonLevelStreamChunkSelection : uint8
{
	PlayerLocations                          = 0,
	SpawnRoomLocations                       = 1,
	EDungeonLevelStreamChunkSelection_MAX    = 2,
};

// Enum DungeonArchitectRuntime.EDungeonLevelStreamUnloadMethod
// NumValues: 0x0003
enum class EDungeonLevelStreamUnloadMethod : uint8
{
	KeepHiddenChunksInMemory                 = 0,
	UnloadHiddenChunks                       = 1,
	EDungeonLevelStreamUnloadMethod_MAX      = 2,
};

// Enum DungeonArchitectRuntime.EDungeonLevelStreamLoadMethod
// NumValues: 0x0003
enum class EDungeonLevelStreamLoadMethod : uint8
{
	LoadOnDemand                             = 0,
	LoadEverythingInMemory                   = 1,
	EDungeonLevelStreamLoadMethod_MAX        = 2,
};

// Enum DungeonArchitectRuntime.EDungeonLevelStreamingStrategy
// NumValues: 0x0003
enum class EDungeonLevelStreamingStrategy : uint8
{
	LayoutDepth                              = 0,
	Distance                                 = 1,
	EDungeonLevelStreamingStrategy_MAX       = 2,
};

// Enum DungeonArchitectRuntime.EDungeonLevelStreamingLoadingStrategy
// NumValues: 0x0004
enum class EDungeonLevelStreamingLoadingStrategy : uint8
{
	PreloadEverything                        = 0,
	LoadOnDemand                             = 1,
	OnlyVisibleLoaded                        = 2,
	EDungeonLevelStreamingLoadingStrategy_MAX = 3,
};

// Enum DungeonArchitectRuntime.EDungeonMiniMapIconCoordinateSystem
// NumValues: 0x0003
enum class EDungeonMiniMapIconCoordinateSystem : uint8
{
	Pixels                                   = 0,
	WorldCoordinates                         = 1,
	EDungeonMiniMapIconCoordinateSystem_MAX  = 2,
};

// Enum DungeonArchitectRuntime.EFlowGraphItemType
// NumValues: 0x0009
enum class EFlowGraphItemType : uint8
{
	Enemy                                    = 0,
	Entrance                                 = 1,
	Exit                                     = 2,
	Treasure                                 = 3,
	Key                                      = 4,
	Lock                                     = 5,
	Teleporter                               = 6,
	Custom                                   = 7,
	EFlowGraphItemType_MAX                   = 8,
};

// Enum DungeonArchitectRuntime.EFlowAbstractLinkType
// NumValues: 0x0004
enum class EFlowAbstractLinkType : uint8
{
	Unconnected                              = 0,
	Connected                                = 1,
	OneWay                                   = 2,
	EFlowAbstractLinkType_MAX                = 3,
};

// Enum DungeonArchitectRuntime.EridFlowTask_SpawnItemsMethod
// NumValues: 0x0003
enum class EridFlowTask_SpawnItemsMethod : uint8
{
	RandomRange                              = 0,
	LinearDifficulty                         = 1,
	EridFlowTask_MAX                         = 2,
};

// Enum DungeonArchitectRuntime.ERuleNodeExecutionMode
// NumValues: 0x0005
enum class ERuleNodeExecutionMode : uint8
{
	RunOnce                                  = 0,
	RunWithProbability                       = 1,
	Iterate                                  = 2,
	IterateRange                             = 3,
	ERuleNodeExecutionMode_MAX               = 4,
};

// Enum DungeonArchitectRuntime.EGridDungeonWallType
// NumValues: 0x0003
enum class EGridDungeonWallType : uint8
{
	WallsAsEdges                             = 0,
	WallsAsTileBlocks                        = 1,
	EGridDungeonWallType_MAX                 = 2,
};

// Enum DungeonArchitectRuntime.FCellType
// NumValues: 0x0005
enum class EFCellType : uint8
{
	Room                                     = 0,
	Corridor                                 = 1,
	CorridorPadding                          = 2,
	Unknown                                  = 3,
	FCellType_MAX                            = 4,
};

// Enum DungeonArchitectRuntime.DungeonModelBuildState
// NumValues: 0x0007
enum class EDungeonModelBuildState : uint8
{
	Initial                                  = 0,
	Separation                               = 1,
	Triangulation                            = 2,
	SpanningTree                             = 3,
	Corridors                                = 4,
	Complete                                 = 5,
	DungeonModelBuildState_MAX               = 6,
};

// Enum DungeonArchitectRuntime.EGridPaintToolCellType
// NumValues: 0x0003
enum class EGridPaintToolCellType : uint8
{
	Corridor                                 = 0,
	Room                                     = 1,
	EGridPaintToolCellType_MAX               = 2,
};

// Enum DungeonArchitectRuntime.EGridFlowTilemapWallGenerationMethod
// NumValues: 0x0003
enum class EGridFlowTilemapWallGenerationMethod : uint8
{
	WallAsTiles                              = 0,
	WallAsEdges                              = 1,
	EGridFlowTilemapWallGenerationMethod_MAX = 2,
};

// Enum DungeonArchitectRuntime.EGridFlowAbstractNodeRoomType
// NumValues: 0x0005
enum class EGridFlowAbstractNodeRoomType : uint8
{
	Unknown                                  = 0,
	Room                                     = 1,
	Corridor                                 = 2,
	Cave                                     = 3,
	EGridFlowAbstractNodeRoomType_MAX        = 4,
};

// Enum DungeonArchitectRuntime.EGridFlowTilemapCellOverlayMergeWallOverlayRule
// NumValues: 0x0004
enum class EGridFlowTilemapCellOverlayMergeWallOverlayRule : uint8
{
	KeepWallAndOverlay                       = 0,
	KeepWallRemoveOverlay                    = 1,
	KeepOverlayRemoveWall                    = 2,
	EGridFlowTilemapCellOverlayMergeWallOverlayRule_MAX = 3,
};

// Enum DungeonArchitectRuntime.EGridFlowTilemapCellCategory
// NumValues: 0x0004
enum class EGridFlowTilemapCellCategory : uint8
{
	Layout                                   = 0,
	Biome                                    = 1,
	Elevation                                = 2,
	EGridFlowTilemapCellCategory_MAX         = 3,
};

// Enum DungeonArchitectRuntime.EGridFlowTilemapEdgeType
// NumValues: 0x0005
enum class EGridFlowTilemapEdgeType : uint8
{
	Empty                                    = 0,
	Wall                                     = 1,
	Fence                                    = 2,
	Door                                     = 3,
	EGridFlowTilemapEdgeType_MAX             = 4,
};

// Enum DungeonArchitectRuntime.EGridFlowTilemapCellType
// NumValues: 0x0006
enum class EGridFlowTilemapCellType : uint8
{
	Empty                                    = 0,
	Floor                                    = 1,
	Wall                                     = 2,
	Door                                     = 3,
	Custom                                   = 4,
	EGridFlowTilemapCellType_MAX             = 5,
};

// Enum DungeonArchitectRuntime.EGridSpatialCellOccupation
// NumValues: 0x0004
enum class EGridSpatialCellOccupation : uint8
{
	DontCare                                 = 0,
	Occupied                                 = 1,
	Empty                                    = 2,
	EGridSpatialCellOccupation_MAX           = 3,
};

// Enum DungeonArchitectRuntime.EIsaacRoomTileType
// NumValues: 0x0004
enum class EIsaacRoomTileType : uint8
{
	Floor                                    = 0,
	Door                                     = 1,
	Empty                                    = 2,
	EIsaacRoomTileType_MAX                   = 3,
};

// Enum DungeonArchitectRuntime.EIsaacRoomType
// NumValues: 0x0006
enum class EIsaacRoomType : uint8
{
	Normal                                   = 0,
	Spawn                                    = 1,
	Treasure                                 = 2,
	Boss                                     = 4,
	Exit                                     = 8,
	EIsaacRoomType_MAX                       = 9,
};

// Enum DungeonArchitectRuntime.ESimpleCityCellType
// NumValues: 0x0006
enum class ESimpleCityCellType : uint8
{
	Road                                     = 0,
	House                                    = 1,
	Park                                     = 2,
	UserDefined                              = 3,
	Empty                                    = 4,
	ESimpleCityCellType_MAX                  = 5,
};

// Enum DungeonArchitectRuntime.ESimpleCitySpatialCellOccupation
// NumValues: 0x0006
enum class ESimpleCitySpatialCellOccupation : uint8
{
	Ignore                                   = 0,
	Road                                     = 1,
	House                                    = 2,
	Park                                     = 3,
	Outskirts                                = 4,
	ESimpleCitySpatialCellOccupation_MAX     = 5,
};

// Enum DungeonArchitectRuntime.ESnapConnectionConstraint
// NumValues: 0x0004
enum class ESnapConnectionConstraint : uint8
{
	Magnet                                   = 0,
	PlugMale                                 = 1,
	PlugFemale                               = 2,
	ESnapConnectionConstraint_MAX            = 3,
};

// Enum DungeonArchitectRuntime.ESnapConnectionDoorType
// NumValues: 0x0008
enum class ESnapConnectionDoorType : uint8
{
	NotApplicable                            = 0,
	NormalDoor                               = 1,
	OneWayDoor                               = 2,
	OneWayDoorUp                             = 3,
	OneWayDoorDown                           = 4,
	LockedDoor                               = 5,
	CustomDoor                               = 6,
	ESnapConnectionDoorType_MAX              = 7,
};

// Enum DungeonArchitectRuntime.ESnapConnectionState
// NumValues: 0x0004
enum class ESnapConnectionState : uint8
{
	Unknown                                  = 0,
	Door                                     = 1,
	Wall                                     = 2,
	ESnapConnectionState_MAX                 = 3,
};

// Enum DungeonArchitectRuntime.ESnapFlowAGTaskModuleCategoryOverrideMethod
// NumValues: 0x0004
enum class ESnapFlowAGTaskModuleCategoryOverrideMethod : uint8
{
	None                                     = 0,
	StartEnd                                 = 1,
	Blueprint                                = 2,
	ESnapFlowAGTaskModuleCategoryOverrideMethod_MAX = 3,
};

// ScriptStruct DungeonArchitectRuntime.DungeonMiniMapOverlayIcon
// 0x0030 (0x0030 - 0x0000)
struct FDungeonMiniMapOverlayIcon final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDungeonMiniMapIconCoordinateSystem           ScreenSizeType;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Tint;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonMiniMapOverlayIcon) == 0x000008, "Wrong alignment on FDungeonMiniMapOverlayIcon");
static_assert(sizeof(FDungeonMiniMapOverlayIcon) == 0x000030, "Wrong size on FDungeonMiniMapOverlayIcon");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, Name) == 0x000000, "Member 'FDungeonMiniMapOverlayIcon::Name' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, Icon) == 0x000008, "Member 'FDungeonMiniMapOverlayIcon::Icon' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, ScreenSize) == 0x000010, "Member 'FDungeonMiniMapOverlayIcon::ScreenSize' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, ScreenSizeType) == 0x000014, "Member 'FDungeonMiniMapOverlayIcon::ScreenSizeType' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, Tint) == 0x000018, "Member 'FDungeonMiniMapOverlayIcon::Tint' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayIcon, Rotation) == 0x000028, "Member 'FDungeonMiniMapOverlayIcon::Rotation' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapConnectionInstance
// 0x0090 (0x0090 - 0x0000)
struct FSnapConnectionInstance final
{
public:
	struct FGuid                                  ModuleA;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  DoorA;                                             // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ModuleB;                                           // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  DoorB;                                             // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldTransform;                                    // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedDoorActor;                              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          SpawnedDoorActors;                                 // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnapConnectionInstance) == 0x000010, "Wrong alignment on FSnapConnectionInstance");
static_assert(sizeof(FSnapConnectionInstance) == 0x000090, "Wrong size on FSnapConnectionInstance");
static_assert(offsetof(FSnapConnectionInstance, ModuleA) == 0x000000, "Member 'FSnapConnectionInstance::ModuleA' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, DoorA) == 0x000010, "Member 'FSnapConnectionInstance::DoorA' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, ModuleB) == 0x000020, "Member 'FSnapConnectionInstance::ModuleB' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, DoorB) == 0x000030, "Member 'FSnapConnectionInstance::DoorB' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, WorldTransform) == 0x000040, "Member 'FSnapConnectionInstance::WorldTransform' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, bHasSpawnedDoorActor) == 0x000070, "Member 'FSnapConnectionInstance::bHasSpawnedDoorActor' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, bReverse) == 0x000071, "Member 'FSnapConnectionInstance::bReverse' has a wrong offset!");
static_assert(offsetof(FSnapConnectionInstance, SpawnedDoorActors) == 0x000078, "Member 'FSnapConnectionInstance::SpawnedDoorActors' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.DungeonSchemaAction_NewNode
// 0x0008 (0x0108 - 0x0100)
struct FDungeonSchemaAction_NewNode final : public FEdGraphSchemaAction
{
public:
	class UEdGraphNode*                           NodeTemplate;                                      // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonSchemaAction_NewNode) == 0x000008, "Wrong alignment on FDungeonSchemaAction_NewNode");
static_assert(sizeof(FDungeonSchemaAction_NewNode) == 0x000108, "Wrong size on FDungeonSchemaAction_NewNode");
static_assert(offsetof(FDungeonSchemaAction_NewNode, NodeTemplate) == 0x000100, "Member 'FDungeonSchemaAction_NewNode::NodeTemplate' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.DungeonLevelStreamingConfig
// 0x0018 (0x0018 - 0x0000)
struct FDungeonLevelStreamingConfig final
{
public:
	bool                                          bEnabledLevelStreaming;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDungeonLevelStreamChunkSelection             InitialLoadLocation;                               // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDungeonLevelStreamingStrategy                StreamingStrategy;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VisibilityRoomDepth;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VisibilityDistance;                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDungeonLevelStreamLoadMethod                 LoadMethod;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDungeonLevelStreamUnloadMethod               UnloadMethod;                                      // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProcessStreamingNavigation;                       // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonLevelStreamingConfig) == 0x000004, "Wrong alignment on FDungeonLevelStreamingConfig");
static_assert(sizeof(FDungeonLevelStreamingConfig) == 0x000018, "Wrong size on FDungeonLevelStreamingConfig");
static_assert(offsetof(FDungeonLevelStreamingConfig, bEnabledLevelStreaming) == 0x000000, "Member 'FDungeonLevelStreamingConfig::bEnabledLevelStreaming' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, InitialLoadLocation) == 0x000001, "Member 'FDungeonLevelStreamingConfig::InitialLoadLocation' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, StreamingStrategy) == 0x000002, "Member 'FDungeonLevelStreamingConfig::StreamingStrategy' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, VisibilityRoomDepth) == 0x000004, "Member 'FDungeonLevelStreamingConfig::VisibilityRoomDepth' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, VisibilityDistance) == 0x000008, "Member 'FDungeonLevelStreamingConfig::VisibilityDistance' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, LoadMethod) == 0x000014, "Member 'FDungeonLevelStreamingConfig::LoadMethod' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, UnloadMethod) == 0x000015, "Member 'FDungeonLevelStreamingConfig::UnloadMethod' has a wrong offset!");
static_assert(offsetof(FDungeonLevelStreamingConfig, bProcessStreamingNavigation) == 0x000016, "Member 'FDungeonLevelStreamingConfig::bProcessStreamingNavigation' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.DungeonStreamingChunkParamRep
// 0x0098 (0x0098 - 0x0000)
struct FDungeonStreamingChunkParamRep final
{
public:
	class FString                                 LevelLongPackageName;                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogicLevelLongPackageName;                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InstanceId;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         OrderNum;                                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0060(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          Neighbors;                                         // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSpawnRoomChunk;                                   // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonStreamingChunkParamRep) == 0x000008, "Wrong alignment on FDungeonStreamingChunkParamRep");
static_assert(sizeof(FDungeonStreamingChunkParamRep) == 0x000098, "Wrong size on FDungeonStreamingChunkParamRep");
static_assert(offsetof(FDungeonStreamingChunkParamRep, LevelLongPackageName) == 0x000000, "Member 'FDungeonStreamingChunkParamRep::LevelLongPackageName' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, LogicLevelLongPackageName) == 0x000010, "Member 'FDungeonStreamingChunkParamRep::LogicLevelLongPackageName' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, InstanceId) == 0x000020, "Member 'FDungeonStreamingChunkParamRep::InstanceId' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, Location) == 0x000024, "Member 'FDungeonStreamingChunkParamRep::Location' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, Rotation) == 0x000030, "Member 'FDungeonStreamingChunkParamRep::Rotation' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, OrderNum) == 0x00003C, "Member 'FDungeonStreamingChunkParamRep::OrderNum' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, Category) == 0x000040, "Member 'FDungeonStreamingChunkParamRep::Category' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, ID) == 0x000050, "Member 'FDungeonStreamingChunkParamRep::ID' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, Bounds) == 0x000060, "Member 'FDungeonStreamingChunkParamRep::Bounds' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, Neighbors) == 0x000080, "Member 'FDungeonStreamingChunkParamRep::Neighbors' has a wrong offset!");
static_assert(offsetof(FDungeonStreamingChunkParamRep, bSpawnRoomChunk) == 0x000090, "Member 'FDungeonStreamingChunkParamRep::bSpawnRoomChunk' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.MarkerReplaceEntry
// 0x0020 (0x0020 - 0x0000)
struct FMarkerReplaceEntry final
{
public:
	class FString                                 MarkerName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplacementName;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerReplaceEntry) == 0x000008, "Wrong alignment on FMarkerReplaceEntry");
static_assert(sizeof(FMarkerReplaceEntry) == 0x000020, "Wrong size on FMarkerReplaceEntry");
static_assert(offsetof(FMarkerReplaceEntry, MarkerName) == 0x000000, "Member 'FMarkerReplaceEntry::MarkerName' has a wrong offset!");
static_assert(offsetof(FMarkerReplaceEntry, ReplacementName) == 0x000010, "Member 'FMarkerReplaceEntry::ReplacementName' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.MaterialOverride
// 0x0010 (0x0010 - 0x0000)
struct FMaterialOverride final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialOverride) == 0x000008, "Wrong alignment on FMaterialOverride");
static_assert(sizeof(FMaterialOverride) == 0x000010, "Wrong size on FMaterialOverride");
static_assert(offsetof(FMaterialOverride, Index) == 0x000000, "Member 'FMaterialOverride::Index' has a wrong offset!");
static_assert(offsetof(FMaterialOverride, Material) == 0x000008, "Member 'FMaterialOverride::Material' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.DungeonMiniMapOverlayTracking
// 0x001C (0x001C - 0x0000)
struct FDungeonMiniMapOverlayTracking final
{
public:
	TWeakObjectPtr<class AActor>                  TrackedActor;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientToRotation;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonMiniMapOverlayTracking) == 0x000004, "Wrong alignment on FDungeonMiniMapOverlayTracking");
static_assert(sizeof(FDungeonMiniMapOverlayTracking) == 0x00001C, "Wrong size on FDungeonMiniMapOverlayTracking");
static_assert(offsetof(FDungeonMiniMapOverlayTracking, TrackedActor) == 0x000000, "Member 'FDungeonMiniMapOverlayTracking::TrackedActor' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayTracking, ID) == 0x000008, "Member 'FDungeonMiniMapOverlayTracking::ID' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayTracking, IconName) == 0x000010, "Member 'FDungeonMiniMapOverlayTracking::IconName' has a wrong offset!");
static_assert(offsetof(FDungeonMiniMapOverlayTracking, bOrientToRotation) == 0x000018, "Member 'FDungeonMiniMapOverlayTracking::bOrientToRotation' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.DungeonMarkerInfo
// 0x0060 (0x0060 - 0x0000)
struct FDungeonMarkerInfo final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   NodeId;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDungeonSpawnLogic*>             SpawnLogics;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                TemplateObject;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonMarkerInfo) == 0x000010, "Wrong alignment on FDungeonMarkerInfo");
static_assert(sizeof(FDungeonMarkerInfo) == 0x000060, "Wrong size on FDungeonMarkerInfo");
static_assert(offsetof(FDungeonMarkerInfo, Transform) == 0x000000, "Member 'FDungeonMarkerInfo::Transform' has a wrong offset!");
static_assert(offsetof(FDungeonMarkerInfo, NodeId) == 0x000030, "Member 'FDungeonMarkerInfo::NodeId' has a wrong offset!");
static_assert(offsetof(FDungeonMarkerInfo, SpawnLogics) == 0x000038, "Member 'FDungeonMarkerInfo::SpawnLogics' has a wrong offset!");
static_assert(offsetof(FDungeonMarkerInfo, TemplateObject) == 0x000048, "Member 'FDungeonMarkerInfo::TemplateObject' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.PropChildSocketData
// 0x0040 (0x0040 - 0x0000)
struct FPropChildSocketData final
{
public:
	class FString                                 SocketType;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropChildSocketData) == 0x000010, "Wrong alignment on FPropChildSocketData");
static_assert(sizeof(FPropChildSocketData) == 0x000040, "Wrong size on FPropChildSocketData");
static_assert(offsetof(FPropChildSocketData, SocketType) == 0x000000, "Member 'FPropChildSocketData::SocketType' has a wrong offset!");
static_assert(offsetof(FPropChildSocketData, Offset) == 0x000010, "Member 'FPropChildSocketData::Offset' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.PropTypeData
// 0x00C0 (0x00C0 - 0x0000)
struct FPropTypeData final
{
public:
	class FName                                   NodeId;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                AssetObject;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttachToSocket;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSelectionLogic;                                // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogicOverridesAffinity;                           // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDungeonSelectorLogic*>          SelectionLogics;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTransformLogic;                                // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDungeonTransformLogic*>         TransformLogics;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSpawnLogic;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDungeonSpawnLogic*>             SpawnLogics;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ConsumeOnAttach;                                   // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0070(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseSpatialConstraint;                             // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonSpatialConstraint*              SpatialConstraint;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPropChildSocketData>           ChildSockets;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropTypeData) == 0x000010, "Wrong alignment on FPropTypeData");
static_assert(sizeof(FPropTypeData) == 0x0000C0, "Wrong size on FPropTypeData");
static_assert(offsetof(FPropTypeData, NodeId) == 0x000000, "Member 'FPropTypeData::NodeId' has a wrong offset!");
static_assert(offsetof(FPropTypeData, AssetObject) == 0x000008, "Member 'FPropTypeData::AssetObject' has a wrong offset!");
static_assert(offsetof(FPropTypeData, AttachToSocket) == 0x000010, "Member 'FPropTypeData::AttachToSocket' has a wrong offset!");
static_assert(offsetof(FPropTypeData, Probability) == 0x000020, "Member 'FPropTypeData::Probability' has a wrong offset!");
static_assert(offsetof(FPropTypeData, bUseSelectionLogic) == 0x000024, "Member 'FPropTypeData::bUseSelectionLogic' has a wrong offset!");
static_assert(offsetof(FPropTypeData, bLogicOverridesAffinity) == 0x000025, "Member 'FPropTypeData::bLogicOverridesAffinity' has a wrong offset!");
static_assert(offsetof(FPropTypeData, SelectionLogics) == 0x000028, "Member 'FPropTypeData::SelectionLogics' has a wrong offset!");
static_assert(offsetof(FPropTypeData, bUseTransformLogic) == 0x000038, "Member 'FPropTypeData::bUseTransformLogic' has a wrong offset!");
static_assert(offsetof(FPropTypeData, TransformLogics) == 0x000040, "Member 'FPropTypeData::TransformLogics' has a wrong offset!");
static_assert(offsetof(FPropTypeData, bUseSpawnLogic) == 0x000050, "Member 'FPropTypeData::bUseSpawnLogic' has a wrong offset!");
static_assert(offsetof(FPropTypeData, SpawnLogics) == 0x000058, "Member 'FPropTypeData::SpawnLogics' has a wrong offset!");
static_assert(offsetof(FPropTypeData, ConsumeOnAttach) == 0x000068, "Member 'FPropTypeData::ConsumeOnAttach' has a wrong offset!");
static_assert(offsetof(FPropTypeData, Offset) == 0x000070, "Member 'FPropTypeData::Offset' has a wrong offset!");
static_assert(offsetof(FPropTypeData, bUseSpatialConstraint) == 0x0000A0, "Member 'FPropTypeData::bUseSpatialConstraint' has a wrong offset!");
static_assert(offsetof(FPropTypeData, SpatialConstraint) == 0x0000A8, "Member 'FPropTypeData::SpatialConstraint' has a wrong offset!");
static_assert(offsetof(FPropTypeData, ChildSockets) == 0x0000B0, "Member 'FPropTypeData::ChildSockets' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.PropSocket
// 0x0080 (0x0080 - 0x0000)
struct FPropSocket final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SocketType;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClusterThemeOverride;                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsConsumed;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x1F];                                      // 0x0061(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPropSocket) == 0x000010, "Wrong alignment on FPropSocket");
static_assert(sizeof(FPropSocket) == 0x000080, "Wrong size on FPropSocket");
static_assert(offsetof(FPropSocket, ID) == 0x000000, "Member 'FPropSocket::ID' has a wrong offset!");
static_assert(offsetof(FPropSocket, SocketType) == 0x000008, "Member 'FPropSocket::SocketType' has a wrong offset!");
static_assert(offsetof(FPropSocket, ClusterThemeOverride) == 0x000018, "Member 'FPropSocket::ClusterThemeOverride' has a wrong offset!");
static_assert(offsetof(FPropSocket, Transform) == 0x000030, "Member 'FPropSocket::Transform' has a wrong offset!");
static_assert(offsetof(FPropSocket, IsConsumed) == 0x000060, "Member 'FPropSocket::IsConsumed' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.ClusterThemeInfo
// 0x0020 (0x0020 - 0x0000)
struct FClusterThemeInfo final
{
public:
	class FString                                 ClusterThemeName;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDungeonThemeAsset*>             Themes;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterThemeInfo) == 0x000008, "Wrong alignment on FClusterThemeInfo");
static_assert(sizeof(FClusterThemeInfo) == 0x000020, "Wrong size on FClusterThemeInfo");
static_assert(offsetof(FClusterThemeInfo, ClusterThemeName) == 0x000000, "Member 'FClusterThemeInfo::ClusterThemeName' has a wrong offset!");
static_assert(offsetof(FClusterThemeInfo, Themes) == 0x000010, "Member 'FClusterThemeInfo::Themes' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowItemCustomInfo
// 0x0038 (0x0038 - 0x0000)
struct FGridFlowItemCustomInfo final
{
public:
	class FString                                 PreviewText;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PreviewTextColor;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PreviewBackgroundColor;                            // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridFlowItemCustomInfo) == 0x000008, "Wrong alignment on FGridFlowItemCustomInfo");
static_assert(sizeof(FGridFlowItemCustomInfo) == 0x000038, "Wrong size on FGridFlowItemCustomInfo");
static_assert(offsetof(FGridFlowItemCustomInfo, PreviewText) == 0x000000, "Member 'FGridFlowItemCustomInfo::PreviewText' has a wrong offset!");
static_assert(offsetof(FGridFlowItemCustomInfo, PreviewTextColor) == 0x000010, "Member 'FGridFlowItemCustomInfo::PreviewTextColor' has a wrong offset!");
static_assert(offsetof(FGridFlowItemCustomInfo, PreviewBackgroundColor) == 0x000020, "Member 'FGridFlowItemCustomInfo::PreviewBackgroundColor' has a wrong offset!");
static_assert(offsetof(FGridFlowItemCustomInfo, FontScale) == 0x000030, "Member 'FGridFlowItemCustomInfo::FontScale' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.FlowAbstractNodeGroup
// 0x0020 (0x0020 - 0x0000)
struct FFlowAbstractNodeGroup final
{
public:
	struct FGuid                                  GroupId;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          GroupNodes;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlowAbstractNodeGroup) == 0x000008, "Wrong alignment on FFlowAbstractNodeGroup");
static_assert(sizeof(FFlowAbstractNodeGroup) == 0x000020, "Wrong size on FFlowAbstractNodeGroup");
static_assert(offsetof(FFlowAbstractNodeGroup, GroupId) == 0x000000, "Member 'FFlowAbstractNodeGroup::GroupId' has a wrong offset!");
static_assert(offsetof(FFlowAbstractNodeGroup, GroupNodes) == 0x000010, "Member 'FFlowAbstractNodeGroup::GroupNodes' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.RuleNodeExecutionModeConfig
// 0x0010 (0x0010 - 0x0000)
struct FRuleNodeExecutionModeConfig final
{
public:
	float                                         RunProbability;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCount;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCountMin;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCountMax;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuleNodeExecutionModeConfig) == 0x000004, "Wrong alignment on FRuleNodeExecutionModeConfig");
static_assert(sizeof(FRuleNodeExecutionModeConfig) == 0x000010, "Wrong size on FRuleNodeExecutionModeConfig");
static_assert(offsetof(FRuleNodeExecutionModeConfig, RunProbability) == 0x000000, "Member 'FRuleNodeExecutionModeConfig::RunProbability' has a wrong offset!");
static_assert(offsetof(FRuleNodeExecutionModeConfig, IterationCount) == 0x000004, "Member 'FRuleNodeExecutionModeConfig::IterationCount' has a wrong offset!");
static_assert(offsetof(FRuleNodeExecutionModeConfig, IterationCountMin) == 0x000008, "Member 'FRuleNodeExecutionModeConfig::IterationCountMin' has a wrong offset!");
static_assert(offsetof(FRuleNodeExecutionModeConfig, IterationCountMax) == 0x00000C, "Member 'FRuleNodeExecutionModeConfig::IterationCountMax' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.StairInfo
// 0x0040 (0x0040 - 0x0000)
struct FStairInfo final
{
public:
	int32                                         OwnerCell;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConnectedToCell;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             IPosition;                                         // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStairInfo) == 0x000010, "Wrong alignment on FStairInfo");
static_assert(sizeof(FStairInfo) == 0x000040, "Wrong size on FStairInfo");
static_assert(offsetof(FStairInfo, OwnerCell) == 0x000000, "Member 'FStairInfo::OwnerCell' has a wrong offset!");
static_assert(offsetof(FStairInfo, ConnectedToCell) == 0x000004, "Member 'FStairInfo::ConnectedToCell' has a wrong offset!");
static_assert(offsetof(FStairInfo, Position) == 0x000008, "Member 'FStairInfo::Position' has a wrong offset!");
static_assert(offsetof(FStairInfo, Rotation) == 0x000020, "Member 'FStairInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FStairInfo, IPosition) == 0x000030, "Member 'FStairInfo::IPosition' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridCellInfo
// 0x0008 (0x0008 - 0x0000)
struct FGridCellInfo final
{
public:
	int32                                         CellId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFCellType                                    CellType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContainsDoor;                                      // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridCellInfo) == 0x000004, "Wrong alignment on FGridCellInfo");
static_assert(sizeof(FGridCellInfo) == 0x000008, "Wrong size on FGridCellInfo");
static_assert(offsetof(FGridCellInfo, CellId) == 0x000000, "Member 'FGridCellInfo::CellId' has a wrong offset!");
static_assert(offsetof(FGridCellInfo, CellType) == 0x000004, "Member 'FGridCellInfo::CellType' has a wrong offset!");
static_assert(offsetof(FGridCellInfo, ContainsDoor) == 0x000005, "Member 'FGridCellInfo::ContainsDoor' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.CellDoor
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FCellDoor final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCellDoor) == 0x000004, "Wrong alignment on FCellDoor");
static_assert(sizeof(FCellDoor) == 0x000024, "Wrong size on FCellDoor");

// ScriptStruct DungeonArchitectRuntime.Rectangle
// 0x0018 (0x0018 - 0x0000)
struct FRectangle final
{
public:
	struct FIntVector                             Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Size;                                              // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRectangle) == 0x000004, "Wrong alignment on FRectangle");
static_assert(sizeof(FRectangle) == 0x000018, "Wrong size on FRectangle");
static_assert(offsetof(FRectangle, Location) == 0x000000, "Member 'FRectangle::Location' has a wrong offset!");
static_assert(offsetof(FRectangle, Size) == 0x00000C, "Member 'FRectangle::Size' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.Cell
// 0x0058 (0x0058 - 0x0000)
struct FCell final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRectangle                             Bounds;                                            // 0x0004(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EFCellType                                    CellType;                                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UserDefined;                                       // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClusterId;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ConnectedRooms;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FixedRoomConnections;                              // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AdjacentCells;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCell) == 0x000008, "Wrong alignment on FCell");
static_assert(sizeof(FCell) == 0x000058, "Wrong size on FCell");
static_assert(offsetof(FCell, ID) == 0x000000, "Member 'FCell::ID' has a wrong offset!");
static_assert(offsetof(FCell, Bounds) == 0x000004, "Member 'FCell::Bounds' has a wrong offset!");
static_assert(offsetof(FCell, CellType) == 0x00001C, "Member 'FCell::CellType' has a wrong offset!");
static_assert(offsetof(FCell, UserDefined) == 0x00001D, "Member 'FCell::UserDefined' has a wrong offset!");
static_assert(offsetof(FCell, ClusterId) == 0x000020, "Member 'FCell::ClusterId' has a wrong offset!");
static_assert(offsetof(FCell, ConnectedRooms) == 0x000028, "Member 'FCell::ConnectedRooms' has a wrong offset!");
static_assert(offsetof(FCell, FixedRoomConnections) == 0x000038, "Member 'FCell::FixedRoomConnections' has a wrong offset!");
static_assert(offsetof(FCell, AdjacentCells) == 0x000048, "Member 'FCell::AdjacentCells' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridToolRectStrokeData
// 0x001C (0x001C - 0x0000)
struct FGridToolRectStrokeData final
{
public:
	struct FRectangle                             Rectangle;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EGridPaintToolCellType                        CellType;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridToolRectStrokeData) == 0x000004, "Wrong alignment on FGridToolRectStrokeData");
static_assert(sizeof(FGridToolRectStrokeData) == 0x00001C, "Wrong size on FGridToolRectStrokeData");
static_assert(offsetof(FGridToolRectStrokeData, Rectangle) == 0x000000, "Member 'FGridToolRectStrokeData::Rectangle' has a wrong offset!");
static_assert(offsetof(FGridToolRectStrokeData, CellType) == 0x000018, "Member 'FGridToolRectStrokeData::CellType' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridToolPaintStrokeData
// 0x0010 (0x0010 - 0x0000)
struct FGridToolPaintStrokeData final
{
public:
	struct FIntVector                             Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridPaintToolCellType                        CellType;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridToolPaintStrokeData) == 0x000004, "Wrong alignment on FGridToolPaintStrokeData");
static_assert(sizeof(FGridToolPaintStrokeData) == 0x000010, "Wrong size on FGridToolPaintStrokeData");
static_assert(offsetof(FGridToolPaintStrokeData, Location) == 0x000000, "Member 'FGridToolPaintStrokeData::Location' has a wrong offset!");
static_assert(offsetof(FGridToolPaintStrokeData, CellType) == 0x00000C, "Member 'FGridToolPaintStrokeData::CellType' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowChunkQueryResult
// 0x0038 (0x0038 - 0x0000)
struct FGridFlowChunkQueryResult final
{
public:
	struct FIntPoint                              LayoutNodeCoord;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TilemapCoordStart;                                 // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TilemapCoordEnd;                                   // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TileCoords;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EGridFlowAbstractNodeRoomType                 RoomType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridFlowChunkQueryResult) == 0x000008, "Wrong alignment on FGridFlowChunkQueryResult");
static_assert(sizeof(FGridFlowChunkQueryResult) == 0x000038, "Wrong size on FGridFlowChunkQueryResult");
static_assert(offsetof(FGridFlowChunkQueryResult, LayoutNodeCoord) == 0x000000, "Member 'FGridFlowChunkQueryResult::LayoutNodeCoord' has a wrong offset!");
static_assert(offsetof(FGridFlowChunkQueryResult, TilemapCoordStart) == 0x000008, "Member 'FGridFlowChunkQueryResult::TilemapCoordStart' has a wrong offset!");
static_assert(offsetof(FGridFlowChunkQueryResult, TilemapCoordEnd) == 0x000014, "Member 'FGridFlowChunkQueryResult::TilemapCoordEnd' has a wrong offset!");
static_assert(offsetof(FGridFlowChunkQueryResult, TileCoords) == 0x000020, "Member 'FGridFlowChunkQueryResult::TileCoords' has a wrong offset!");
static_assert(offsetof(FGridFlowChunkQueryResult, RoomType) == 0x000030, "Member 'FGridFlowChunkQueryResult::RoomType' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowExecNodeTilemapOverlayNoiseSettings
// 0x001C (0x001C - 0x0000)
struct FGridFlowExecNodeTilemapOverlayNoiseSettings final
{
public:
	int32                                         NoiseOctaves;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseFrequency;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseValuePower;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseMinValue;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseMaxValue;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseThreshold;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinDistFromMainPath;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowExecNodeTilemapOverlayNoiseSettings) == 0x000004, "Wrong alignment on FGridFlowExecNodeTilemapOverlayNoiseSettings");
static_assert(sizeof(FGridFlowExecNodeTilemapOverlayNoiseSettings) == 0x00001C, "Wrong size on FGridFlowExecNodeTilemapOverlayNoiseSettings");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseOctaves) == 0x000000, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseOctaves' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseFrequency) == 0x000004, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseFrequency' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseValuePower) == 0x000008, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseValuePower' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseMinValue) == 0x00000C, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseMinValue' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseMaxValue) == 0x000010, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseMaxValue' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, NoiseThreshold) == 0x000014, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::NoiseThreshold' has a wrong offset!");
static_assert(offsetof(FGridFlowExecNodeTilemapOverlayNoiseSettings, MinDistFromMainPath) == 0x000018, "Member 'FGridFlowExecNodeTilemapOverlayNoiseSettings::MinDistFromMainPath' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowAbstractNodeTilemapMetadata
// 0x0020 (0x0020 - 0x0000)
struct FGridFlowAbstractNodeTilemapMetadata final
{
public:
	struct FIntPoint                              TileCoordStart;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TileCoordEnd;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIntPoint>                      Tiles;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowAbstractNodeTilemapMetadata) == 0x000008, "Wrong alignment on FGridFlowAbstractNodeTilemapMetadata");
static_assert(sizeof(FGridFlowAbstractNodeTilemapMetadata) == 0x000020, "Wrong size on FGridFlowAbstractNodeTilemapMetadata");
static_assert(offsetof(FGridFlowAbstractNodeTilemapMetadata, TileCoordStart) == 0x000000, "Member 'FGridFlowAbstractNodeTilemapMetadata::TileCoordStart' has a wrong offset!");
static_assert(offsetof(FGridFlowAbstractNodeTilemapMetadata, TileCoordEnd) == 0x000008, "Member 'FGridFlowAbstractNodeTilemapMetadata::TileCoordEnd' has a wrong offset!");
static_assert(offsetof(FGridFlowAbstractNodeTilemapMetadata, Tiles) == 0x000010, "Member 'FGridFlowAbstractNodeTilemapMetadata::Tiles' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCellWallInfo
// 0x0010 (0x0010 - 0x0000)
struct FGridFlowTilemapCellWallInfo final
{
public:
	TArray<struct FIntPoint>                      OwningTiles;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowTilemapCellWallInfo) == 0x000008, "Wrong alignment on FGridFlowTilemapCellWallInfo");
static_assert(sizeof(FGridFlowTilemapCellWallInfo) == 0x000010, "Wrong size on FGridFlowTilemapCellWallInfo");
static_assert(offsetof(FGridFlowTilemapCellWallInfo, OwningTiles) == 0x000000, "Member 'FGridFlowTilemapCellWallInfo::OwningTiles' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCellDoorInfo
// 0x0020 (0x0020 - 0x0000)
struct FGridFlowTilemapCellDoorInfo final
{
public:
	bool                                          bLocked;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOneWay;                                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             ChunkA;                                            // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ChunkB;                                            // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowTilemapCellDoorInfo) == 0x000004, "Wrong alignment on FGridFlowTilemapCellDoorInfo");
static_assert(sizeof(FGridFlowTilemapCellDoorInfo) == 0x000020, "Wrong size on FGridFlowTilemapCellDoorInfo");
static_assert(offsetof(FGridFlowTilemapCellDoorInfo, bLocked) == 0x000000, "Member 'FGridFlowTilemapCellDoorInfo::bLocked' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellDoorInfo, bOneWay) == 0x000001, "Member 'FGridFlowTilemapCellDoorInfo::bOneWay' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellDoorInfo, ChunkA) == 0x000004, "Member 'FGridFlowTilemapCellDoorInfo::ChunkA' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellDoorInfo, ChunkB) == 0x000010, "Member 'FGridFlowTilemapCellDoorInfo::ChunkB' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellDoorInfo, Angle) == 0x00001C, "Member 'FGridFlowTilemapCellDoorInfo::Angle' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCustomCellInfo
// 0x0020 (0x0020 - 0x0000)
struct FGridFlowTilemapCustomCellInfo final
{
public:
	class FString                                 MarkerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowTilemapCustomCellInfo) == 0x000008, "Wrong alignment on FGridFlowTilemapCustomCellInfo");
static_assert(sizeof(FGridFlowTilemapCustomCellInfo) == 0x000020, "Wrong size on FGridFlowTilemapCustomCellInfo");
static_assert(offsetof(FGridFlowTilemapCustomCellInfo, MarkerName) == 0x000000, "Member 'FGridFlowTilemapCustomCellInfo::MarkerName' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCustomCellInfo, DefaultColor) == 0x000010, "Member 'FGridFlowTilemapCustomCellInfo::DefaultColor' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCellOverlayMergeConfig
// 0x0018 (0x0018 - 0x0000)
struct FGridFlowTilemapCellOverlayMergeConfig final
{
public:
	float                                         MinHeight;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridFlowTilemapCellOverlayMergeWallOverlayRule WallOverlayRule;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarkerHeightOffsetForLayoutTiles;                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarkerHeightOffsetForNonLayoutTiles;               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveElevationMarker;                             // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridFlowTilemapCellOverlayMergeConfig) == 0x000004, "Wrong alignment on FGridFlowTilemapCellOverlayMergeConfig");
static_assert(sizeof(FGridFlowTilemapCellOverlayMergeConfig) == 0x000018, "Wrong size on FGridFlowTilemapCellOverlayMergeConfig");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, MinHeight) == 0x000000, "Member 'FGridFlowTilemapCellOverlayMergeConfig::MinHeight' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, MaxHeight) == 0x000004, "Member 'FGridFlowTilemapCellOverlayMergeConfig::MaxHeight' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, WallOverlayRule) == 0x000008, "Member 'FGridFlowTilemapCellOverlayMergeConfig::WallOverlayRule' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, MarkerHeightOffsetForLayoutTiles) == 0x00000C, "Member 'FGridFlowTilemapCellOverlayMergeConfig::MarkerHeightOffsetForLayoutTiles' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, MarkerHeightOffsetForNonLayoutTiles) == 0x000010, "Member 'FGridFlowTilemapCellOverlayMergeConfig::MarkerHeightOffsetForNonLayoutTiles' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlayMergeConfig, RemoveElevationMarker) == 0x000014, "Member 'FGridFlowTilemapCellOverlayMergeConfig::RemoveElevationMarker' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCellOverlay
// 0x0048 (0x0048 - 0x0000)
struct FGridFlowTilemapCellOverlay final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseValue;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTileBlockingOverlay;                              // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCellOverlayMergeConfig MergeConfig;                                       // 0x0030(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowTilemapCellOverlay) == 0x000008, "Wrong alignment on FGridFlowTilemapCellOverlay");
static_assert(sizeof(FGridFlowTilemapCellOverlay) == 0x000048, "Wrong size on FGridFlowTilemapCellOverlay");
static_assert(offsetof(FGridFlowTilemapCellOverlay, bEnabled) == 0x000000, "Member 'FGridFlowTilemapCellOverlay::bEnabled' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlay, MarkerName) == 0x000008, "Member 'FGridFlowTilemapCellOverlay::MarkerName' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlay, Color) == 0x000018, "Member 'FGridFlowTilemapCellOverlay::Color' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlay, NoiseValue) == 0x000028, "Member 'FGridFlowTilemapCellOverlay::NoiseValue' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlay, bTileBlockingOverlay) == 0x00002C, "Member 'FGridFlowTilemapCellOverlay::bTileBlockingOverlay' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCellOverlay, MergeConfig) == 0x000030, "Member 'FGridFlowTilemapCellOverlay::MergeConfig' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCell
// 0x00D8 (0x00D8 - 0x0000)
struct FGridFlowTilemapCell final
{
public:
	EGridFlowTilemapCellType                      CellType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCustomCellInfo         CustomCellInfo;                                    // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHasItem;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ItemId;                                            // 0x002C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Tags;                                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasOverlay;                                       // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCellOverlay            Overlay;                                           // 0x0058(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector                                ChunkCoord;                                        // 0x00A0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TileCoord;                                         // 0x00AC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomColor;                                   // 0x00B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CustomColor;                                       // 0x00B8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainPath;                                         // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLayoutCell;                                       // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnreachable;                                      // 0x00CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceFromMainPath;                              // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridFlowTilemapCell) == 0x000008, "Wrong alignment on FGridFlowTilemapCell");
static_assert(sizeof(FGridFlowTilemapCell) == 0x0000D8, "Wrong size on FGridFlowTilemapCell");
static_assert(offsetof(FGridFlowTilemapCell, CellType) == 0x000000, "Member 'FGridFlowTilemapCell::CellType' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, CustomCellInfo) == 0x000008, "Member 'FGridFlowTilemapCell::CustomCellInfo' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bHasItem) == 0x000028, "Member 'FGridFlowTilemapCell::bHasItem' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, ItemId) == 0x00002C, "Member 'FGridFlowTilemapCell::ItemId' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, Tags) == 0x000040, "Member 'FGridFlowTilemapCell::Tags' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bHasOverlay) == 0x000050, "Member 'FGridFlowTilemapCell::bHasOverlay' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, Overlay) == 0x000058, "Member 'FGridFlowTilemapCell::Overlay' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, ChunkCoord) == 0x0000A0, "Member 'FGridFlowTilemapCell::ChunkCoord' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, TileCoord) == 0x0000AC, "Member 'FGridFlowTilemapCell::TileCoord' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bUseCustomColor) == 0x0000B4, "Member 'FGridFlowTilemapCell::bUseCustomColor' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, CustomColor) == 0x0000B8, "Member 'FGridFlowTilemapCell::CustomColor' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bMainPath) == 0x0000C8, "Member 'FGridFlowTilemapCell::bMainPath' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bLayoutCell) == 0x0000C9, "Member 'FGridFlowTilemapCell::bLayoutCell' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, bUnreachable) == 0x0000CA, "Member 'FGridFlowTilemapCell::bUnreachable' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, DistanceFromMainPath) == 0x0000CC, "Member 'FGridFlowTilemapCell::DistanceFromMainPath' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCell, Height) == 0x0000D0, "Member 'FGridFlowTilemapCell::Height' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapCoord
// 0x000C (0x000C - 0x0000)
struct FGridFlowTilemapCoord final
{
public:
	struct FIntPoint                              Coord;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEdgeCoord;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHorizontalEdge;                                   // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridFlowTilemapCoord) == 0x000004, "Wrong alignment on FGridFlowTilemapCoord");
static_assert(sizeof(FGridFlowTilemapCoord) == 0x00000C, "Wrong size on FGridFlowTilemapCoord");
static_assert(offsetof(FGridFlowTilemapCoord, Coord) == 0x000000, "Member 'FGridFlowTilemapCoord::Coord' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCoord, bIsEdgeCoord) == 0x000008, "Member 'FGridFlowTilemapCoord::bIsEdgeCoord' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapCoord, bHorizontalEdge) == 0x000009, "Member 'FGridFlowTilemapCoord::bHorizontalEdge' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridFlowTilemapEdge
// 0x002C (0x002C - 0x0000)
struct FGridFlowTilemapEdge final
{
public:
	EGridFlowTilemapEdgeType                      EdgeType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ItemId;                                            // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightCoord;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarkerAngle;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasItem;                                          // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCoord                  EdgeCoord;                                         // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridFlowTilemapEdge) == 0x000004, "Wrong alignment on FGridFlowTilemapEdge");
static_assert(sizeof(FGridFlowTilemapEdge) == 0x00002C, "Wrong size on FGridFlowTilemapEdge");
static_assert(offsetof(FGridFlowTilemapEdge, EdgeType) == 0x000000, "Member 'FGridFlowTilemapEdge::EdgeType' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapEdge, ItemId) == 0x000004, "Member 'FGridFlowTilemapEdge::ItemId' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapEdge, HeightCoord) == 0x000014, "Member 'FGridFlowTilemapEdge::HeightCoord' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapEdge, MarkerAngle) == 0x000018, "Member 'FGridFlowTilemapEdge::MarkerAngle' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapEdge, bHasItem) == 0x00001C, "Member 'FGridFlowTilemapEdge::bHasItem' has a wrong offset!");
static_assert(offsetof(FGridFlowTilemapEdge, EdgeCoord) == 0x000020, "Member 'FGridFlowTilemapEdge::EdgeCoord' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridSpatialConstraintCellData
// 0x0001 (0x0001 - 0x0000)
struct FGridSpatialConstraintCellData final
{
public:
	EGridSpatialCellOccupation                    OccupationConstraint;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridSpatialConstraintCellData) == 0x000001, "Wrong alignment on FGridSpatialConstraintCellData");
static_assert(sizeof(FGridSpatialConstraintCellData) == 0x000001, "Wrong size on FGridSpatialConstraintCellData");
static_assert(offsetof(FGridSpatialConstraintCellData, OccupationConstraint) == 0x000000, "Member 'FGridSpatialConstraintCellData::OccupationConstraint' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridSpatialConstraint2x2Data
// 0x0010 (0x0010 - 0x0000)
struct FGridSpatialConstraint2x2Data final
{
public:
	TArray<struct FGridSpatialConstraintCellData> Cells;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridSpatialConstraint2x2Data) == 0x000008, "Wrong alignment on FGridSpatialConstraint2x2Data");
static_assert(sizeof(FGridSpatialConstraint2x2Data) == 0x000010, "Wrong size on FGridSpatialConstraint2x2Data");
static_assert(offsetof(FGridSpatialConstraint2x2Data, Cells) == 0x000000, "Member 'FGridSpatialConstraint2x2Data::Cells' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridSpatialConstraint3x3Data
// 0x0010 (0x0010 - 0x0000)
struct FGridSpatialConstraint3x3Data final
{
public:
	TArray<struct FGridSpatialConstraintCellData> Cells;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridSpatialConstraint3x3Data) == 0x000008, "Wrong alignment on FGridSpatialConstraint3x3Data");
static_assert(sizeof(FGridSpatialConstraint3x3Data) == 0x000010, "Wrong size on FGridSpatialConstraint3x3Data");
static_assert(offsetof(FGridSpatialConstraint3x3Data, Cells) == 0x000000, "Member 'FGridSpatialConstraint3x3Data::Cells' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.GridSpatialConstraintEdgeData
// 0x0010 (0x0010 - 0x0000)
struct FGridSpatialConstraintEdgeData final
{
public:
	TArray<struct FGridSpatialConstraintCellData> Cells;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridSpatialConstraintEdgeData) == 0x000008, "Wrong alignment on FGridSpatialConstraintEdgeData");
static_assert(sizeof(FGridSpatialConstraintEdgeData) == 0x000010, "Wrong size on FGridSpatialConstraintEdgeData");
static_assert(offsetof(FGridSpatialConstraintEdgeData, Cells) == 0x000000, "Member 'FGridSpatialConstraintEdgeData::Cells' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.IsaacDoor
// 0x000C (0x000C - 0x0000)
struct FIsaacDoor final
{
public:
	int32                                         RoomA;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomB;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIsaacDoor) == 0x000004, "Wrong alignment on FIsaacDoor");
static_assert(sizeof(FIsaacDoor) == 0x00000C, "Wrong size on FIsaacDoor");
static_assert(offsetof(FIsaacDoor, RoomA) == 0x000000, "Member 'FIsaacDoor::RoomA' has a wrong offset!");
static_assert(offsetof(FIsaacDoor, RoomB) == 0x000004, "Member 'FIsaacDoor::RoomB' has a wrong offset!");
static_assert(offsetof(FIsaacDoor, Ratio) == 0x000008, "Member 'FIsaacDoor::Ratio' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.IsaacRoomTile
// 0x0001 (0x0001 - 0x0000)
struct FIsaacRoomTile final
{
public:
	EIsaacRoomTileType                            TileType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIsaacRoomTile) == 0x000001, "Wrong alignment on FIsaacRoomTile");
static_assert(sizeof(FIsaacRoomTile) == 0x000001, "Wrong size on FIsaacRoomTile");
static_assert(offsetof(FIsaacRoomTile, TileType) == 0x000000, "Member 'FIsaacRoomTile::TileType' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.IsaacRoomLayout
// 0x0018 (0x0018 - 0x0000)
struct FIsaacRoomLayout final
{
public:
	TArray<struct FIsaacRoomTile>                 Tiles;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIsaacRoomLayout) == 0x000008, "Wrong alignment on FIsaacRoomLayout");
static_assert(sizeof(FIsaacRoomLayout) == 0x000018, "Wrong size on FIsaacRoomLayout");
static_assert(offsetof(FIsaacRoomLayout, Tiles) == 0x000000, "Member 'FIsaacRoomLayout::Tiles' has a wrong offset!");
static_assert(offsetof(FIsaacRoomLayout, Width) == 0x000010, "Member 'FIsaacRoomLayout::Width' has a wrong offset!");
static_assert(offsetof(FIsaacRoomLayout, Height) == 0x000014, "Member 'FIsaacRoomLayout::Height' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.IsaacRoom
// 0x0050 (0x0050 - 0x0000)
struct FIsaacRoom final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsaacRoomType                                RoomType;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIsaacRoomLayout                       Layout;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 AdjacentRooms;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FIntVector>                     DoorPositions;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIsaacRoom) == 0x000008, "Wrong alignment on FIsaacRoom");
static_assert(sizeof(FIsaacRoom) == 0x000050, "Wrong size on FIsaacRoom");
static_assert(offsetof(FIsaacRoom, ID) == 0x000000, "Member 'FIsaacRoom::ID' has a wrong offset!");
static_assert(offsetof(FIsaacRoom, Location) == 0x000004, "Member 'FIsaacRoom::Location' has a wrong offset!");
static_assert(offsetof(FIsaacRoom, RoomType) == 0x000010, "Member 'FIsaacRoom::RoomType' has a wrong offset!");
static_assert(offsetof(FIsaacRoom, Layout) == 0x000018, "Member 'FIsaacRoom::Layout' has a wrong offset!");
static_assert(offsetof(FIsaacRoom, AdjacentRooms) == 0x000030, "Member 'FIsaacRoom::AdjacentRooms' has a wrong offset!");
static_assert(offsetof(FIsaacRoom, DoorPositions) == 0x000040, "Member 'FIsaacRoom::DoorPositions' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.PlaceableMarkerAssetSpriteSettings
// 0x0008 (0x0008 - 0x0000)
struct FPlaceableMarkerAssetSpriteSettings final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlaceableMarkerAssetSpriteSettings) == 0x000004, "Wrong alignment on FPlaceableMarkerAssetSpriteSettings");
static_assert(sizeof(FPlaceableMarkerAssetSpriteSettings) == 0x000008, "Wrong size on FPlaceableMarkerAssetSpriteSettings");
static_assert(offsetof(FPlaceableMarkerAssetSpriteSettings, Scale) == 0x000000, "Member 'FPlaceableMarkerAssetSpriteSettings::Scale' has a wrong offset!");
static_assert(offsetof(FPlaceableMarkerAssetSpriteSettings, OffsetZ) == 0x000004, "Member 'FPlaceableMarkerAssetSpriteSettings::OffsetZ' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.CityBlockDimension
// 0x0020 (0x0020 - 0x0000)
struct FCityBlockDimension final
{
public:
	class FString                                 MarkerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeX;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCityBlockDimension) == 0x000008, "Wrong alignment on FCityBlockDimension");
static_assert(sizeof(FCityBlockDimension) == 0x000020, "Wrong size on FCityBlockDimension");
static_assert(offsetof(FCityBlockDimension, MarkerName) == 0x000000, "Member 'FCityBlockDimension::MarkerName' has a wrong offset!");
static_assert(offsetof(FCityBlockDimension, SizeX) == 0x000010, "Member 'FCityBlockDimension::SizeX' has a wrong offset!");
static_assert(offsetof(FCityBlockDimension, SizeY) == 0x000014, "Member 'FCityBlockDimension::SizeY' has a wrong offset!");
static_assert(offsetof(FCityBlockDimension, Probability) == 0x000018, "Member 'FCityBlockDimension::Probability' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SimpleCityCell
// 0x0040 (0x0040 - 0x0000)
struct FSimpleCityCell final
{
public:
	struct FIntVector                             Position;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimpleCityCellType                           CellType;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             BlockSize;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MarkerNameOverride;                                // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleCityCell) == 0x000010, "Wrong alignment on FSimpleCityCell");
static_assert(sizeof(FSimpleCityCell) == 0x000040, "Wrong size on FSimpleCityCell");
static_assert(offsetof(FSimpleCityCell, Position) == 0x000000, "Member 'FSimpleCityCell::Position' has a wrong offset!");
static_assert(offsetof(FSimpleCityCell, CellType) == 0x00000C, "Member 'FSimpleCityCell::CellType' has a wrong offset!");
static_assert(offsetof(FSimpleCityCell, Rotation) == 0x000010, "Member 'FSimpleCityCell::Rotation' has a wrong offset!");
static_assert(offsetof(FSimpleCityCell, BlockSize) == 0x000020, "Member 'FSimpleCityCell::BlockSize' has a wrong offset!");
static_assert(offsetof(FSimpleCityCell, MarkerNameOverride) == 0x000030, "Member 'FSimpleCityCell::MarkerNameOverride' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SimpleCitySpatialConstraintCellData
// 0x0001 (0x0001 - 0x0000)
struct FSimpleCitySpatialConstraintCellData final
{
public:
	ESimpleCitySpatialCellOccupation              OccupationConstraint;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleCitySpatialConstraintCellData) == 0x000001, "Wrong alignment on FSimpleCitySpatialConstraintCellData");
static_assert(sizeof(FSimpleCitySpatialConstraintCellData) == 0x000001, "Wrong size on FSimpleCitySpatialConstraintCellData");
static_assert(offsetof(FSimpleCitySpatialConstraintCellData, OccupationConstraint) == 0x000000, "Member 'FSimpleCitySpatialConstraintCellData::OccupationConstraint' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SimpleCitySpatialConstraint3x3Data
// 0x0010 (0x0010 - 0x0000)
struct FSimpleCitySpatialConstraint3x3Data final
{
public:
	TArray<struct FSimpleCitySpatialConstraintCellData> Cells;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleCitySpatialConstraint3x3Data) == 0x000008, "Wrong alignment on FSimpleCitySpatialConstraint3x3Data");
static_assert(sizeof(FSimpleCitySpatialConstraint3x3Data) == 0x000010, "Wrong size on FSimpleCitySpatialConstraint3x3Data");
static_assert(offsetof(FSimpleCitySpatialConstraint3x3Data, Cells) == 0x000000, "Member 'FSimpleCitySpatialConstraint3x3Data::Cells' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapChunkActorDataEntry
// 0x0060 (0x0060 - 0x0000)
struct FSnapChunkActorDataEntry final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ActorName;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ActorData;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapChunkActorDataEntry) == 0x000010, "Wrong alignment on FSnapChunkActorDataEntry");
static_assert(sizeof(FSnapChunkActorDataEntry) == 0x000060, "Wrong size on FSnapChunkActorDataEntry");
static_assert(offsetof(FSnapChunkActorDataEntry, ActorClass) == 0x000000, "Member 'FSnapChunkActorDataEntry::ActorClass' has a wrong offset!");
static_assert(offsetof(FSnapChunkActorDataEntry, ActorTransform) == 0x000010, "Member 'FSnapChunkActorDataEntry::ActorTransform' has a wrong offset!");
static_assert(offsetof(FSnapChunkActorDataEntry, ActorName) == 0x000040, "Member 'FSnapChunkActorDataEntry::ActorName' has a wrong offset!");
static_assert(offsetof(FSnapChunkActorDataEntry, ActorData) == 0x000050, "Member 'FSnapChunkActorDataEntry::ActorData' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapConnectionVisualMeshInfo_DEPRECATED
// 0x0040 (0x0040 - 0x0000)
struct FSnapConnectionVisualMeshInfo_DEPRECATED final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapConnectionVisualMeshInfo_DEPRECATED) == 0x000010, "Wrong alignment on FSnapConnectionVisualMeshInfo_DEPRECATED");
static_assert(sizeof(FSnapConnectionVisualMeshInfo_DEPRECATED) == 0x000040, "Wrong size on FSnapConnectionVisualMeshInfo_DEPRECATED");
static_assert(offsetof(FSnapConnectionVisualMeshInfo_DEPRECATED, StaticMesh) == 0x000000, "Member 'FSnapConnectionVisualMeshInfo_DEPRECATED::StaticMesh' has a wrong offset!");
static_assert(offsetof(FSnapConnectionVisualMeshInfo_DEPRECATED, MaterialOverride) == 0x000008, "Member 'FSnapConnectionVisualMeshInfo_DEPRECATED::MaterialOverride' has a wrong offset!");
static_assert(offsetof(FSnapConnectionVisualMeshInfo_DEPRECATED, Offset) == 0x000010, "Member 'FSnapConnectionVisualMeshInfo_DEPRECATED::Offset' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapConnectionVisualBlueprintInfo_DEPRECATED
// 0x0040 (0x0040 - 0x0000)
struct FSnapConnectionVisualBlueprintInfo_DEPRECATED final
{
public:
	TSubclassOf<class AActor>                     BlueprintClass;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapConnectionVisualBlueprintInfo_DEPRECATED) == 0x000010, "Wrong alignment on FSnapConnectionVisualBlueprintInfo_DEPRECATED");
static_assert(sizeof(FSnapConnectionVisualBlueprintInfo_DEPRECATED) == 0x000040, "Wrong size on FSnapConnectionVisualBlueprintInfo_DEPRECATED");
static_assert(offsetof(FSnapConnectionVisualBlueprintInfo_DEPRECATED, BlueprintClass) == 0x000000, "Member 'FSnapConnectionVisualBlueprintInfo_DEPRECATED::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FSnapConnectionVisualBlueprintInfo_DEPRECATED, Offset) == 0x000010, "Member 'FSnapConnectionVisualBlueprintInfo_DEPRECATED::Offset' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapConnectionVisualInfo_DEPRECATED
// 0x0090 (0x0090 - 0x0000)
struct FSnapConnectionVisualInfo_DEPRECATED final
{
public:
	bool                                          bStaticMesh;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSnapConnectionVisualMeshInfo_DEPRECATED MeshInfo;                                          // 0x0010(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSnapConnectionVisualBlueprintInfo_DEPRECATED BlueprintInfo;                                     // 0x0050(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapConnectionVisualInfo_DEPRECATED) == 0x000010, "Wrong alignment on FSnapConnectionVisualInfo_DEPRECATED");
static_assert(sizeof(FSnapConnectionVisualInfo_DEPRECATED) == 0x000090, "Wrong size on FSnapConnectionVisualInfo_DEPRECATED");
static_assert(offsetof(FSnapConnectionVisualInfo_DEPRECATED, bStaticMesh) == 0x000000, "Member 'FSnapConnectionVisualInfo_DEPRECATED::bStaticMesh' has a wrong offset!");
static_assert(offsetof(FSnapConnectionVisualInfo_DEPRECATED, MeshInfo) == 0x000010, "Member 'FSnapConnectionVisualInfo_DEPRECATED::MeshInfo' has a wrong offset!");
static_assert(offsetof(FSnapConnectionVisualInfo_DEPRECATED, BlueprintInfo) == 0x000050, "Member 'FSnapConnectionVisualInfo_DEPRECATED::BlueprintInfo' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapFlowAGNodeGroupSetting
// 0x0010 (0x0010 - 0x0000)
struct FSnapFlowAGNodeGroupSetting final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GroupSize;                                         // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapFlowAGNodeGroupSetting) == 0x000004, "Wrong alignment on FSnapFlowAGNodeGroupSetting");
static_assert(sizeof(FSnapFlowAGNodeGroupSetting) == 0x000010, "Wrong size on FSnapFlowAGNodeGroupSetting");
static_assert(offsetof(FSnapFlowAGNodeGroupSetting, Weight) == 0x000000, "Member 'FSnapFlowAGNodeGroupSetting::Weight' has a wrong offset!");
static_assert(offsetof(FSnapFlowAGNodeGroupSetting, GroupSize) == 0x000004, "Member 'FSnapFlowAGNodeGroupSetting::GroupSize' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapGridFlowModuleInstanceSerializedData
// 0x0090 (0x0090 - 0x0000)
struct FSnapGridFlowModuleInstanceSerializedData final
{
public:
	struct FGuid                                  ModuleInstanceId;                                  // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0040(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Category;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ModuleBounds;                                      // 0x0070(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnapGridFlowModuleInstanceSerializedData) == 0x000010, "Wrong alignment on FSnapGridFlowModuleInstanceSerializedData");
static_assert(sizeof(FSnapGridFlowModuleInstanceSerializedData) == 0x000090, "Wrong size on FSnapGridFlowModuleInstanceSerializedData");
static_assert(offsetof(FSnapGridFlowModuleInstanceSerializedData, ModuleInstanceId) == 0x000000, "Member 'FSnapGridFlowModuleInstanceSerializedData::ModuleInstanceId' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleInstanceSerializedData, WorldTransform) == 0x000010, "Member 'FSnapGridFlowModuleInstanceSerializedData::WorldTransform' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleInstanceSerializedData, Level) == 0x000040, "Member 'FSnapGridFlowModuleInstanceSerializedData::Level' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleInstanceSerializedData, Category) == 0x000068, "Member 'FSnapGridFlowModuleInstanceSerializedData::Category' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleInstanceSerializedData, ModuleBounds) == 0x000070, "Member 'FSnapGridFlowModuleInstanceSerializedData::ModuleBounds' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapGridFlowModuleDatabaseConnectionInfo
// 0x0050 (0x0050 - 0x0000)
struct FSnapGridFlowModuleDatabaseConnectionInfo final
{
public:
	struct FGuid                                  ConnectionId;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USnapConnectionInfo*                    ConnectionInfo;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapConnectionConstraint                     ConnectionConstraint;                              // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnapGridFlowModuleDatabaseConnectionInfo) == 0x000010, "Wrong alignment on FSnapGridFlowModuleDatabaseConnectionInfo");
static_assert(sizeof(FSnapGridFlowModuleDatabaseConnectionInfo) == 0x000050, "Wrong size on FSnapGridFlowModuleDatabaseConnectionInfo");
static_assert(offsetof(FSnapGridFlowModuleDatabaseConnectionInfo, ConnectionId) == 0x000000, "Member 'FSnapGridFlowModuleDatabaseConnectionInfo::ConnectionId' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseConnectionInfo, Transform) == 0x000010, "Member 'FSnapGridFlowModuleDatabaseConnectionInfo::Transform' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseConnectionInfo, ConnectionInfo) == 0x000040, "Member 'FSnapGridFlowModuleDatabaseConnectionInfo::ConnectionInfo' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseConnectionInfo, ConnectionConstraint) == 0x000048, "Member 'FSnapGridFlowModuleDatabaseConnectionInfo::ConnectionConstraint' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SGFModuleAssemblySideCell
// 0x0034 (0x0034 - 0x0000)
struct FSGFModuleAssemblySideCell final
{
public:
	int32                                         ConnectionIdx;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  NodeId;                                            // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LinkedNodeId;                                      // 0x0014(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  LinkID;                                            // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSGFModuleAssemblySideCell) == 0x000004, "Wrong alignment on FSGFModuleAssemblySideCell");
static_assert(sizeof(FSGFModuleAssemblySideCell) == 0x000034, "Wrong size on FSGFModuleAssemblySideCell");
static_assert(offsetof(FSGFModuleAssemblySideCell, ConnectionIdx) == 0x000000, "Member 'FSGFModuleAssemblySideCell::ConnectionIdx' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssemblySideCell, NodeId) == 0x000004, "Member 'FSGFModuleAssemblySideCell::NodeId' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssemblySideCell, LinkedNodeId) == 0x000014, "Member 'FSGFModuleAssemblySideCell::LinkedNodeId' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssemblySideCell, LinkID) == 0x000024, "Member 'FSGFModuleAssemblySideCell::LinkID' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SGFModuleAssemblySide
// 0x0018 (0x0018 - 0x0000)
struct FSGFModuleAssemblySide final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSGFModuleAssemblySideCell>     ConnectionIndices;                                 // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSGFModuleAssemblySide) == 0x000008, "Wrong alignment on FSGFModuleAssemblySide");
static_assert(sizeof(FSGFModuleAssemblySide) == 0x000018, "Wrong size on FSGFModuleAssemblySide");
static_assert(offsetof(FSGFModuleAssemblySide, Width) == 0x000000, "Member 'FSGFModuleAssemblySide::Width' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssemblySide, Height) == 0x000004, "Member 'FSGFModuleAssemblySide::Height' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssemblySide, ConnectionIndices) == 0x000008, "Member 'FSGFModuleAssemblySide::ConnectionIndices' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SGFModuleAssembly
// 0x00A0 (0x00A0 - 0x0000)
struct FSGFModuleAssembly final
{
public:
	struct FIntVector                             NumChunks;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSGFModuleAssemblySide                 Front;                                             // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	struct FSGFModuleAssemblySide                 Left;                                              // 0x0028(0x0018)(NativeAccessSpecifierPublic)
	struct FSGFModuleAssemblySide                 Back;                                              // 0x0040(0x0018)(NativeAccessSpecifierPublic)
	struct FSGFModuleAssemblySide                 Right;                                             // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	struct FSGFModuleAssemblySide                 Top;                                               // 0x0070(0x0018)(NativeAccessSpecifierPublic)
	struct FSGFModuleAssemblySide                 Down;                                              // 0x0088(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSGFModuleAssembly) == 0x000008, "Wrong alignment on FSGFModuleAssembly");
static_assert(sizeof(FSGFModuleAssembly) == 0x0000A0, "Wrong size on FSGFModuleAssembly");
static_assert(offsetof(FSGFModuleAssembly, NumChunks) == 0x000000, "Member 'FSGFModuleAssembly::NumChunks' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Front) == 0x000010, "Member 'FSGFModuleAssembly::Front' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Left) == 0x000028, "Member 'FSGFModuleAssembly::Left' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Back) == 0x000040, "Member 'FSGFModuleAssembly::Back' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Right) == 0x000058, "Member 'FSGFModuleAssembly::Right' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Top) == 0x000070, "Member 'FSGFModuleAssembly::Top' has a wrong offset!");
static_assert(offsetof(FSGFModuleAssembly, Down) == 0x000088, "Member 'FSGFModuleAssembly::Down' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapGridFlowModuleDatabaseItem
// 0x00F8 (0x00F8 - 0x0000)
struct FSnapGridFlowModuleDatabaseItem final
{
public:
	TSoftObjectPtr<class UWorld>                  LogicLevel;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Category;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRotation;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectionWeight;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ModuleBounds;                                      // 0x0060(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             NumChunks;                                         // 0x007C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSnapGridFlowModuleDatabaseConnectionInfo> Connections;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UPlaceableMarkerAsset>, int32> AvailableMarkers;                                  // 0x0098(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSGFModuleAssembly>             RotatedAssemblies;                                 // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapGridFlowModuleDatabaseItem) == 0x000008, "Wrong alignment on FSnapGridFlowModuleDatabaseItem");
static_assert(sizeof(FSnapGridFlowModuleDatabaseItem) == 0x0000F8, "Wrong size on FSnapGridFlowModuleDatabaseItem");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, LogicLevel) == 0x000000, "Member 'FSnapGridFlowModuleDatabaseItem::LogicLevel' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, Level) == 0x000028, "Member 'FSnapGridFlowModuleDatabaseItem::Level' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, Category) == 0x000050, "Member 'FSnapGridFlowModuleDatabaseItem::Category' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, bAllowRotation) == 0x000058, "Member 'FSnapGridFlowModuleDatabaseItem::bAllowRotation' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, SelectionWeight) == 0x00005C, "Member 'FSnapGridFlowModuleDatabaseItem::SelectionWeight' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, ModuleBounds) == 0x000060, "Member 'FSnapGridFlowModuleDatabaseItem::ModuleBounds' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, NumChunks) == 0x00007C, "Member 'FSnapGridFlowModuleDatabaseItem::NumChunks' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, Connections) == 0x000088, "Member 'FSnapGridFlowModuleDatabaseItem::Connections' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, AvailableMarkers) == 0x000098, "Member 'FSnapGridFlowModuleDatabaseItem::AvailableMarkers' has a wrong offset!");
static_assert(offsetof(FSnapGridFlowModuleDatabaseItem, RotatedAssemblies) == 0x0000E8, "Member 'FSnapGridFlowModuleDatabaseItem::RotatedAssemblies' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapMapModuleInstanceSerializedData
// 0x0090 (0x0090 - 0x0000)
struct FSnapMapModuleInstanceSerializedData final
{
public:
	struct FGuid                                  ModuleInstanceId;                                  // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0040(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Category;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ModuleBounds;                                      // 0x0070(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnapMapModuleInstanceSerializedData) == 0x000010, "Wrong alignment on FSnapMapModuleInstanceSerializedData");
static_assert(sizeof(FSnapMapModuleInstanceSerializedData) == 0x000090, "Wrong size on FSnapMapModuleInstanceSerializedData");
static_assert(offsetof(FSnapMapModuleInstanceSerializedData, ModuleInstanceId) == 0x000000, "Member 'FSnapMapModuleInstanceSerializedData::ModuleInstanceId' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleInstanceSerializedData, WorldTransform) == 0x000010, "Member 'FSnapMapModuleInstanceSerializedData::WorldTransform' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleInstanceSerializedData, Level) == 0x000040, "Member 'FSnapMapModuleInstanceSerializedData::Level' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleInstanceSerializedData, Category) == 0x000068, "Member 'FSnapMapModuleInstanceSerializedData::Category' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleInstanceSerializedData, ModuleBounds) == 0x000070, "Member 'FSnapMapModuleInstanceSerializedData::ModuleBounds' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapMapModuleDatabaseConnectionInfo
// 0x0050 (0x0050 - 0x0000)
struct FSnapMapModuleDatabaseConnectionInfo final
{
public:
	struct FGuid                                  ConnectionId;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USnapConnectionInfo*                    ConnectionInfo;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapConnectionConstraint                     ConnectionConstraint;                              // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnapMapModuleDatabaseConnectionInfo) == 0x000010, "Wrong alignment on FSnapMapModuleDatabaseConnectionInfo");
static_assert(sizeof(FSnapMapModuleDatabaseConnectionInfo) == 0x000050, "Wrong size on FSnapMapModuleDatabaseConnectionInfo");
static_assert(offsetof(FSnapMapModuleDatabaseConnectionInfo, ConnectionId) == 0x000000, "Member 'FSnapMapModuleDatabaseConnectionInfo::ConnectionId' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseConnectionInfo, Transform) == 0x000010, "Member 'FSnapMapModuleDatabaseConnectionInfo::Transform' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseConnectionInfo, ConnectionInfo) == 0x000040, "Member 'FSnapMapModuleDatabaseConnectionInfo::ConnectionInfo' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseConnectionInfo, ConnectionConstraint) == 0x000048, "Member 'FSnapMapModuleDatabaseConnectionInfo::ConnectionConstraint' has a wrong offset!");

// ScriptStruct DungeonArchitectRuntime.SnapMapModuleDatabaseItem
// 0x0088 (0x0088 - 0x0000)
struct FSnapMapModuleDatabaseItem final
{
public:
	TSoftObjectPtr<class UWorld>                  LogicLevel;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Category;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ModuleBounds;                                      // 0x0058(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSnapMapModuleDatabaseConnectionInfo> Connections;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnapMapModuleDatabaseItem) == 0x000008, "Wrong alignment on FSnapMapModuleDatabaseItem");
static_assert(sizeof(FSnapMapModuleDatabaseItem) == 0x000088, "Wrong size on FSnapMapModuleDatabaseItem");
static_assert(offsetof(FSnapMapModuleDatabaseItem, LogicLevel) == 0x000000, "Member 'FSnapMapModuleDatabaseItem::LogicLevel' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseItem, Level) == 0x000028, "Member 'FSnapMapModuleDatabaseItem::Level' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseItem, Category) == 0x000050, "Member 'FSnapMapModuleDatabaseItem::Category' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseItem, ModuleBounds) == 0x000058, "Member 'FSnapMapModuleDatabaseItem::ModuleBounds' has a wrong offset!");
static_assert(offsetof(FSnapMapModuleDatabaseItem, Connections) == 0x000078, "Member 'FSnapMapModuleDatabaseItem::Connections' has a wrong offset!");

}


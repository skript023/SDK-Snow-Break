#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonArchitectRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "DungeonArchitectRuntime_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function DungeonArchitectRuntime.Dungeon.GetDungeonActor
// 0x0008 (0x0008 - 0x0000)
struct Dungeon_GetDungeonActor final
{
public:
	class ADungeon*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Dungeon_GetDungeonActor) == 0x000008, "Wrong alignment on Dungeon_GetDungeonActor");
static_assert(sizeof(Dungeon_GetDungeonActor) == 0x000008, "Wrong size on Dungeon_GetDungeonActor");
static_assert(offsetof(Dungeon_GetDungeonActor, ReturnValue) == 0x000000, "Member 'Dungeon_GetDungeonActor::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.Dungeon.GetDungeonLevelNumber
// 0x0010 (0x0010 - 0x0000)
struct Dungeon_GetDungeonLevelNumber final
{
public:
	const class UObject*                          SceneObject;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Dungeon_GetDungeonLevelNumber) == 0x000008, "Wrong alignment on Dungeon_GetDungeonLevelNumber");
static_assert(sizeof(Dungeon_GetDungeonLevelNumber) == 0x000010, "Wrong size on Dungeon_GetDungeonLevelNumber");
static_assert(offsetof(Dungeon_GetDungeonLevelNumber, SceneObject) == 0x000000, "Member 'Dungeon_GetDungeonLevelNumber::SceneObject' has a wrong offset!");
static_assert(offsetof(Dungeon_GetDungeonLevelNumber, ReturnValue) == 0x000008, "Member 'Dungeon_GetDungeonLevelNumber::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.Dungeon.GetQuery
// 0x0008 (0x0008 - 0x0000)
struct Dungeon_GetQuery final
{
public:
	class UDungeonQuery*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Dungeon_GetQuery) == 0x000008, "Wrong alignment on Dungeon_GetQuery");
static_assert(sizeof(Dungeon_GetQuery) == 0x000008, "Wrong size on Dungeon_GetQuery");
static_assert(offsetof(Dungeon_GetQuery, ReturnValue) == 0x000000, "Member 'Dungeon_GetQuery::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.Dungeon.SetBuilderClass
// 0x0010 (0x0010 - 0x0000)
struct Dungeon_SetBuilderClass final
{
public:
	TSubclassOf<class UDungeonBuilder>            InBuilderClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonBuilder*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Dungeon_SetBuilderClass) == 0x000008, "Wrong alignment on Dungeon_SetBuilderClass");
static_assert(sizeof(Dungeon_SetBuilderClass) == 0x000010, "Wrong size on Dungeon_SetBuilderClass");
static_assert(offsetof(Dungeon_SetBuilderClass, InBuilderClass) == 0x000000, "Member 'Dungeon_SetBuilderClass::InBuilderClass' has a wrong offset!");
static_assert(offsetof(Dungeon_SetBuilderClass, ReturnValue) == 0x000008, "Member 'Dungeon_SetBuilderClass::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.ActorBelongsToDungeon
// 0x0018 (0x0018 - 0x0000)
struct DungeonBPFunctionLibrary_ActorBelongsToDungeon final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToCheck;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonBPFunctionLibrary_ActorBelongsToDungeon) == 0x000008, "Wrong alignment on DungeonBPFunctionLibrary_ActorBelongsToDungeon");
static_assert(sizeof(DungeonBPFunctionLibrary_ActorBelongsToDungeon) == 0x000018, "Wrong size on DungeonBPFunctionLibrary_ActorBelongsToDungeon");
static_assert(offsetof(DungeonBPFunctionLibrary_ActorBelongsToDungeon, Dungeon) == 0x000000, "Member 'DungeonBPFunctionLibrary_ActorBelongsToDungeon::Dungeon' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_ActorBelongsToDungeon, ActorToCheck) == 0x000008, "Member 'DungeonBPFunctionLibrary_ActorBelongsToDungeon::ActorToCheck' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_ActorBelongsToDungeon, ReturnValue) == 0x000010, "Member 'DungeonBPFunctionLibrary_ActorBelongsToDungeon::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.DungeonObjectHasAuthority
// 0x0010 (0x0010 - 0x0000)
struct DungeonBPFunctionLibrary_DungeonObjectHasAuthority final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonBPFunctionLibrary_DungeonObjectHasAuthority) == 0x000008, "Wrong alignment on DungeonBPFunctionLibrary_DungeonObjectHasAuthority");
static_assert(sizeof(DungeonBPFunctionLibrary_DungeonObjectHasAuthority) == 0x000010, "Wrong size on DungeonBPFunctionLibrary_DungeonObjectHasAuthority");
static_assert(offsetof(DungeonBPFunctionLibrary_DungeonObjectHasAuthority, Object) == 0x000000, "Member 'DungeonBPFunctionLibrary_DungeonObjectHasAuthority::Object' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_DungeonObjectHasAuthority, ReturnValue) == 0x000008, "Member 'DungeonBPFunctionLibrary_DungeonObjectHasAuthority::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.SpawnDungeonOwnedActor
// 0x0050 (0x0050 - 0x0000)
struct DungeonBPFunctionLibrary_SpawnDungeonOwnedActor final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor) == 0x000010, "Wrong alignment on DungeonBPFunctionLibrary_SpawnDungeonOwnedActor");
static_assert(sizeof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor) == 0x000050, "Wrong size on DungeonBPFunctionLibrary_SpawnDungeonOwnedActor");
static_assert(offsetof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor, Dungeon) == 0x000000, "Member 'DungeonBPFunctionLibrary_SpawnDungeonOwnedActor::Dungeon' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor, ActorClass) == 0x000008, "Member 'DungeonBPFunctionLibrary_SpawnDungeonOwnedActor::ActorClass' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor, Transform) == 0x000010, "Member 'DungeonBPFunctionLibrary_SpawnDungeonOwnedActor::Transform' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_SpawnDungeonOwnedActor, ReturnValue) == 0x000040, "Member 'DungeonBPFunctionLibrary_SpawnDungeonOwnedActor::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.StreamDungeonModuleLevel
// 0x0058 (0x0058 - 0x0000)
struct DungeonBPFunctionLibrary_StreamDungeonModuleLevel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceId;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0034(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0040(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOutSuccess;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel) == 0x000008, "Wrong alignment on DungeonBPFunctionLibrary_StreamDungeonModuleLevel");
static_assert(sizeof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel) == 0x000058, "Wrong size on DungeonBPFunctionLibrary_StreamDungeonModuleLevel");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, WorldContextObject) == 0x000000, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, Level) == 0x000008, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::Level' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, InstanceId) == 0x000030, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::InstanceId' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, Location) == 0x000034, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::Location' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, Rotation) == 0x000040, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::Rotation' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, bOutSuccess) == 0x00004C, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::bOutSuccess' has a wrong offset!");
static_assert(offsetof(DungeonBPFunctionLibrary_StreamDungeonModuleLevel, ReturnValue) == 0x000050, "Member 'DungeonBPFunctionLibrary_StreamDungeonModuleLevel::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBuilder.EmitMarker
// 0x0040 (0x0040 - 0x0000)
struct DungeonBuilder_EmitMarker final
{
public:
	class FString                                 SocketType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonBuilder_EmitMarker) == 0x000010, "Wrong alignment on DungeonBuilder_EmitMarker");
static_assert(sizeof(DungeonBuilder_EmitMarker) == 0x000040, "Wrong size on DungeonBuilder_EmitMarker");
static_assert(offsetof(DungeonBuilder_EmitMarker, SocketType) == 0x000000, "Member 'DungeonBuilder_EmitMarker::SocketType' has a wrong offset!");
static_assert(offsetof(DungeonBuilder_EmitMarker, Transform) == 0x000010, "Member 'DungeonBuilder_EmitMarker::Transform' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonBuilder.GetMarkers
// 0x0010 (0x0010 - 0x0000)
struct DungeonBuilder_GetMarkers final
{
public:
	TArray<struct FPropSocket>                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonBuilder_GetMarkers) == 0x000008, "Wrong alignment on DungeonBuilder_GetMarkers");
static_assert(sizeof(DungeonBuilder_GetMarkers) == 0x000010, "Wrong size on DungeonBuilder_GetMarkers");
static_assert(offsetof(DungeonBuilder_GetMarkers, ReturnValue) == 0x000000, "Member 'DungeonBuilder_GetMarkers::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnDungeonDestroyed
// 0x0008 (0x0008 - 0x0000)
struct DungeonEventListener_OnDungeonDestroyed final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnDungeonDestroyed) == 0x000008, "Wrong alignment on DungeonEventListener_OnDungeonDestroyed");
static_assert(sizeof(DungeonEventListener_OnDungeonDestroyed) == 0x000008, "Wrong size on DungeonEventListener_OnDungeonDestroyed");
static_assert(offsetof(DungeonEventListener_OnDungeonDestroyed, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnDungeonDestroyed::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnDungeonLayoutBuilt
// 0x0008 (0x0008 - 0x0000)
struct DungeonEventListener_OnDungeonLayoutBuilt final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnDungeonLayoutBuilt) == 0x000008, "Wrong alignment on DungeonEventListener_OnDungeonLayoutBuilt");
static_assert(sizeof(DungeonEventListener_OnDungeonLayoutBuilt) == 0x000008, "Wrong size on DungeonEventListener_OnDungeonLayoutBuilt");
static_assert(offsetof(DungeonEventListener_OnDungeonLayoutBuilt, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnDungeonLayoutBuilt::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnMarkersEmitted
// 0x0028 (0x0028 - 0x0000)
struct DungeonEventListener_OnMarkersEmitted final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDungeonMarkerInfo>             MarkerList;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDungeonMarkerInfo>             MarkerListRef;                                     // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnMarkersEmitted) == 0x000008, "Wrong alignment on DungeonEventListener_OnMarkersEmitted");
static_assert(sizeof(DungeonEventListener_OnMarkersEmitted) == 0x000028, "Wrong size on DungeonEventListener_OnMarkersEmitted");
static_assert(offsetof(DungeonEventListener_OnMarkersEmitted, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnMarkersEmitted::Dungeon' has a wrong offset!");
static_assert(offsetof(DungeonEventListener_OnMarkersEmitted, MarkerList) == 0x000008, "Member 'DungeonEventListener_OnMarkersEmitted::MarkerList' has a wrong offset!");
static_assert(offsetof(DungeonEventListener_OnMarkersEmitted, MarkerListRef) == 0x000018, "Member 'DungeonEventListener_OnMarkersEmitted::MarkerListRef' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnPostDungeonBuild
// 0x0008 (0x0008 - 0x0000)
struct DungeonEventListener_OnPostDungeonBuild final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnPostDungeonBuild) == 0x000008, "Wrong alignment on DungeonEventListener_OnPostDungeonBuild");
static_assert(sizeof(DungeonEventListener_OnPostDungeonBuild) == 0x000008, "Wrong size on DungeonEventListener_OnPostDungeonBuild");
static_assert(offsetof(DungeonEventListener_OnPostDungeonBuild, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnPostDungeonBuild::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnPreDungeonBuild
// 0x0008 (0x0008 - 0x0000)
struct DungeonEventListener_OnPreDungeonBuild final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnPreDungeonBuild) == 0x000008, "Wrong alignment on DungeonEventListener_OnPreDungeonBuild");
static_assert(sizeof(DungeonEventListener_OnPreDungeonBuild) == 0x000008, "Wrong size on DungeonEventListener_OnPreDungeonBuild");
static_assert(offsetof(DungeonEventListener_OnPreDungeonBuild, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnPreDungeonBuild::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonEventListener.OnPreDungeonDestroy
// 0x0008 (0x0008 - 0x0000)
struct DungeonEventListener_OnPreDungeonDestroy final
{
public:
	class ADungeon*                               Dungeon;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonEventListener_OnPreDungeonDestroy) == 0x000008, "Wrong alignment on DungeonEventListener_OnPreDungeonDestroy");
static_assert(sizeof(DungeonEventListener_OnPreDungeonDestroy) == 0x000008, "Wrong size on DungeonEventListener_OnPreDungeonDestroy");
static_assert(offsetof(DungeonEventListener_OnPreDungeonDestroy, Dungeon) == 0x000000, "Member 'DungeonEventListener_OnPreDungeonDestroy::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonStreamingChunk.GetAllActorsOfClass
// 0x0018 (0x0018 - 0x0000)
struct DungeonStreamingChunk_GetAllActorsOfClass final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonStreamingChunk_GetAllActorsOfClass) == 0x000008, "Wrong alignment on DungeonStreamingChunk_GetAllActorsOfClass");
static_assert(sizeof(DungeonStreamingChunk_GetAllActorsOfClass) == 0x000018, "Wrong size on DungeonStreamingChunk_GetAllActorsOfClass");
static_assert(offsetof(DungeonStreamingChunk_GetAllActorsOfClass, InClass) == 0x000000, "Member 'DungeonStreamingChunk_GetAllActorsOfClass::InClass' has a wrong offset!");
static_assert(offsetof(DungeonStreamingChunk_GetAllActorsOfClass, OutActors) == 0x000008, "Member 'DungeonStreamingChunk_GetAllActorsOfClass::OutActors' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonMarkerEmitter.EmitMarkers
// 0x0020 (0x0020 - 0x0000)
struct DungeonMarkerEmitter_EmitMarkers final
{
public:
	class UDungeonBuilder*                        Builder;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonModel*                          Model;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonConfig*                         Config;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonQuery*                          Query;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonMarkerEmitter_EmitMarkers) == 0x000008, "Wrong alignment on DungeonMarkerEmitter_EmitMarkers");
static_assert(sizeof(DungeonMarkerEmitter_EmitMarkers) == 0x000020, "Wrong size on DungeonMarkerEmitter_EmitMarkers");
static_assert(offsetof(DungeonMarkerEmitter_EmitMarkers, Builder) == 0x000000, "Member 'DungeonMarkerEmitter_EmitMarkers::Builder' has a wrong offset!");
static_assert(offsetof(DungeonMarkerEmitter_EmitMarkers, Model) == 0x000008, "Member 'DungeonMarkerEmitter_EmitMarkers::Model' has a wrong offset!");
static_assert(offsetof(DungeonMarkerEmitter_EmitMarkers, Config) == 0x000010, "Member 'DungeonMarkerEmitter_EmitMarkers::Config' has a wrong offset!");
static_assert(offsetof(DungeonMarkerEmitter_EmitMarkers, Query) == 0x000018, "Member 'DungeonMarkerEmitter_EmitMarkers::Query' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonMiniMap.BuildLayout
// 0x0010 (0x0010 - 0x0000)
struct DungeonMiniMap_BuildLayout final
{
public:
	class UDungeonModel*                          DungeonModel;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDungeonConfig*                         DungeonConfig;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonMiniMap_BuildLayout) == 0x000008, "Wrong alignment on DungeonMiniMap_BuildLayout");
static_assert(sizeof(DungeonMiniMap_BuildLayout) == 0x000010, "Wrong size on DungeonMiniMap_BuildLayout");
static_assert(offsetof(DungeonMiniMap_BuildLayout, DungeonModel) == 0x000000, "Member 'DungeonMiniMap_BuildLayout::DungeonModel' has a wrong offset!");
static_assert(offsetof(DungeonMiniMap_BuildLayout, DungeonConfig) == 0x000008, "Member 'DungeonMiniMap_BuildLayout::DungeonConfig' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonMiniMap.CreateMaterialInstance
// 0x0008 (0x0008 - 0x0000)
struct DungeonMiniMap_CreateMaterialInstance final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonMiniMap_CreateMaterialInstance) == 0x000008, "Wrong alignment on DungeonMiniMap_CreateMaterialInstance");
static_assert(sizeof(DungeonMiniMap_CreateMaterialInstance) == 0x000008, "Wrong size on DungeonMiniMap_CreateMaterialInstance");
static_assert(offsetof(DungeonMiniMap_CreateMaterialInstance, ReturnValue) == 0x000000, "Member 'DungeonMiniMap_CreateMaterialInstance::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonMiniMap.CreateMaterialInstanceFromTemplate
// 0x0010 (0x0010 - 0x0000)
struct DungeonMiniMap_CreateMaterialInstanceFromTemplate final
{
public:
	class UMaterialInterface*                     InMaterialTemplate;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonMiniMap_CreateMaterialInstanceFromTemplate) == 0x000008, "Wrong alignment on DungeonMiniMap_CreateMaterialInstanceFromTemplate");
static_assert(sizeof(DungeonMiniMap_CreateMaterialInstanceFromTemplate) == 0x000010, "Wrong size on DungeonMiniMap_CreateMaterialInstanceFromTemplate");
static_assert(offsetof(DungeonMiniMap_CreateMaterialInstanceFromTemplate, InMaterialTemplate) == 0x000000, "Member 'DungeonMiniMap_CreateMaterialInstanceFromTemplate::InMaterialTemplate' has a wrong offset!");
static_assert(offsetof(DungeonMiniMap_CreateMaterialInstanceFromTemplate, ReturnValue) == 0x000008, "Member 'DungeonMiniMap_CreateMaterialInstanceFromTemplate::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonMiniMap.UpdateMaterial
// 0x0008 (0x0008 - 0x0000)
struct DungeonMiniMap_UpdateMaterial final
{
public:
	class UMaterialInterface*                     InMaterial;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonMiniMap_UpdateMaterial) == 0x000008, "Wrong alignment on DungeonMiniMap_UpdateMaterial");
static_assert(sizeof(DungeonMiniMap_UpdateMaterial) == 0x000008, "Wrong size on DungeonMiniMap_UpdateMaterial");
static_assert(offsetof(DungeonMiniMap_UpdateMaterial, InMaterial) == 0x000000, "Member 'DungeonMiniMap_UpdateMaterial::InMaterial' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.ExpandBounds
// 0x0034 (0x0034 - 0x0000)
struct DungeonModelHelper_ExpandBounds final
{
public:
	struct FRectangle                             Bounds;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRectangle                             Result;                                            // 0x001C(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_ExpandBounds) == 0x000004, "Wrong alignment on DungeonModelHelper_ExpandBounds");
static_assert(sizeof(DungeonModelHelper_ExpandBounds) == 0x000034, "Wrong size on DungeonModelHelper_ExpandBounds");
static_assert(offsetof(DungeonModelHelper_ExpandBounds, Bounds) == 0x000000, "Member 'DungeonModelHelper_ExpandBounds::Bounds' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_ExpandBounds, Size) == 0x000018, "Member 'DungeonModelHelper_ExpandBounds::Size' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_ExpandBounds, Result) == 0x00001C, "Member 'DungeonModelHelper_ExpandBounds::Result' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.GetCenterExtent
// 0x0030 (0x0030 - 0x0000)
struct DungeonModelHelper_GetCenterExtent final
{
public:
	struct FRectangle                             Rectangle;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_GetCenterExtent) == 0x000004, "Wrong alignment on DungeonModelHelper_GetCenterExtent");
static_assert(sizeof(DungeonModelHelper_GetCenterExtent) == 0x000030, "Wrong size on DungeonModelHelper_GetCenterExtent");
static_assert(offsetof(DungeonModelHelper_GetCenterExtent, Rectangle) == 0x000000, "Member 'DungeonModelHelper_GetCenterExtent::Rectangle' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_GetCenterExtent, Center) == 0x000018, "Member 'DungeonModelHelper_GetCenterExtent::Center' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_GetCenterExtent, Extent) == 0x000024, "Member 'DungeonModelHelper_GetCenterExtent::Extent' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.GetRectAreaPoints
// 0x0028 (0x0028 - 0x0000)
struct DungeonModelHelper_GetRectAreaPoints final
{
public:
	struct FRectangle                             Rectangle;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FIntVector>                     BorderPoints;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_GetRectAreaPoints) == 0x000008, "Wrong alignment on DungeonModelHelper_GetRectAreaPoints");
static_assert(sizeof(DungeonModelHelper_GetRectAreaPoints) == 0x000028, "Wrong size on DungeonModelHelper_GetRectAreaPoints");
static_assert(offsetof(DungeonModelHelper_GetRectAreaPoints, Rectangle) == 0x000000, "Member 'DungeonModelHelper_GetRectAreaPoints::Rectangle' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_GetRectAreaPoints, BorderPoints) == 0x000018, "Member 'DungeonModelHelper_GetRectAreaPoints::BorderPoints' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.GetRectBorderPoints
// 0x0028 (0x0028 - 0x0000)
struct DungeonModelHelper_GetRectBorderPoints final
{
public:
	struct FRectangle                             Rectangle;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FIntVector>                     BorderPoints;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_GetRectBorderPoints) == 0x000008, "Wrong alignment on DungeonModelHelper_GetRectBorderPoints");
static_assert(sizeof(DungeonModelHelper_GetRectBorderPoints) == 0x000028, "Wrong size on DungeonModelHelper_GetRectBorderPoints");
static_assert(offsetof(DungeonModelHelper_GetRectBorderPoints, Rectangle) == 0x000000, "Member 'DungeonModelHelper_GetRectBorderPoints::Rectangle' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_GetRectBorderPoints, BorderPoints) == 0x000018, "Member 'DungeonModelHelper_GetRectBorderPoints::BorderPoints' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.MakeIntVector
// 0x0018 (0x0018 - 0x0000)
struct DungeonModelHelper_MakeIntVector final
{
public:
	struct FVector                                In;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_MakeIntVector) == 0x000004, "Wrong alignment on DungeonModelHelper_MakeIntVector");
static_assert(sizeof(DungeonModelHelper_MakeIntVector) == 0x000018, "Wrong size on DungeonModelHelper_MakeIntVector");
static_assert(offsetof(DungeonModelHelper_MakeIntVector, In) == 0x000000, "Member 'DungeonModelHelper_MakeIntVector::In' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_MakeIntVector, ReturnValue) == 0x00000C, "Member 'DungeonModelHelper_MakeIntVector::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonModelHelper.MakeVector
// 0x001C (0x001C - 0x0000)
struct DungeonModelHelper_MakeVector final
{
public:
	struct FIntVector                             In;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonModelHelper_MakeVector) == 0x000004, "Wrong alignment on DungeonModelHelper_MakeVector");
static_assert(sizeof(DungeonModelHelper_MakeVector) == 0x00001C, "Wrong size on DungeonModelHelper_MakeVector");
static_assert(offsetof(DungeonModelHelper_MakeVector, In) == 0x000000, "Member 'DungeonModelHelper_MakeVector::In' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_MakeVector, Scale) == 0x00000C, "Member 'DungeonModelHelper_MakeVector::Scale' has a wrong offset!");
static_assert(offsetof(DungeonModelHelper_MakeVector, ReturnValue) == 0x000010, "Member 'DungeonModelHelper_MakeVector::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonNavLinkProxy.SetupSmartLinkData
// 0x001C (0x001C - 0x0000)
struct DungeonNavLinkProxy_SetupSmartLinkData final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             Direction;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonNavLinkProxy_SetupSmartLinkData) == 0x000004, "Wrong alignment on DungeonNavLinkProxy_SetupSmartLinkData");
static_assert(sizeof(DungeonNavLinkProxy_SetupSmartLinkData) == 0x00001C, "Wrong size on DungeonNavLinkProxy_SetupSmartLinkData");
static_assert(offsetof(DungeonNavLinkProxy_SetupSmartLinkData, Start) == 0x000000, "Member 'DungeonNavLinkProxy_SetupSmartLinkData::Start' has a wrong offset!");
static_assert(offsetof(DungeonNavLinkProxy_SetupSmartLinkData, End) == 0x00000C, "Member 'DungeonNavLinkProxy_SetupSmartLinkData::End' has a wrong offset!");
static_assert(offsetof(DungeonNavLinkProxy_SetupSmartLinkData, Direction) == 0x000018, "Member 'DungeonNavLinkProxy_SetupSmartLinkData::Direction' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.GetBool
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_GetBool final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonQueryUserState_GetBool) == 0x000004, "Wrong alignment on DungeonQueryUserState_GetBool");
static_assert(sizeof(DungeonQueryUserState_GetBool) == 0x00000C, "Wrong size on DungeonQueryUserState_GetBool");
static_assert(offsetof(DungeonQueryUserState_GetBool, Name_0) == 0x000000, "Member 'DungeonQueryUserState_GetBool::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_GetBool, ReturnValue) == 0x000008, "Member 'DungeonQueryUserState_GetBool::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.GetFloat
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_GetFloat final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_GetFloat) == 0x000004, "Wrong alignment on DungeonQueryUserState_GetFloat");
static_assert(sizeof(DungeonQueryUserState_GetFloat) == 0x00000C, "Wrong size on DungeonQueryUserState_GetFloat");
static_assert(offsetof(DungeonQueryUserState_GetFloat, Name_0) == 0x000000, "Member 'DungeonQueryUserState_GetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_GetFloat, ReturnValue) == 0x000008, "Member 'DungeonQueryUserState_GetFloat::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.GetInt
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_GetInt final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_GetInt) == 0x000004, "Wrong alignment on DungeonQueryUserState_GetInt");
static_assert(sizeof(DungeonQueryUserState_GetInt) == 0x00000C, "Wrong size on DungeonQueryUserState_GetInt");
static_assert(offsetof(DungeonQueryUserState_GetInt, Name_0) == 0x000000, "Member 'DungeonQueryUserState_GetInt::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_GetInt, ReturnValue) == 0x000008, "Member 'DungeonQueryUserState_GetInt::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.GetString
// 0x0018 (0x0018 - 0x0000)
struct DungeonQueryUserState_GetString final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_GetString) == 0x000008, "Wrong alignment on DungeonQueryUserState_GetString");
static_assert(sizeof(DungeonQueryUserState_GetString) == 0x000018, "Wrong size on DungeonQueryUserState_GetString");
static_assert(offsetof(DungeonQueryUserState_GetString, Name_0) == 0x000000, "Member 'DungeonQueryUserState_GetString::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_GetString, ReturnValue) == 0x000008, "Member 'DungeonQueryUserState_GetString::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.GetVector
// 0x0014 (0x0014 - 0x0000)
struct DungeonQueryUserState_GetVector final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_GetVector) == 0x000004, "Wrong alignment on DungeonQueryUserState_GetVector");
static_assert(sizeof(DungeonQueryUserState_GetVector) == 0x000014, "Wrong size on DungeonQueryUserState_GetVector");
static_assert(offsetof(DungeonQueryUserState_GetVector, Name_0) == 0x000000, "Member 'DungeonQueryUserState_GetVector::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_GetVector, ReturnValue) == 0x000008, "Member 'DungeonQueryUserState_GetVector::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.SetBool
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_SetBool final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonQueryUserState_SetBool) == 0x000004, "Wrong alignment on DungeonQueryUserState_SetBool");
static_assert(sizeof(DungeonQueryUserState_SetBool) == 0x00000C, "Wrong size on DungeonQueryUserState_SetBool");
static_assert(offsetof(DungeonQueryUserState_SetBool, Name_0) == 0x000000, "Member 'DungeonQueryUserState_SetBool::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_SetBool, Value) == 0x000008, "Member 'DungeonQueryUserState_SetBool::Value' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.SetFloat
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_SetFloat final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_SetFloat) == 0x000004, "Wrong alignment on DungeonQueryUserState_SetFloat");
static_assert(sizeof(DungeonQueryUserState_SetFloat) == 0x00000C, "Wrong size on DungeonQueryUserState_SetFloat");
static_assert(offsetof(DungeonQueryUserState_SetFloat, Name_0) == 0x000000, "Member 'DungeonQueryUserState_SetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_SetFloat, Value) == 0x000008, "Member 'DungeonQueryUserState_SetFloat::Value' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.SetInt
// 0x000C (0x000C - 0x0000)
struct DungeonQueryUserState_SetInt final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_SetInt) == 0x000004, "Wrong alignment on DungeonQueryUserState_SetInt");
static_assert(sizeof(DungeonQueryUserState_SetInt) == 0x00000C, "Wrong size on DungeonQueryUserState_SetInt");
static_assert(offsetof(DungeonQueryUserState_SetInt, Name_0) == 0x000000, "Member 'DungeonQueryUserState_SetInt::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_SetInt, Value) == 0x000008, "Member 'DungeonQueryUserState_SetInt::Value' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.SetString
// 0x0018 (0x0018 - 0x0000)
struct DungeonQueryUserState_SetString final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_SetString) == 0x000008, "Wrong alignment on DungeonQueryUserState_SetString");
static_assert(sizeof(DungeonQueryUserState_SetString) == 0x000018, "Wrong size on DungeonQueryUserState_SetString");
static_assert(offsetof(DungeonQueryUserState_SetString, Name_0) == 0x000000, "Member 'DungeonQueryUserState_SetString::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_SetString, Value) == 0x000008, "Member 'DungeonQueryUserState_SetString::Value' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonQueryUserState.SetVector
// 0x0014 (0x0014 - 0x0000)
struct DungeonQueryUserState_SetVector final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonQueryUserState_SetVector) == 0x000004, "Wrong alignment on DungeonQueryUserState_SetVector");
static_assert(sizeof(DungeonQueryUserState_SetVector) == 0x000014, "Wrong size on DungeonQueryUserState_SetVector");
static_assert(offsetof(DungeonQueryUserState_SetVector, Name_0) == 0x000000, "Member 'DungeonQueryUserState_SetVector::Name_0' has a wrong offset!");
static_assert(offsetof(DungeonQueryUserState_SetVector, Value) == 0x000008, "Member 'DungeonQueryUserState_SetVector::Value' has a wrong offset!");

// Function DungeonArchitectRuntime.SnapMapDungeonTransformLogic.GetNodeOffset
// 0x0040 (0x0040 - 0x0000)
struct SnapMapDungeonTransformLogic_GetNodeOffset final
{
public:
	class USnapMapDungeonModel*                   Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SnapMapDungeonTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on SnapMapDungeonTransformLogic_GetNodeOffset");
static_assert(sizeof(SnapMapDungeonTransformLogic_GetNodeOffset) == 0x000040, "Wrong size on SnapMapDungeonTransformLogic_GetNodeOffset");
static_assert(offsetof(SnapMapDungeonTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'SnapMapDungeonTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(SnapMapDungeonTransformLogic_GetNodeOffset, Offset) == 0x000010, "Member 'SnapMapDungeonTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.DungeonSpawnLogic.OnItemSpawn
// 0x0010 (0x0010 - 0x0000)
struct DungeonSpawnLogic_OnItemSpawn final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADungeon*                               Dungeon;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSpawnLogic_OnItemSpawn) == 0x000008, "Wrong alignment on DungeonSpawnLogic_OnItemSpawn");
static_assert(sizeof(DungeonSpawnLogic_OnItemSpawn) == 0x000010, "Wrong size on DungeonSpawnLogic_OnItemSpawn");
static_assert(offsetof(DungeonSpawnLogic_OnItemSpawn, Actor) == 0x000000, "Member 'DungeonSpawnLogic_OnItemSpawn::Actor' has a wrong offset!");
static_assert(offsetof(DungeonSpawnLogic_OnItemSpawn, Dungeon) == 0x000008, "Member 'DungeonSpawnLogic_OnItemSpawn::Dungeon' has a wrong offset!");

// Function DungeonArchitectRuntime.FloorPlanSelectorLogic.SelectNode
// 0x0028 (0x0028 - 0x0000)
struct FloorPlanSelectorLogic_SelectNode final
{
public:
	class UFloorPlanModel*                        Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloorPlanConfig*                       Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridZ;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FloorPlanSelectorLogic_SelectNode) == 0x000008, "Wrong alignment on FloorPlanSelectorLogic_SelectNode");
static_assert(sizeof(FloorPlanSelectorLogic_SelectNode) == 0x000028, "Wrong size on FloorPlanSelectorLogic_SelectNode");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, Model) == 0x000000, "Member 'FloorPlanSelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, Config) == 0x000008, "Member 'FloorPlanSelectorLogic_SelectNode::Config' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, RandomStream) == 0x000010, "Member 'FloorPlanSelectorLogic_SelectNode::RandomStream' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, GridX) == 0x000018, "Member 'FloorPlanSelectorLogic_SelectNode::GridX' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, GridY) == 0x00001C, "Member 'FloorPlanSelectorLogic_SelectNode::GridY' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, GridZ) == 0x000020, "Member 'FloorPlanSelectorLogic_SelectNode::GridZ' has a wrong offset!");
static_assert(offsetof(FloorPlanSelectorLogic_SelectNode, ReturnValue) == 0x000024, "Member 'FloorPlanSelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.FloorPlanTransformLogic.GetNodeOffset
// 0x0050 (0x0050 - 0x0000)
struct FloorPlanTransformLogic_GetNodeOffset final
{
public:
	class UFloorPlanModel*                        Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloorPlanConfig*                       Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0020(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorPlanTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on FloorPlanTransformLogic_GetNodeOffset");
static_assert(sizeof(FloorPlanTransformLogic_GetNodeOffset) == 0x000050, "Wrong size on FloorPlanTransformLogic_GetNodeOffset");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'FloorPlanTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, Config) == 0x000008, "Member 'FloorPlanTransformLogic_GetNodeOffset::Config' has a wrong offset!");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, RandomStream) == 0x000010, "Member 'FloorPlanTransformLogic_GetNodeOffset::RandomStream' has a wrong offset!");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, GridX) == 0x000018, "Member 'FloorPlanTransformLogic_GetNodeOffset::GridX' has a wrong offset!");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, GridY) == 0x00001C, "Member 'FloorPlanTransformLogic_GetNodeOffset::GridY' has a wrong offset!");
static_assert(offsetof(FloorPlanTransformLogic_GetNodeOffset, Offset) == 0x000020, "Member 'FloorPlanTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.FlowAbstractNode.ContainsItem
// 0x000C (0x000C - 0x0000)
struct FlowAbstractNode_ContainsItem final
{
public:
	EFlowGraphItemType                            ItemType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FlowAbstractNode_ContainsItem) == 0x000004, "Wrong alignment on FlowAbstractNode_ContainsItem");
static_assert(sizeof(FlowAbstractNode_ContainsItem) == 0x00000C, "Wrong size on FlowAbstractNode_ContainsItem");
static_assert(offsetof(FlowAbstractNode_ContainsItem, ItemType) == 0x000000, "Member 'FlowAbstractNode_ContainsItem::ItemType' has a wrong offset!");
static_assert(offsetof(FlowAbstractNode_ContainsItem, Count) == 0x000004, "Member 'FlowAbstractNode_ContainsItem::Count' has a wrong offset!");
static_assert(offsetof(FlowAbstractNode_ContainsItem, ReturnValue) == 0x000008, "Member 'FlowAbstractNode_ContainsItem::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.SnapMapDungeonSelectorLogic.SelectNode
// 0x0010 (0x0010 - 0x0000)
struct SnapMapDungeonSelectorLogic_SelectNode final
{
public:
	class USnapMapDungeonModel*                   Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SnapMapDungeonSelectorLogic_SelectNode) == 0x000008, "Wrong alignment on SnapMapDungeonSelectorLogic_SelectNode");
static_assert(sizeof(SnapMapDungeonSelectorLogic_SelectNode) == 0x000010, "Wrong size on SnapMapDungeonSelectorLogic_SelectNode");
static_assert(offsetof(SnapMapDungeonSelectorLogic_SelectNode, Model) == 0x000000, "Member 'SnapMapDungeonSelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(SnapMapDungeonSelectorLogic_SelectNode, ReturnValue) == 0x000008, "Member 'SnapMapDungeonSelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.Grid3DLayoutNodeCreationConstraint.CanCreateLayoutNode
// 0x0024 (0x0024 - 0x0000)
struct Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode final
{
public:
	struct FIntVector                             NodeCoord;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GridSize;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPathLength;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPathPosition;                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode) == 0x000004, "Wrong alignment on Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode");
static_assert(sizeof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode) == 0x000024, "Wrong size on Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode");
static_assert(offsetof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode, NodeCoord) == 0x000000, "Member 'Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode::NodeCoord' has a wrong offset!");
static_assert(offsetof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode, GridSize) == 0x00000C, "Member 'Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode::GridSize' has a wrong offset!");
static_assert(offsetof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode, TotalPathLength) == 0x000018, "Member 'Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode::TotalPathLength' has a wrong offset!");
static_assert(offsetof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode, CurrentPathPosition) == 0x00001C, "Member 'Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode::CurrentPathPosition' has a wrong offset!");
static_assert(offsetof(Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode, ReturnValue) == 0x000020, "Member 'Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonBuilder.ContainsCell
// 0x000C (0x000C - 0x0000)
struct GridDungeonBuilder_ContainsCell final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonBuilder_ContainsCell) == 0x000004, "Wrong alignment on GridDungeonBuilder_ContainsCell");
static_assert(sizeof(GridDungeonBuilder_ContainsCell) == 0x00000C, "Wrong size on GridDungeonBuilder_ContainsCell");
static_assert(offsetof(GridDungeonBuilder_ContainsCell, X) == 0x000000, "Member 'GridDungeonBuilder_ContainsCell::X' has a wrong offset!");
static_assert(offsetof(GridDungeonBuilder_ContainsCell, Y) == 0x000004, "Member 'GridDungeonBuilder_ContainsCell::Y' has a wrong offset!");
static_assert(offsetof(GridDungeonBuilder_ContainsCell, ReturnValue) == 0x000008, "Member 'GridDungeonBuilder_ContainsCell::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonBuilder.GetCellsOfType
// 0x0018 (0x0018 - 0x0000)
struct GridDungeonBuilder_GetCellsOfType final
{
public:
	EFCellType                                    CellType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCell>                          Cells;                                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonBuilder_GetCellsOfType) == 0x000008, "Wrong alignment on GridDungeonBuilder_GetCellsOfType");
static_assert(sizeof(GridDungeonBuilder_GetCellsOfType) == 0x000018, "Wrong size on GridDungeonBuilder_GetCellsOfType");
static_assert(offsetof(GridDungeonBuilder_GetCellsOfType, CellType) == 0x000000, "Member 'GridDungeonBuilder_GetCellsOfType::CellType' has a wrong offset!");
static_assert(offsetof(GridDungeonBuilder_GetCellsOfType, Cells) == 0x000008, "Member 'GridDungeonBuilder_GetCellsOfType::Cells' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonBuilder.GetCorridors
// 0x0010 (0x0010 - 0x0000)
struct GridDungeonBuilder_GetCorridors final
{
public:
	TArray<struct FCell>                          CorridorCells;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonBuilder_GetCorridors) == 0x000008, "Wrong alignment on GridDungeonBuilder_GetCorridors");
static_assert(sizeof(GridDungeonBuilder_GetCorridors) == 0x000010, "Wrong size on GridDungeonBuilder_GetCorridors");
static_assert(offsetof(GridDungeonBuilder_GetCorridors, CorridorCells) == 0x000000, "Member 'GridDungeonBuilder_GetCorridors::CorridorCells' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonBuilder.GetRandomStream
// 0x0008 (0x0008 - 0x0000)
struct GridDungeonBuilder_GetRandomStream final
{
public:
	struct FRandomStream                          OutRandomStream;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonBuilder_GetRandomStream) == 0x000004, "Wrong alignment on GridDungeonBuilder_GetRandomStream");
static_assert(sizeof(GridDungeonBuilder_GetRandomStream) == 0x000008, "Wrong size on GridDungeonBuilder_GetRandomStream");
static_assert(offsetof(GridDungeonBuilder_GetRandomStream, OutRandomStream) == 0x000000, "Member 'GridDungeonBuilder_GetRandomStream::OutRandomStream' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonBuilder.GetRooms
// 0x0010 (0x0010 - 0x0000)
struct GridDungeonBuilder_GetRooms final
{
public:
	TArray<struct FCell>                          RoomCells;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonBuilder_GetRooms) == 0x000008, "Wrong alignment on GridDungeonBuilder_GetRooms");
static_assert(sizeof(GridDungeonBuilder_GetRooms) == 0x000010, "Wrong size on GridDungeonBuilder_GetRooms");
static_assert(offsetof(GridDungeonBuilder_GetRooms, RoomCells) == 0x000000, "Member 'GridDungeonBuilder_GetRooms::RoomCells' has a wrong offset!");

// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.ConnectRooms
// 0x0008 (0x0008 - 0x0000)
struct GridCustomDungeonBuilder_ConnectRooms final
{
public:
	int32                                         Room1;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Room2;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridCustomDungeonBuilder_ConnectRooms) == 0x000004, "Wrong alignment on GridCustomDungeonBuilder_ConnectRooms");
static_assert(sizeof(GridCustomDungeonBuilder_ConnectRooms) == 0x000008, "Wrong size on GridCustomDungeonBuilder_ConnectRooms");
static_assert(offsetof(GridCustomDungeonBuilder_ConnectRooms, Room1) == 0x000000, "Member 'GridCustomDungeonBuilder_ConnectRooms::Room1' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_ConnectRooms, Room2) == 0x000004, "Member 'GridCustomDungeonBuilder_ConnectRooms::Room2' has a wrong offset!");

// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.GenerateCustomLayout
// 0x0008 (0x0008 - 0x0000)
struct GridCustomDungeonBuilder_GenerateCustomLayout final
{
public:
	class UGridDungeonConfig*                     GridConfig;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridCustomDungeonBuilder_GenerateCustomLayout) == 0x000008, "Wrong alignment on GridCustomDungeonBuilder_GenerateCustomLayout");
static_assert(sizeof(GridCustomDungeonBuilder_GenerateCustomLayout) == 0x000008, "Wrong size on GridCustomDungeonBuilder_GenerateCustomLayout");
static_assert(offsetof(GridCustomDungeonBuilder_GenerateCustomLayout, GridConfig) == 0x000000, "Member 'GridCustomDungeonBuilder_GenerateCustomLayout::GridConfig' has a wrong offset!");

// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.GetRandomOffset
// 0x0014 (0x0014 - 0x0000)
struct GridCustomDungeonBuilder_GetRandomOffset final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutX;                                              // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutY;                                              // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridCustomDungeonBuilder_GetRandomOffset) == 0x000004, "Wrong alignment on GridCustomDungeonBuilder_GetRandomOffset");
static_assert(sizeof(GridCustomDungeonBuilder_GetRandomOffset) == 0x000014, "Wrong size on GridCustomDungeonBuilder_GetRandomOffset");
static_assert(offsetof(GridCustomDungeonBuilder_GetRandomOffset, X) == 0x000000, "Member 'GridCustomDungeonBuilder_GetRandomOffset::X' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_GetRandomOffset, Y) == 0x000004, "Member 'GridCustomDungeonBuilder_GetRandomOffset::Y' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_GetRandomOffset, Radius) == 0x000008, "Member 'GridCustomDungeonBuilder_GetRandomOffset::Radius' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_GetRandomOffset, OutX) == 0x00000C, "Member 'GridCustomDungeonBuilder_GetRandomOffset::OutX' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_GetRandomOffset, OutY) == 0x000010, "Member 'GridCustomDungeonBuilder_GetRandomOffset::OutY' has a wrong offset!");

// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.RegisterRoom
// 0x0018 (0x0018 - 0x0000)
struct GridCustomDungeonBuilder_RegisterRoom final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomId;                                            // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridCustomDungeonBuilder_RegisterRoom) == 0x000004, "Wrong alignment on GridCustomDungeonBuilder_RegisterRoom");
static_assert(sizeof(GridCustomDungeonBuilder_RegisterRoom) == 0x000018, "Wrong size on GridCustomDungeonBuilder_RegisterRoom");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, X) == 0x000000, "Member 'GridCustomDungeonBuilder_RegisterRoom::X' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, Y) == 0x000004, "Member 'GridCustomDungeonBuilder_RegisterRoom::Y' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, Z) == 0x000008, "Member 'GridCustomDungeonBuilder_RegisterRoom::Z' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, Width) == 0x00000C, "Member 'GridCustomDungeonBuilder_RegisterRoom::Width' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, Height) == 0x000010, "Member 'GridCustomDungeonBuilder_RegisterRoom::Height' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoom, RoomId) == 0x000014, "Member 'GridCustomDungeonBuilder_RegisterRoom::RoomId' has a wrong offset!");

// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.RegisterRoomAt
// 0x0010 (0x0010 - 0x0000)
struct GridCustomDungeonBuilder_RegisterRoomAt final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomId;                                            // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridCustomDungeonBuilder_RegisterRoomAt) == 0x000004, "Wrong alignment on GridCustomDungeonBuilder_RegisterRoomAt");
static_assert(sizeof(GridCustomDungeonBuilder_RegisterRoomAt) == 0x000010, "Wrong size on GridCustomDungeonBuilder_RegisterRoomAt");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoomAt, X) == 0x000000, "Member 'GridCustomDungeonBuilder_RegisterRoomAt::X' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoomAt, Y) == 0x000004, "Member 'GridCustomDungeonBuilder_RegisterRoomAt::Y' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoomAt, Z) == 0x000008, "Member 'GridCustomDungeonBuilder_RegisterRoomAt::Z' has a wrong offset!");
static_assert(offsetof(GridCustomDungeonBuilder_RegisterRoomAt, RoomId) == 0x00000C, "Member 'GridCustomDungeonBuilder_RegisterRoomAt::RoomId' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModel.GetGridCellLookup
// 0x0010 (0x0010 - 0x0000)
struct GridDungeonModel_GetGridCellLookup final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGridCellInfo                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModel_GetGridCellLookup) == 0x000004, "Wrong alignment on GridDungeonModel_GetGridCellLookup");
static_assert(sizeof(GridDungeonModel_GetGridCellLookup) == 0x000010, "Wrong size on GridDungeonModel_GetGridCellLookup");
static_assert(offsetof(GridDungeonModel_GetGridCellLookup, X) == 0x000000, "Member 'GridDungeonModel_GetGridCellLookup::X' has a wrong offset!");
static_assert(offsetof(GridDungeonModel_GetGridCellLookup, Y) == 0x000004, "Member 'GridDungeonModel_GetGridCellLookup::Y' has a wrong offset!");
static_assert(offsetof(GridDungeonModel_GetGridCellLookup, ReturnValue) == 0x000008, "Member 'GridDungeonModel_GetGridCellLookup::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.AddPaintCell
// 0x0020 (0x0020 - 0x0000)
struct GridDungeonModelHelper_AddPaintCell final
{
public:
	struct FGridToolPaintStrokeData               CellData;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class ADungeon*                               Dungeon;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticRebuild;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonModelHelper_AddPaintCell) == 0x000008, "Wrong alignment on GridDungeonModelHelper_AddPaintCell");
static_assert(sizeof(GridDungeonModelHelper_AddPaintCell) == 0x000020, "Wrong size on GridDungeonModelHelper_AddPaintCell");
static_assert(offsetof(GridDungeonModelHelper_AddPaintCell, CellData) == 0x000000, "Member 'GridDungeonModelHelper_AddPaintCell::CellData' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_AddPaintCell, Dungeon) == 0x000010, "Member 'GridDungeonModelHelper_AddPaintCell::Dungeon' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_AddPaintCell, bAutomaticRebuild) == 0x000018, "Member 'GridDungeonModelHelper_AddPaintCell::bAutomaticRebuild' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetBoundingBox
// 0x0028 (0x0028 - 0x0000)
struct GridDungeonModelHelper_GetBoundingBox final
{
public:
	TArray<struct FCell>                          Cells;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRectangle                             Bounds;                                            // 0x0010(0x0018)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_GetBoundingBox) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetBoundingBox");
static_assert(sizeof(GridDungeonModelHelper_GetBoundingBox) == 0x000028, "Wrong size on GridDungeonModelHelper_GetBoundingBox");
static_assert(offsetof(GridDungeonModelHelper_GetBoundingBox, Cells) == 0x000000, "Member 'GridDungeonModelHelper_GetBoundingBox::Cells' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetBoundingBox, Bounds) == 0x000010, "Member 'GridDungeonModelHelper_GetBoundingBox::Bounds' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellCenter
// 0x0068 (0x0068 - 0x0000)
struct GridDungeonModelHelper_GetCellCenter final
{
public:
	struct FCell                                  Cell;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0058(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonModelHelper_GetCellCenter) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetCellCenter");
static_assert(sizeof(GridDungeonModelHelper_GetCellCenter) == 0x000068, "Wrong size on GridDungeonModelHelper_GetCellCenter");
static_assert(offsetof(GridDungeonModelHelper_GetCellCenter, Cell) == 0x000000, "Member 'GridDungeonModelHelper_GetCellCenter::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetCellCenter, Center) == 0x000058, "Member 'GridDungeonModelHelper_GetCellCenter::Center' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellConnectedRooms
// 0x0068 (0x0068 - 0x0000)
struct GridDungeonModelHelper_GetCellConnectedRooms final
{
public:
	struct FCell                                  Cell;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ConnectedRooms;                                    // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_GetCellConnectedRooms) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetCellConnectedRooms");
static_assert(sizeof(GridDungeonModelHelper_GetCellConnectedRooms) == 0x000068, "Wrong size on GridDungeonModelHelper_GetCellConnectedRooms");
static_assert(offsetof(GridDungeonModelHelper_GetCellConnectedRooms, Cell) == 0x000000, "Member 'GridDungeonModelHelper_GetCellConnectedRooms::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetCellConnectedRooms, ConnectedRooms) == 0x000058, "Member 'GridDungeonModelHelper_GetCellConnectedRooms::ConnectedRooms' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellMSTRooms
// 0x0068 (0x0068 - 0x0000)
struct GridDungeonModelHelper_GetCellMSTRooms final
{
public:
	struct FCell                                  Cell;                                              // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 MSTRooms;                                          // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_GetCellMSTRooms) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetCellMSTRooms");
static_assert(sizeof(GridDungeonModelHelper_GetCellMSTRooms) == 0x000068, "Wrong size on GridDungeonModelHelper_GetCellMSTRooms");
static_assert(offsetof(GridDungeonModelHelper_GetCellMSTRooms, Cell) == 0x000000, "Member 'GridDungeonModelHelper_GetCellMSTRooms::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetCellMSTRooms, MSTRooms) == 0x000058, "Member 'GridDungeonModelHelper_GetCellMSTRooms::MSTRooms' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetDoorExits
// 0x003C (0x003C - 0x0000)
struct GridDungeonModelHelper_GetDoorExits final
{
public:
	struct FCellDoor                              Door;                                              // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ExitA;                                             // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitB;                                             // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_GetDoorExits) == 0x000004, "Wrong alignment on GridDungeonModelHelper_GetDoorExits");
static_assert(sizeof(GridDungeonModelHelper_GetDoorExits) == 0x00003C, "Wrong size on GridDungeonModelHelper_GetDoorExits");
static_assert(offsetof(GridDungeonModelHelper_GetDoorExits, Door) == 0x000000, "Member 'GridDungeonModelHelper_GetDoorExits::Door' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetDoorExits, ExitA) == 0x000024, "Member 'GridDungeonModelHelper_GetDoorExits::ExitA' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetDoorExits, ExitB) == 0x000030, "Member 'GridDungeonModelHelper_GetDoorExits::ExitB' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetRandomCellLocation
// 0x0020 (0x0020 - 0x0000)
struct GridDungeonModelHelper_GetRandomCellLocation final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonConfig*                     Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonModelHelper_GetRandomCellLocation) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetRandomCellLocation");
static_assert(sizeof(GridDungeonModelHelper_GetRandomCellLocation) == 0x000020, "Wrong size on GridDungeonModelHelper_GetRandomCellLocation");
static_assert(offsetof(GridDungeonModelHelper_GetRandomCellLocation, Model) == 0x000000, "Member 'GridDungeonModelHelper_GetRandomCellLocation::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetRandomCellLocation, Config) == 0x000008, "Member 'GridDungeonModelHelper_GetRandomCellLocation::Config' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetRandomCellLocation, ReturnValue) == 0x000010, "Member 'GridDungeonModelHelper_GetRandomCellLocation::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetRoomFreeEdge
// 0x0080 (0x0080 - 0x0000)
struct GridDungeonModelHelper_GetRoomFreeEdge final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCell                                  RoomCell;                                          // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FreeEdgeCenters;                                   // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FreeEdgeAngles;                                    // 0x0070(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_GetRoomFreeEdge) == 0x000008, "Wrong alignment on GridDungeonModelHelper_GetRoomFreeEdge");
static_assert(sizeof(GridDungeonModelHelper_GetRoomFreeEdge) == 0x000080, "Wrong size on GridDungeonModelHelper_GetRoomFreeEdge");
static_assert(offsetof(GridDungeonModelHelper_GetRoomFreeEdge, Model) == 0x000000, "Member 'GridDungeonModelHelper_GetRoomFreeEdge::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetRoomFreeEdge, RoomCell) == 0x000008, "Member 'GridDungeonModelHelper_GetRoomFreeEdge::RoomCell' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetRoomFreeEdge, FreeEdgeCenters) == 0x000060, "Member 'GridDungeonModelHelper_GetRoomFreeEdge::FreeEdgeCenters' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_GetRoomFreeEdge, FreeEdgeAngles) == 0x000070, "Member 'GridDungeonModelHelper_GetRoomFreeEdge::FreeEdgeAngles' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.RemovePaintCell
// 0x0020 (0x0020 - 0x0000)
struct GridDungeonModelHelper_RemovePaintCell final
{
public:
	struct FGridToolPaintStrokeData               CellData;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class ADungeon*                               Dungeon;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticRebuild;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonModelHelper_RemovePaintCell) == 0x000008, "Wrong alignment on GridDungeonModelHelper_RemovePaintCell");
static_assert(sizeof(GridDungeonModelHelper_RemovePaintCell) == 0x000020, "Wrong size on GridDungeonModelHelper_RemovePaintCell");
static_assert(offsetof(GridDungeonModelHelper_RemovePaintCell, CellData) == 0x000000, "Member 'GridDungeonModelHelper_RemovePaintCell::CellData' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_RemovePaintCell, Dungeon) == 0x000010, "Member 'GridDungeonModelHelper_RemovePaintCell::Dungeon' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_RemovePaintCell, bAutomaticRebuild) == 0x000018, "Member 'GridDungeonModelHelper_RemovePaintCell::bAutomaticRebuild' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonModelHelper.ToWorldCoords
// 0x003C (0x003C - 0x0000)
struct GridDungeonModelHelper_ToWorldCoords final
{
public:
	struct FRectangle                             Bounds;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                GridSize;                                          // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonModelHelper_ToWorldCoords) == 0x000004, "Wrong alignment on GridDungeonModelHelper_ToWorldCoords");
static_assert(sizeof(GridDungeonModelHelper_ToWorldCoords) == 0x00003C, "Wrong size on GridDungeonModelHelper_ToWorldCoords");
static_assert(offsetof(GridDungeonModelHelper_ToWorldCoords, Bounds) == 0x000000, "Member 'GridDungeonModelHelper_ToWorldCoords::Bounds' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_ToWorldCoords, GridSize) == 0x000018, "Member 'GridDungeonModelHelper_ToWorldCoords::GridSize' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_ToWorldCoords, Location) == 0x000024, "Member 'GridDungeonModelHelper_ToWorldCoords::Location' has a wrong offset!");
static_assert(offsetof(GridDungeonModelHelper_ToWorldCoords, Size) == 0x000030, "Member 'GridDungeonModelHelper_ToWorldCoords::Size' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.ContainsDoorBetween
// 0x000C (0x000C - 0x0000)
struct GridDungeonQuery_ContainsDoorBetween final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_ContainsDoorBetween) == 0x000004, "Wrong alignment on GridDungeonQuery_ContainsDoorBetween");
static_assert(sizeof(GridDungeonQuery_ContainsDoorBetween) == 0x00000C, "Wrong size on GridDungeonQuery_ContainsDoorBetween");
static_assert(offsetof(GridDungeonQuery_ContainsDoorBetween, CellA) == 0x000000, "Member 'GridDungeonQuery_ContainsDoorBetween::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_ContainsDoorBetween, CellB) == 0x000004, "Member 'GridDungeonQuery_ContainsDoorBetween::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_ContainsDoorBetween, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_ContainsDoorBetween::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.ContainsStairBetween
// 0x000C (0x000C - 0x0000)
struct GridDungeonQuery_ContainsStairBetween final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_ContainsStairBetween) == 0x000004, "Wrong alignment on GridDungeonQuery_ContainsStairBetween");
static_assert(sizeof(GridDungeonQuery_ContainsStairBetween) == 0x00000C, "Wrong size on GridDungeonQuery_ContainsStairBetween");
static_assert(offsetof(GridDungeonQuery_ContainsStairBetween, CellA) == 0x000000, "Member 'GridDungeonQuery_ContainsStairBetween::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_ContainsStairBetween, CellB) == 0x000004, "Member 'GridDungeonQuery_ContainsStairBetween::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_ContainsStairBetween, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_ContainsStairBetween::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetAdjacentCells
// 0x0018 (0x0018 - 0x0000)
struct GridDungeonQuery_GetAdjacentCells final
{
public:
	int32                                         CellId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OutAdjacentCells;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetAdjacentCells) == 0x000008, "Wrong alignment on GridDungeonQuery_GetAdjacentCells");
static_assert(sizeof(GridDungeonQuery_GetAdjacentCells) == 0x000018, "Wrong size on GridDungeonQuery_GetAdjacentCells");
static_assert(offsetof(GridDungeonQuery_GetAdjacentCells, CellId) == 0x000000, "Member 'GridDungeonQuery_GetAdjacentCells::CellId' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetAdjacentCells, OutAdjacentCells) == 0x000008, "Member 'GridDungeonQuery_GetAdjacentCells::OutAdjacentCells' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetAdjacentCellsOnEdge
// 0x0040 (0x0040 - 0x0000)
struct GridDungeonQuery_GetAdjacentCellsOnEdge final
{
public:
	struct FTransform                             WallMarkerTransform;                               // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CellA;                                             // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_GetAdjacentCellsOnEdge) == 0x000010, "Wrong alignment on GridDungeonQuery_GetAdjacentCellsOnEdge");
static_assert(sizeof(GridDungeonQuery_GetAdjacentCellsOnEdge) == 0x000040, "Wrong size on GridDungeonQuery_GetAdjacentCellsOnEdge");
static_assert(offsetof(GridDungeonQuery_GetAdjacentCellsOnEdge, WallMarkerTransform) == 0x000000, "Member 'GridDungeonQuery_GetAdjacentCellsOnEdge::WallMarkerTransform' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetAdjacentCellsOnEdge, CellA) == 0x000030, "Member 'GridDungeonQuery_GetAdjacentCellsOnEdge::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetAdjacentCellsOnEdge, CellB) == 0x000034, "Member 'GridDungeonQuery_GetAdjacentCellsOnEdge::CellB' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellAtLocation
// 0x0014 (0x0014 - 0x0000)
struct GridDungeonQuery_GetCellAtLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutCellId;                                         // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutValid;                                         // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_GetCellAtLocation) == 0x000004, "Wrong alignment on GridDungeonQuery_GetCellAtLocation");
static_assert(sizeof(GridDungeonQuery_GetCellAtLocation) == 0x000014, "Wrong size on GridDungeonQuery_GetCellAtLocation");
static_assert(offsetof(GridDungeonQuery_GetCellAtLocation, WorldLocation) == 0x000000, "Member 'GridDungeonQuery_GetCellAtLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellAtLocation, OutCellId) == 0x00000C, "Member 'GridDungeonQuery_GetCellAtLocation::OutCellId' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellAtLocation, bOutValid) == 0x000010, "Member 'GridDungeonQuery_GetCellAtLocation::bOutValid' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellDimension
// 0x001C (0x001C - 0x0000)
struct GridDungeonQuery_GetCellDimension final
{
public:
	int32                                         CellId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutCenter;                                         // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutSize;                                           // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetCellDimension) == 0x000004, "Wrong alignment on GridDungeonQuery_GetCellDimension");
static_assert(sizeof(GridDungeonQuery_GetCellDimension) == 0x00001C, "Wrong size on GridDungeonQuery_GetCellDimension");
static_assert(offsetof(GridDungeonQuery_GetCellDimension, CellId) == 0x000000, "Member 'GridDungeonQuery_GetCellDimension::CellId' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellDimension, OutCenter) == 0x000004, "Member 'GridDungeonQuery_GetCellDimension::OutCenter' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellDimension, OutSize) == 0x000010, "Member 'GridDungeonQuery_GetCellDimension::OutSize' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetCells
// 0x0010 (0x0010 - 0x0000)
struct GridDungeonQuery_GetCells final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetCells) == 0x000008, "Wrong alignment on GridDungeonQuery_GetCells");
static_assert(sizeof(GridDungeonQuery_GetCells) == 0x000010, "Wrong size on GridDungeonQuery_GetCells");
static_assert(offsetof(GridDungeonQuery_GetCells, ReturnValue) == 0x000000, "Member 'GridDungeonQuery_GetCells::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellsOfType
// 0x0018 (0x0018 - 0x0000)
struct GridDungeonQuery_GetCellsOfType final
{
public:
	EFCellType                                    CellType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetCellsOfType) == 0x000008, "Wrong alignment on GridDungeonQuery_GetCellsOfType");
static_assert(sizeof(GridDungeonQuery_GetCellsOfType) == 0x000018, "Wrong size on GridDungeonQuery_GetCellsOfType");
static_assert(offsetof(GridDungeonQuery_GetCellsOfType, CellType) == 0x000000, "Member 'GridDungeonQuery_GetCellsOfType::CellType' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellsOfType, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_GetCellsOfType::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellType
// 0x0008 (0x0008 - 0x0000)
struct GridDungeonQuery_GetCellType final
{
public:
	int32                                         CellId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFCellType                                    ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_GetCellType) == 0x000004, "Wrong alignment on GridDungeonQuery_GetCellType");
static_assert(sizeof(GridDungeonQuery_GetCellType) == 0x000008, "Wrong size on GridDungeonQuery_GetCellType");
static_assert(offsetof(GridDungeonQuery_GetCellType, CellId) == 0x000000, "Member 'GridDungeonQuery_GetCellType::CellId' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetCellType, ReturnValue) == 0x000004, "Member 'GridDungeonQuery_GetCellType::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetDoorBetween
// 0x002C (0x002C - 0x0000)
struct GridDungeonQuery_GetDoorBetween final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCellDoor                              ReturnValue;                                       // 0x0008(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetDoorBetween) == 0x000004, "Wrong alignment on GridDungeonQuery_GetDoorBetween");
static_assert(sizeof(GridDungeonQuery_GetDoorBetween) == 0x00002C, "Wrong size on GridDungeonQuery_GetDoorBetween");
static_assert(offsetof(GridDungeonQuery_GetDoorBetween, CellA) == 0x000000, "Member 'GridDungeonQuery_GetDoorBetween::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetDoorBetween, CellB) == 0x000004, "Member 'GridDungeonQuery_GetDoorBetween::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetDoorBetween, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_GetDoorBetween::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetFurthestRooms
// 0x0008 (0x0008 - 0x0000)
struct GridDungeonQuery_GetFurthestRooms final
{
public:
	int32                                         OutRoomA;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutRoomB;                                          // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetFurthestRooms) == 0x000004, "Wrong alignment on GridDungeonQuery_GetFurthestRooms");
static_assert(sizeof(GridDungeonQuery_GetFurthestRooms) == 0x000008, "Wrong size on GridDungeonQuery_GetFurthestRooms");
static_assert(offsetof(GridDungeonQuery_GetFurthestRooms, OutRoomA) == 0x000000, "Member 'GridDungeonQuery_GetFurthestRooms::OutRoomA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetFurthestRooms, OutRoomB) == 0x000004, "Member 'GridDungeonQuery_GetFurthestRooms::OutRoomB' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetOpeningPointBetweenAdjacentCells
// 0x0014 (0x0014 - 0x0000)
struct GridDungeonQuery_GetOpeningPointBetweenAdjacentCells final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetOpeningPointBetweenAdjacentCells) == 0x000004, "Wrong alignment on GridDungeonQuery_GetOpeningPointBetweenAdjacentCells");
static_assert(sizeof(GridDungeonQuery_GetOpeningPointBetweenAdjacentCells) == 0x000014, "Wrong size on GridDungeonQuery_GetOpeningPointBetweenAdjacentCells");
static_assert(offsetof(GridDungeonQuery_GetOpeningPointBetweenAdjacentCells, CellA) == 0x000000, "Member 'GridDungeonQuery_GetOpeningPointBetweenAdjacentCells::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetOpeningPointBetweenAdjacentCells, CellB) == 0x000004, "Member 'GridDungeonQuery_GetOpeningPointBetweenAdjacentCells::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetOpeningPointBetweenAdjacentCells, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_GetOpeningPointBetweenAdjacentCells::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetPathBetweenCells
// 0x0020 (0x0020 - 0x0000)
struct GridDungeonQuery_GetPathBetweenCells final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 OutResult;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOutSuccess;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_GetPathBetweenCells) == 0x000008, "Wrong alignment on GridDungeonQuery_GetPathBetweenCells");
static_assert(sizeof(GridDungeonQuery_GetPathBetweenCells) == 0x000020, "Wrong size on GridDungeonQuery_GetPathBetweenCells");
static_assert(offsetof(GridDungeonQuery_GetPathBetweenCells, CellA) == 0x000000, "Member 'GridDungeonQuery_GetPathBetweenCells::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetPathBetweenCells, CellB) == 0x000004, "Member 'GridDungeonQuery_GetPathBetweenCells::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetPathBetweenCells, OutResult) == 0x000008, "Member 'GridDungeonQuery_GetPathBetweenCells::OutResult' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetPathBetweenCells, bOutSuccess) == 0x000018, "Member 'GridDungeonQuery_GetPathBetweenCells::bOutSuccess' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCell
// 0x0004 (0x0004 - 0x0000)
struct GridDungeonQuery_GetRandomCell final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetRandomCell) == 0x000004, "Wrong alignment on GridDungeonQuery_GetRandomCell");
static_assert(sizeof(GridDungeonQuery_GetRandomCell) == 0x000004, "Wrong size on GridDungeonQuery_GetRandomCell");
static_assert(offsetof(GridDungeonQuery_GetRandomCell, ReturnValue) == 0x000000, "Member 'GridDungeonQuery_GetRandomCell::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellFromStream
// 0x000C (0x000C - 0x0000)
struct GridDungeonQuery_GetRandomCellFromStream final
{
public:
	struct FRandomStream                          RandomStream;                                      // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetRandomCellFromStream) == 0x000004, "Wrong alignment on GridDungeonQuery_GetRandomCellFromStream");
static_assert(sizeof(GridDungeonQuery_GetRandomCellFromStream) == 0x00000C, "Wrong size on GridDungeonQuery_GetRandomCellFromStream");
static_assert(offsetof(GridDungeonQuery_GetRandomCellFromStream, RandomStream) == 0x000000, "Member 'GridDungeonQuery_GetRandomCellFromStream::RandomStream' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetRandomCellFromStream, ReturnValue) == 0x000008, "Member 'GridDungeonQuery_GetRandomCellFromStream::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellOfType
// 0x0008 (0x0008 - 0x0000)
struct GridDungeonQuery_GetRandomCellOfType final
{
public:
	EFCellType                                    CellType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetRandomCellOfType) == 0x000004, "Wrong alignment on GridDungeonQuery_GetRandomCellOfType");
static_assert(sizeof(GridDungeonQuery_GetRandomCellOfType) == 0x000008, "Wrong size on GridDungeonQuery_GetRandomCellOfType");
static_assert(offsetof(GridDungeonQuery_GetRandomCellOfType, CellType) == 0x000000, "Member 'GridDungeonQuery_GetRandomCellOfType::CellType' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetRandomCellOfType, ReturnValue) == 0x000004, "Member 'GridDungeonQuery_GetRandomCellOfType::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellOfTypeFromStream
// 0x0010 (0x0010 - 0x0000)
struct GridDungeonQuery_GetRandomCellOfTypeFromStream final
{
public:
	EFCellType                                    CellType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          RandomStream;                                      // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetRandomCellOfTypeFromStream) == 0x000004, "Wrong alignment on GridDungeonQuery_GetRandomCellOfTypeFromStream");
static_assert(sizeof(GridDungeonQuery_GetRandomCellOfTypeFromStream) == 0x000010, "Wrong size on GridDungeonQuery_GetRandomCellOfTypeFromStream");
static_assert(offsetof(GridDungeonQuery_GetRandomCellOfTypeFromStream, CellType) == 0x000000, "Member 'GridDungeonQuery_GetRandomCellOfTypeFromStream::CellType' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetRandomCellOfTypeFromStream, RandomStream) == 0x000004, "Member 'GridDungeonQuery_GetRandomCellOfTypeFromStream::RandomStream' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetRandomCellOfTypeFromStream, ReturnValue) == 0x00000C, "Member 'GridDungeonQuery_GetRandomCellOfTypeFromStream::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.GetStairBetween
// 0x0050 (0x0050 - 0x0000)
struct GridDungeonQuery_GetStairBetween final
{
public:
	int32                                         CellA;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellB;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStairInfo                             ReturnValue;                                       // 0x0010(0x0040)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonQuery_GetStairBetween) == 0x000010, "Wrong alignment on GridDungeonQuery_GetStairBetween");
static_assert(sizeof(GridDungeonQuery_GetStairBetween) == 0x000050, "Wrong size on GridDungeonQuery_GetStairBetween");
static_assert(offsetof(GridDungeonQuery_GetStairBetween, CellA) == 0x000000, "Member 'GridDungeonQuery_GetStairBetween::CellA' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetStairBetween, CellB) == 0x000004, "Member 'GridDungeonQuery_GetStairBetween::CellB' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_GetStairBetween, ReturnValue) == 0x000010, "Member 'GridDungeonQuery_GetStairBetween::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonQuery.IsNearMarker
// 0x0060 (0x0060 - 0x0000)
struct GridDungeonQuery_IsNearMarker final
{
public:
	struct FTransform                             CurrentMarkerTransform;                            // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 NearbyMarkerName;                                  // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearbyDistance;                                    // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonBuilder*                        Builder;                                           // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNear;                                           // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumFound;                                          // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonQuery_IsNearMarker) == 0x000010, "Wrong alignment on GridDungeonQuery_IsNearMarker");
static_assert(sizeof(GridDungeonQuery_IsNearMarker) == 0x000060, "Wrong size on GridDungeonQuery_IsNearMarker");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, CurrentMarkerTransform) == 0x000000, "Member 'GridDungeonQuery_IsNearMarker::CurrentMarkerTransform' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, NearbyMarkerName) == 0x000030, "Member 'GridDungeonQuery_IsNearMarker::NearbyMarkerName' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, NearbyDistance) == 0x000040, "Member 'GridDungeonQuery_IsNearMarker::NearbyDistance' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, Builder) == 0x000048, "Member 'GridDungeonQuery_IsNearMarker::Builder' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, bIsNear) == 0x000050, "Member 'GridDungeonQuery_IsNearMarker::bIsNear' has a wrong offset!");
static_assert(offsetof(GridDungeonQuery_IsNearMarker, NumFound) == 0x000054, "Member 'GridDungeonQuery_IsNearMarker::NumFound' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.ContainsStair
// 0x0070 (0x0070 - 0x0000)
struct GridDungeonSelectorLogic_ContainsStair final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCell                                  Cell;                                              // 0x0008(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonSelectorLogic_ContainsStair) == 0x000008, "Wrong alignment on GridDungeonSelectorLogic_ContainsStair");
static_assert(sizeof(GridDungeonSelectorLogic_ContainsStair) == 0x000070, "Wrong size on GridDungeonSelectorLogic_ContainsStair");
static_assert(offsetof(GridDungeonSelectorLogic_ContainsStair, Model) == 0x000000, "Member 'GridDungeonSelectorLogic_ContainsStair::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_ContainsStair, Cell) == 0x000008, "Member 'GridDungeonSelectorLogic_ContainsStair::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_ContainsStair, GridX) == 0x000060, "Member 'GridDungeonSelectorLogic_ContainsStair::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_ContainsStair, GridY) == 0x000064, "Member 'GridDungeonSelectorLogic_ContainsStair::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_ContainsStair, ReturnValue) == 0x000068, "Member 'GridDungeonSelectorLogic_ContainsStair::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsOnCorner
// 0x0018 (0x0018 - 0x0000)
struct GridDungeonSelectorLogic_IsOnCorner final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonSelectorLogic_IsOnCorner) == 0x000008, "Wrong alignment on GridDungeonSelectorLogic_IsOnCorner");
static_assert(sizeof(GridDungeonSelectorLogic_IsOnCorner) == 0x000018, "Wrong size on GridDungeonSelectorLogic_IsOnCorner");
static_assert(offsetof(GridDungeonSelectorLogic_IsOnCorner, Model) == 0x000000, "Member 'GridDungeonSelectorLogic_IsOnCorner::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsOnCorner, GridX) == 0x000008, "Member 'GridDungeonSelectorLogic_IsOnCorner::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsOnCorner, GridY) == 0x00000C, "Member 'GridDungeonSelectorLogic_IsOnCorner::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsOnCorner, ReturnValue) == 0x000010, "Member 'GridDungeonSelectorLogic_IsOnCorner::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsPassageTooNarrow
// 0x0018 (0x0018 - 0x0000)
struct GridDungeonSelectorLogic_IsPassageTooNarrow final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonSelectorLogic_IsPassageTooNarrow) == 0x000008, "Wrong alignment on GridDungeonSelectorLogic_IsPassageTooNarrow");
static_assert(sizeof(GridDungeonSelectorLogic_IsPassageTooNarrow) == 0x000018, "Wrong size on GridDungeonSelectorLogic_IsPassageTooNarrow");
static_assert(offsetof(GridDungeonSelectorLogic_IsPassageTooNarrow, Model) == 0x000000, "Member 'GridDungeonSelectorLogic_IsPassageTooNarrow::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPassageTooNarrow, GridX) == 0x000008, "Member 'GridDungeonSelectorLogic_IsPassageTooNarrow::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPassageTooNarrow, GridY) == 0x00000C, "Member 'GridDungeonSelectorLogic_IsPassageTooNarrow::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPassageTooNarrow, ReturnValue) == 0x000010, "Member 'GridDungeonSelectorLogic_IsPassageTooNarrow::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsPillarOnCorner
// 0x0050 (0x0050 - 0x0000)
struct GridDungeonSelectorLogic_IsPillarOnCorner final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutCornerOffset;                                   // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonSelectorLogic_IsPillarOnCorner) == 0x000010, "Wrong alignment on GridDungeonSelectorLogic_IsPillarOnCorner");
static_assert(sizeof(GridDungeonSelectorLogic_IsPillarOnCorner) == 0x000050, "Wrong size on GridDungeonSelectorLogic_IsPillarOnCorner");
static_assert(offsetof(GridDungeonSelectorLogic_IsPillarOnCorner, Model) == 0x000000, "Member 'GridDungeonSelectorLogic_IsPillarOnCorner::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPillarOnCorner, GridX) == 0x000008, "Member 'GridDungeonSelectorLogic_IsPillarOnCorner::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPillarOnCorner, GridY) == 0x00000C, "Member 'GridDungeonSelectorLogic_IsPillarOnCorner::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPillarOnCorner, OutCornerOffset) == 0x000010, "Member 'GridDungeonSelectorLogic_IsPillarOnCorner::OutCornerOffset' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_IsPillarOnCorner, ReturnValue) == 0x000040, "Member 'GridDungeonSelectorLogic_IsPillarOnCorner::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.SelectNode
// 0x00D0 (0x00D0 - 0x0000)
struct GridDungeonSelectorLogic_SelectNode final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonConfig*                     Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonBuilder*                    Builder;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonQuery*                      Query;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCell                                  Cell;                                              // 0x0020(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0078(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MarkerTransform;                                   // 0x0090(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridDungeonSelectorLogic_SelectNode) == 0x000010, "Wrong alignment on GridDungeonSelectorLogic_SelectNode");
static_assert(sizeof(GridDungeonSelectorLogic_SelectNode) == 0x0000D0, "Wrong size on GridDungeonSelectorLogic_SelectNode");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, Model) == 0x000000, "Member 'GridDungeonSelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, Config) == 0x000008, "Member 'GridDungeonSelectorLogic_SelectNode::Config' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, Builder) == 0x000010, "Member 'GridDungeonSelectorLogic_SelectNode::Builder' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, Query) == 0x000018, "Member 'GridDungeonSelectorLogic_SelectNode::Query' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, Cell) == 0x000020, "Member 'GridDungeonSelectorLogic_SelectNode::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, RandomStream) == 0x000078, "Member 'GridDungeonSelectorLogic_SelectNode::RandomStream' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, GridX) == 0x000080, "Member 'GridDungeonSelectorLogic_SelectNode::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, GridY) == 0x000084, "Member 'GridDungeonSelectorLogic_SelectNode::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, MarkerTransform) == 0x000090, "Member 'GridDungeonSelectorLogic_SelectNode::MarkerTransform' has a wrong offset!");
static_assert(offsetof(GridDungeonSelectorLogic_SelectNode, ReturnValue) == 0x0000C0, "Member 'GridDungeonSelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridDungeonTransformLogic.GetNodeOffset
// 0x00F0 (0x00F0 - 0x0000)
struct GridDungeonTransformLogic_GetNodeOffset final
{
public:
	class UGridDungeonModel*                      Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonConfig*                     Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonBuilder*                    Builder;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridDungeonQuery*                      Query;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCell                                  Cell;                                              // 0x0020(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0078(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MarkerTransform;                                   // 0x0090(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x00C0(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridDungeonTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on GridDungeonTransformLogic_GetNodeOffset");
static_assert(sizeof(GridDungeonTransformLogic_GetNodeOffset) == 0x0000F0, "Wrong size on GridDungeonTransformLogic_GetNodeOffset");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'GridDungeonTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Config) == 0x000008, "Member 'GridDungeonTransformLogic_GetNodeOffset::Config' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Builder) == 0x000010, "Member 'GridDungeonTransformLogic_GetNodeOffset::Builder' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Query) == 0x000018, "Member 'GridDungeonTransformLogic_GetNodeOffset::Query' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Cell) == 0x000020, "Member 'GridDungeonTransformLogic_GetNodeOffset::Cell' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, RandomStream) == 0x000078, "Member 'GridDungeonTransformLogic_GetNodeOffset::RandomStream' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, GridX) == 0x000080, "Member 'GridDungeonTransformLogic_GetNodeOffset::GridX' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, GridY) == 0x000084, "Member 'GridDungeonTransformLogic_GetNodeOffset::GridY' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, MarkerTransform) == 0x000090, "Member 'GridDungeonTransformLogic_GetNodeOffset::MarkerTransform' has a wrong offset!");
static_assert(offsetof(GridDungeonTransformLogic_GetNodeOffset, Offset) == 0x0000C0, "Member 'GridDungeonTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtLayoutNode
// 0x0040 (0x0040 - 0x0000)
struct GridFlowQuery_GetChunkAtLayoutNode final
{
public:
	const class UFlowAbstractNode*                InLayoutNode;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGridFlowChunkQueryResult              Result;                                            // 0x0008(0x0038)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowQuery_GetChunkAtLayoutNode) == 0x000008, "Wrong alignment on GridFlowQuery_GetChunkAtLayoutNode");
static_assert(sizeof(GridFlowQuery_GetChunkAtLayoutNode) == 0x000040, "Wrong size on GridFlowQuery_GetChunkAtLayoutNode");
static_assert(offsetof(GridFlowQuery_GetChunkAtLayoutNode, InLayoutNode) == 0x000000, "Member 'GridFlowQuery_GetChunkAtLayoutNode::InLayoutNode' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetChunkAtLayoutNode, Result) == 0x000008, "Member 'GridFlowQuery_GetChunkAtLayoutNode::Result' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.IsNearMarker
// 0x0060 (0x0060 - 0x0000)
struct GridFlowQuery_IsNearMarker final
{
public:
	struct FTransform                             CurrentMarkerTransform;                            // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 NearbyMarkerName;                                  // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearbyDistance;                                    // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDungeonBuilder*                        Builder;                                           // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNear;                                           // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumFound;                                          // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_IsNearMarker) == 0x000010, "Wrong alignment on GridFlowQuery_IsNearMarker");
static_assert(sizeof(GridFlowQuery_IsNearMarker) == 0x000060, "Wrong size on GridFlowQuery_IsNearMarker");
static_assert(offsetof(GridFlowQuery_IsNearMarker, CurrentMarkerTransform) == 0x000000, "Member 'GridFlowQuery_IsNearMarker::CurrentMarkerTransform' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_IsNearMarker, NearbyMarkerName) == 0x000030, "Member 'GridFlowQuery_IsNearMarker::NearbyMarkerName' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_IsNearMarker, NearbyDistance) == 0x000040, "Member 'GridFlowQuery_IsNearMarker::NearbyDistance' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_IsNearMarker, Builder) == 0x000048, "Member 'GridFlowQuery_IsNearMarker::Builder' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_IsNearMarker, bIsNear) == 0x000050, "Member 'GridFlowQuery_IsNearMarker::bIsNear' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_IsNearMarker, NumFound) == 0x000054, "Member 'GridFlowQuery_IsNearMarker::NumFound' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.ConvertTileToWorldCoord
// 0x0018 (0x0018 - 0x0000)
struct GridFlowQuery_ConvertTileToWorldCoord final
{
public:
	struct FVector                                TileCoord;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowQuery_ConvertTileToWorldCoord) == 0x000004, "Wrong alignment on GridFlowQuery_ConvertTileToWorldCoord");
static_assert(sizeof(GridFlowQuery_ConvertTileToWorldCoord) == 0x000018, "Wrong size on GridFlowQuery_ConvertTileToWorldCoord");
static_assert(offsetof(GridFlowQuery_ConvertTileToWorldCoord, TileCoord) == 0x000000, "Member 'GridFlowQuery_ConvertTileToWorldCoord::TileCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_ConvertTileToWorldCoord, ReturnValue) == 0x00000C, "Member 'GridFlowQuery_ConvertTileToWorldCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.ConvertWorldToTileCoord
// 0x0018 (0x0018 - 0x0000)
struct GridFlowQuery_ConvertWorldToTileCoord final
{
public:
	struct FVector                                WorldCoords;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowQuery_ConvertWorldToTileCoord) == 0x000004, "Wrong alignment on GridFlowQuery_ConvertWorldToTileCoord");
static_assert(sizeof(GridFlowQuery_ConvertWorldToTileCoord) == 0x000018, "Wrong size on GridFlowQuery_ConvertWorldToTileCoord");
static_assert(offsetof(GridFlowQuery_ConvertWorldToTileCoord, WorldCoords) == 0x000000, "Member 'GridFlowQuery_ConvertWorldToTileCoord::WorldCoords' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_ConvertWorldToTileCoord, ReturnValue) == 0x00000C, "Member 'GridFlowQuery_ConvertWorldToTileCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetCellAtTileCoord
// 0x00F0 (0x00F0 - 0x0000)
struct GridFlowQuery_GetCellAtTileCoord final
{
public:
	struct FVector                                TileCoord;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCell                   OutCell;                                           // 0x0010(0x00D8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_GetCellAtTileCoord) == 0x000008, "Wrong alignment on GridFlowQuery_GetCellAtTileCoord");
static_assert(sizeof(GridFlowQuery_GetCellAtTileCoord) == 0x0000F0, "Wrong size on GridFlowQuery_GetCellAtTileCoord");
static_assert(offsetof(GridFlowQuery_GetCellAtTileCoord, TileCoord) == 0x000000, "Member 'GridFlowQuery_GetCellAtTileCoord::TileCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellAtTileCoord, OutCell) == 0x000010, "Member 'GridFlowQuery_GetCellAtTileCoord::OutCell' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellAtTileCoord, ReturnValue) == 0x0000E8, "Member 'GridFlowQuery_GetCellAtTileCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetCellAtWorldCoord
// 0x00F0 (0x00F0 - 0x0000)
struct GridFlowQuery_GetCellAtWorldCoord final
{
public:
	struct FVector                                WorldCoord;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowTilemapCell                   OutCell;                                           // 0x0010(0x00D8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_GetCellAtWorldCoord) == 0x000008, "Wrong alignment on GridFlowQuery_GetCellAtWorldCoord");
static_assert(sizeof(GridFlowQuery_GetCellAtWorldCoord) == 0x0000F0, "Wrong size on GridFlowQuery_GetCellAtWorldCoord");
static_assert(offsetof(GridFlowQuery_GetCellAtWorldCoord, WorldCoord) == 0x000000, "Member 'GridFlowQuery_GetCellAtWorldCoord::WorldCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellAtWorldCoord, OutCell) == 0x000010, "Member 'GridFlowQuery_GetCellAtWorldCoord::OutCell' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellAtWorldCoord, ReturnValue) == 0x0000E8, "Member 'GridFlowQuery_GetCellAtWorldCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetCellRoomType
// 0x0010 (0x0010 - 0x0000)
struct GridFlowQuery_GetCellRoomType final
{
public:
	struct FVector                                WorldCoord;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGridFlowAbstractNodeRoomType                 OutRoomType;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_GetCellRoomType) == 0x000004, "Wrong alignment on GridFlowQuery_GetCellRoomType");
static_assert(sizeof(GridFlowQuery_GetCellRoomType) == 0x000010, "Wrong size on GridFlowQuery_GetCellRoomType");
static_assert(offsetof(GridFlowQuery_GetCellRoomType, WorldCoord) == 0x000000, "Member 'GridFlowQuery_GetCellRoomType::WorldCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellRoomType, OutRoomType) == 0x00000C, "Member 'GridFlowQuery_GetCellRoomType::OutRoomType' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetCellRoomType, ReturnValue) == 0x00000D, "Member 'GridFlowQuery_GetCellRoomType::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtWorldCoord
// 0x0050 (0x0050 - 0x0000)
struct GridFlowQuery_GetChunkAtWorldCoord final
{
public:
	struct FVector                                InWorldCoord;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowChunkQueryResult              Result;                                            // 0x0010(0x0038)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_GetChunkAtWorldCoord) == 0x000008, "Wrong alignment on GridFlowQuery_GetChunkAtWorldCoord");
static_assert(sizeof(GridFlowQuery_GetChunkAtWorldCoord) == 0x000050, "Wrong size on GridFlowQuery_GetChunkAtWorldCoord");
static_assert(offsetof(GridFlowQuery_GetChunkAtWorldCoord, InWorldCoord) == 0x000000, "Member 'GridFlowQuery_GetChunkAtWorldCoord::InWorldCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetChunkAtWorldCoord, Result) == 0x000010, "Member 'GridFlowQuery_GetChunkAtWorldCoord::Result' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetChunkAtWorldCoord, ReturnValue) == 0x000048, "Member 'GridFlowQuery_GetChunkAtWorldCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetFreeTileLocation
// 0x0028 (0x0028 - 0x0000)
struct GridFlowQuery_GetFreeTileLocation final
{
public:
	TArray<EGridFlowAbstractNodeRoomType>         AllowedRoomTypes;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRandomStream                          Random;                                            // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          OutSuccess;                                        // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutWorldCoord;                                     // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowQuery_GetFreeTileLocation) == 0x000008, "Wrong alignment on GridFlowQuery_GetFreeTileLocation");
static_assert(sizeof(GridFlowQuery_GetFreeTileLocation) == 0x000028, "Wrong size on GridFlowQuery_GetFreeTileLocation");
static_assert(offsetof(GridFlowQuery_GetFreeTileLocation, AllowedRoomTypes) == 0x000000, "Member 'GridFlowQuery_GetFreeTileLocation::AllowedRoomTypes' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetFreeTileLocation, Random) == 0x000010, "Member 'GridFlowQuery_GetFreeTileLocation::Random' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetFreeTileLocation, OutSuccess) == 0x000018, "Member 'GridFlowQuery_GetFreeTileLocation::OutSuccess' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetFreeTileLocation, OutWorldCoord) == 0x00001C, "Member 'GridFlowQuery_GetFreeTileLocation::OutWorldCoord' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetAllChunksOfType
// 0x0018 (0x0018 - 0x0000)
struct GridFlowQuery_GetAllChunksOfType final
{
public:
	EGridFlowAbstractNodeRoomType                 RoomType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGridFlowChunkQueryResult>      OutChunks;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowQuery_GetAllChunksOfType) == 0x000008, "Wrong alignment on GridFlowQuery_GetAllChunksOfType");
static_assert(sizeof(GridFlowQuery_GetAllChunksOfType) == 0x000018, "Wrong size on GridFlowQuery_GetAllChunksOfType");
static_assert(offsetof(GridFlowQuery_GetAllChunksOfType, RoomType) == 0x000000, "Member 'GridFlowQuery_GetAllChunksOfType::RoomType' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetAllChunksOfType, OutChunks) == 0x000008, "Member 'GridFlowQuery_GetAllChunksOfType::OutChunks' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtLayoutNodeCoord
// 0x0050 (0x0050 - 0x0000)
struct GridFlowQuery_GetChunkAtLayoutNodeCoord final
{
public:
	struct FVector                                InLayoutNodeCoord;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGridFlowChunkQueryResult              Result;                                            // 0x0010(0x0038)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowQuery_GetChunkAtLayoutNodeCoord) == 0x000008, "Wrong alignment on GridFlowQuery_GetChunkAtLayoutNodeCoord");
static_assert(sizeof(GridFlowQuery_GetChunkAtLayoutNodeCoord) == 0x000050, "Wrong size on GridFlowQuery_GetChunkAtLayoutNodeCoord");
static_assert(offsetof(GridFlowQuery_GetChunkAtLayoutNodeCoord, InLayoutNodeCoord) == 0x000000, "Member 'GridFlowQuery_GetChunkAtLayoutNodeCoord::InLayoutNodeCoord' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetChunkAtLayoutNodeCoord, Result) == 0x000010, "Member 'GridFlowQuery_GetChunkAtLayoutNodeCoord::Result' has a wrong offset!");
static_assert(offsetof(GridFlowQuery_GetChunkAtLayoutNodeCoord, ReturnValue) == 0x000048, "Member 'GridFlowQuery_GetChunkAtLayoutNodeCoord::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowSelectorLogic.SelectNode
// 0x0070 (0x0070 - 0x0000)
struct GridFlowSelectorLogic_SelectNode final
{
public:
	class UGridFlowModel*                         Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowConfig*                        Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowBuilder*                       Builder;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowQuery*                         Query;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0020(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TileX;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileY;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MarkerTransform;                                   // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridFlowSelectorLogic_SelectNode) == 0x000010, "Wrong alignment on GridFlowSelectorLogic_SelectNode");
static_assert(sizeof(GridFlowSelectorLogic_SelectNode) == 0x000070, "Wrong size on GridFlowSelectorLogic_SelectNode");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, Model) == 0x000000, "Member 'GridFlowSelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, Config) == 0x000008, "Member 'GridFlowSelectorLogic_SelectNode::Config' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, Builder) == 0x000010, "Member 'GridFlowSelectorLogic_SelectNode::Builder' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, Query) == 0x000018, "Member 'GridFlowSelectorLogic_SelectNode::Query' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, RandomStream) == 0x000020, "Member 'GridFlowSelectorLogic_SelectNode::RandomStream' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, TileX) == 0x000028, "Member 'GridFlowSelectorLogic_SelectNode::TileX' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, TileY) == 0x00002C, "Member 'GridFlowSelectorLogic_SelectNode::TileY' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, MarkerTransform) == 0x000030, "Member 'GridFlowSelectorLogic_SelectNode::MarkerTransform' has a wrong offset!");
static_assert(offsetof(GridFlowSelectorLogic_SelectNode, ReturnValue) == 0x000060, "Member 'GridFlowSelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.GridFlowTransformLogic.GetNodeOffset
// 0x0060 (0x0060 - 0x0000)
struct GridFlowTransformLogic_GetNodeOffset final
{
public:
	class UGridFlowModel*                         Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowConfig*                        Config;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridFlowQuery*                         Query;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GridX;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridY;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0030(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridFlowTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on GridFlowTransformLogic_GetNodeOffset");
static_assert(sizeof(GridFlowTransformLogic_GetNodeOffset) == 0x000060, "Wrong size on GridFlowTransformLogic_GetNodeOffset");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'GridFlowTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, Config) == 0x000008, "Member 'GridFlowTransformLogic_GetNodeOffset::Config' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, Query) == 0x000010, "Member 'GridFlowTransformLogic_GetNodeOffset::Query' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, RandomStream) == 0x000018, "Member 'GridFlowTransformLogic_GetNodeOffset::RandomStream' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, GridX) == 0x000020, "Member 'GridFlowTransformLogic_GetNodeOffset::GridX' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, GridY) == 0x000024, "Member 'GridFlowTransformLogic_GetNodeOffset::GridY' has a wrong offset!");
static_assert(offsetof(GridFlowTransformLogic_GetNodeOffset, Offset) == 0x000030, "Member 'GridFlowTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonModel.RemoveStylingFromRoom
// 0x0004 (0x0004 - 0x0000)
struct IsaacDungeonModel_RemoveStylingFromRoom final
{
public:
	int32                                         RoomId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonModel_RemoveStylingFromRoom) == 0x000004, "Wrong alignment on IsaacDungeonModel_RemoveStylingFromRoom");
static_assert(sizeof(IsaacDungeonModel_RemoveStylingFromRoom) == 0x000004, "Wrong size on IsaacDungeonModel_RemoveStylingFromRoom");
static_assert(offsetof(IsaacDungeonModel_RemoveStylingFromRoom, RoomId) == 0x000000, "Member 'IsaacDungeonModel_RemoveStylingFromRoom::RoomId' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonQuery.ContainsDoorBetween
// 0x000C (0x000C - 0x0000)
struct IsaacDungeonQuery_ContainsDoorBetween final
{
public:
	int32                                         RoomAId;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomBId;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(IsaacDungeonQuery_ContainsDoorBetween) == 0x000004, "Wrong alignment on IsaacDungeonQuery_ContainsDoorBetween");
static_assert(sizeof(IsaacDungeonQuery_ContainsDoorBetween) == 0x00000C, "Wrong size on IsaacDungeonQuery_ContainsDoorBetween");
static_assert(offsetof(IsaacDungeonQuery_ContainsDoorBetween, RoomAId) == 0x000000, "Member 'IsaacDungeonQuery_ContainsDoorBetween::RoomAId' has a wrong offset!");
static_assert(offsetof(IsaacDungeonQuery_ContainsDoorBetween, RoomBId) == 0x000004, "Member 'IsaacDungeonQuery_ContainsDoorBetween::RoomBId' has a wrong offset!");
static_assert(offsetof(IsaacDungeonQuery_ContainsDoorBetween, ReturnValue) == 0x000008, "Member 'IsaacDungeonQuery_ContainsDoorBetween::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetFurthestRooms
// 0x0008 (0x0008 - 0x0000)
struct IsaacDungeonQuery_GetFurthestRooms final
{
public:
	int32                                         OutRoomA;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutRoomB;                                          // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonQuery_GetFurthestRooms) == 0x000004, "Wrong alignment on IsaacDungeonQuery_GetFurthestRooms");
static_assert(sizeof(IsaacDungeonQuery_GetFurthestRooms) == 0x000008, "Wrong size on IsaacDungeonQuery_GetFurthestRooms");
static_assert(offsetof(IsaacDungeonQuery_GetFurthestRooms, OutRoomA) == 0x000000, "Member 'IsaacDungeonQuery_GetFurthestRooms::OutRoomA' has a wrong offset!");
static_assert(offsetof(IsaacDungeonQuery_GetFurthestRooms, OutRoomB) == 0x000004, "Member 'IsaacDungeonQuery_GetFurthestRooms::OutRoomB' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetRandomValidPlatform
// 0x000C (0x000C - 0x0000)
struct IsaacDungeonQuery_GetRandomValidPlatform final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonQuery_GetRandomValidPlatform) == 0x000004, "Wrong alignment on IsaacDungeonQuery_GetRandomValidPlatform");
static_assert(sizeof(IsaacDungeonQuery_GetRandomValidPlatform) == 0x00000C, "Wrong size on IsaacDungeonQuery_GetRandomValidPlatform");
static_assert(offsetof(IsaacDungeonQuery_GetRandomValidPlatform, ReturnValue) == 0x000000, "Member 'IsaacDungeonQuery_GetRandomValidPlatform::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetRoom
// 0x0058 (0x0058 - 0x0000)
struct IsaacDungeonQuery_GetRoom final
{
public:
	int32                                         RoomId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIsaacRoom                             ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonQuery_GetRoom) == 0x000008, "Wrong alignment on IsaacDungeonQuery_GetRoom");
static_assert(sizeof(IsaacDungeonQuery_GetRoom) == 0x000058, "Wrong size on IsaacDungeonQuery_GetRoom");
static_assert(offsetof(IsaacDungeonQuery_GetRoom, RoomId) == 0x000000, "Member 'IsaacDungeonQuery_GetRoom::RoomId' has a wrong offset!");
static_assert(offsetof(IsaacDungeonQuery_GetRoom, ReturnValue) == 0x000008, "Member 'IsaacDungeonQuery_GetRoom::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetValidPlatformOnRoom
// 0x0010 (0x0010 - 0x0000)
struct IsaacDungeonQuery_GetValidPlatformOnRoom final
{
public:
	int32                                         RoomId;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonQuery_GetValidPlatformOnRoom) == 0x000004, "Wrong alignment on IsaacDungeonQuery_GetValidPlatformOnRoom");
static_assert(sizeof(IsaacDungeonQuery_GetValidPlatformOnRoom) == 0x000010, "Wrong size on IsaacDungeonQuery_GetValidPlatformOnRoom");
static_assert(offsetof(IsaacDungeonQuery_GetValidPlatformOnRoom, RoomId) == 0x000000, "Member 'IsaacDungeonQuery_GetValidPlatformOnRoom::RoomId' has a wrong offset!");
static_assert(offsetof(IsaacDungeonQuery_GetValidPlatformOnRoom, ReturnValue) == 0x000004, "Member 'IsaacDungeonQuery_GetValidPlatformOnRoom::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonSelectorLogic.SelectNode
// 0x0010 (0x0010 - 0x0000)
struct IsaacDungeonSelectorLogic_SelectNode final
{
public:
	class UIsaacDungeonModel*                     Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(IsaacDungeonSelectorLogic_SelectNode) == 0x000008, "Wrong alignment on IsaacDungeonSelectorLogic_SelectNode");
static_assert(sizeof(IsaacDungeonSelectorLogic_SelectNode) == 0x000010, "Wrong size on IsaacDungeonSelectorLogic_SelectNode");
static_assert(offsetof(IsaacDungeonSelectorLogic_SelectNode, Model) == 0x000000, "Member 'IsaacDungeonSelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(IsaacDungeonSelectorLogic_SelectNode, ReturnValue) == 0x000008, "Member 'IsaacDungeonSelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.IsaacDungeonTransformLogic.GetNodeOffset
// 0x0040 (0x0040 - 0x0000)
struct IsaacDungeonTransformLogic_GetNodeOffset final
{
public:
	class UIsaacDungeonModel*                     Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(IsaacDungeonTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on IsaacDungeonTransformLogic_GetNodeOffset");
static_assert(sizeof(IsaacDungeonTransformLogic_GetNodeOffset) == 0x000040, "Wrong size on IsaacDungeonTransformLogic_GetNodeOffset");
static_assert(offsetof(IsaacDungeonTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'IsaacDungeonTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(IsaacDungeonTransformLogic_GetNodeOffset, Offset) == 0x000010, "Member 'IsaacDungeonTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.SimpleCitySelectorLogic.SelectNode
// 0x0010 (0x0010 - 0x0000)
struct SimpleCitySelectorLogic_SelectNode final
{
public:
	class USimpleCityModel*                       Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SimpleCitySelectorLogic_SelectNode) == 0x000008, "Wrong alignment on SimpleCitySelectorLogic_SelectNode");
static_assert(sizeof(SimpleCitySelectorLogic_SelectNode) == 0x000010, "Wrong size on SimpleCitySelectorLogic_SelectNode");
static_assert(offsetof(SimpleCitySelectorLogic_SelectNode, Model) == 0x000000, "Member 'SimpleCitySelectorLogic_SelectNode::Model' has a wrong offset!");
static_assert(offsetof(SimpleCitySelectorLogic_SelectNode, ReturnValue) == 0x000008, "Member 'SimpleCitySelectorLogic_SelectNode::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.SimpleCityTransformLogic.GetNodeOffset
// 0x0040 (0x0040 - 0x0000)
struct SimpleCityTransformLogic_GetNodeOffset final
{
public:
	class USimpleCityModel*                       Model;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SimpleCityTransformLogic_GetNodeOffset) == 0x000010, "Wrong alignment on SimpleCityTransformLogic_GetNodeOffset");
static_assert(sizeof(SimpleCityTransformLogic_GetNodeOffset) == 0x000040, "Wrong size on SimpleCityTransformLogic_GetNodeOffset");
static_assert(offsetof(SimpleCityTransformLogic_GetNodeOffset, Model) == 0x000000, "Member 'SimpleCityTransformLogic_GetNodeOffset::Model' has a wrong offset!");
static_assert(offsetof(SimpleCityTransformLogic_GetNodeOffset, Offset) == 0x000010, "Member 'SimpleCityTransformLogic_GetNodeOffset::Offset' has a wrong offset!");

// Function DungeonArchitectRuntime.SnapConnectionActor.GetSpawnedInstances
// 0x0010 (0x0010 - 0x0000)
struct SnapConnectionActor_GetSpawnedInstances final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SnapConnectionActor_GetSpawnedInstances) == 0x000008, "Wrong alignment on SnapConnectionActor_GetSpawnedInstances");
static_assert(sizeof(SnapConnectionActor_GetSpawnedInstances) == 0x000010, "Wrong size on SnapConnectionActor_GetSpawnedInstances");
static_assert(offsetof(SnapConnectionActor_GetSpawnedInstances, ReturnValue) == 0x000000, "Member 'SnapConnectionActor_GetSpawnedInstances::ReturnValue' has a wrong offset!");

// Function DungeonArchitectRuntime.SnapFlowNodeCategorySelectionOverride.TryOverrideCategories
// 0x0030 (0x0030 - 0x0000)
struct SnapFlowNodeCategorySelectionOverride_TryOverrideCategories final
{
public:
	int32                                         PathIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathLength;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExistingCategories;                                // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutNewCategories;                                  // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories) == 0x000008, "Wrong alignment on SnapFlowNodeCategorySelectionOverride_TryOverrideCategories");
static_assert(sizeof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories) == 0x000030, "Wrong size on SnapFlowNodeCategorySelectionOverride_TryOverrideCategories");
static_assert(offsetof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories, PathIndex) == 0x000000, "Member 'SnapFlowNodeCategorySelectionOverride_TryOverrideCategories::PathIndex' has a wrong offset!");
static_assert(offsetof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories, PathLength) == 0x000004, "Member 'SnapFlowNodeCategorySelectionOverride_TryOverrideCategories::PathLength' has a wrong offset!");
static_assert(offsetof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories, ExistingCategories) == 0x000008, "Member 'SnapFlowNodeCategorySelectionOverride_TryOverrideCategories::ExistingCategories' has a wrong offset!");
static_assert(offsetof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories, OutNewCategories) == 0x000018, "Member 'SnapFlowNodeCategorySelectionOverride_TryOverrideCategories::OutNewCategories' has a wrong offset!");
static_assert(offsetof(SnapFlowNodeCategorySelectionOverride_TryOverrideCategories, ReturnValue) == 0x000028, "Member 'SnapFlowNodeCategorySelectionOverride_TryOverrideCategories::ReturnValue' has a wrong offset!");

}


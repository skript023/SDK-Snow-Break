#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RichmanOL

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "RichmanOL_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "ChessMap_classes.hpp"
#include "MiniGame_classes.hpp"


namespace SDK
{

// Class RichmanOL.RichmanOL_AIController
// 0x0038 (0x02D8 - 0x02A0)
class ARichmanOL_AIController final : public AController
{
public:
	class ARichmanOL_Character*                   CurrentChar;                                       // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Mgr*                         RichmanMgr;                                        // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUIMode;                                          // 0x02B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            TempMovement;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitCallback;                                      // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x17];                                     // 0x02C1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExplosiveContinueMove();
	void ExplosiveFinishMove();
	void FixRotation();
	void RemoveMoveGroundTip();
	void ResetRichmanState();
	void ShowDirEffect();
	void StopMovementImmediately();

	class ARichmanOL_Character* GetCurrentChar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_AIController">();
	}
	static class ARichmanOL_AIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_AIController>();
	}
};
static_assert(alignof(ARichmanOL_AIController) == 0x000008, "Wrong alignment on ARichmanOL_AIController");
static_assert(sizeof(ARichmanOL_AIController) == 0x0002D8, "Wrong size on ARichmanOL_AIController");
static_assert(offsetof(ARichmanOL_AIController, CurrentChar) == 0x0002A0, "Member 'ARichmanOL_AIController::CurrentChar' has a wrong offset!");
static_assert(offsetof(ARichmanOL_AIController, RichmanMgr) == 0x0002A8, "Member 'ARichmanOL_AIController::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_AIController, IsUIMode) == 0x0002B0, "Member 'ARichmanOL_AIController::IsUIMode' has a wrong offset!");
static_assert(offsetof(ARichmanOL_AIController, TempMovement) == 0x0002B8, "Member 'ARichmanOL_AIController::TempMovement' has a wrong offset!");
static_assert(offsetof(ARichmanOL_AIController, WaitCallback) == 0x0002C0, "Member 'ARichmanOL_AIController::WaitCallback' has a wrong offset!");

// Class RichmanOL.RichmanOL_AnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class URichmanOL_AnimInstance final : public UAnimInstance
{
public:
	bool                                          IsPush;                                            // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRun;                                             // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWalk;                                            // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceToMoveDir;                                  // 0x02BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToControllerAngle;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleHorizontalSpeed;                              // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpeed;                                   // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_AnimInstance">();
	}
	static class URichmanOL_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanOL_AnimInstance>();
	}
};
static_assert(alignof(URichmanOL_AnimInstance) == 0x000010, "Wrong alignment on URichmanOL_AnimInstance");
static_assert(sizeof(URichmanOL_AnimInstance) == 0x0002D0, "Wrong size on URichmanOL_AnimInstance");
static_assert(offsetof(URichmanOL_AnimInstance, IsPush) == 0x0002B8, "Member 'URichmanOL_AnimInstance::IsPush' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, IsRun) == 0x0002B9, "Member 'URichmanOL_AnimInstance::IsRun' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, IsWalk) == 0x0002BA, "Member 'URichmanOL_AnimInstance::IsWalk' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, bIsFaceToMoveDir) == 0x0002BB, "Member 'URichmanOL_AnimInstance::bIsFaceToMoveDir' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, Speed) == 0x0002BC, "Member 'URichmanOL_AnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, MoveToControllerAngle) == 0x0002C0, "Member 'URichmanOL_AnimInstance::MoveToControllerAngle' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, ScaleHorizontalSpeed) == 0x0002C4, "Member 'URichmanOL_AnimInstance::ScaleHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, HorizontalSpeed) == 0x0002C8, "Member 'URichmanOL_AnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(URichmanOL_AnimInstance, MaxSpeed) == 0x0002CC, "Member 'URichmanOL_AnimInstance::MaxSpeed' has a wrong offset!");

// Class RichmanOL.AnimNotify_OnRichmanOL_FootLanding
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnRichmanOL_FootLanding final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnRichmanOL_FootLanding">();
	}
	static class UAnimNotify_OnRichmanOL_FootLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnRichmanOL_FootLanding>();
	}
};
static_assert(alignof(UAnimNotify_OnRichmanOL_FootLanding) == 0x000008, "Wrong alignment on UAnimNotify_OnRichmanOL_FootLanding");
static_assert(sizeof(UAnimNotify_OnRichmanOL_FootLanding) == 0x000038, "Wrong size on UAnimNotify_OnRichmanOL_FootLanding");

// Class RichmanOL.RichmanOL_CameraFollow
// 0x00F8 (0x0320 - 0x0228)
class ARichmanOL_CameraFollow final : public AActor
{
public:
	class AActor*                                 Target;                                            // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Mgr*                         RichmanMgr;                                        // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FollowActor;                                       // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_PlayerController*            PlayerController;                                  // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ShowTarget;                                        // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  CentralActor;                                      // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanOL_CameraFollowType                   FollowType;                                        // 0x0258(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxViewSize;                                       // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinViewSize;                                       // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightShowDistance;                                 // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerformSpeed;                                      // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowZoom;                                           // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CameraInitPos;                                     // 0x0270(0x0030)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraReturnDelay;                                 // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraReturnDuration;                              // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x78];                                     // 0x02A8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAutoFollowComplete();
	bool GetLockControl();
	bool IsSlidingView();
	void OnInit();
	void OnMouseMove(const struct FVector2D& DeltaPos);
	void OnZoomChange(float InZoom);
	void PlayReturnAnim(float Duration);
	void RefreshCameraRange(class AChessRegion* Region);
	void ResetCamera();
	void SetCameraShowTarget(class AActor* InTarget);
	void SetCentralActor();
	void SetFollowTarget(class AActor* InCharacter, bool Immediately);
	void SetLockControl(bool InLockControl);
	void SetSlidingView(bool bSlid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_CameraFollow">();
	}
	static class ARichmanOL_CameraFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_CameraFollow>();
	}
};
static_assert(alignof(ARichmanOL_CameraFollow) == 0x000010, "Wrong alignment on ARichmanOL_CameraFollow");
static_assert(sizeof(ARichmanOL_CameraFollow) == 0x000320, "Wrong size on ARichmanOL_CameraFollow");
static_assert(offsetof(ARichmanOL_CameraFollow, Target) == 0x000228, "Member 'ARichmanOL_CameraFollow::Target' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, RichmanMgr) == 0x000230, "Member 'ARichmanOL_CameraFollow::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, FollowActor) == 0x000238, "Member 'ARichmanOL_CameraFollow::FollowActor' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, PlayerController) == 0x000240, "Member 'ARichmanOL_CameraFollow::PlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, ShowTarget) == 0x000248, "Member 'ARichmanOL_CameraFollow::ShowTarget' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, CentralActor) == 0x000250, "Member 'ARichmanOL_CameraFollow::CentralActor' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, FollowType) == 0x000258, "Member 'ARichmanOL_CameraFollow::FollowType' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, MaxViewSize) == 0x00025C, "Member 'ARichmanOL_CameraFollow::MaxViewSize' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, MinViewSize) == 0x000260, "Member 'ARichmanOL_CameraFollow::MinViewSize' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, LightShowDistance) == 0x000264, "Member 'ARichmanOL_CameraFollow::LightShowDistance' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, PerformSpeed) == 0x000268, "Member 'ARichmanOL_CameraFollow::PerformSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, NowZoom) == 0x00026C, "Member 'ARichmanOL_CameraFollow::NowZoom' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, CameraInitPos) == 0x000270, "Member 'ARichmanOL_CameraFollow::CameraInitPos' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, CameraReturnDelay) == 0x0002A0, "Member 'ARichmanOL_CameraFollow::CameraReturnDelay' has a wrong offset!");
static_assert(offsetof(ARichmanOL_CameraFollow, CameraReturnDuration) == 0x0002A4, "Member 'ARichmanOL_CameraFollow::CameraReturnDuration' has a wrong offset!");

// Class RichmanOL.RichmanOL_Character
// 0x0170 (0x0640 - 0x04D0)
class ARichmanOL_Character final : public AChessNpcBase
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TplId;                                             // 0x04D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uid;                                               // 0x04D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillIDs;                                          // 0x04D8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	int32                                         Charge;                                            // 0x04E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharge;                                         // 0x04EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Money;                                             // 0x04F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildScore;                                        // 0x04F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuessValue;                                        // 0x04F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuessIndex;                                        // 0x04FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAutoPlay;                                        // 0x0500(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InOperation;                                       // 0x0501(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_502[0x2];                                      // 0x0502(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StateCode;                                         // 0x0504(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsland;                                          // 0x0508(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EscapeIslandCount;                                 // 0x050C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentUseCardId;                                  // 0x0510(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  SkillTarget;                                       // 0x0514(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Star1Value;                                        // 0x051C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Star2Value;                                        // 0x0520(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Star3Value;                                        // 0x0524(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BitFlag;                                           // 0x0528(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionID;                                          // 0x052C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRichmanOL_SkillEffect>         Effects;                                           // 0x0530(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsAI;                                              // 0x0540(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0548(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerFaceId;                                      // 0x0558(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerFrameId;                                     // 0x055C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueNetId;                                       // 0x0560(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocalPlayer;                                     // 0x0570(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DoubleCount;                                       // 0x0574(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextMoveStep;                                      // 0x0578(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NextRoundTravel;                                   // 0x057C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57D[0x3];                                      // 0x057D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AChessGround>            BornGround;                                        // 0x0580(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AChessGround>            CurrentBuyGround;                                  // 0x0588(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveSkills;                                     // 0x0590(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class ARichmanOL_Mgr*                         RichmanMgr;                                        // 0x05A0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddPassiveSkillRate;                               // 0x05A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalOfflineTime;                                  // 0x05AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalAutoTime;                                     // 0x05B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URichmanOL_PlayerMovementComponent*     CharMoveComp;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegionId;                                          // 0x05C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_PlayerController*            PlayerController;                                  // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_AIController*                AIController;                                      // 0x05D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRun;                                             // 0x05D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWalk;                                            // 0x05D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRounding;                                        // 0x05DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasTransfer;                                       // 0x05DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookingAtCamera;                                 // 0x05DC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DD[0x3];                                      // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TopEffectId;                                       // 0x05E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugSkillRate;                                    // 0x05E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x14];                                     // 0x05E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllRotateLerpSeconds;                              // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageHappy;                                      // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageSad;                                        // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageJump;                                       // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageJumpend;                                    // 0x0618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageGreeting;                                   // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageSkill;                                      // 0x0628(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeed;                                      // 0x0630(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0xC];                                      // 0x0634(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCharge(int32 InValue);
	void AddEffect(const struct FRichmanOL_SkillEffect& Effect);
	bool AddMoney(int32 InValue);
	void DestroyTopEffect();
	void ForceSetSkillActive(int32 InSkillId, bool InValue);
	class FString GetHeadIconId();
	class FString GetLangNameKey();
	int32 GetNpcUID();
	struct FIntVector GetPosition();
	int32 GetRegionId();
	int32 GetStarValue(int32 Idx);
	bool HasActiveEffect(class FName EffectName, int32* InSkillId, int32* InParam);
	bool HasEffectByName(class FName EffectName);
	void LuaImpl_NotifyInIslandChanged(bool InValue);
	void LuaImpl_NotifyInitSkills(const struct FRichmanOL_PlayerData& InData);
	void LuaImpl_NotifyMoveEnd(class ARichmanOL_ChessGround* InGround);
	void LuaImpl_NotifyThroughBornGround();
	void Multicast_DoExpression(int32 ExpressionId, int32 InRoleID);
	TArray<int32> NotifyEffectStage(ERichmanOL_FlowStage InStage, float Effective);
	void OnRep_ActionId();
	void OnRep_AutoPlay();
	void OnRep_BuildScore();
	void OnRep_Charge();
	void OnRep_GuessValue();
	void OnRep_InIsland();
	void OnRep_InOperation();
	void OnRep_Money();
	void OnRep_SkillIds();
	void OnRep_StateCode();
	void PlayTopEffect(int32 ID);
	void RemoveEffectByName(class FName InName);
	void RemoveEffectBySkillId(int32 SkillID);
	void ResetPosition();
	void SetActionId(int32 InActionId);
	void SetAutoPlay(bool InValue);
	void SetBitFlag(int32 InValue);
	void SetBuildScore(int32 InValue);
	void SetCharge(int32 InValue);
	void SetCurrentUseCardId(int32 InValue);
	void SetDebugSkillRate(int32 InValue);
	void SetGroundActor(class AChessGround* InGroundActor);
	void SetGuessIndex(int32 InValue);
	void SetGuessValue(int32 InValue);
	void SetInIsland(bool InValue);
	void SetInOperation(bool InValue);
	void SetMaxCharge(int32 InValue);
	void SetMoney(int32 InValue);
	void SetSkillIds(const TArray<int32>& InValue);
	void SetStarValue(int32 Idx, int32 Value);
	void SetStateCode(int32 InValue);
	void StartMoving(int32 Steps);
	void Teleport(class ARichmanOL_ChessGround* InDestGround);
	void UpdateStandingGround();
	void UpdateWalkState(bool IsRun_0, bool IsWalk_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_Character">();
	}
	static class ARichmanOL_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_Character>();
	}
};
static_assert(alignof(ARichmanOL_Character) == 0x000010, "Wrong alignment on ARichmanOL_Character");
static_assert(sizeof(ARichmanOL_Character) == 0x000640, "Wrong size on ARichmanOL_Character");
static_assert(offsetof(ARichmanOL_Character, TplId) == 0x0004D0, "Member 'ARichmanOL_Character::TplId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Uid) == 0x0004D4, "Member 'ARichmanOL_Character::Uid' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, SkillIDs) == 0x0004D8, "Member 'ARichmanOL_Character::SkillIDs' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Charge) == 0x0004E8, "Member 'ARichmanOL_Character::Charge' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MaxCharge) == 0x0004EC, "Member 'ARichmanOL_Character::MaxCharge' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Money) == 0x0004F0, "Member 'ARichmanOL_Character::Money' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, BuildScore) == 0x0004F4, "Member 'ARichmanOL_Character::BuildScore' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, GuessValue) == 0x0004F8, "Member 'ARichmanOL_Character::GuessValue' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, GuessIndex) == 0x0004FC, "Member 'ARichmanOL_Character::GuessIndex' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsAutoPlay) == 0x000500, "Member 'ARichmanOL_Character::IsAutoPlay' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, InOperation) == 0x000501, "Member 'ARichmanOL_Character::InOperation' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, StateCode) == 0x000504, "Member 'ARichmanOL_Character::StateCode' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, InIsland) == 0x000508, "Member 'ARichmanOL_Character::InIsland' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, EscapeIslandCount) == 0x00050C, "Member 'ARichmanOL_Character::EscapeIslandCount' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, CurrentUseCardId) == 0x000510, "Member 'ARichmanOL_Character::CurrentUseCardId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, SkillTarget) == 0x000514, "Member 'ARichmanOL_Character::SkillTarget' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Star1Value) == 0x00051C, "Member 'ARichmanOL_Character::Star1Value' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Star2Value) == 0x000520, "Member 'ARichmanOL_Character::Star2Value' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Star3Value) == 0x000524, "Member 'ARichmanOL_Character::Star3Value' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, BitFlag) == 0x000528, "Member 'ARichmanOL_Character::BitFlag' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, ActionID) == 0x00052C, "Member 'ARichmanOL_Character::ActionID' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, Effects) == 0x000530, "Member 'ARichmanOL_Character::Effects' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsAI) == 0x000540, "Member 'ARichmanOL_Character::IsAI' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, PlayerName) == 0x000548, "Member 'ARichmanOL_Character::PlayerName' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, PlayerFaceId) == 0x000558, "Member 'ARichmanOL_Character::PlayerFaceId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, PlayerFrameId) == 0x00055C, "Member 'ARichmanOL_Character::PlayerFrameId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, UniqueNetId) == 0x000560, "Member 'ARichmanOL_Character::UniqueNetId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsLocalPlayer) == 0x000570, "Member 'ARichmanOL_Character::IsLocalPlayer' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, DoubleCount) == 0x000574, "Member 'ARichmanOL_Character::DoubleCount' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, NextMoveStep) == 0x000578, "Member 'ARichmanOL_Character::NextMoveStep' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, NextRoundTravel) == 0x00057C, "Member 'ARichmanOL_Character::NextRoundTravel' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, BornGround) == 0x000580, "Member 'ARichmanOL_Character::BornGround' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, CurrentBuyGround) == 0x000588, "Member 'ARichmanOL_Character::CurrentBuyGround' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, PassiveSkills) == 0x000590, "Member 'ARichmanOL_Character::PassiveSkills' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, RichmanMgr) == 0x0005A0, "Member 'ARichmanOL_Character::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, AddPassiveSkillRate) == 0x0005A8, "Member 'ARichmanOL_Character::AddPassiveSkillRate' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, TotalOfflineTime) == 0x0005AC, "Member 'ARichmanOL_Character::TotalOfflineTime' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, TotalAutoTime) == 0x0005B0, "Member 'ARichmanOL_Character::TotalAutoTime' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, CharMoveComp) == 0x0005B8, "Member 'ARichmanOL_Character::CharMoveComp' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, RegionId) == 0x0005C0, "Member 'ARichmanOL_Character::RegionId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, PlayerController) == 0x0005C8, "Member 'ARichmanOL_Character::PlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, AIController) == 0x0005D0, "Member 'ARichmanOL_Character::AIController' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsRun) == 0x0005D8, "Member 'ARichmanOL_Character::IsRun' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsWalk) == 0x0005D9, "Member 'ARichmanOL_Character::IsWalk' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsRounding) == 0x0005DA, "Member 'ARichmanOL_Character::IsRounding' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, HasTransfer) == 0x0005DB, "Member 'ARichmanOL_Character::HasTransfer' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, IsLookingAtCamera) == 0x0005DC, "Member 'ARichmanOL_Character::IsLookingAtCamera' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, TopEffectId) == 0x0005E0, "Member 'ARichmanOL_Character::TopEffectId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, DebugSkillRate) == 0x0005E4, "Member 'ARichmanOL_Character::DebugSkillRate' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, AllRotateLerpSeconds) == 0x0005FC, "Member 'ARichmanOL_Character::AllRotateLerpSeconds' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageHappy) == 0x000600, "Member 'ARichmanOL_Character::MontageHappy' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageSad) == 0x000608, "Member 'ARichmanOL_Character::MontageSad' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageJump) == 0x000610, "Member 'ARichmanOL_Character::MontageJump' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageJumpend) == 0x000618, "Member 'ARichmanOL_Character::MontageJumpend' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageGreeting) == 0x000620, "Member 'ARichmanOL_Character::MontageGreeting' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MontageSkill) == 0x000628, "Member 'ARichmanOL_Character::MontageSkill' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Character, MaxWalkSpeed) == 0x000630, "Member 'ARichmanOL_Character::MaxWalkSpeed' has a wrong offset!");

// Class RichmanOL.RichmanOL_ChessGround
// 0x0080 (0x02F8 - 0x0278)
class ARichmanOL_ChessGround final : public AChessGround
{
public:
	int32                                         Distance;                                          // 0x0278(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroundIndex;                                       // 0x027C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_BuildingObject*              BuildingObject;                                    // 0x0280(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TollMultiplier;                                    // 0x0288(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsColorMonopoly;                                   // 0x028C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillTollMultiplier;                               // 0x0290(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillTollMultiplierEnemy;                          // 0x0294(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanOL_BuildingDirection                  BuildingDirection;                                 // 0x0298(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReduceTollMultUntilArrive;                         // 0x029C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReduceTollMultUntilArriveEnemy;                    // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PowerOffUntilArrive;                               // 0x02A4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TollFreeUntilArrive;                               // 0x02A5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6[0x2];                                      // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PosOffset;                                         // 0x02A8(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotation;                                    // 0x02B4(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ARichmanOL_Character>> GroundCharacters;                                  // 0x02C0(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARichmanOL_Mgr>          RichmanMgr;                                        // 0x02D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             NormalMaterials;                                   // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         TopEffectId;                                       // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckObjectHasTag(const class FString& InTagName);
	void DestroyBuilding();
	class ARichmanOL_BuildingObject* GetBuilding();
	class AChessObject* GetFirstObjectByTag(const class FString& InTagName);
	bool IsInFrontOfBuilding(class ARichmanOL_BuildingObject* InBuilding);
	void NotifyCharacterEntry(class ARichmanOL_Character* InCharacter, bool IsMoving);
	void NotifyCharacterLeave(class ARichmanOL_Character* InCharacter);
	void OnRep_IsColorMonopoly();
	void SetColorMonopoly(bool InValue);
	void SetSkillTollMultiplier(float InSkillTollMultiplier);
	void SetSkillTollMultiplierEnemy(float InSkillTollMultiplier);
	void UpdateTollMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_ChessGround">();
	}
	static class ARichmanOL_ChessGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_ChessGround>();
	}
};
static_assert(alignof(ARichmanOL_ChessGround) == 0x000008, "Wrong alignment on ARichmanOL_ChessGround");
static_assert(sizeof(ARichmanOL_ChessGround) == 0x0002F8, "Wrong size on ARichmanOL_ChessGround");
static_assert(offsetof(ARichmanOL_ChessGround, Distance) == 0x000278, "Member 'ARichmanOL_ChessGround::Distance' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, GroundIndex) == 0x00027C, "Member 'ARichmanOL_ChessGround::GroundIndex' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, BuildingObject) == 0x000280, "Member 'ARichmanOL_ChessGround::BuildingObject' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, TollMultiplier) == 0x000288, "Member 'ARichmanOL_ChessGround::TollMultiplier' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, IsColorMonopoly) == 0x00028C, "Member 'ARichmanOL_ChessGround::IsColorMonopoly' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, SkillTollMultiplier) == 0x000290, "Member 'ARichmanOL_ChessGround::SkillTollMultiplier' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, SkillTollMultiplierEnemy) == 0x000294, "Member 'ARichmanOL_ChessGround::SkillTollMultiplierEnemy' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, BuildingDirection) == 0x000298, "Member 'ARichmanOL_ChessGround::BuildingDirection' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, ReduceTollMultUntilArrive) == 0x00029C, "Member 'ARichmanOL_ChessGround::ReduceTollMultUntilArrive' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, ReduceTollMultUntilArriveEnemy) == 0x0002A0, "Member 'ARichmanOL_ChessGround::ReduceTollMultUntilArriveEnemy' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, PowerOffUntilArrive) == 0x0002A4, "Member 'ARichmanOL_ChessGround::PowerOffUntilArrive' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, TollFreeUntilArrive) == 0x0002A5, "Member 'ARichmanOL_ChessGround::TollFreeUntilArrive' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, PosOffset) == 0x0002A8, "Member 'ARichmanOL_ChessGround::PosOffset' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, PlayerRotation) == 0x0002B4, "Member 'ARichmanOL_ChessGround::PlayerRotation' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, GroundCharacters) == 0x0002C0, "Member 'ARichmanOL_ChessGround::GroundCharacters' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, RichmanMgr) == 0x0002D0, "Member 'ARichmanOL_ChessGround::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, MeshComponent) == 0x0002D8, "Member 'ARichmanOL_ChessGround::MeshComponent' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, NormalMaterials) == 0x0002E0, "Member 'ARichmanOL_ChessGround::NormalMaterials' has a wrong offset!");
static_assert(offsetof(ARichmanOL_ChessGround, TopEffectId) == 0x0002F0, "Member 'ARichmanOL_ChessGround::TopEffectId' has a wrong offset!");

// Class RichmanOL.RichmanOL_ChessObject
// 0x0000 (0x0258 - 0x0258)
class ARichmanOL_ChessObject : public AChessObject
{
public:
	class FString GetTagParam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_ChessObject">();
	}
	static class ARichmanOL_ChessObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_ChessObject>();
	}
};
static_assert(alignof(ARichmanOL_ChessObject) == 0x000008, "Wrong alignment on ARichmanOL_ChessObject");
static_assert(sizeof(ARichmanOL_ChessObject) == 0x000258, "Wrong size on ARichmanOL_ChessObject");

// Class RichmanOL.RichmanOL_BuildingObject
// 0x0090 (0x02E8 - 0x0258)
class ARichmanOL_BuildingObject final : public ARichmanOL_ChessObject
{
public:
	class ARichmanOL_BuildingObject*              ParentBuilding;                                    // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_BuildingObject*              ChildBuilding;                                     // 0x0260(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComponent;                                     // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             NormalMaterials;                                   // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UMeshComponent*                         ChildMeshComponent;                                // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             ChildNormalMaterials;                              // 0x0290(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARichmanOL_Mgr>          RichmanMgr;                                        // 0x02A0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   OwnerCharacter;                                    // 0x02A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitGroundMeshHeight;                              // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_ChessGround*                 ParentGround;                                      // 0x02B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MyMaterial;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EnemyMaterial;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FuncAnim;                                          // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectId;                                          // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeOwner(class ARichmanOL_Character* InOwner);
	int32 GetBuildingLevel();
	ERichmanOL_BuildingType GetBuildingType();
	int32 GetChildTplId();
	class ARichmanOL_Character* GetOwnerCharacter();
	void OnRep_OnChildBuildingChange();
	void OnRep_OnOwnerChange();
	void SetLevel(int32 InLevel, class ARichmanOL_Character* InOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_BuildingObject">();
	}
	static class ARichmanOL_BuildingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_BuildingObject>();
	}
};
static_assert(alignof(ARichmanOL_BuildingObject) == 0x000008, "Wrong alignment on ARichmanOL_BuildingObject");
static_assert(sizeof(ARichmanOL_BuildingObject) == 0x0002E8, "Wrong size on ARichmanOL_BuildingObject");
static_assert(offsetof(ARichmanOL_BuildingObject, ParentBuilding) == 0x000258, "Member 'ARichmanOL_BuildingObject::ParentBuilding' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, ChildBuilding) == 0x000260, "Member 'ARichmanOL_BuildingObject::ChildBuilding' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, MeshComponent) == 0x000268, "Member 'ARichmanOL_BuildingObject::MeshComponent' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, SkeletalMeshComponent) == 0x000270, "Member 'ARichmanOL_BuildingObject::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, NormalMaterials) == 0x000278, "Member 'ARichmanOL_BuildingObject::NormalMaterials' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, ChildMeshComponent) == 0x000288, "Member 'ARichmanOL_BuildingObject::ChildMeshComponent' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, ChildNormalMaterials) == 0x000290, "Member 'ARichmanOL_BuildingObject::ChildNormalMaterials' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, RichmanMgr) == 0x0002A0, "Member 'ARichmanOL_BuildingObject::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, OwnerCharacter) == 0x0002A8, "Member 'ARichmanOL_BuildingObject::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, Level) == 0x0002B0, "Member 'ARichmanOL_BuildingObject::Level' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, InitGroundMeshHeight) == 0x0002B4, "Member 'ARichmanOL_BuildingObject::InitGroundMeshHeight' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, ParentGround) == 0x0002B8, "Member 'ARichmanOL_BuildingObject::ParentGround' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, MyMaterial) == 0x0002C0, "Member 'ARichmanOL_BuildingObject::MyMaterial' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, EnemyMaterial) == 0x0002C8, "Member 'ARichmanOL_BuildingObject::EnemyMaterial' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, IdleAnim) == 0x0002D0, "Member 'ARichmanOL_BuildingObject::IdleAnim' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, FuncAnim) == 0x0002D8, "Member 'ARichmanOL_BuildingObject::FuncAnim' has a wrong offset!");
static_assert(offsetof(ARichmanOL_BuildingObject, EffectId) == 0x0002E0, "Member 'ARichmanOL_BuildingObject::EffectId' has a wrong offset!");

// Class RichmanOL.RichmanOL_Library
// 0x0000 (0x0028 - 0x0028)
class URichmanOL_Library final : public UBlueprintFunctionLibrary
{
public:
	static void AdjustMap(class AChessRegion* Region);
	static bool CheckSingleMonopoly(class ARichmanOL_Mgr* InMgr, class ARichmanOL_Character* InCharacter, class ARichmanOL_ChessGround* InGMGround, int32* NeedCount, TArray<class ARichmanOL_ChessGround*>* Grounds);
	static class ARichmanOL_BuildingObject* FindBuildingById(class ARichmanOL_Mgr* InMgr, int32 ID);
	static class ARichmanOL_ChessGround* FindGroundById(class ARichmanOL_Mgr* InMgr, int64 Uid);
	static class AChessGround* FindGroundByPos(class ARichmanOL_Mgr* InMgr, int32 PosX, int32 PosY);
	static class ARichmanOL_ChessGround* FindGroundByUID(class ARichmanOL_Mgr* InMgr, int64 Uid);
	static TArray<class ARichmanOL_ChessGround*> FindGroundListByType(class ARichmanOL_Character* InMe, ERichmanOL_GroundType InType);
	static class AChessObject* FindObjectById(class ARichmanOL_Mgr* InMgr, int64 Uid);
	static class ARichmanOL_BuildingObject* GetBuildingByType(class ARichmanOL_Mgr* InMgr, ERichmanOL_BuildingType InType);
	static ERichmanOL_BuildingType GetBuildingType(int32 TplId);
	static TArray<class ARichmanOL_BuildingObject*> GetCharacterBuildings(class ARichmanOL_Mgr* InMgr, class ARichmanOL_Character* InCharacter, int32 MinLevel, int32 MaxLevel);
	static int32 GetDiceThrow(int32 Max, int32 Min);
	static class ARichmanOL_ChessGround* GetGroundByBuildingType(class ARichmanOL_Mgr* InMgr, ERichmanOL_BuildingType InType);
	static int32 GetMonopolyColorCount(class ARichmanOL_Mgr* InMgr, class ARichmanOL_Character* InCharacter, class ARichmanOL_ChessGround* InGMGround, TArray<class ARichmanOL_ChessGround*>* Grounds, int32* InMinNeed);
	static int32 GetNpcActiveSkillId(class ARichmanOL_Mgr* InMgr, int32 NpcId);
	static int32 GetObjectIcon(class ARichmanOL_Mgr* InMgr, int32 TplId);
	static class FString GetObjectName(class ARichmanOL_Mgr* InMgr, int32 TplId);
	static bool IsClient(class AActor* Owner);
	static bool IsDS(class AActor* Owner);
	static bool IsStandalone(class AActor* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_Library">();
	}
	static class URichmanOL_Library* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanOL_Library>();
	}
};
static_assert(alignof(URichmanOL_Library) == 0x000008, "Wrong alignment on URichmanOL_Library");
static_assert(sizeof(URichmanOL_Library) == 0x000028, "Wrong size on URichmanOL_Library");

// Class RichmanOL.RichmanOL_Local
// 0x01A8 (0x03D0 - 0x0228)
class ARichmanOL_Local final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStepDistance;                                   // 0x0230(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepAnimTime;                                   // 0x0234(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepAnimDelay;                                     // 0x0238(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_PlayerController*            PlayerController;                                  // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_CameraFollow*                CameraFollow;                                      // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Mgr*                         Mgr;                                               // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   Me;                                                // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   Enemy;                                             // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInitOk;                                          // 0x0268(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLuaInitOk;                                       // 0x0269(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A[0x6];                                      // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UFXSystemComponent*>        AllEffects;                                        // 0x0270(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x110];                                    // 0x02C0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyEffect(int32 InEffectId);
	class UFXSystemComponent* FindEffectById(int32 InId);
	bool LuaImpl_CheckInitOK();
	void LuaImpl_NotifyColorMonopoly(class ARichmanOL_ChessGround* InGround);
	void LuaImpl_NotifyEntrySpecialBuilding(ERichmanOL_BuildingType InType, class ARichmanOL_BuildingObject* InBuilding);
	void LuaImpl_NotifyGroundBuildingChanged(class ARichmanOL_BuildingObject* InBuilding);
	void LuaImpl_NotifyInitSuccess();
	void LuaImpl_NotifyLuaTick(float InDeltaTime);
	void LuaImpl_NotifyMoveToGround(class ARichmanOL_ChessGround* InGround);
	void LuaImpl_NotifyRefreshUI(class ARichmanOL_Character* InCharacter, ERichmanOL_RefreshUIType InType);
	void LuaImpl_ShowExpression(int32 ExpressionId, int32 InRoleID);
	int32 PlayEffect(const class FString& InPath, const struct FVector& InLocation, const struct FRotator& InRotate, const struct FVector& InScale, bool IsPersistent);
	int32 PlayEffectAttached(const class FString& InPath, class USceneComponent* AttachToComponent, const struct FVector& InLocation, const struct FRotator& InRotate, const struct FVector& InScale, bool IsPersistent);
	int32 PlayEffectAttachedById(int32 ID, class USceneComponent* AttachToComponent, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	int32 PlayEffectById(int32 ID, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	void PlayGroundClickAnim(class ARichmanOL_ChessGround* InGround);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_Local">();
	}
	static class ARichmanOL_Local* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_Local>();
	}
};
static_assert(alignof(ARichmanOL_Local) == 0x000008, "Wrong alignment on ARichmanOL_Local");
static_assert(sizeof(ARichmanOL_Local) == 0x0003D0, "Wrong size on ARichmanOL_Local");
static_assert(offsetof(ARichmanOL_Local, MaxStepDistance) == 0x000230, "Member 'ARichmanOL_Local::MaxStepDistance' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, MaxStepAnimTime) == 0x000234, "Member 'ARichmanOL_Local::MaxStepAnimTime' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, StepAnimDelay) == 0x000238, "Member 'ARichmanOL_Local::StepAnimDelay' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, PlayerController) == 0x000240, "Member 'ARichmanOL_Local::PlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, CameraFollow) == 0x000248, "Member 'ARichmanOL_Local::CameraFollow' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, Mgr) == 0x000250, "Member 'ARichmanOL_Local::Mgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, Me) == 0x000258, "Member 'ARichmanOL_Local::Me' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, Enemy) == 0x000260, "Member 'ARichmanOL_Local::Enemy' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, IsInitOk) == 0x000268, "Member 'ARichmanOL_Local::IsInitOk' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, IsLuaInitOk) == 0x000269, "Member 'ARichmanOL_Local::IsLuaInitOk' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Local, AllEffects) == 0x000270, "Member 'ARichmanOL_Local::AllEffects' has a wrong offset!");

// Class RichmanOL.RichmanOL_Mgr
// 0x02E8 (0x05A0 - 0x02B8)
class ARichmanOL_Mgr final : public AMiniGameHandler
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRichmanOL_PlayerData                  Player1Data;                                       // 0x02C0(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FRichmanOL_PlayerData                  Player2Data;                                       // 0x0300(0x0040)(Edit, NativeAccessSpecifierPublic)
	int32                                         TestLevelId;                                       // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestPlayerCount;                                   // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AChessMapActor*                         ChessMapActor;                                     // 0x0348(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARichmanOL_Character*>           AllCharacters;                                     // 0x0350(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VictoryScore;                                      // 0x0360(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerCount;                                       // 0x0364(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FightLevelID;                                      // 0x0368(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_Character*                   CurrentCharacter;                                  // 0x0370(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ShopCards;                                         // 0x0378(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         InitMoney;                                         // 0x0388(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllGrounds;                                        // 0x0390(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARichmanOL_AIController*>        AIControllers;                                     // 0x03A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AChessRegion*                           CurrentRegion;                                     // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDS;                                              // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClient;                                          // 0x03B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStandalone;                                      // 0x03BA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BB[0x1];                                      // 0x03BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterMoveSpeed;                                // 0x03BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   FirstCharacter;                                    // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   SecondCharacter;                                   // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanOL_FlowStage                          GameStage;                                         // 0x03D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x1];                                      // 0x03D1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         Round;                                             // 0x03D2(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         WinWay;                                            // 0x03D4(0x0002)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_Character*                   WinCharacter;                                      // 0x03D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSwitchAction;                                    // 0x03E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PosOffset;                                         // 0x03E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitNpcOffset1;                                    // 0x03E8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitNpcOffset2;                                    // 0x03F4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TollMultiplierWhenColorMonopoly;                   // 0x0400(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x10C];                                    // 0x0404(0x010C)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_Local*                       LocalPlayer;                                       // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x88];                                     // 0x0518(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ARichmanOL_Character* FindCharacterByUID(int32 Uid);
	void GetAllCharacters(TArray<class ARichmanOL_Character*>* InArray);
	void GetAllRichmanActor(TArray<class AChessObject*>* InArray);
	class ARichmanOL_Character* GetEnemyCharacter(class ARichmanOL_Character* InMe);
	void GotoStage(ERichmanOL_FlowStage InStage);
	void LuaImpl_NotifyEntryStage(ERichmanOL_FlowStage InStage);
	void LuaImpl_NotifyExitStage(ERichmanOL_FlowStage InStage);
	void LuaImpl_NotifyTick(float DeltaTime);
	void LuaImpl_Start();
	void OnRep_ChessMapActor();
	void OnRep_CurrentCharacter();
	void OnRep_FightLevelID();
	void OnRep_GameStage();
	void OnRep_Round();
	void ResetMap();
	void SetCurrentCharacter(class ARichmanOL_Character* InCharacter);
	void SetFightLevelID(int32 InId);
	void SetPlayerOrder(class ARichmanOL_Character* InFirst, class ARichmanOL_Character* InSecond);
	void SetRound(int32 InValue);
	void StartGame(int32 LevelID, const class FString& LevelPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_Mgr">();
	}
	static class ARichmanOL_Mgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_Mgr>();
	}
};
static_assert(alignof(ARichmanOL_Mgr) == 0x000008, "Wrong alignment on ARichmanOL_Mgr");
static_assert(sizeof(ARichmanOL_Mgr) == 0x0005A0, "Wrong size on ARichmanOL_Mgr");
static_assert(offsetof(ARichmanOL_Mgr, Player1Data) == 0x0002C0, "Member 'ARichmanOL_Mgr::Player1Data' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, Player2Data) == 0x000300, "Member 'ARichmanOL_Mgr::Player2Data' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, TestLevelId) == 0x000340, "Member 'ARichmanOL_Mgr::TestLevelId' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, TestPlayerCount) == 0x000344, "Member 'ARichmanOL_Mgr::TestPlayerCount' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, ChessMapActor) == 0x000348, "Member 'ARichmanOL_Mgr::ChessMapActor' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, AllCharacters) == 0x000350, "Member 'ARichmanOL_Mgr::AllCharacters' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, VictoryScore) == 0x000360, "Member 'ARichmanOL_Mgr::VictoryScore' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, PlayerCount) == 0x000364, "Member 'ARichmanOL_Mgr::PlayerCount' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, FightLevelID) == 0x000368, "Member 'ARichmanOL_Mgr::FightLevelID' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, CurrentCharacter) == 0x000370, "Member 'ARichmanOL_Mgr::CurrentCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, ShopCards) == 0x000378, "Member 'ARichmanOL_Mgr::ShopCards' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, InitMoney) == 0x000388, "Member 'ARichmanOL_Mgr::InitMoney' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, AllGrounds) == 0x000390, "Member 'ARichmanOL_Mgr::AllGrounds' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, AIControllers) == 0x0003A0, "Member 'ARichmanOL_Mgr::AIControllers' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, CurrentRegion) == 0x0003B0, "Member 'ARichmanOL_Mgr::CurrentRegion' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, IsDS) == 0x0003B8, "Member 'ARichmanOL_Mgr::IsDS' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, IsClient) == 0x0003B9, "Member 'ARichmanOL_Mgr::IsClient' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, IsStandalone) == 0x0003BA, "Member 'ARichmanOL_Mgr::IsStandalone' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, CharacterMoveSpeed) == 0x0003BC, "Member 'ARichmanOL_Mgr::CharacterMoveSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, FirstCharacter) == 0x0003C0, "Member 'ARichmanOL_Mgr::FirstCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, SecondCharacter) == 0x0003C8, "Member 'ARichmanOL_Mgr::SecondCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, GameStage) == 0x0003D0, "Member 'ARichmanOL_Mgr::GameStage' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, Round) == 0x0003D2, "Member 'ARichmanOL_Mgr::Round' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, WinWay) == 0x0003D4, "Member 'ARichmanOL_Mgr::WinWay' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, WinCharacter) == 0x0003D8, "Member 'ARichmanOL_Mgr::WinCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, IsSwitchAction) == 0x0003E0, "Member 'ARichmanOL_Mgr::IsSwitchAction' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, PosOffset) == 0x0003E4, "Member 'ARichmanOL_Mgr::PosOffset' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, InitNpcOffset1) == 0x0003E8, "Member 'ARichmanOL_Mgr::InitNpcOffset1' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, InitNpcOffset2) == 0x0003F4, "Member 'ARichmanOL_Mgr::InitNpcOffset2' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, TollMultiplierWhenColorMonopoly) == 0x000400, "Member 'ARichmanOL_Mgr::TollMultiplierWhenColorMonopoly' has a wrong offset!");
static_assert(offsetof(ARichmanOL_Mgr, LocalPlayer) == 0x000510, "Member 'ARichmanOL_Mgr::LocalPlayer' has a wrong offset!");

// Class RichmanOL.RichmanOL_PlayerController
// 0x0030 (0x05C8 - 0x0598)
class ARichmanOL_PlayerController final : public AMiniGamePlayerController
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_Mgr*                         RichmanMgr;                                        // 0x05A0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanOL_Character*                   CurrentCharacter;                                  // 0x05A8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoadingComplete;                                 // 0x05B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x17];                                     // 0x05B1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallClient(int32 InCmd, const class FString& InContent);
	void CallClient2(int32 InCmd, const class FString& InContent);
	void CallDS(int32 InCmd, const class FString& InContent);
	void CallDS2(int32 InCmd, const class FString& InContent);
	bool CanConsumeExpressionPoint();
	void ConsumeExpressionPoint();
	int32 GetBuyPrice(int32 SrcPrice);
	class AActor* GetClickActor(bool IgnoreGround);
	class ARichmanOL_Character* GetCurrentChar();
	int32 GetLevelUpPrice(int32 SrcPrice);
	int32 GetTollPrice(int32 SrcPrice);
	void GMServerCall(const class FString& FuncName, const class FString& InParam);
	void GMServerCallExec(const class FString& FuncName, const class FString& InParam);
	void LuaImpl_CallClientExec(int32 InCmd, const class FString& InContent);
	void LuaImpl_CallDSExec(int32 InCmd, const class FString& InContent);
	void NotifyClientLoadingComplete();
	void NotifyGiveupRoom();
	void OnTouch();
	void Server_RequestExpression(int32 ExpressionId);
	void SetMoveByMouse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_PlayerController">();
	}
	static class ARichmanOL_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanOL_PlayerController>();
	}
};
static_assert(alignof(ARichmanOL_PlayerController) == 0x000008, "Wrong alignment on ARichmanOL_PlayerController");
static_assert(sizeof(ARichmanOL_PlayerController) == 0x0005C8, "Wrong size on ARichmanOL_PlayerController");
static_assert(offsetof(ARichmanOL_PlayerController, RichmanMgr) == 0x0005A0, "Member 'ARichmanOL_PlayerController::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanOL_PlayerController, CurrentCharacter) == 0x0005A8, "Member 'ARichmanOL_PlayerController::CurrentCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanOL_PlayerController, IsLoadingComplete) == 0x0005B0, "Member 'ARichmanOL_PlayerController::IsLoadingComplete' has a wrong offset!");

// Class RichmanOL.RichmanOL_PlayerMovementComponent
// 0x0080 (0x0B80 - 0x0B00)
class URichmanOL_PlayerMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B00[0x20];                                     // 0x0B00(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanOL_Character*                   RichmanCharacter;                                  // 0x0B20(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AChessGround*>                   PathActors;                                        // 0x0B28(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AChessGround*                           LastShowDirGround;                                 // 0x0B38(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B40[0x40];                                     // 0x0B40(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoMove(const TArray<class AChessGround*>& Grounds);
	TArray<class AChessGround*> FindPathByGround(class AChessGround* InDest, int32 InType);
	TArray<class AChessGround*> FindPathByStep(int32 Steps);
	bool IsMoveComplete();
	void LookAtTarget(class AActor* InActor, bool Immediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanOL_PlayerMovementComponent">();
	}
	static class URichmanOL_PlayerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanOL_PlayerMovementComponent>();
	}
};
static_assert(alignof(URichmanOL_PlayerMovementComponent) == 0x000010, "Wrong alignment on URichmanOL_PlayerMovementComponent");
static_assert(sizeof(URichmanOL_PlayerMovementComponent) == 0x000B80, "Wrong size on URichmanOL_PlayerMovementComponent");
static_assert(offsetof(URichmanOL_PlayerMovementComponent, RichmanCharacter) == 0x000B20, "Member 'URichmanOL_PlayerMovementComponent::RichmanCharacter' has a wrong offset!");
static_assert(offsetof(URichmanOL_PlayerMovementComponent, PathActors) == 0x000B28, "Member 'URichmanOL_PlayerMovementComponent::PathActors' has a wrong offset!");
static_assert(offsetof(URichmanOL_PlayerMovementComponent, LastShowDirGround) == 0x000B38, "Member 'URichmanOL_PlayerMovementComponent::LastShowDirGround' has a wrong offset!");

}


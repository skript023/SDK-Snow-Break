#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Blindage

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Blindage_structs.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class Blindage.BlindageAssetUserData
// 0x0000 (0x0028 - 0x0028)
class UBlindageAssetUserData final : public UAssetUserData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindageAssetUserData">();
	}
	static class UBlindageAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindageAssetUserData>();
	}
};
static_assert(alignof(UBlindageAssetUserData) == 0x000008, "Wrong alignment on UBlindageAssetUserData");
static_assert(sizeof(UBlindageAssetUserData) == 0x000028, "Wrong size on UBlindageAssetUserData");

// Class Blindage.BlindageGenerateInterface
// 0x0000 (0x0028 - 0x0028)
class IBlindageGenerateInterface final : public IInterface
{
public:
	void BeforeBlindageGenerated();
	void OnBlindageGenerated(class ABlindage* Blindage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindageGenerateInterface">();
	}
	static class IBlindageGenerateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlindageGenerateInterface>();
	}
};
static_assert(alignof(IBlindageGenerateInterface) == 0x000008, "Wrong alignment on IBlindageGenerateInterface");
static_assert(sizeof(IBlindageGenerateInterface) == 0x000028, "Wrong size on IBlindageGenerateInterface");

// Class Blindage.BlindageInteract
// 0x0000 (0x0028 - 0x0028)
class IBlindageInteract final : public IInterface
{
public:
	float GetLeftBufferTime();
	struct FVector GetPlayerLocationInBlindage(class ABlindage* Blindage);
	float GetRightBufferTime();
	bool IsLeftMoveBuffering();
	bool IsPlayerBlindageEdgeMove(class ABlindage* Blindage);
	bool IsPlayerInBlindageState();
	bool IsRightMoveBuffering();
	void LeftMoveBuffering(bool bValue);
	void OnBlindageDestroy(class ABlindage* Blindage);
	void OnCatchedByBlindage(class ABlindage* Blindage);
	void OnEnterBlindageCollision(class ABlindage* Blindage);
	void OnLeaveBlindage(class ABlindage* Blindage);
	void OnLeaveBlindageCollision(class ABlindage* Blindage);
	void ResetBlindageData();
	void RightMoveBuffering(bool bValue);
	void SetLeftBufferTime(float FValue);
	void SetRightBufferTime(float FValue);

	float GetEnterPositionMaxAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindageInteract">();
	}
	static class IBlindageInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlindageInteract>();
	}
};
static_assert(alignof(IBlindageInteract) == 0x000008, "Wrong alignment on IBlindageInteract");
static_assert(sizeof(IBlindageInteract) == 0x000028, "Wrong size on IBlindageInteract");

// Class Blindage.Blindage
// 0x01B8 (0x03E0 - 0x0228)
class ABlindage : public AActor
{
public:
	uint8                                         Pad_228[0xA8];                                     // 0x0228(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshTransform;                                     // 0x02D0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class FString                                 DebugName;                                         // 0x0300(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBlindageType                                 Type;                                              // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TouchableAngle;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UIOffset;                                          // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlindageLength;                                    // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlindageWidth;                                     // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlindageHeight;                                    // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterStandOffset;                              // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLeftShootable;                                  // 0x032C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRightShootable;                                 // 0x032D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32E[0x2];                                      // 0x032E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EdgeEnterSnapRange;                                // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FullBlindageForbidShootAngle;                      // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBlindageForbidShootArea>       ForbidShootAreas;                                  // 0x0338(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         LeftEnterRange;                                    // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightEnterRange;                                   // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BackEnterPercentage;                               // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoCatchLengthPercentage;                         // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoCatchAngle;                                    // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftQuitLimitLength;                               // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightQuitLimitLength;                              // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceMovementQuitLimitLength;                      // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfBunkerBackMoveDistance;                        // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FullBunkerBackMoveDistance;                        // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x4];                                      // 0x0370(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClimbable;                                        // 0x0374(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbMaxDistance;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClimbOffsetStart;                                  // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClimbOffsetEnd;                                    // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClimbCheckPercentagy;                              // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeshClimbWidth;                                    // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeshClimbLength;                                   // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeshClimbHeight;                                   // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMannulClimbParameters;                         // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlindageLinkInfo>              BlindageLinks_Left;                                // 0x0398(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FBlindageLinkInfo>              BlindageLinks_Right;                               // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UProceduralMeshComponent*               CubeMesh;                                          // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       SplineComponent;                                   // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           SplineMesh;                                        // 0x03C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bDrawBlindageLinkDebugInfo;                        // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ShowDebugArea(const class UObject* WorldContextObject, bool bShow);

	const TArray<struct FBlindageLinkInfo> GetBlindageLinks_Left();
	const TArray<struct FBlindageLinkInfo> GetBlindageLinks_Right();
	EBlindageEnterType GetEnterArea(class ACharacter* GameCharacter, const struct FVector& ProjectPos);
	bool IsInForbidShootArea(const struct FVector& Pos);
	void K2_DisableBlindage();
	void K2_EnableBlindage();
	void OnBeginOverLap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverLap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetBlindageTickEnable(bool bInEnabled);
	void SetClimbMeshInfo(const struct FTransform& Transform, float Width, float Length, float Height);

	struct FClimbCheckInfo CheckClimbInfo(class ACharacter* Character, const struct FVector& InClimbDir, float MaxCrossDistance, float ExtraEndOffset) const;
	float GetBackMoveDistance() const;
	struct FVector GetBlindageForward() const;
	struct FVector GetBlindageHorizontalForward() const;
	struct FVector GetBlindageHorizontalRight() const;
	struct FRotator GetBlindageOrientation() const;
	struct FVector GetBlindageRight() const;
	EBlindageType GetBlindageType() const;
	float GetClimbOffsetEnd() const;
	float GetClimbOffsetStart() const;
	struct FVector GetEnterPosition(const class ACharacter* GameCharacter) const;
	struct FVector GetEnterPosition_WithPos(const class ACharacter* GameCharacter, const struct FVector& PredictPos) const;
	struct FVector GetFrontEdge() const;
	float GetFullBlindageForbidShootAngle() const;
	float GetFullBunkerBackMoveDistance() const;
	float GetHalfBunkerBackMoveDistance() const;
	struct FVector GetLeftEdge() const;
	struct FVector GetLeftEdge_WithOutStandOffset() const;
	struct FVector GetLeftEnterPoint() const;
	struct FVector GetLeftShootPoint() const;
	float GetMeshClimbActualLength() const;
	float GetMeshClimbHeight() const;
	float GetMeshClimbLength() const;
	float GetMeshClimbWidth() const;
	struct FVector GetMoveQuitLeftPos() const;
	struct FVector GetMoveQuitRightPos() const;
	struct FVector GetRightEdge() const;
	struct FVector GetRightEdge_WithOutStandOffset() const;
	struct FVector GetRightEnterPoint() const;
	struct FVector GetRightShootPoint() const;
	struct FVector GetSpecificDirTouchPosition(const class ACharacter* GameCharacter) const;
	struct FVector GetTouchPosition(const class ACharacter* GameCharacter) const;
	bool IsClimbable() const;
	bool IsInAutoCatchArea(const class ACharacter* Actor) const;
	bool IsInBackEnterArea(const class ACharacter* Actor) const;
	bool IsInClimbArea(const class ACharacter* Actor) const;
	bool IsLeftShootable() const;
	bool IsRightShootable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Blindage">();
	}
	static class ABlindage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlindage>();
	}
};
static_assert(alignof(ABlindage) == 0x000010, "Wrong alignment on ABlindage");
static_assert(sizeof(ABlindage) == 0x0003E0, "Wrong size on ABlindage");
static_assert(offsetof(ABlindage, MeshTransform) == 0x0002D0, "Member 'ABlindage::MeshTransform' has a wrong offset!");
static_assert(offsetof(ABlindage, DebugName) == 0x000300, "Member 'ABlindage::DebugName' has a wrong offset!");
static_assert(offsetof(ABlindage, Type) == 0x000310, "Member 'ABlindage::Type' has a wrong offset!");
static_assert(offsetof(ABlindage, TouchableAngle) == 0x000314, "Member 'ABlindage::TouchableAngle' has a wrong offset!");
static_assert(offsetof(ABlindage, UIOffset) == 0x000318, "Member 'ABlindage::UIOffset' has a wrong offset!");
static_assert(offsetof(ABlindage, BlindageLength) == 0x00031C, "Member 'ABlindage::BlindageLength' has a wrong offset!");
static_assert(offsetof(ABlindage, BlindageWidth) == 0x000320, "Member 'ABlindage::BlindageWidth' has a wrong offset!");
static_assert(offsetof(ABlindage, BlindageHeight) == 0x000324, "Member 'ABlindage::BlindageHeight' has a wrong offset!");
static_assert(offsetof(ABlindage, CharacterStandOffset) == 0x000328, "Member 'ABlindage::CharacterStandOffset' has a wrong offset!");
static_assert(offsetof(ABlindage, bIsLeftShootable) == 0x00032C, "Member 'ABlindage::bIsLeftShootable' has a wrong offset!");
static_assert(offsetof(ABlindage, bIsRightShootable) == 0x00032D, "Member 'ABlindage::bIsRightShootable' has a wrong offset!");
static_assert(offsetof(ABlindage, EdgeEnterSnapRange) == 0x000330, "Member 'ABlindage::EdgeEnterSnapRange' has a wrong offset!");
static_assert(offsetof(ABlindage, FullBlindageForbidShootAngle) == 0x000334, "Member 'ABlindage::FullBlindageForbidShootAngle' has a wrong offset!");
static_assert(offsetof(ABlindage, ForbidShootAreas) == 0x000338, "Member 'ABlindage::ForbidShootAreas' has a wrong offset!");
static_assert(offsetof(ABlindage, LeftEnterRange) == 0x000348, "Member 'ABlindage::LeftEnterRange' has a wrong offset!");
static_assert(offsetof(ABlindage, RightEnterRange) == 0x00034C, "Member 'ABlindage::RightEnterRange' has a wrong offset!");
static_assert(offsetof(ABlindage, BackEnterPercentage) == 0x000350, "Member 'ABlindage::BackEnterPercentage' has a wrong offset!");
static_assert(offsetof(ABlindage, AutoCatchLengthPercentage) == 0x000354, "Member 'ABlindage::AutoCatchLengthPercentage' has a wrong offset!");
static_assert(offsetof(ABlindage, AutoCatchAngle) == 0x000358, "Member 'ABlindage::AutoCatchAngle' has a wrong offset!");
static_assert(offsetof(ABlindage, LeftQuitLimitLength) == 0x00035C, "Member 'ABlindage::LeftQuitLimitLength' has a wrong offset!");
static_assert(offsetof(ABlindage, RightQuitLimitLength) == 0x000360, "Member 'ABlindage::RightQuitLimitLength' has a wrong offset!");
static_assert(offsetof(ABlindage, ForceMovementQuitLimitLength) == 0x000364, "Member 'ABlindage::ForceMovementQuitLimitLength' has a wrong offset!");
static_assert(offsetof(ABlindage, HalfBunkerBackMoveDistance) == 0x000368, "Member 'ABlindage::HalfBunkerBackMoveDistance' has a wrong offset!");
static_assert(offsetof(ABlindage, FullBunkerBackMoveDistance) == 0x00036C, "Member 'ABlindage::FullBunkerBackMoveDistance' has a wrong offset!");
static_assert(offsetof(ABlindage, bClimbable) == 0x000374, "Member 'ABlindage::bClimbable' has a wrong offset!");
static_assert(offsetof(ABlindage, ClimbMaxDistance) == 0x000378, "Member 'ABlindage::ClimbMaxDistance' has a wrong offset!");
static_assert(offsetof(ABlindage, ClimbOffsetStart) == 0x00037C, "Member 'ABlindage::ClimbOffsetStart' has a wrong offset!");
static_assert(offsetof(ABlindage, ClimbOffsetEnd) == 0x000380, "Member 'ABlindage::ClimbOffsetEnd' has a wrong offset!");
static_assert(offsetof(ABlindage, ClimbCheckPercentagy) == 0x000384, "Member 'ABlindage::ClimbCheckPercentagy' has a wrong offset!");
static_assert(offsetof(ABlindage, MeshClimbWidth) == 0x000388, "Member 'ABlindage::MeshClimbWidth' has a wrong offset!");
static_assert(offsetof(ABlindage, MeshClimbLength) == 0x00038C, "Member 'ABlindage::MeshClimbLength' has a wrong offset!");
static_assert(offsetof(ABlindage, MeshClimbHeight) == 0x000390, "Member 'ABlindage::MeshClimbHeight' has a wrong offset!");
static_assert(offsetof(ABlindage, bUseMannulClimbParameters) == 0x000394, "Member 'ABlindage::bUseMannulClimbParameters' has a wrong offset!");
static_assert(offsetof(ABlindage, BlindageLinks_Left) == 0x000398, "Member 'ABlindage::BlindageLinks_Left' has a wrong offset!");
static_assert(offsetof(ABlindage, BlindageLinks_Right) == 0x0003A8, "Member 'ABlindage::BlindageLinks_Right' has a wrong offset!");
static_assert(offsetof(ABlindage, CubeMesh) == 0x0003B8, "Member 'ABlindage::CubeMesh' has a wrong offset!");
static_assert(offsetof(ABlindage, SplineComponent) == 0x0003C0, "Member 'ABlindage::SplineComponent' has a wrong offset!");
static_assert(offsetof(ABlindage, SplineMesh) == 0x0003C8, "Member 'ABlindage::SplineMesh' has a wrong offset!");
static_assert(offsetof(ABlindage, bDrawBlindageLinkDebugInfo) == 0x0003D8, "Member 'ABlindage::bDrawBlindageLinkDebugInfo' has a wrong offset!");

// Class Blindage.BlindageFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlindageFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetBlindageMeshesInRadius(const class UObject* WorldContextObject, TArray<class AActor*>* OutActors, const struct FVector& Center, float Radius);
	static struct FTransform GetLevelTransform(const class AActor* InActor);
	static bool IsBlindageMesh(class UStaticMesh* Mesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindageFunctionLibrary">();
	}
	static class UBlindageFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindageFunctionLibrary>();
	}
};
static_assert(alignof(UBlindageFunctionLibrary) == 0x000008, "Wrong alignment on UBlindageFunctionLibrary");
static_assert(sizeof(UBlindageFunctionLibrary) == 0x000028, "Wrong size on UBlindageFunctionLibrary");

// Class Blindage.BlindageSettings
// 0x0068 (0x00A0 - 0x0038)
class UBlindageSettings final : public UDeveloperSettings
{
public:
	bool                                          bShowArea;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugInfo;                                    // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      BlindageMeshObjectTypes;                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  BlindageMeshes;                                    // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindageSettings">();
	}
	static class UBlindageSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindageSettings>();
	}
};
static_assert(alignof(UBlindageSettings) == 0x000008, "Wrong alignment on UBlindageSettings");
static_assert(sizeof(UBlindageSettings) == 0x0000A0, "Wrong size on UBlindageSettings");
static_assert(offsetof(UBlindageSettings, bShowArea) == 0x000038, "Member 'UBlindageSettings::bShowArea' has a wrong offset!");
static_assert(offsetof(UBlindageSettings, bShowDebugInfo) == 0x000039, "Member 'UBlindageSettings::bShowDebugInfo' has a wrong offset!");
static_assert(offsetof(UBlindageSettings, BlindageMeshObjectTypes) == 0x000040, "Member 'UBlindageSettings::BlindageMeshObjectTypes' has a wrong offset!");
static_assert(offsetof(UBlindageSettings, BlindageMeshes) == 0x000050, "Member 'UBlindageSettings::BlindageMeshes' has a wrong offset!");

}


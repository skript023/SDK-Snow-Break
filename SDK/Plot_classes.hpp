#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Plot

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Plot_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameCore_structs.hpp"
#include "GameCore_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class Plot.SubtitlesTextInterface
// 0x0000 (0x0028 - 0x0028)
class ISubtitlesTextInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesTextInterface">();
	}
	static class ISubtitlesTextInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISubtitlesTextInterface>();
	}
};
static_assert(alignof(ISubtitlesTextInterface) == 0x000008, "Wrong alignment on ISubtitlesTextInterface");
static_assert(sizeof(ISubtitlesTextInterface) == 0x000028, "Wrong size on ISubtitlesTextInterface");

// Class Plot.PlotItem
// 0x0068 (0x0090 - 0x0028)
class UPlotItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlotItem*>                      Childs;                                            // 0x0030(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UPlotItem*                              Parent;                                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotScreenType                               ScreenType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWait;                                             // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWaitOperationType                            WaitType;                                          // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timeout;                                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPlotEvent*>                     TimeoutEvents;                                     // 0x0050(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TrackTime;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x2];                                       // 0x0064(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanHaveMultipleChildren;                          // 0x0066(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExecuteIndex;                                      // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayLabel;                                      // 0x0070(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemIndex;                                         // 0x0080(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x2];                                       // 0x0084(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanEditWait;                                      // 0x0086(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_87[0x9];                                       // 0x0087(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clearup();
	void End();
	void OnEnd();
	void OnStart();
	void SetExecuteIndex(int32 InIndex);
	void Start();

	int32 GetChildrenCount() const;
	int32 GetIndex() const;
	class UPlotItem* GetParent() const;
	class UPlot* GetPlot() const;
	class UPlotWidget* GetWidget() const;
	class UWorld* GetWorld() const;
	bool IsTimeout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem">();
	}
	static class UPlotItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem>();
	}
};
static_assert(alignof(UPlotItem) == 0x000008, "Wrong alignment on UPlotItem");
static_assert(sizeof(UPlotItem) == 0x000090, "Wrong size on UPlotItem");
static_assert(offsetof(UPlotItem, Childs) == 0x000030, "Member 'UPlotItem::Childs' has a wrong offset!");
static_assert(offsetof(UPlotItem, Parent) == 0x000040, "Member 'UPlotItem::Parent' has a wrong offset!");
static_assert(offsetof(UPlotItem, ScreenType) == 0x000048, "Member 'UPlotItem::ScreenType' has a wrong offset!");
static_assert(offsetof(UPlotItem, bWait) == 0x000049, "Member 'UPlotItem::bWait' has a wrong offset!");
static_assert(offsetof(UPlotItem, WaitType) == 0x00004A, "Member 'UPlotItem::WaitType' has a wrong offset!");
static_assert(offsetof(UPlotItem, Timeout) == 0x00004C, "Member 'UPlotItem::Timeout' has a wrong offset!");
static_assert(offsetof(UPlotItem, TimeoutEvents) == 0x000050, "Member 'UPlotItem::TimeoutEvents' has a wrong offset!");
static_assert(offsetof(UPlotItem, TrackTime) == 0x000060, "Member 'UPlotItem::TrackTime' has a wrong offset!");
static_assert(offsetof(UPlotItem, bCanHaveMultipleChildren) == 0x000066, "Member 'UPlotItem::bCanHaveMultipleChildren' has a wrong offset!");
static_assert(offsetof(UPlotItem, ExecuteIndex) == 0x000068, "Member 'UPlotItem::ExecuteIndex' has a wrong offset!");
static_assert(offsetof(UPlotItem, DisplayLabel) == 0x000070, "Member 'UPlotItem::DisplayLabel' has a wrong offset!");
static_assert(offsetof(UPlotItem, ItemIndex) == 0x000080, "Member 'UPlotItem::ItemIndex' has a wrong offset!");
static_assert(offsetof(UPlotItem, bCanEditWait) == 0x000086, "Member 'UPlotItem::bCanEditWait' has a wrong offset!");

// Class Plot.PlotItem_FindEvidenceHide
// 0x0010 (0x00A0 - 0x0090)
class UPlotItem_FindEvidenceHide final : public UPlotItem
{
public:
	bool                                          IsShow;                                            // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_FindEvidenceHide">();
	}
	static class UPlotItem_FindEvidenceHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_FindEvidenceHide>();
	}
};
static_assert(alignof(UPlotItem_FindEvidenceHide) == 0x000008, "Wrong alignment on UPlotItem_FindEvidenceHide");
static_assert(sizeof(UPlotItem_FindEvidenceHide) == 0x0000A0, "Wrong size on UPlotItem_FindEvidenceHide");
static_assert(offsetof(UPlotItem_FindEvidenceHide, IsShow) == 0x000090, "Member 'UPlotItem_FindEvidenceHide::IsShow' has a wrong offset!");

// Class Plot.PlotRoleEffectWidget
// 0x0050 (0x02D0 - 0x0280)
class UPlotRoleEffectWidget final : public UUserWidget
{
public:
	class USpineWidget*                           RoleSpineWidget;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotSpineEffectImage*                  RoleSpineEffectImage;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x40];                                     // 0x0290(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetSpineDefaultAnimName(const class FString& RoleName);
	void HideOrShowSpine(bool bIsHide);
	void OnAnimationCompleteHandler(class UObject* InDispatcher, class UTrackEntry* InEntry);
	void OnEffectAnimationCompleteHandler(class UObject* InDispatcher, class UTrackEntry* InEntry);
	void PlayDefaultSpine(const class FString& RoleName);
	void PlaySpine(const class FString& RoleName, const struct FSpineParameters& InParameters, bool bIsHide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotRoleEffectWidget">();
	}
	static class UPlotRoleEffectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotRoleEffectWidget>();
	}
};
static_assert(alignof(UPlotRoleEffectWidget) == 0x000008, "Wrong alignment on UPlotRoleEffectWidget");
static_assert(sizeof(UPlotRoleEffectWidget) == 0x0002D0, "Wrong size on UPlotRoleEffectWidget");
static_assert(offsetof(UPlotRoleEffectWidget, RoleSpineWidget) == 0x000280, "Member 'UPlotRoleEffectWidget::RoleSpineWidget' has a wrong offset!");
static_assert(offsetof(UPlotRoleEffectWidget, RoleSpineEffectImage) == 0x000288, "Member 'UPlotRoleEffectWidget::RoleSpineEffectImage' has a wrong offset!");

// Class Plot.MovieClipBackgroundUserWidget
// 0x0038 (0x02B8 - 0x0280)
class UMovieClipBackgroundUserWidget final : public UUserWidget
{
public:
	class UMovieSkipWidget*                       Umg_MovieSkipWidget;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_SkipTip_Phone;                                // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_SkipTip_Computer;                             // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_SkipTip_Gamepad_Xbox;                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_SkipTip_Gamepad_PS;                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayControllerType                           CurrentType;                                       // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0xF];                                      // 0x02A9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReplaceFontAsset(class UTextBlock* InTextBlock);
	void SetCurrentControlerType(EPlayControllerType TypeToSet);
	void SetSkipTipVisible();
	void SetVisible(bool bIsSetVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipBackgroundUserWidget">();
	}
	static class UMovieClipBackgroundUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipBackgroundUserWidget>();
	}
};
static_assert(alignof(UMovieClipBackgroundUserWidget) == 0x000008, "Wrong alignment on UMovieClipBackgroundUserWidget");
static_assert(sizeof(UMovieClipBackgroundUserWidget) == 0x0002B8, "Wrong size on UMovieClipBackgroundUserWidget");
static_assert(offsetof(UMovieClipBackgroundUserWidget, Umg_MovieSkipWidget) == 0x000280, "Member 'UMovieClipBackgroundUserWidget::Umg_MovieSkipWidget' has a wrong offset!");
static_assert(offsetof(UMovieClipBackgroundUserWidget, Text_SkipTip_Phone) == 0x000288, "Member 'UMovieClipBackgroundUserWidget::Text_SkipTip_Phone' has a wrong offset!");
static_assert(offsetof(UMovieClipBackgroundUserWidget, Text_SkipTip_Computer) == 0x000290, "Member 'UMovieClipBackgroundUserWidget::Text_SkipTip_Computer' has a wrong offset!");
static_assert(offsetof(UMovieClipBackgroundUserWidget, Image_SkipTip_Gamepad_Xbox) == 0x000298, "Member 'UMovieClipBackgroundUserWidget::Image_SkipTip_Gamepad_Xbox' has a wrong offset!");
static_assert(offsetof(UMovieClipBackgroundUserWidget, Image_SkipTip_Gamepad_PS) == 0x0002A0, "Member 'UMovieClipBackgroundUserWidget::Image_SkipTip_Gamepad_PS' has a wrong offset!");
static_assert(offsetof(UMovieClipBackgroundUserWidget, CurrentType) == 0x0002A8, "Member 'UMovieClipBackgroundUserWidget::CurrentType' has a wrong offset!");

// Class Plot.MovieClipSubUserWidget
// 0x0010 (0x0290 - 0x0280)
class UMovieClipSubUserWidget final : public UUserWidget
{
public:
	class FString                                 SubtitlesPath;                                     // 0x0280(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipSubUserWidget">();
	}
	static class UMovieClipSubUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipSubUserWidget>();
	}
};
static_assert(alignof(UMovieClipSubUserWidget) == 0x000008, "Wrong alignment on UMovieClipSubUserWidget");
static_assert(sizeof(UMovieClipSubUserWidget) == 0x000290, "Wrong size on UMovieClipSubUserWidget");
static_assert(offsetof(UMovieClipSubUserWidget, SubtitlesPath) == 0x000280, "Member 'UMovieClipSubUserWidget::SubtitlesPath' has a wrong offset!");

// Class Plot.SpliceImgBG
// 0x0010 (0x0290 - 0x0280)
class USpliceImgBG final : public UUserWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTick;                                             // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteSpliceBG();
	void OnInit(ESpliceType* SpliceType, TArray<class UTexture2D*>* TexturesArray, struct FBlendParameters* BlendParameters, bool bHide, struct FVector2D* RelativeAnchors, struct FVector2D* FocusPosition, float* ScaleMultiplier, class UWidget* InWidget);
	void OnMoveComplete();
	void RemoveAllEffect(bool Recover, bool FastComplete);
	void SetAndMoveBG(bool bHide, struct FVector2D* RelativeAnchors, struct FVector2D* FocusPosition, float* ScaleMultiplier, float Duration, bool IsLoop, int32 LoopTimes);
	void TickMoveBG(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpliceImgBG">();
	}
	static class USpliceImgBG* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpliceImgBG>();
	}
};
static_assert(alignof(USpliceImgBG) == 0x000008, "Wrong alignment on USpliceImgBG");
static_assert(sizeof(USpliceImgBG) == 0x000290, "Wrong size on USpliceImgBG");
static_assert(offsetof(USpliceImgBG, bTick) == 0x000288, "Member 'USpliceImgBG::bTick' has a wrong offset!");

// Class Plot.PlotItem_InteractionGame
// 0x0050 (0x00E0 - 0x0090)
class UPlotItem_InteractionGame final : public UPlotItem
{
public:
	int32                                         PosID;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         LangKeys;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsEnforceProcess;                                  // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseComponent*                        WwiseComponent;                                    // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FInteractionGameRecord> GetHasPlayRecord();
	void OnInput();
	void OnTalkBegin(const class FString& InText, const class FString& InSpeaker, const class FString& InWwiseKey);
	void OnTalkTextChange(const class FString& InText, int32 InMaxNumText, const class FString& Speaker);
	void OnWwiseBegin(const class FString& InWwiseEventID);
	void OnWwiseCompleteHandler(class UWwiseComponent* InWwiseComponent);
	void StopCurPlayWwiseByWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_InteractionGame">();
	}
	static class UPlotItem_InteractionGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_InteractionGame>();
	}
};
static_assert(alignof(UPlotItem_InteractionGame) == 0x000008, "Wrong alignment on UPlotItem_InteractionGame");
static_assert(sizeof(UPlotItem_InteractionGame) == 0x0000E0, "Wrong size on UPlotItem_InteractionGame");
static_assert(offsetof(UPlotItem_InteractionGame, PosID) == 0x000090, "Member 'UPlotItem_InteractionGame::PosID' has a wrong offset!");
static_assert(offsetof(UPlotItem_InteractionGame, LangKeys) == 0x000098, "Member 'UPlotItem_InteractionGame::LangKeys' has a wrong offset!");
static_assert(offsetof(UPlotItem_InteractionGame, IsEnforceProcess) == 0x0000A8, "Member 'UPlotItem_InteractionGame::IsEnforceProcess' has a wrong offset!");
static_assert(offsetof(UPlotItem_InteractionGame, WwiseComponent) == 0x0000B0, "Member 'UPlotItem_InteractionGame::WwiseComponent' has a wrong offset!");

// Class Plot.MovieClipCameraActor
// 0x0010 (0x07D0 - 0x07C0)
class AMovieClipCameraActor final : public ACameraActor
{
public:
	class UStaticMeshComponent*                   PlaneComponent;                                    // 0x07C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BackgroundMesh;                                    // 0x07C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipCameraActor">();
	}
	static class AMovieClipCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovieClipCameraActor>();
	}
};
static_assert(alignof(AMovieClipCameraActor) == 0x000010, "Wrong alignment on AMovieClipCameraActor");
static_assert(sizeof(AMovieClipCameraActor) == 0x0007D0, "Wrong size on AMovieClipCameraActor");
static_assert(offsetof(AMovieClipCameraActor, PlaneComponent) == 0x0007C0, "Member 'AMovieClipCameraActor::PlaneComponent' has a wrong offset!");
static_assert(offsetof(AMovieClipCameraActor, BackgroundMesh) == 0x0007C8, "Member 'AMovieClipCameraActor::BackgroundMesh' has a wrong offset!");

// Class Plot.MovieClipCanvasPanel
// 0x0000 (0x0150 - 0x0150)
class UMovieClipCanvasPanel final : public UCanvasPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipCanvasPanel">();
	}
	static class UMovieClipCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipCanvasPanel>();
	}
};
static_assert(alignof(UMovieClipCanvasPanel) == 0x000008, "Wrong alignment on UMovieClipCanvasPanel");
static_assert(sizeof(UMovieClipCanvasPanel) == 0x000150, "Wrong size on UMovieClipCanvasPanel");

// Class Plot.MovieClipImage
// 0x00E8 (0x0210 - 0x0128)
class UMovieClipImage : public UWidget
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0130(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ULevelSequence*                         LpSequence;                                        // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMainView;                                       // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxViewDistance;                                   // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlaybackRange;                                     // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x30];                                     // 0x01E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraCut(class UCameraComponent* CameraComp);
	void PlayAnimation();
	void StopAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipImage">();
	}
	static class UMovieClipImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipImage>();
	}
};
static_assert(alignof(UMovieClipImage) == 0x000008, "Wrong alignment on UMovieClipImage");
static_assert(sizeof(UMovieClipImage) == 0x000210, "Wrong size on UMovieClipImage");
static_assert(offsetof(UMovieClipImage, Brush) == 0x000130, "Member 'UMovieClipImage::Brush' has a wrong offset!");
static_assert(offsetof(UMovieClipImage, LpSequence) == 0x0001B8, "Member 'UMovieClipImage::LpSequence' has a wrong offset!");
static_assert(offsetof(UMovieClipImage, bIsMainView) == 0x0001C0, "Member 'UMovieClipImage::bIsMainView' has a wrong offset!");
static_assert(offsetof(UMovieClipImage, MaxViewDistance) == 0x0001C4, "Member 'UMovieClipImage::MaxViewDistance' has a wrong offset!");
static_assert(offsetof(UMovieClipImage, PlaybackRange) == 0x0001C8, "Member 'UMovieClipImage::PlaybackRange' has a wrong offset!");
static_assert(offsetof(UMovieClipImage, BrushDelegate) == 0x0001D0, "Member 'UMovieClipImage::BrushDelegate' has a wrong offset!");

// Class Plot.PlotItem_LuaImpl
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_LuaImpl : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSingleWidget();
	void SetWait(bool InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LuaImpl">();
	}
	static class UPlotItem_LuaImpl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LuaImpl>();
	}
};
static_assert(alignof(UPlotItem_LuaImpl) == 0x000008, "Wrong alignment on UPlotItem_LuaImpl");
static_assert(sizeof(UPlotItem_LuaImpl) == 0x0000B0, "Wrong size on UPlotItem_LuaImpl");
static_assert(offsetof(UPlotItem_LuaImpl, OrderType) == 0x000090, "Member 'UPlotItem_LuaImpl::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_LuaImpl, OrderOffset) == 0x000094, "Member 'UPlotItem_LuaImpl::OrderOffset' has a wrong offset!");

// Class Plot.PlotItem_AssignNpcName
// 0x0010 (0x00C0 - 0x00B0)
class UPlotItem_AssignNpcName final : public UPlotItem_LuaImpl
{
public:
	class FString                                 NPC;                                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_AssignNpcName">();
	}
	static class UPlotItem_AssignNpcName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_AssignNpcName>();
	}
};
static_assert(alignof(UPlotItem_AssignNpcName) == 0x000008, "Wrong alignment on UPlotItem_AssignNpcName");
static_assert(sizeof(UPlotItem_AssignNpcName) == 0x0000C0, "Wrong size on UPlotItem_AssignNpcName");
static_assert(offsetof(UPlotItem_AssignNpcName, NPC) == 0x0000B0, "Member 'UPlotItem_AssignNpcName::NPC' has a wrong offset!");

// Class Plot.MovieClipMediaSourceImage
// 0x0050 (0x0260 - 0x0210)
class UMovieClipMediaSourceImage final : public UMovieClipImage
{
public:
	class FString                                 MP4Path;                                           // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       LpMediaSource;                                     // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaPlayer*                           LpMediaPlayer;                                     // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MediaTexturePath;                                  // 0x0230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaTexture*                          MediaTexture;                                      // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMovieClipCameraActor*                  MovieClipCameraActor;                              // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoSetPath();
	void OnMediaOpenFailedHandler(const class FString& DeviceUrl);
	void OnMediaSourceOpenedHandler(const class FString& DeviceUrl);

	TArray<class FString> GetFileList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipMediaSourceImage">();
	}
	static class UMovieClipMediaSourceImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipMediaSourceImage>();
	}
};
static_assert(alignof(UMovieClipMediaSourceImage) == 0x000008, "Wrong alignment on UMovieClipMediaSourceImage");
static_assert(sizeof(UMovieClipMediaSourceImage) == 0x000260, "Wrong size on UMovieClipMediaSourceImage");
static_assert(offsetof(UMovieClipMediaSourceImage, MP4Path) == 0x000210, "Member 'UMovieClipMediaSourceImage::MP4Path' has a wrong offset!");
static_assert(offsetof(UMovieClipMediaSourceImage, LpMediaSource) == 0x000220, "Member 'UMovieClipMediaSourceImage::LpMediaSource' has a wrong offset!");
static_assert(offsetof(UMovieClipMediaSourceImage, LpMediaPlayer) == 0x000228, "Member 'UMovieClipMediaSourceImage::LpMediaPlayer' has a wrong offset!");
static_assert(offsetof(UMovieClipMediaSourceImage, MediaTexturePath) == 0x000230, "Member 'UMovieClipMediaSourceImage::MediaTexturePath' has a wrong offset!");
static_assert(offsetof(UMovieClipMediaSourceImage, MediaTexture) == 0x000248, "Member 'UMovieClipMediaSourceImage::MediaTexture' has a wrong offset!");
static_assert(offsetof(UMovieClipMediaSourceImage, MovieClipCameraActor) == 0x000250, "Member 'UMovieClipMediaSourceImage::MovieClipCameraActor' has a wrong offset!");

// Class Plot.PlotItem_Root
// 0x0030 (0x00C0 - 0x0090)
class UPlotItem_Root final : public UPlotItem
{
public:
	struct FTalkConfig                            TalkConfig;                                        // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Root">();
	}
	static class UPlotItem_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Root>();
	}
};
static_assert(alignof(UPlotItem_Root) == 0x000008, "Wrong alignment on UPlotItem_Root");
static_assert(sizeof(UPlotItem_Root) == 0x0000C0, "Wrong size on UPlotItem_Root");
static_assert(offsetof(UPlotItem_Root, TalkConfig) == 0x000090, "Member 'UPlotItem_Root::TalkConfig' has a wrong offset!");

// Class Plot.MovieClipNormalSubtitlesText
// 0x0020 (0x02E8 - 0x02C8)
class UMovieClipNormalSubtitlesText final : public UTextBlock
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Key;                                               // 0x02D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieClipNormalSubtitlesText">();
	}
	static class UMovieClipNormalSubtitlesText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieClipNormalSubtitlesText>();
	}
};
static_assert(alignof(UMovieClipNormalSubtitlesText) == 0x000008, "Wrong alignment on UMovieClipNormalSubtitlesText");
static_assert(sizeof(UMovieClipNormalSubtitlesText) == 0x0002E8, "Wrong size on UMovieClipNormalSubtitlesText");
static_assert(offsetof(UMovieClipNormalSubtitlesText, Key) == 0x0002D0, "Member 'UMovieClipNormalSubtitlesText::Key' has a wrong offset!");

// Class Plot.PlotCondition
// 0x0000 (0x0028 - 0x0028)
class UPlotCondition : public UObject
{
public:
	bool Check();

	class UPlot* GetPlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotCondition">();
	}
	static class UPlotCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotCondition>();
	}
};
static_assert(alignof(UPlotCondition) == 0x000008, "Wrong alignment on UPlotCondition");
static_assert(sizeof(UPlotCondition) == 0x000028, "Wrong size on UPlotCondition");

// Class Plot.PlotTimeoutCondition
// 0x0010 (0x0038 - 0x0028)
class UPlotTimeoutCondition final : public UPlotCondition
{
public:
	class FString                                 Key;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotTimeoutCondition">();
	}
	static class UPlotTimeoutCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotTimeoutCondition>();
	}
};
static_assert(alignof(UPlotTimeoutCondition) == 0x000008, "Wrong alignment on UPlotTimeoutCondition");
static_assert(sizeof(UPlotTimeoutCondition) == 0x000038, "Wrong size on UPlotTimeoutCondition");
static_assert(offsetof(UPlotTimeoutCondition, Key) == 0x000028, "Member 'UPlotTimeoutCondition::Key' has a wrong offset!");

// Class Plot.MovieSkipWidget
// 0x0020 (0x02A0 - 0x0280)
class UMovieSkipWidget final : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*               SkipCircleInstance;                                // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartingCount;                                    // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartToNow;                                        // 0x028C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkipIntervalTime;                                  // 0x0290(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpValue;                                       // 0x0294(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SkipCircle;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSkipWidget">();
	}
	static class UMovieSkipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSkipWidget>();
	}
};
static_assert(alignof(UMovieSkipWidget) == 0x000008, "Wrong alignment on UMovieSkipWidget");
static_assert(sizeof(UMovieSkipWidget) == 0x0002A0, "Wrong size on UMovieSkipWidget");
static_assert(offsetof(UMovieSkipWidget, SkipCircleInstance) == 0x000280, "Member 'UMovieSkipWidget::SkipCircleInstance' has a wrong offset!");
static_assert(offsetof(UMovieSkipWidget, bStartingCount) == 0x000288, "Member 'UMovieSkipWidget::bStartingCount' has a wrong offset!");
static_assert(offsetof(UMovieSkipWidget, StartToNow) == 0x00028C, "Member 'UMovieSkipWidget::StartToNow' has a wrong offset!");
static_assert(offsetof(UMovieSkipWidget, SkipIntervalTime) == 0x000290, "Member 'UMovieSkipWidget::SkipIntervalTime' has a wrong offset!");
static_assert(offsetof(UMovieSkipWidget, InterpValue) == 0x000294, "Member 'UMovieSkipWidget::InterpValue' has a wrong offset!");
static_assert(offsetof(UMovieSkipWidget, SkipCircle) == 0x000298, "Member 'UMovieSkipWidget::SkipCircle' has a wrong offset!");

// Class Plot.Plot
// 0x0278 (0x02A0 - 0x0028)
class UPlot final : public UObject
{
public:
	class FString                                 PlotConfig;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BGPath;                                            // 0x0038(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBackgroundMask;                               // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USequencerUserWidget>       StageAnimationWidgetClass;                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpineAnimationBlendTime;                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Preload;                                           // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlotItem*                              RootItem;                                          // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x118];                                     // 0x0070(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPlotWidget>             Widget;                                            // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USequencerUserWidget*                   SequencerWidget;                                   // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlotItem*                              SequencerPlotItem;                                 // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlotItem*                              CGSpinePlotItem;                                   // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FConfigItem>       ConfigMap;                                         // 0x01B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0xA0];                                     // 0x0200(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReloadLanguage();
	static void SetPlotLanguageNames(const TArray<class FString>& InLanguageNames);

	void Cleanup();
	void ClearSequence();
	void End(EPlotCompleteType InCompleteType);
	int32 GetConfigId();
	struct FConfigItem GetTalkConfig(class FString* InKey);
	bool IsJump(class UPlotItem* InItem);
	void OnSequencerFinishedHandler();
	void OnWindowActivatedHandler();
	void OnWindowDeactivatedHandler();
	void SetAutoPlay(bool bIsAutoPlay);
	void SetPlayMode(const EPlayMode InPlayMode);
	void SetWidget(class UPlotWidget* InWidget);
	void Start();

	float GetFadeTime() const;
	bool GetIsAutoPlay() const;
	EPlayMode GetPlayMode() const;
	float GetPlaySpeed() const;
	class UPlotItem* GetRootItem() const;
	class UPlotWidget* GetWidget() const;
	class UWorld* GetWorld() const;
	bool HasKey(const class FString& InKey) const;
	bool IsNormalDialogueType() const;
	bool IsVisiableSequencerUserWidget() const;
	bool JumpTo(const class FString& InKey) const;
	void SaveKey(const class FString& InKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Plot">();
	}
	static class UPlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlot>();
	}
};
static_assert(alignof(UPlot) == 0x000008, "Wrong alignment on UPlot");
static_assert(sizeof(UPlot) == 0x0002A0, "Wrong size on UPlot");
static_assert(offsetof(UPlot, PlotConfig) == 0x000028, "Member 'UPlot::PlotConfig' has a wrong offset!");
static_assert(offsetof(UPlot, BGPath) == 0x000038, "Member 'UPlot::BGPath' has a wrong offset!");
static_assert(offsetof(UPlot, bShowBackgroundMask) == 0x000050, "Member 'UPlot::bShowBackgroundMask' has a wrong offset!");
static_assert(offsetof(UPlot, FadeTime) == 0x000054, "Member 'UPlot::FadeTime' has a wrong offset!");
static_assert(offsetof(UPlot, StageAnimationWidgetClass) == 0x000058, "Member 'UPlot::StageAnimationWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlot, SpineAnimationBlendTime) == 0x000060, "Member 'UPlot::SpineAnimationBlendTime' has a wrong offset!");
static_assert(offsetof(UPlot, Preload) == 0x000064, "Member 'UPlot::Preload' has a wrong offset!");
static_assert(offsetof(UPlot, RootItem) == 0x000068, "Member 'UPlot::RootItem' has a wrong offset!");
static_assert(offsetof(UPlot, Widget) == 0x000188, "Member 'UPlot::Widget' has a wrong offset!");
static_assert(offsetof(UPlot, SequencerWidget) == 0x000190, "Member 'UPlot::SequencerWidget' has a wrong offset!");
static_assert(offsetof(UPlot, SequencerPlotItem) == 0x000198, "Member 'UPlot::SequencerPlotItem' has a wrong offset!");
static_assert(offsetof(UPlot, CGSpinePlotItem) == 0x0001A0, "Member 'UPlot::CGSpinePlotItem' has a wrong offset!");
static_assert(offsetof(UPlot, ConfigMap) == 0x0001B0, "Member 'UPlot::ConfigMap' has a wrong offset!");

// Class Plot.PlotCameraObj
// 0x0058 (0x0080 - 0x0028)
class UPlotCameraObj final : public UObject
{
public:
	struct FPlotCameraInfo                        CameraArgs;                                        // 0x0028(0x0058)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotCameraObj">();
	}
	static class UPlotCameraObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotCameraObj>();
	}
};
static_assert(alignof(UPlotCameraObj) == 0x000008, "Wrong alignment on UPlotCameraObj");
static_assert(sizeof(UPlotCameraObj) == 0x000080, "Wrong size on UPlotCameraObj");
static_assert(offsetof(UPlotCameraObj, CameraArgs) == 0x000028, "Member 'UPlotCameraObj::CameraArgs' has a wrong offset!");

// Class Plot.PlotCharacter
// 0x0050 (0x0510 - 0x04C0)
class APlotCharacter final : public ACharacter
{
public:
	class USpringArmComponent*                    CameraArm;                                         // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x48];                                     // 0x04C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPlotCameraInfo GetCameraArgs() const;
	void SetCameraArgs(const struct FPlotCameraInfo& InArgs, class UPlot* InPlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotCharacter">();
	}
	static class APlotCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlotCharacter>();
	}
};
static_assert(alignof(APlotCharacter) == 0x000010, "Wrong alignment on APlotCharacter");
static_assert(sizeof(APlotCharacter) == 0x000510, "Wrong size on APlotCharacter");
static_assert(offsetof(APlotCharacter, CameraArm) == 0x0004B8, "Member 'APlotCharacter::CameraArm' has a wrong offset!");
static_assert(offsetof(APlotCharacter, Camera) == 0x0004C0, "Member 'APlotCharacter::Camera' has a wrong offset!");

// Class Plot.PlotImage
// 0x0058 (0x0288 - 0x0230)
class UPlotImage final : public UImage
{
public:
	uint8                                         Pad_230[0x58];                                     // 0x0230(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotImage">();
	}
	static class UPlotImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotImage>();
	}
};
static_assert(alignof(UPlotImage) == 0x000008, "Wrong alignment on UPlotImage");
static_assert(sizeof(UPlotImage) == 0x000288, "Wrong size on UPlotImage");

// Class Plot.PlotItem_LuaWidget
// 0x0010 (0x00C0 - 0x00B0)
class UPlotItem_LuaWidget final : public UPlotItem_LuaImpl
{
public:
	class FString                                 LuaPath;                                           // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LuaWidget">();
	}
	static class UPlotItem_LuaWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LuaWidget>();
	}
};
static_assert(alignof(UPlotItem_LuaWidget) == 0x000008, "Wrong alignment on UPlotItem_LuaWidget");
static_assert(sizeof(UPlotItem_LuaWidget) == 0x0000C0, "Wrong size on UPlotItem_LuaWidget");
static_assert(offsetof(UPlotItem_LuaWidget, LuaPath) == 0x0000B0, "Member 'UPlotItem_LuaWidget::LuaPath' has a wrong offset!");

// Class Plot.PlotReadKeyCondition
// 0x0018 (0x0040 - 0x0028)
class UPlotReadKeyCondition final : public UPlotCondition
{
public:
	class FString                                 Key;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSavedKey;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRead;                                          // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotReadKeyCondition">();
	}
	static class UPlotReadKeyCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotReadKeyCondition>();
	}
};
static_assert(alignof(UPlotReadKeyCondition) == 0x000008, "Wrong alignment on UPlotReadKeyCondition");
static_assert(sizeof(UPlotReadKeyCondition) == 0x000040, "Wrong size on UPlotReadKeyCondition");
static_assert(offsetof(UPlotReadKeyCondition, Key) == 0x000028, "Member 'UPlotReadKeyCondition::Key' has a wrong offset!");
static_assert(offsetof(UPlotReadKeyCondition, bUseSavedKey) == 0x000038, "Member 'UPlotReadKeyCondition::bUseSavedKey' has a wrong offset!");
static_assert(offsetof(UPlotReadKeyCondition, bHasRead) == 0x000039, "Member 'UPlotReadKeyCondition::bHasRead' has a wrong offset!");

// Class Plot.PlotSelectNumCondition
// 0x0008 (0x0030 - 0x0028)
class UPlotSelectNumCondition final : public UPlotCondition
{
public:
	int32                                         Num;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSelectNumCondition">();
	}
	static class UPlotSelectNumCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSelectNumCondition>();
	}
};
static_assert(alignof(UPlotSelectNumCondition) == 0x000008, "Wrong alignment on UPlotSelectNumCondition");
static_assert(sizeof(UPlotSelectNumCondition) == 0x000030, "Wrong size on UPlotSelectNumCondition");
static_assert(offsetof(UPlotSelectNumCondition, Num) == 0x000028, "Member 'UPlotSelectNumCondition::Num' has a wrong offset!");

// Class Plot.PlotLuaImplWidget
// 0x0008 (0x0288 - 0x0280)
class UPlotLuaImplWidget final : public UUserWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyStart(class UPlotItem_LuaImpl* InPlotItem, class UPlotWidget* InPlotWidget, bool InIsPreview);
	void NotifyStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotLuaImplWidget">();
	}
	static class UPlotLuaImplWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotLuaImplWidget>();
	}
};
static_assert(alignof(UPlotLuaImplWidget) == 0x000008, "Wrong alignment on UPlotLuaImplWidget");
static_assert(sizeof(UPlotLuaImplWidget) == 0x000288, "Wrong size on UPlotLuaImplWidget");

// Class Plot.PlotEvent
// 0x0000 (0x0028 - 0x0028)
class UPlotEvent : public UObject
{
public:
	bool DoEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotEvent">();
	}
	static class UPlotEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotEvent>();
	}
};
static_assert(alignof(UPlotEvent) == 0x000008, "Wrong alignment on UPlotEvent");
static_assert(sizeof(UPlotEvent) == 0x000028, "Wrong size on UPlotEvent");

// Class Plot.PlotEvent_JumpKey
// 0x0010 (0x0038 - 0x0028)
class UPlotEvent_JumpKey final : public UPlotEvent
{
public:
	class FString                                 Key;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotEvent_JumpKey">();
	}
	static class UPlotEvent_JumpKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotEvent_JumpKey>();
	}
};
static_assert(alignof(UPlotEvent_JumpKey) == 0x000008, "Wrong alignment on UPlotEvent_JumpKey");
static_assert(sizeof(UPlotEvent_JumpKey) == 0x000038, "Wrong size on UPlotEvent_JumpKey");
static_assert(offsetof(UPlotEvent_JumpKey, Key) == 0x000028, "Member 'UPlotEvent_JumpKey::Key' has a wrong offset!");

// Class Plot.PlotSaveItem
// 0x0088 (0x0118 - 0x0090)
class UPlotSaveItem : public UPlotItem
{
public:
	struct FConfigItem                            Config;                                            // 0x0090(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bSave;                                             // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetContentFromSelectItemData(const struct FSelectItemData& SelectItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSaveItem">();
	}
	static class UPlotSaveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSaveItem>();
	}
};
static_assert(alignof(UPlotSaveItem) == 0x000008, "Wrong alignment on UPlotSaveItem");
static_assert(sizeof(UPlotSaveItem) == 0x000118, "Wrong size on UPlotSaveItem");
static_assert(offsetof(UPlotSaveItem, Config) == 0x000090, "Member 'UPlotSaveItem::Config' has a wrong offset!");
static_assert(offsetof(UPlotSaveItem, bSave) == 0x000110, "Member 'UPlotSaveItem::bSave' has a wrong offset!");

// Class Plot.PlotItem_AddSpotLight
// 0x0060 (0x00F0 - 0x0090)
class UPlotItem_AddSpotLight final : public UPlotItem
{
public:
	class FString                                 RoleName;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LightName;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpotLightParameters                   SpotLightParameters;                               // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x00DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bHide : 1;                                         // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_AddSpotLight">();
	}
	static class UPlotItem_AddSpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_AddSpotLight>();
	}
};
static_assert(alignof(UPlotItem_AddSpotLight) == 0x000008, "Wrong alignment on UPlotItem_AddSpotLight");
static_assert(sizeof(UPlotItem_AddSpotLight) == 0x0000F0, "Wrong size on UPlotItem_AddSpotLight");
static_assert(offsetof(UPlotItem_AddSpotLight, RoleName) == 0x000090, "Member 'UPlotItem_AddSpotLight::RoleName' has a wrong offset!");
static_assert(offsetof(UPlotItem_AddSpotLight, LightName) == 0x0000A0, "Member 'UPlotItem_AddSpotLight::LightName' has a wrong offset!");
static_assert(offsetof(UPlotItem_AddSpotLight, SpotLightParameters) == 0x0000B0, "Member 'UPlotItem_AddSpotLight::SpotLightParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_AddSpotLight, RelativeLocation) == 0x0000D0, "Member 'UPlotItem_AddSpotLight::RelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlotItem_AddSpotLight, RelativeRotation) == 0x0000DC, "Member 'UPlotItem_AddSpotLight::RelativeRotation' has a wrong offset!");

// Class Plot.PlotSubtitlesTextBlock
// 0x0000 (0x02C8 - 0x02C8)
class UPlotSubtitlesTextBlock final : public UTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSubtitlesTextBlock">();
	}
	static class UPlotSubtitlesTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSubtitlesTextBlock>();
	}
};
static_assert(alignof(UPlotSubtitlesTextBlock) == 0x000008, "Wrong alignment on UPlotSubtitlesTextBlock");
static_assert(sizeof(UPlotSubtitlesTextBlock) == 0x0002C8, "Wrong size on UPlotSubtitlesTextBlock");

// Class Plot.PlotItem_BackgroundSubtitles
// 0x00B8 (0x0148 - 0x0090)
class UPlotItem_BackgroundSubtitles final : public UPlotItem
{
public:
	class FText                                   Text;                                              // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TextKey;                                           // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 WwiseEventID;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSelfLangFile;                                   // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FontPath;                                          // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontSize;                                          // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotTextAnchorLayoutType                     AnchorType;                                        // 0x00F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBold;                                             // 0x00F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVertical;                                       // 0x00F7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineHeightPercentage;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FontColor;                                         // 0x00FC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x010C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFowardType                                   FowardType;                                        // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotSubtitlesFadeInType                      FadeInType;                                        // 0x0115(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseComponent*                        WwiseBSComponent;                                  // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWwiseCompleteHandler(class UWwiseComponent* InWwiseComponent);

	class FText GetRemoveLineBreakText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_BackgroundSubtitles">();
	}
	static class UPlotItem_BackgroundSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_BackgroundSubtitles>();
	}
};
static_assert(alignof(UPlotItem_BackgroundSubtitles) == 0x000008, "Wrong alignment on UPlotItem_BackgroundSubtitles");
static_assert(sizeof(UPlotItem_BackgroundSubtitles) == 0x000148, "Wrong size on UPlotItem_BackgroundSubtitles");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, Text) == 0x000090, "Member 'UPlotItem_BackgroundSubtitles::Text' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, TextKey) == 0x0000A8, "Member 'UPlotItem_BackgroundSubtitles::TextKey' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, WwiseEventID) == 0x0000C0, "Member 'UPlotItem_BackgroundSubtitles::WwiseEventID' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, UseSelfLangFile) == 0x0000D0, "Member 'UPlotItem_BackgroundSubtitles::UseSelfLangFile' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, FontPath) == 0x0000D8, "Member 'UPlotItem_BackgroundSubtitles::FontPath' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, FontSize) == 0x0000F0, "Member 'UPlotItem_BackgroundSubtitles::FontSize' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, Justification) == 0x0000F4, "Member 'UPlotItem_BackgroundSubtitles::Justification' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, AnchorType) == 0x0000F5, "Member 'UPlotItem_BackgroundSubtitles::AnchorType' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, bBold) == 0x0000F6, "Member 'UPlotItem_BackgroundSubtitles::bBold' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, bIsVertical) == 0x0000F7, "Member 'UPlotItem_BackgroundSubtitles::bIsVertical' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, LineHeightPercentage) == 0x0000F8, "Member 'UPlotItem_BackgroundSubtitles::LineHeightPercentage' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, FontColor) == 0x0000FC, "Member 'UPlotItem_BackgroundSubtitles::FontColor' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, Offset) == 0x00010C, "Member 'UPlotItem_BackgroundSubtitles::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, FowardType) == 0x000114, "Member 'UPlotItem_BackgroundSubtitles::FowardType' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, FadeInType) == 0x000115, "Member 'UPlotItem_BackgroundSubtitles::FadeInType' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, BlendInTime) == 0x000118, "Member 'UPlotItem_BackgroundSubtitles::BlendInTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, WaitTime) == 0x00011C, "Member 'UPlotItem_BackgroundSubtitles::WaitTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, BlendOutTime) == 0x000120, "Member 'UPlotItem_BackgroundSubtitles::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitles, WwiseBSComponent) == 0x000128, "Member 'UPlotItem_BackgroundSubtitles::WwiseBSComponent' has a wrong offset!");

// Class Plot.PlotItem_BackgroundSubtitleOneByOne
// 0x01C0 (0x0250 - 0x0090)
class UPlotItem_BackgroundSubtitleOneByOne final : public UPlotItem
{
public:
	TArray<class FString>                         Keys;                                              // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         EventNames;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseSelfLangFile;                                   // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FontSize;                                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotTextAnchorLayoutType                     AnchorType;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBold;                                             // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x1];                                       // 0x00BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FontColor;                                         // 0x00BC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x00CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOut;                                           // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirTime;                                           // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Content;                                           // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseComponent*                        WwiseBSComponent;                                  // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x150];                                    // 0x0100(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FSubtitleRecord> GetHasPlayRecord();
	void OnInput();
	void OnWwiseCompleteHandler(class UWwiseComponent* InWwiseComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_BackgroundSubtitleOneByOne">();
	}
	static class UPlotItem_BackgroundSubtitleOneByOne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_BackgroundSubtitleOneByOne>();
	}
};
static_assert(alignof(UPlotItem_BackgroundSubtitleOneByOne) == 0x000008, "Wrong alignment on UPlotItem_BackgroundSubtitleOneByOne");
static_assert(sizeof(UPlotItem_BackgroundSubtitleOneByOne) == 0x000250, "Wrong size on UPlotItem_BackgroundSubtitleOneByOne");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Keys) == 0x000090, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Keys' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, EventNames) == 0x0000A0, "Member 'UPlotItem_BackgroundSubtitleOneByOne::EventNames' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, UseSelfLangFile) == 0x0000B0, "Member 'UPlotItem_BackgroundSubtitleOneByOne::UseSelfLangFile' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, FontSize) == 0x0000B4, "Member 'UPlotItem_BackgroundSubtitleOneByOne::FontSize' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Justification) == 0x0000B8, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Justification' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, AnchorType) == 0x0000B9, "Member 'UPlotItem_BackgroundSubtitleOneByOne::AnchorType' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, bBold) == 0x0000BA, "Member 'UPlotItem_BackgroundSubtitleOneByOne::bBold' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, FontColor) == 0x0000BC, "Member 'UPlotItem_BackgroundSubtitleOneByOne::FontColor' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Offset) == 0x0000CC, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Width) == 0x0000D4, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Width' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Speed) == 0x0000D8, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Speed' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, FadeOut) == 0x0000DC, "Member 'UPlotItem_BackgroundSubtitleOneByOne::FadeOut' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, DirTime) == 0x0000E0, "Member 'UPlotItem_BackgroundSubtitleOneByOne::DirTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, Content) == 0x0000E8, "Member 'UPlotItem_BackgroundSubtitleOneByOne::Content' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitleOneByOne, WwiseBSComponent) == 0x0000F8, "Member 'UPlotItem_BackgroundSubtitleOneByOne::WwiseBSComponent' has a wrong offset!");

// Class Plot.PlotItem_BackgroundSubtitle_New
// 0x0218 (0x02A8 - 0x0090)
class UPlotItem_BackgroundSubtitle_New final : public UPlotItem
{
public:
	bool                                          IsOneByOne;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Keys;                                              // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         EventNames;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Speakers;                                          // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseSelfLangFile;                                   // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FontSize;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotTextAnchorLayoutType                     AnchorType;                                        // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBold;                                             // 0x00D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x1];                                       // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FontColor;                                         // 0x00D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBackgroundSubtitlesOneByOneParams     BackgroundSubtitlesOneByOneParams;                 // 0x00F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBackgroundSubtitlesParams             BackgroundSubtitlesParams;                         // 0x00FC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Content;                                           // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseComponent*                        WwiseBSComponent;                                  // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x180];                                    // 0x0128(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FSubtitleRecord> GetHasPlayRecord();
	void OnInput();
	void OnWwiseCompleteHandler(class UWwiseComponent* InWwiseComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_BackgroundSubtitle_New">();
	}
	static class UPlotItem_BackgroundSubtitle_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_BackgroundSubtitle_New>();
	}
};
static_assert(alignof(UPlotItem_BackgroundSubtitle_New) == 0x000008, "Wrong alignment on UPlotItem_BackgroundSubtitle_New");
static_assert(sizeof(UPlotItem_BackgroundSubtitle_New) == 0x0002A8, "Wrong size on UPlotItem_BackgroundSubtitle_New");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, IsOneByOne) == 0x000090, "Member 'UPlotItem_BackgroundSubtitle_New::IsOneByOne' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Keys) == 0x000098, "Member 'UPlotItem_BackgroundSubtitle_New::Keys' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, EventNames) == 0x0000A8, "Member 'UPlotItem_BackgroundSubtitle_New::EventNames' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Speakers) == 0x0000B8, "Member 'UPlotItem_BackgroundSubtitle_New::Speakers' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, UseSelfLangFile) == 0x0000C8, "Member 'UPlotItem_BackgroundSubtitle_New::UseSelfLangFile' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, FontSize) == 0x0000CC, "Member 'UPlotItem_BackgroundSubtitle_New::FontSize' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Justification) == 0x0000D0, "Member 'UPlotItem_BackgroundSubtitle_New::Justification' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, AnchorType) == 0x0000D1, "Member 'UPlotItem_BackgroundSubtitle_New::AnchorType' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, bBold) == 0x0000D2, "Member 'UPlotItem_BackgroundSubtitle_New::bBold' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, FontColor) == 0x0000D4, "Member 'UPlotItem_BackgroundSubtitle_New::FontColor' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Offset) == 0x0000E4, "Member 'UPlotItem_BackgroundSubtitle_New::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Width) == 0x0000EC, "Member 'UPlotItem_BackgroundSubtitle_New::Width' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, BackgroundSubtitlesOneByOneParams) == 0x0000F0, "Member 'UPlotItem_BackgroundSubtitle_New::BackgroundSubtitlesOneByOneParams' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, BackgroundSubtitlesParams) == 0x0000FC, "Member 'UPlotItem_BackgroundSubtitle_New::BackgroundSubtitlesParams' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, Content) == 0x000110, "Member 'UPlotItem_BackgroundSubtitle_New::Content' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundSubtitle_New, WwiseBSComponent) == 0x000120, "Member 'UPlotItem_BackgroundSubtitle_New::WwiseBSComponent' has a wrong offset!");

// Class Plot.PlotItem_BackgroundTransform
// 0x00A0 (0x0130 - 0x0090)
class UPlotItem_BackgroundTransform final : public UPlotItem
{
public:
	bool                                          TransformInherit;                                  // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewAnchor;                                       // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RelativeAnchors;                                   // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusPosition;                                     // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ScaleCurve;                                        // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopTimes;                                         // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MoveCurve;                                         // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x48];                                      // 0x00E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_BackgroundTransform">();
	}
	static class UPlotItem_BackgroundTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_BackgroundTransform>();
	}
};
static_assert(alignof(UPlotItem_BackgroundTransform) == 0x000008, "Wrong alignment on UPlotItem_BackgroundTransform");
static_assert(sizeof(UPlotItem_BackgroundTransform) == 0x000130, "Wrong size on UPlotItem_BackgroundTransform");
static_assert(offsetof(UPlotItem_BackgroundTransform, TransformInherit) == 0x000090, "Member 'UPlotItem_BackgroundTransform::TransformInherit' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, IsNewAnchor) == 0x000091, "Member 'UPlotItem_BackgroundTransform::IsNewAnchor' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, RelativeAnchors) == 0x000094, "Member 'UPlotItem_BackgroundTransform::RelativeAnchors' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, FocusPosition) == 0x00009C, "Member 'UPlotItem_BackgroundTransform::FocusPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, Duration) == 0x0000A4, "Member 'UPlotItem_BackgroundTransform::Duration' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, ScaleMultiplier) == 0x0000A8, "Member 'UPlotItem_BackgroundTransform::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, ScaleCurve) == 0x0000B0, "Member 'UPlotItem_BackgroundTransform::ScaleCurve' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, IsLoop) == 0x0000C8, "Member 'UPlotItem_BackgroundTransform::IsLoop' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, LoopTimes) == 0x0000CC, "Member 'UPlotItem_BackgroundTransform::LoopTimes' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransform, MoveCurve) == 0x0000D0, "Member 'UPlotItem_BackgroundTransform::MoveCurve' has a wrong offset!");

// Class Plot.PlotItem_KillBackgroundTransform
// 0x0008 (0x0098 - 0x0090)
class UPlotItem_KillBackgroundTransform final : public UPlotItem
{
public:
	bool                                          IsRecover;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Iscompleteflag;                                    // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeleteBG;                                          // 0x0092(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_KillBackgroundTransform">();
	}
	static class UPlotItem_KillBackgroundTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_KillBackgroundTransform>();
	}
};
static_assert(alignof(UPlotItem_KillBackgroundTransform) == 0x000008, "Wrong alignment on UPlotItem_KillBackgroundTransform");
static_assert(sizeof(UPlotItem_KillBackgroundTransform) == 0x000098, "Wrong size on UPlotItem_KillBackgroundTransform");
static_assert(offsetof(UPlotItem_KillBackgroundTransform, IsRecover) == 0x000090, "Member 'UPlotItem_KillBackgroundTransform::IsRecover' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillBackgroundTransform, Iscompleteflag) == 0x000091, "Member 'UPlotItem_KillBackgroundTransform::Iscompleteflag' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillBackgroundTransform, DeleteBG) == 0x000092, "Member 'UPlotItem_KillBackgroundTransform::DeleteBG' has a wrong offset!");

// Class Plot.PlotItem_BackgroundTransformEffect
// 0x0070 (0x0100 - 0x0090)
class UPlotItem_BackgroundTransformEffect final : public UPlotItem
{
public:
	struct FVector2D                              FocusPosition;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScale;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendValue;                                        // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_BackgroundTransformEffect">();
	}
	static class UPlotItem_BackgroundTransformEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_BackgroundTransformEffect>();
	}
};
static_assert(alignof(UPlotItem_BackgroundTransformEffect) == 0x000008, "Wrong alignment on UPlotItem_BackgroundTransformEffect");
static_assert(sizeof(UPlotItem_BackgroundTransformEffect) == 0x000100, "Wrong size on UPlotItem_BackgroundTransformEffect");
static_assert(offsetof(UPlotItem_BackgroundTransformEffect, FocusPosition) == 0x000090, "Member 'UPlotItem_BackgroundTransformEffect::FocusPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransformEffect, EndScale) == 0x000098, "Member 'UPlotItem_BackgroundTransformEffect::EndScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_BackgroundTransformEffect, BlendValue) == 0x0000A0, "Member 'UPlotItem_BackgroundTransformEffect::BlendValue' has a wrong offset!");

// Class Plot.PlotItem_Branch
// 0x0018 (0x0130 - 0x0118)
class UPlotItem_Branch final : public UPlotSaveItem
{
public:
	TArray<struct FBranchItemStruct>              Branchs;                                           // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSelect(int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Branch">();
	}
	static class UPlotItem_Branch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Branch>();
	}
};
static_assert(alignof(UPlotItem_Branch) == 0x000008, "Wrong alignment on UPlotItem_Branch");
static_assert(sizeof(UPlotItem_Branch) == 0x000130, "Wrong size on UPlotItem_Branch");
static_assert(offsetof(UPlotItem_Branch, Branchs) == 0x000118, "Member 'UPlotItem_Branch::Branchs' has a wrong offset!");

// Class Plot.PlotItem_Branch_Item
// 0x0000 (0x0118 - 0x0118)
class UPlotItem_Branch_Item final : public UPlotSaveItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Branch_Item">();
	}
	static class UPlotItem_Branch_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Branch_Item>();
	}
};
static_assert(alignof(UPlotItem_Branch_Item) == 0x000008, "Wrong alignment on UPlotItem_Branch_Item");
static_assert(sizeof(UPlotItem_Branch_Item) == 0x000118, "Wrong size on UPlotItem_Branch_Item");

// Class Plot.PlotItem_CGSpine
// 0x0038 (0x00C8 - 0x0090)
class UPlotItem_CGSpine final : public UPlotItem
{
public:
	class FName                                   SpineName;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCGSpineParameters                     CGSpineParameters;                                 // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_CGSpine">();
	}
	static class UPlotItem_CGSpine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_CGSpine>();
	}
};
static_assert(alignof(UPlotItem_CGSpine) == 0x000008, "Wrong alignment on UPlotItem_CGSpine");
static_assert(sizeof(UPlotItem_CGSpine) == 0x0000C8, "Wrong size on UPlotItem_CGSpine");
static_assert(offsetof(UPlotItem_CGSpine, SpineName) == 0x000090, "Member 'UPlotItem_CGSpine::SpineName' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpine, CGSpineParameters) == 0x000098, "Member 'UPlotItem_CGSpine::CGSpineParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpine, BlendTime) == 0x0000C0, "Member 'UPlotItem_CGSpine::BlendTime' has a wrong offset!");

// Class Plot.PlotItem_CGSpinePlayEffect
// 0x0008 (0x0098 - 0x0090)
class UPlotItem_CGSpinePlayEffect final : public UPlotItem
{
public:
	class FName                                   Name_0;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_CGSpinePlayEffect">();
	}
	static class UPlotItem_CGSpinePlayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_CGSpinePlayEffect>();
	}
};
static_assert(alignof(UPlotItem_CGSpinePlayEffect) == 0x000008, "Wrong alignment on UPlotItem_CGSpinePlayEffect");
static_assert(sizeof(UPlotItem_CGSpinePlayEffect) == 0x000098, "Wrong size on UPlotItem_CGSpinePlayEffect");
static_assert(offsetof(UPlotItem_CGSpinePlayEffect, Name_0) == 0x000090, "Member 'UPlotItem_CGSpinePlayEffect::Name_0' has a wrong offset!");

// Class Plot.PlotItem_CGSpineCameraAnimation
// 0x0048 (0x00D8 - 0x0090)
class UPlotItem_CGSpineCameraAnimation final : public UPlotItem
{
public:
	struct FVector2D                              StartLocation;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetLocation;                                    // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedCurve;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartScale;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScale;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_CGSpineCameraAnimation">();
	}
	static class UPlotItem_CGSpineCameraAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_CGSpineCameraAnimation>();
	}
};
static_assert(alignof(UPlotItem_CGSpineCameraAnimation) == 0x000008, "Wrong alignment on UPlotItem_CGSpineCameraAnimation");
static_assert(sizeof(UPlotItem_CGSpineCameraAnimation) == 0x0000D8, "Wrong size on UPlotItem_CGSpineCameraAnimation");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, StartLocation) == 0x000090, "Member 'UPlotItem_CGSpineCameraAnimation::StartLocation' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, TargetLocation) == 0x000098, "Member 'UPlotItem_CGSpineCameraAnimation::TargetLocation' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, MoveTime) == 0x0000A0, "Member 'UPlotItem_CGSpineCameraAnimation::MoveTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, SpeedCurve) == 0x0000A8, "Member 'UPlotItem_CGSpineCameraAnimation::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, StartScale) == 0x0000B0, "Member 'UPlotItem_CGSpineCameraAnimation::StartScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_CGSpineCameraAnimation, EndScale) == 0x0000B4, "Member 'UPlotItem_CGSpineCameraAnimation::EndScale' has a wrong offset!");

// Class Plot.PlotItem_ColorTint
// 0x0028 (0x00B8 - 0x0090)
class UPlotItem_ColorTint final : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TintColor;                                         // 0x009C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ColorTint">();
	}
	static class UPlotItem_ColorTint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ColorTint>();
	}
};
static_assert(alignof(UPlotItem_ColorTint) == 0x000008, "Wrong alignment on UPlotItem_ColorTint");
static_assert(sizeof(UPlotItem_ColorTint) == 0x0000B8, "Wrong size on UPlotItem_ColorTint");
static_assert(offsetof(UPlotItem_ColorTint, OrderType) == 0x000090, "Member 'UPlotItem_ColorTint::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint, OrderOffset) == 0x000094, "Member 'UPlotItem_ColorTint::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint, bIsOpen) == 0x000098, "Member 'UPlotItem_ColorTint::bIsOpen' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint, TintColor) == 0x00009C, "Member 'UPlotItem_ColorTint::TintColor' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint, Brightness) == 0x0000AC, "Member 'UPlotItem_ColorTint::Brightness' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint, Intensity) == 0x0000B0, "Member 'UPlotItem_ColorTint::Intensity' has a wrong offset!");

// Class Plot.PlotItem_ColorTint_New
// 0x0088 (0x0118 - 0x0090)
class UPlotItem_ColorTint_New final : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TintColor;                                         // 0x009C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Transition;                                        // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ColorTint_New">();
	}
	static class UPlotItem_ColorTint_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ColorTint_New>();
	}
};
static_assert(alignof(UPlotItem_ColorTint_New) == 0x000008, "Wrong alignment on UPlotItem_ColorTint_New");
static_assert(sizeof(UPlotItem_ColorTint_New) == 0x000118, "Wrong size on UPlotItem_ColorTint_New");
static_assert(offsetof(UPlotItem_ColorTint_New, OrderType) == 0x000090, "Member 'UPlotItem_ColorTint_New::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, OrderOffset) == 0x000094, "Member 'UPlotItem_ColorTint_New::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, bIsOpen) == 0x000098, "Member 'UPlotItem_ColorTint_New::bIsOpen' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, TintColor) == 0x00009C, "Member 'UPlotItem_ColorTint_New::TintColor' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, Brightness) == 0x0000AC, "Member 'UPlotItem_ColorTint_New::Brightness' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, Intensity) == 0x0000B0, "Member 'UPlotItem_ColorTint_New::Intensity' has a wrong offset!");
static_assert(offsetof(UPlotItem_ColorTint_New, Transition) == 0x0000B4, "Member 'UPlotItem_ColorTint_New::Transition' has a wrong offset!");

// Class Plot.PlotItem_Delay
// 0x0010 (0x00A0 - 0x0090)
class UPlotItem_Delay final : public UPlotItem
{
public:
	float                                         DelayTime;                                         // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Delay">();
	}
	static class UPlotItem_Delay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Delay>();
	}
};
static_assert(alignof(UPlotItem_Delay) == 0x000008, "Wrong alignment on UPlotItem_Delay");
static_assert(sizeof(UPlotItem_Delay) == 0x0000A0, "Wrong size on UPlotItem_Delay");
static_assert(offsetof(UPlotItem_Delay, DelayTime) == 0x000090, "Member 'UPlotItem_Delay::DelayTime' has a wrong offset!");

// Class Plot.PlotSingleScreenWidget
// 0x00C8 (0x0390 - 0x02C8)
class UPlotSingleScreenWidget final : public UGameCoreWidget
{
public:
	class UPlotImage*                             BG;                                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget1;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget2;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget3;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget4;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget5;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget6;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotRoleEffectWidget*                  SpineWidget3D;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Reward;                                            // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotImage*                             BgReward;                                          // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotImage*                             RewardIcon;                                        // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background_Mask;                                   // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Background_Blur;                                   // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PoseNode;                                          // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LeftPose;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 CenterPose;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RightPose;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LC_Pose;                                           // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TC_Pose;                                           // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RC_Pose;                                           // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Stage_Pose;                                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotWidget*                            PlotWidget;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMain;                                            // 0x0378(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlotRoleEffectWidget*>          SpineImages;                                       // 0x0380(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void LuaImply_BeginEntryMove(class UPlotItem_PlaySwitchScreenEntryAnim* ScreenAnimItem);
	void LuaImply_BeginLeaveMove();
	void LuaImply_EndMove();
	void LuaImply_OnUpdate(float DeltaTime, float InRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSingleScreenWidget">();
	}
	static class UPlotSingleScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSingleScreenWidget>();
	}
};
static_assert(alignof(UPlotSingleScreenWidget) == 0x000008, "Wrong alignment on UPlotSingleScreenWidget");
static_assert(sizeof(UPlotSingleScreenWidget) == 0x000390, "Wrong size on UPlotSingleScreenWidget");
static_assert(offsetof(UPlotSingleScreenWidget, BG) == 0x0002C8, "Member 'UPlotSingleScreenWidget::BG' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget1) == 0x0002D0, "Member 'UPlotSingleScreenWidget::SpineWidget1' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget2) == 0x0002D8, "Member 'UPlotSingleScreenWidget::SpineWidget2' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget3) == 0x0002E0, "Member 'UPlotSingleScreenWidget::SpineWidget3' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget4) == 0x0002E8, "Member 'UPlotSingleScreenWidget::SpineWidget4' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget5) == 0x0002F0, "Member 'UPlotSingleScreenWidget::SpineWidget5' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget6) == 0x0002F8, "Member 'UPlotSingleScreenWidget::SpineWidget6' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineWidget3D) == 0x000300, "Member 'UPlotSingleScreenWidget::SpineWidget3D' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, Reward) == 0x000308, "Member 'UPlotSingleScreenWidget::Reward' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, BgReward) == 0x000310, "Member 'UPlotSingleScreenWidget::BgReward' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, RewardIcon) == 0x000318, "Member 'UPlotSingleScreenWidget::RewardIcon' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, Background_Mask) == 0x000320, "Member 'UPlotSingleScreenWidget::Background_Mask' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, Background_Blur) == 0x000328, "Member 'UPlotSingleScreenWidget::Background_Blur' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, PoseNode) == 0x000330, "Member 'UPlotSingleScreenWidget::PoseNode' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, LeftPose) == 0x000338, "Member 'UPlotSingleScreenWidget::LeftPose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, CenterPose) == 0x000340, "Member 'UPlotSingleScreenWidget::CenterPose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, RightPose) == 0x000348, "Member 'UPlotSingleScreenWidget::RightPose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, LC_Pose) == 0x000350, "Member 'UPlotSingleScreenWidget::LC_Pose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, TC_Pose) == 0x000358, "Member 'UPlotSingleScreenWidget::TC_Pose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, RC_Pose) == 0x000360, "Member 'UPlotSingleScreenWidget::RC_Pose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, Stage_Pose) == 0x000368, "Member 'UPlotSingleScreenWidget::Stage_Pose' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, PlotWidget) == 0x000370, "Member 'UPlotSingleScreenWidget::PlotWidget' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, IsMain) == 0x000378, "Member 'UPlotSingleScreenWidget::IsMain' has a wrong offset!");
static_assert(offsetof(UPlotSingleScreenWidget, SpineImages) == 0x000380, "Member 'UPlotSingleScreenWidget::SpineImages' has a wrong offset!");

// Class Plot.PlotItem_OpenOrCloseDoubleScreen
// 0x0008 (0x0098 - 0x0090)
class UPlotItem_OpenOrCloseDoubleScreen final : public UPlotItem
{
public:
	bool                                          bIsOpen;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_OpenOrCloseDoubleScreen">();
	}
	static class UPlotItem_OpenOrCloseDoubleScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_OpenOrCloseDoubleScreen>();
	}
};
static_assert(alignof(UPlotItem_OpenOrCloseDoubleScreen) == 0x000008, "Wrong alignment on UPlotItem_OpenOrCloseDoubleScreen");
static_assert(sizeof(UPlotItem_OpenOrCloseDoubleScreen) == 0x000098, "Wrong size on UPlotItem_OpenOrCloseDoubleScreen");
static_assert(offsetof(UPlotItem_OpenOrCloseDoubleScreen, bIsOpen) == 0x000090, "Member 'UPlotItem_OpenOrCloseDoubleScreen::bIsOpen' has a wrong offset!");

// Class Plot.PlotItem_PlaySwitchScreenEntryAnim
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_PlaySwitchScreenEntryAnim final : public UPlotItem
{
public:
	EPlotSwitchScreenEntryType                    SwitchType;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestRate;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0xC];                                       // 0x009C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlaySwitchScreenEntryAnim">();
	}
	static class UPlotItem_PlaySwitchScreenEntryAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlaySwitchScreenEntryAnim>();
	}
};
static_assert(alignof(UPlotItem_PlaySwitchScreenEntryAnim) == 0x000008, "Wrong alignment on UPlotItem_PlaySwitchScreenEntryAnim");
static_assert(sizeof(UPlotItem_PlaySwitchScreenEntryAnim) == 0x0000A8, "Wrong size on UPlotItem_PlaySwitchScreenEntryAnim");
static_assert(offsetof(UPlotItem_PlaySwitchScreenEntryAnim, SwitchType) == 0x000090, "Member 'UPlotItem_PlaySwitchScreenEntryAnim::SwitchType' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlaySwitchScreenEntryAnim, DestRate) == 0x000094, "Member 'UPlotItem_PlaySwitchScreenEntryAnim::DestRate' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlaySwitchScreenEntryAnim, Duration) == 0x000098, "Member 'UPlotItem_PlaySwitchScreenEntryAnim::Duration' has a wrong offset!");

// Class Plot.PlotItem_PlaySwitchScreenLeaveAnim
// 0x0010 (0x00A0 - 0x0090)
class UPlotItem_PlaySwitchScreenLeaveAnim final : public UPlotItem
{
public:
	float                                         Duration;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlaySwitchScreenLeaveAnim">();
	}
	static class UPlotItem_PlaySwitchScreenLeaveAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlaySwitchScreenLeaveAnim>();
	}
};
static_assert(alignof(UPlotItem_PlaySwitchScreenLeaveAnim) == 0x000008, "Wrong alignment on UPlotItem_PlaySwitchScreenLeaveAnim");
static_assert(sizeof(UPlotItem_PlaySwitchScreenLeaveAnim) == 0x0000A0, "Wrong size on UPlotItem_PlaySwitchScreenLeaveAnim");
static_assert(offsetof(UPlotItem_PlaySwitchScreenLeaveAnim, Duration) == 0x000090, "Member 'UPlotItem_PlaySwitchScreenLeaveAnim::Duration' has a wrong offset!");

// Class Plot.PlotItem_EffectWithBone
// 0x0078 (0x0108 - 0x0090)
class UPlotItem_EffectWithBone final : public UPlotItem
{
public:
	int32                                         Pos;                                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EffectAsset;                                       // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BoneName;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NiagaraSystemAsset;                                // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SpawnedNiagaraComponent;                           // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_EffectWithBone">();
	}
	static class UPlotItem_EffectWithBone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_EffectWithBone>();
	}
};
static_assert(alignof(UPlotItem_EffectWithBone) == 0x000008, "Wrong alignment on UPlotItem_EffectWithBone");
static_assert(sizeof(UPlotItem_EffectWithBone) == 0x000108, "Wrong size on UPlotItem_EffectWithBone");
static_assert(offsetof(UPlotItem_EffectWithBone, Pos) == 0x000090, "Member 'UPlotItem_EffectWithBone::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, ID) == 0x000098, "Member 'UPlotItem_EffectWithBone::ID' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, EffectAsset) == 0x0000A8, "Member 'UPlotItem_EffectWithBone::EffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, BoneName) == 0x0000C0, "Member 'UPlotItem_EffectWithBone::BoneName' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, LocationOffset) == 0x0000D0, "Member 'UPlotItem_EffectWithBone::LocationOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, NiagaraSystemAsset) == 0x0000E0, "Member 'UPlotItem_EffectWithBone::NiagaraSystemAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_EffectWithBone, SpawnedNiagaraComponent) == 0x0000E8, "Member 'UPlotItem_EffectWithBone::SpawnedNiagaraComponent' has a wrong offset!");

// Class Plot.PlotFindEvidenceWidget
// 0x0008 (0x02D0 - 0x02C8)
class UPlotFindEvidenceWidget final : public UGameCoreWidget
{
public:
	TWeakObjectPtr<class UPlotItem_FindEvidence>  FindEvidence;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UPlotWidget* GetPlotWidget();
	void GotoGroup(const class FString& InGroupName);
	void LuaImpl_OnGroupComplete();
	void NotifyComplete(const TArray<class FString>& InArray);
	void OnGroupComplete();
	void OnStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotFindEvidenceWidget">();
	}
	static class UPlotFindEvidenceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotFindEvidenceWidget>();
	}
};
static_assert(alignof(UPlotFindEvidenceWidget) == 0x000008, "Wrong alignment on UPlotFindEvidenceWidget");
static_assert(sizeof(UPlotFindEvidenceWidget) == 0x0002D0, "Wrong size on UPlotFindEvidenceWidget");
static_assert(offsetof(UPlotFindEvidenceWidget, FindEvidence) == 0x0002C8, "Member 'UPlotFindEvidenceWidget::FindEvidence' has a wrong offset!");

// Class Plot.PlotItem_FindEvidence
// 0x0048 (0x00D8 - 0x0090)
class UPlotItem_FindEvidence final : public UPlotItem
{
public:
	struct FSoftClassPath                         UMGPath;                                           // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotWidgetOrderType                          ZOrder;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlaceName;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InitGroup;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_FindEvidence">();
	}
	static class UPlotItem_FindEvidence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_FindEvidence>();
	}
};
static_assert(alignof(UPlotItem_FindEvidence) == 0x000008, "Wrong alignment on UPlotItem_FindEvidence");
static_assert(sizeof(UPlotItem_FindEvidence) == 0x0000D8, "Wrong size on UPlotItem_FindEvidence");
static_assert(offsetof(UPlotItem_FindEvidence, UMGPath) == 0x000090, "Member 'UPlotItem_FindEvidence::UMGPath' has a wrong offset!");
static_assert(offsetof(UPlotItem_FindEvidence, ZOrder) == 0x0000A8, "Member 'UPlotItem_FindEvidence::ZOrder' has a wrong offset!");
static_assert(offsetof(UPlotItem_FindEvidence, OrderOffset) == 0x0000AC, "Member 'UPlotItem_FindEvidence::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_FindEvidence, PlaceName) == 0x0000B0, "Member 'UPlotItem_FindEvidence::PlaceName' has a wrong offset!");
static_assert(offsetof(UPlotItem_FindEvidence, InitGroup) == 0x0000C0, "Member 'UPlotItem_FindEvidence::InitGroup' has a wrong offset!");

// Class Plot.PlotItem_FullscreenSpine
// 0x0080 (0x0110 - 0x0090)
class UPlotItem_FullscreenSpine final : public UPlotItem
{
public:
	class FString                                 RoleName;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpineParameters                       SpineParameters;                                   // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bHide : 1;                                         // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Order;                                             // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpineWidget*                           SpineWidget;                                       // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_FullscreenSpine">();
	}
	static class UPlotItem_FullscreenSpine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_FullscreenSpine>();
	}
};
static_assert(alignof(UPlotItem_FullscreenSpine) == 0x000008, "Wrong alignment on UPlotItem_FullscreenSpine");
static_assert(sizeof(UPlotItem_FullscreenSpine) == 0x000110, "Wrong size on UPlotItem_FullscreenSpine");
static_assert(offsetof(UPlotItem_FullscreenSpine, RoleName) == 0x000090, "Member 'UPlotItem_FullscreenSpine::RoleName' has a wrong offset!");
static_assert(offsetof(UPlotItem_FullscreenSpine, SpineParameters) == 0x0000A0, "Member 'UPlotItem_FullscreenSpine::SpineParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_FullscreenSpine, Order) == 0x0000F4, "Member 'UPlotItem_FullscreenSpine::Order' has a wrong offset!");
static_assert(offsetof(UPlotItem_FullscreenSpine, SpineWidget) == 0x0000F8, "Member 'UPlotItem_FullscreenSpine::SpineWidget' has a wrong offset!");

// Class Plot.PlotItem_Group
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_Group final : public UPlotItem
{
public:
	class FString                                 GroupName;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Group">();
	}
	static class UPlotItem_Group* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Group>();
	}
};
static_assert(alignof(UPlotItem_Group) == 0x000008, "Wrong alignment on UPlotItem_Group");
static_assert(sizeof(UPlotItem_Group) == 0x0000B0, "Wrong size on UPlotItem_Group");
static_assert(offsetof(UPlotItem_Group, GroupName) == 0x000090, "Member 'UPlotItem_Group::GroupName' has a wrong offset!");

// Class Plot.PlotItem_LoadHandDraw
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_LoadHandDraw final : public UPlotItem
{
public:
	struct FSoftClassPath                         UMGHandDrawAsset;                                  // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotWidgetOrderType                          ZOrder;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x1F];                                      // 0x00B1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LoadHandDraw">();
	}
	static class UPlotItem_LoadHandDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LoadHandDraw>();
	}
};
static_assert(alignof(UPlotItem_LoadHandDraw) == 0x000008, "Wrong alignment on UPlotItem_LoadHandDraw");
static_assert(sizeof(UPlotItem_LoadHandDraw) == 0x0000D0, "Wrong size on UPlotItem_LoadHandDraw");
static_assert(offsetof(UPlotItem_LoadHandDraw, UMGHandDrawAsset) == 0x000090, "Member 'UPlotItem_LoadHandDraw::UMGHandDrawAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadHandDraw, ZOrder) == 0x0000A8, "Member 'UPlotItem_LoadHandDraw::ZOrder' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadHandDraw, OrderOffset) == 0x0000AC, "Member 'UPlotItem_LoadHandDraw::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadHandDraw, bHide) == 0x0000B0, "Member 'UPlotItem_LoadHandDraw::bHide' has a wrong offset!");

// Class Plot.PlotItem_ControlHandDraw
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_ControlHandDraw final : public UPlotItem
{
public:
	bool                                          bClearAll;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAll;                                          // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHandDrawAxisParams>            HandDrawAxisOpenArray;                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MoveOffset;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ControlHandDraw">();
	}
	static class UPlotItem_ControlHandDraw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ControlHandDraw>();
	}
};
static_assert(alignof(UPlotItem_ControlHandDraw) == 0x000008, "Wrong alignment on UPlotItem_ControlHandDraw");
static_assert(sizeof(UPlotItem_ControlHandDraw) == 0x0000D0, "Wrong size on UPlotItem_ControlHandDraw");
static_assert(offsetof(UPlotItem_ControlHandDraw, bClearAll) == 0x000090, "Member 'UPlotItem_ControlHandDraw::bClearAll' has a wrong offset!");
static_assert(offsetof(UPlotItem_ControlHandDraw, bShowAll) == 0x000091, "Member 'UPlotItem_ControlHandDraw::bShowAll' has a wrong offset!");
static_assert(offsetof(UPlotItem_ControlHandDraw, HandDrawAxisOpenArray) == 0x000098, "Member 'UPlotItem_ControlHandDraw::HandDrawAxisOpenArray' has a wrong offset!");
static_assert(offsetof(UPlotItem_ControlHandDraw, MoveOffset) == 0x0000A8, "Member 'UPlotItem_ControlHandDraw::MoveOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_ControlHandDraw, Multiplier) == 0x0000B0, "Member 'UPlotItem_ControlHandDraw::Multiplier' has a wrong offset!");
static_assert(offsetof(UPlotItem_ControlHandDraw, Duration) == 0x0000B4, "Member 'UPlotItem_ControlHandDraw::Duration' has a wrong offset!");

// Class Plot.PlotItem_KillEffectWithBone
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_KillEffectWithBone final : public UPlotItem
{
public:
	int32                                         Pos;                                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_KillEffectWithBone">();
	}
	static class UPlotItem_KillEffectWithBone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_KillEffectWithBone>();
	}
};
static_assert(alignof(UPlotItem_KillEffectWithBone) == 0x000008, "Wrong alignment on UPlotItem_KillEffectWithBone");
static_assert(sizeof(UPlotItem_KillEffectWithBone) == 0x0000A8, "Wrong size on UPlotItem_KillEffectWithBone");
static_assert(offsetof(UPlotItem_KillEffectWithBone, Pos) == 0x000090, "Member 'UPlotItem_KillEffectWithBone::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillEffectWithBone, ID) == 0x000098, "Member 'UPlotItem_KillEffectWithBone::ID' has a wrong offset!");

// Class Plot.PlotItem_LoadImg
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_LoadImg : public UPlotItem
{
public:
	struct FSoftObjectPath                        ImgPath;                                           // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlendParameters                       BlendParameters;                                   // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bHide : 1;                                         // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RelativeAnchors;                                   // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusPosition;                                     // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LoadImg">();
	}
	static class UPlotItem_LoadImg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LoadImg>();
	}
};
static_assert(alignof(UPlotItem_LoadImg) == 0x000008, "Wrong alignment on UPlotItem_LoadImg");
static_assert(sizeof(UPlotItem_LoadImg) == 0x0000D0, "Wrong size on UPlotItem_LoadImg");
static_assert(offsetof(UPlotItem_LoadImg, ImgPath) == 0x000090, "Member 'UPlotItem_LoadImg::ImgPath' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadImg, BlendParameters) == 0x0000A8, "Member 'UPlotItem_LoadImg::BlendParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadImg, RelativeAnchors) == 0x0000BC, "Member 'UPlotItem_LoadImg::RelativeAnchors' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadImg, FocusPosition) == 0x0000C4, "Member 'UPlotItem_LoadImg::FocusPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadImg, ScaleMultiplier) == 0x0000CC, "Member 'UPlotItem_LoadImg::ScaleMultiplier' has a wrong offset!");

// Class Plot.PlotItem_LoadImg_Reward
// 0x0000 (0x00D0 - 0x00D0)
class UPlotItem_LoadImg_Reward final : public UPlotItem_LoadImg
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LoadImg_Reward">();
	}
	static class UPlotItem_LoadImg_Reward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LoadImg_Reward>();
	}
};
static_assert(alignof(UPlotItem_LoadImg_Reward) == 0x000008, "Wrong alignment on UPlotItem_LoadImg_Reward");
static_assert(sizeof(UPlotItem_LoadImg_Reward) == 0x0000D0, "Wrong size on UPlotItem_LoadImg_Reward");

// Class Plot.PlotItem_LoadEffectImage
// 0x0018 (0x00E8 - 0x00D0)
class UPlotItem_LoadEffectImage final : public UPlotItem_LoadImg
{
public:
	struct FVector2D                              Position;                                          // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotImage*                             ImageComponent;                                    // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepeatIndex;                                       // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCenter : 1;                                       // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLowest : 1;                                       // 0x00E4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LoadEffectImage">();
	}
	static class UPlotItem_LoadEffectImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LoadEffectImage>();
	}
};
static_assert(alignof(UPlotItem_LoadEffectImage) == 0x000008, "Wrong alignment on UPlotItem_LoadEffectImage");
static_assert(sizeof(UPlotItem_LoadEffectImage) == 0x0000E8, "Wrong size on UPlotItem_LoadEffectImage");
static_assert(offsetof(UPlotItem_LoadEffectImage, Position) == 0x0000D0, "Member 'UPlotItem_LoadEffectImage::Position' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadEffectImage, ImageComponent) == 0x0000D8, "Member 'UPlotItem_LoadEffectImage::ImageComponent' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadEffectImage, RepeatIndex) == 0x0000E0, "Member 'UPlotItem_LoadEffectImage::RepeatIndex' has a wrong offset!");

// Class Plot.PlotItem_LoadAndSetMultiImg
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_LoadAndSetMultiImg final : public UPlotItem
{
public:
	ESpliceType                                   SpliceType;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                ImgPathArray;                                      // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x14];                                      // 0x00A8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RelativeAnchors;                                   // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusPosition;                                     // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void LoadMultiImgs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_LoadAndSetMultiImg">();
	}
	static class UPlotItem_LoadAndSetMultiImg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_LoadAndSetMultiImg>();
	}
};
static_assert(alignof(UPlotItem_LoadAndSetMultiImg) == 0x000008, "Wrong alignment on UPlotItem_LoadAndSetMultiImg");
static_assert(sizeof(UPlotItem_LoadAndSetMultiImg) == 0x0000D0, "Wrong size on UPlotItem_LoadAndSetMultiImg");
static_assert(offsetof(UPlotItem_LoadAndSetMultiImg, SpliceType) == 0x000090, "Member 'UPlotItem_LoadAndSetMultiImg::SpliceType' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadAndSetMultiImg, ImgPathArray) == 0x000098, "Member 'UPlotItem_LoadAndSetMultiImg::ImgPathArray' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadAndSetMultiImg, RelativeAnchors) == 0x0000BC, "Member 'UPlotItem_LoadAndSetMultiImg::RelativeAnchors' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadAndSetMultiImg, FocusPosition) == 0x0000C4, "Member 'UPlotItem_LoadAndSetMultiImg::FocusPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_LoadAndSetMultiImg, ScaleMultiplier) == 0x0000CC, "Member 'UPlotItem_LoadAndSetMultiImg::ScaleMultiplier' has a wrong offset!");

// Class Plot.PlotItem_DebugTip
// 0x0010 (0x00C0 - 0x00B0)
class UPlotItem_DebugTip final : public UPlotItem_LuaImpl
{
public:
	class FString                                 Tip;                                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_DebugTip">();
	}
	static class UPlotItem_DebugTip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_DebugTip>();
	}
};
static_assert(alignof(UPlotItem_DebugTip) == 0x000008, "Wrong alignment on UPlotItem_DebugTip");
static_assert(sizeof(UPlotItem_DebugTip) == 0x0000C0, "Wrong size on UPlotItem_DebugTip");
static_assert(offsetof(UPlotItem_DebugTip, Tip) == 0x0000B0, "Member 'UPlotItem_DebugTip::Tip' has a wrong offset!");

// Class Plot.PlotItem_DisableAllScreenMessages
// 0x0000 (0x0090 - 0x0090)
class UPlotItem_DisableAllScreenMessages final : public UPlotItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_DisableAllScreenMessages">();
	}
	static class UPlotItem_DisableAllScreenMessages* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_DisableAllScreenMessages>();
	}
};
static_assert(alignof(UPlotItem_DisableAllScreenMessages) == 0x000008, "Wrong alignment on UPlotItem_DisableAllScreenMessages");
static_assert(sizeof(UPlotItem_DisableAllScreenMessages) == 0x000090, "Wrong size on UPlotItem_DisableAllScreenMessages");

// Class Plot.PlotItem_SetSkipEnabled
// 0x0008 (0x00B8 - 0x00B0)
class UPlotItem_SetSkipEnabled final : public UPlotItem_LuaImpl
{
public:
	bool                                          Enabled;                                           // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetSkipEnabled">();
	}
	static class UPlotItem_SetSkipEnabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetSkipEnabled>();
	}
};
static_assert(alignof(UPlotItem_SetSkipEnabled) == 0x000008, "Wrong alignment on UPlotItem_SetSkipEnabled");
static_assert(sizeof(UPlotItem_SetSkipEnabled) == 0x0000B8, "Wrong size on UPlotItem_SetSkipEnabled");
static_assert(offsetof(UPlotItem_SetSkipEnabled, Enabled) == 0x0000B0, "Member 'UPlotItem_SetSkipEnabled::Enabled' has a wrong offset!");

// Class Plot.PlotItem_TableGame
// 0x0070 (0x0120 - 0x00B0)
class UPlotItem_TableGame final : public UPlotItem_LuaImpl
{
public:
	class FString                                 TextKey;                                           // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiceMin;                                           // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiceMax;                                           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestValue;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GreatSuccess;                                      // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicFail;                                          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SuccessGroup;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GreatSuccessGroup;                                 // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FailGroup;                                         // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicFailGroup;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GotoGroup(const class FString& InGroupName);
	void OnGroupComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_TableGame">();
	}
	static class UPlotItem_TableGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_TableGame>();
	}
};
static_assert(alignof(UPlotItem_TableGame) == 0x000008, "Wrong alignment on UPlotItem_TableGame");
static_assert(sizeof(UPlotItem_TableGame) == 0x000120, "Wrong size on UPlotItem_TableGame");
static_assert(offsetof(UPlotItem_TableGame, TextKey) == 0x0000B0, "Member 'UPlotItem_TableGame::TextKey' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, DiceMin) == 0x0000C0, "Member 'UPlotItem_TableGame::DiceMin' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, DiceMax) == 0x0000C4, "Member 'UPlotItem_TableGame::DiceMax' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, DestValue) == 0x0000C8, "Member 'UPlotItem_TableGame::DestValue' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, GreatSuccess) == 0x0000CC, "Member 'UPlotItem_TableGame::GreatSuccess' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, EpicFail) == 0x0000D0, "Member 'UPlotItem_TableGame::EpicFail' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, SuccessGroup) == 0x0000D8, "Member 'UPlotItem_TableGame::SuccessGroup' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, GreatSuccessGroup) == 0x0000E8, "Member 'UPlotItem_TableGame::GreatSuccessGroup' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, FailGroup) == 0x0000F8, "Member 'UPlotItem_TableGame::FailGroup' has a wrong offset!");
static_assert(offsetof(UPlotItem_TableGame, EpicFailGroup) == 0x000108, "Member 'UPlotItem_TableGame::EpicFailGroup' has a wrong offset!");

// Class Plot.PlotItem_OpenCGSpine
// 0x0038 (0x00C8 - 0x0090)
class UPlotItem_OpenCGSpine final : public UPlotItem
{
public:
	class UCGSpineData*                           CGSpineAsset;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlendParameters                       BlendParameters;                                   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Location;                                          // 0x00AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpen;                                             // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNewCamera;                                     // 0x00B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x12];                                      // 0x00B6(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_OpenCGSpine">();
	}
	static class UPlotItem_OpenCGSpine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_OpenCGSpine>();
	}
};
static_assert(alignof(UPlotItem_OpenCGSpine) == 0x000008, "Wrong alignment on UPlotItem_OpenCGSpine");
static_assert(sizeof(UPlotItem_OpenCGSpine) == 0x0000C8, "Wrong size on UPlotItem_OpenCGSpine");
static_assert(offsetof(UPlotItem_OpenCGSpine, CGSpineAsset) == 0x000090, "Member 'UPlotItem_OpenCGSpine::CGSpineAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenCGSpine, BlendParameters) == 0x000098, "Member 'UPlotItem_OpenCGSpine::BlendParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenCGSpine, Scale) == 0x0000A8, "Member 'UPlotItem_OpenCGSpine::Scale' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenCGSpine, Location) == 0x0000AC, "Member 'UPlotItem_OpenCGSpine::Location' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenCGSpine, bOpen) == 0x0000B4, "Member 'UPlotItem_OpenCGSpine::bOpen' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenCGSpine, bUseNewCamera) == 0x0000B5, "Member 'UPlotItem_OpenCGSpine::bUseNewCamera' has a wrong offset!");

// Class Plot.PlotItem_OpenSequencerUserWidget
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_OpenSequencerUserWidget final : public UPlotItem
{
public:
	TSubclassOf<class USequencerUserWidget>       StageAnimationWidgetClass;                         // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USequencerUserWidget>       StageAnimationWidgetClassFix;                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipWhenNoFixRes;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCloseDefaultBackgroundSound : 1;                  // 0x00A1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_OpenSequencerUserWidget">();
	}
	static class UPlotItem_OpenSequencerUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_OpenSequencerUserWidget>();
	}
};
static_assert(alignof(UPlotItem_OpenSequencerUserWidget) == 0x000008, "Wrong alignment on UPlotItem_OpenSequencerUserWidget");
static_assert(sizeof(UPlotItem_OpenSequencerUserWidget) == 0x0000A8, "Wrong size on UPlotItem_OpenSequencerUserWidget");
static_assert(offsetof(UPlotItem_OpenSequencerUserWidget, StageAnimationWidgetClass) == 0x000090, "Member 'UPlotItem_OpenSequencerUserWidget::StageAnimationWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenSequencerUserWidget, StageAnimationWidgetClassFix) == 0x000098, "Member 'UPlotItem_OpenSequencerUserWidget::StageAnimationWidgetClassFix' has a wrong offset!");
static_assert(offsetof(UPlotItem_OpenSequencerUserWidget, bSkipWhenNoFixRes) == 0x0000A0, "Member 'UPlotItem_OpenSequencerUserWidget::bSkipWhenNoFixRes' has a wrong offset!");

// Class Plot.PlotItem_PlayEffect
// 0x0058 (0x00E8 - 0x0090)
class UPlotItem_PlayEffect final : public UPlotItem
{
public:
	class FString                                 EffectName;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Effect;                                            // 0x00A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x00C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0xF];                                       // 0x00D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlayEffect">();
	}
	static class UPlotItem_PlayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlayEffect>();
	}
};
static_assert(alignof(UPlotItem_PlayEffect) == 0x000008, "Wrong alignment on UPlotItem_PlayEffect");
static_assert(sizeof(UPlotItem_PlayEffect) == 0x0000E8, "Wrong size on UPlotItem_PlayEffect");
static_assert(offsetof(UPlotItem_PlayEffect, EffectName) == 0x000090, "Member 'UPlotItem_PlayEffect::EffectName' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayEffect, Effect) == 0x0000A0, "Member 'UPlotItem_PlayEffect::Effect' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayEffect, Position) == 0x0000B8, "Member 'UPlotItem_PlayEffect::Position' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayEffect, Rotator) == 0x0000C4, "Member 'UPlotItem_PlayEffect::Rotator' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayEffect, SocketName) == 0x0000D0, "Member 'UPlotItem_PlayEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayEffect, bHide) == 0x0000D8, "Member 'UPlotItem_PlayEffect::bHide' has a wrong offset!");

// Class Plot.PlotItem_PlaySequence
// 0x0088 (0x0118 - 0x0090)
class UPlotItem_PlaySequence final : public UPlotItem
{
public:
	struct FPlotCutSceneData                      CutSceneData;                                      // 0x0090(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSequenceFinishedHandler(float InTime);
	void PlayFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlaySequence">();
	}
	static class UPlotItem_PlaySequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlaySequence>();
	}
};
static_assert(alignof(UPlotItem_PlaySequence) == 0x000008, "Wrong alignment on UPlotItem_PlaySequence");
static_assert(sizeof(UPlotItem_PlaySequence) == 0x000118, "Wrong size on UPlotItem_PlaySequence");
static_assert(offsetof(UPlotItem_PlaySequence, CutSceneData) == 0x000090, "Member 'UPlotItem_PlaySequence::CutSceneData' has a wrong offset!");

// Class Plot.PlotItem_PlaySequence_Item
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_PlaySequence_Item final : public UPlotItem
{
public:
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlaySequence_Item">();
	}
	static class UPlotItem_PlaySequence_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlaySequence_Item>();
	}
};
static_assert(alignof(UPlotItem_PlaySequence_Item) == 0x000008, "Wrong alignment on UPlotItem_PlaySequence_Item");
static_assert(sizeof(UPlotItem_PlaySequence_Item) == 0x0000A8, "Wrong size on UPlotItem_PlaySequence_Item");

// Class Plot.PlotItem_PlayUIParticleEffect
// 0x00A8 (0x0138 - 0x0090)
class UPlotItem_PlayUIParticleEffect final : public UPlotItem
{
public:
	struct FSoftObjectPath                        EffectAsset;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         UMGEffectAsset;                                    // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCartoon;                                         // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TrackName;                                         // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Looptime;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_key;                                          // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PositionLT;                                        // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PositionRB;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AssetBounds;                                       // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotWidgetOrderType                          ZOrder;                                            // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x23];                                     // 0x0115(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlayUIParticleEffect">();
	}
	static class UPlotItem_PlayUIParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlayUIParticleEffect>();
	}
};
static_assert(alignof(UPlotItem_PlayUIParticleEffect) == 0x000008, "Wrong alignment on UPlotItem_PlayUIParticleEffect");
static_assert(sizeof(UPlotItem_PlayUIParticleEffect) == 0x000138, "Wrong size on UPlotItem_PlayUIParticleEffect");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, EffectAsset) == 0x000090, "Member 'UPlotItem_PlayUIParticleEffect::EffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, UMGEffectAsset) == 0x0000A8, "Member 'UPlotItem_PlayUIParticleEffect::UMGEffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, IsCartoon) == 0x0000C0, "Member 'UPlotItem_PlayUIParticleEffect::IsCartoon' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, TrackName) == 0x0000C8, "Member 'UPlotItem_PlayUIParticleEffect::TrackName' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, Looptime) == 0x0000D8, "Member 'UPlotItem_PlayUIParticleEffect::Looptime' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, Name_key) == 0x0000E0, "Member 'UPlotItem_PlayUIParticleEffect::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, PositionLT) == 0x0000F0, "Member 'UPlotItem_PlayUIParticleEffect::PositionLT' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, PositionRB) == 0x0000F8, "Member 'UPlotItem_PlayUIParticleEffect::PositionRB' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, AssetBounds) == 0x000100, "Member 'UPlotItem_PlayUIParticleEffect::AssetBounds' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, ZOrder) == 0x000108, "Member 'UPlotItem_PlayUIParticleEffect::ZOrder' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, OrderOffset) == 0x00010C, "Member 'UPlotItem_PlayUIParticleEffect::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, FadeTime) == 0x000110, "Member 'UPlotItem_PlayUIParticleEffect::FadeTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayUIParticleEffect, bHide) == 0x000114, "Member 'UPlotItem_PlayUIParticleEffect::bHide' has a wrong offset!");

// Class Plot.PlotItem_PartialUIParticleEffect
// 0x0098 (0x0128 - 0x0090)
class UPlotItem_PartialUIParticleEffect final : public UPlotItem
{
public:
	struct FSoftObjectPath                        EffectAsset;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         UMGEffectAsset;                                    // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_key;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               AnchorPosition;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AssetBounds;                                       // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotWidgetOrderType                          ZOrder;                                            // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x0104(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x23];                                     // 0x0105(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PartialUIParticleEffect">();
	}
	static class UPlotItem_PartialUIParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PartialUIParticleEffect>();
	}
};
static_assert(alignof(UPlotItem_PartialUIParticleEffect) == 0x000008, "Wrong alignment on UPlotItem_PartialUIParticleEffect");
static_assert(sizeof(UPlotItem_PartialUIParticleEffect) == 0x000128, "Wrong size on UPlotItem_PartialUIParticleEffect");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, EffectAsset) == 0x000090, "Member 'UPlotItem_PartialUIParticleEffect::EffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, UMGEffectAsset) == 0x0000A8, "Member 'UPlotItem_PartialUIParticleEffect::UMGEffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, Name_key) == 0x0000C0, "Member 'UPlotItem_PartialUIParticleEffect::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, AnchorPosition) == 0x0000D0, "Member 'UPlotItem_PartialUIParticleEffect::AnchorPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, Position) == 0x0000E0, "Member 'UPlotItem_PartialUIParticleEffect::Position' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, Size) == 0x0000E8, "Member 'UPlotItem_PartialUIParticleEffect::Size' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, AssetBounds) == 0x0000F0, "Member 'UPlotItem_PartialUIParticleEffect::AssetBounds' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, ZOrder) == 0x0000F8, "Member 'UPlotItem_PartialUIParticleEffect::ZOrder' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, OrderOffset) == 0x0000FC, "Member 'UPlotItem_PartialUIParticleEffect::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, FadeTime) == 0x000100, "Member 'UPlotItem_PartialUIParticleEffect::FadeTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_PartialUIParticleEffect, bHide) == 0x000104, "Member 'UPlotItem_PartialUIParticleEffect::bHide' has a wrong offset!");

// Class Plot.PlotItem_MovePartialUIParticleEffect
// 0x0078 (0x0108 - 0x0090)
class UPlotItem_MovePartialUIParticleEffect final : public UPlotItem
{
public:
	struct FSoftObjectPath                        EffectAsset;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         UMGEffectAsset;                                    // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_key;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoTweenType                                  MoveType;                                          // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ControlPoint;                                      // 0x00D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MoveCurve;                                         // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopTimes;                                         // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_MovePartialUIParticleEffect">();
	}
	static class UPlotItem_MovePartialUIParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_MovePartialUIParticleEffect>();
	}
};
static_assert(alignof(UPlotItem_MovePartialUIParticleEffect) == 0x000008, "Wrong alignment on UPlotItem_MovePartialUIParticleEffect");
static_assert(sizeof(UPlotItem_MovePartialUIParticleEffect) == 0x000108, "Wrong size on UPlotItem_MovePartialUIParticleEffect");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, EffectAsset) == 0x000090, "Member 'UPlotItem_MovePartialUIParticleEffect::EffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, UMGEffectAsset) == 0x0000A8, "Member 'UPlotItem_MovePartialUIParticleEffect::UMGEffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, Name_key) == 0x0000C0, "Member 'UPlotItem_MovePartialUIParticleEffect::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, MoveType) == 0x0000D0, "Member 'UPlotItem_MovePartialUIParticleEffect::MoveType' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, ControlPoint) == 0x0000D4, "Member 'UPlotItem_MovePartialUIParticleEffect::ControlPoint' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, MoveCurve) == 0x0000E0, "Member 'UPlotItem_MovePartialUIParticleEffect::MoveCurve' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, IsLoop) == 0x0000F8, "Member 'UPlotItem_MovePartialUIParticleEffect::IsLoop' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, LoopTimes) == 0x0000FC, "Member 'UPlotItem_MovePartialUIParticleEffect::LoopTimes' has a wrong offset!");
static_assert(offsetof(UPlotItem_MovePartialUIParticleEffect, Duration) == 0x000100, "Member 'UPlotItem_MovePartialUIParticleEffect::Duration' has a wrong offset!");

// Class Plot.PlotItem_KillUIParticleEffect
// 0x0048 (0x00D8 - 0x0090)
class UPlotItem_KillUIParticleEffect final : public UPlotItem
{
public:
	struct FSoftObjectPath                        EffectAsset;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         UMGEffectAsset;                                    // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_key;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Iscompleteflag;                                    // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_KillUIParticleEffect">();
	}
	static class UPlotItem_KillUIParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_KillUIParticleEffect>();
	}
};
static_assert(alignof(UPlotItem_KillUIParticleEffect) == 0x000008, "Wrong alignment on UPlotItem_KillUIParticleEffect");
static_assert(sizeof(UPlotItem_KillUIParticleEffect) == 0x0000D8, "Wrong size on UPlotItem_KillUIParticleEffect");
static_assert(offsetof(UPlotItem_KillUIParticleEffect, EffectAsset) == 0x000090, "Member 'UPlotItem_KillUIParticleEffect::EffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillUIParticleEffect, UMGEffectAsset) == 0x0000A8, "Member 'UPlotItem_KillUIParticleEffect::UMGEffectAsset' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillUIParticleEffect, Name_key) == 0x0000C0, "Member 'UPlotItem_KillUIParticleEffect::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillUIParticleEffect, Iscompleteflag) == 0x0000D0, "Member 'UPlotItem_KillUIParticleEffect::Iscompleteflag' has a wrong offset!");

// Class Plot.PlotItem_PlayWwise
// 0x0060 (0x00F0 - 0x0090)
class UPlotItem_PlayWwise final : public UPlotItem
{
public:
	struct FNameSelected                          EventNameSelected;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_key;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BusName;                                           // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeScale;                                       // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlayCount;                                         // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseComponent*                        WwiseComponent;                                    // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWwiseEndPlayHandler(class UWwiseComponent* InWwiseComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_PlayWwise">();
	}
	static class UPlotItem_PlayWwise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_PlayWwise>();
	}
};
static_assert(alignof(UPlotItem_PlayWwise) == 0x000008, "Wrong alignment on UPlotItem_PlayWwise");
static_assert(sizeof(UPlotItem_PlayWwise) == 0x0000F0, "Wrong size on UPlotItem_PlayWwise");
static_assert(offsetof(UPlotItem_PlayWwise, EventNameSelected) == 0x000090, "Member 'UPlotItem_PlayWwise::EventNameSelected' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, EventName) == 0x0000A0, "Member 'UPlotItem_PlayWwise::EventName' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, Name_key) == 0x0000B0, "Member 'UPlotItem_PlayWwise::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, BusName) == 0x0000C0, "Member 'UPlotItem_PlayWwise::BusName' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, FadeInTime) == 0x0000D0, "Member 'UPlotItem_PlayWwise::FadeInTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, VolumeScale) == 0x0000D4, "Member 'UPlotItem_PlayWwise::VolumeScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, PlayCount) == 0x0000D8, "Member 'UPlotItem_PlayWwise::PlayCount' has a wrong offset!");
static_assert(offsetof(UPlotItem_PlayWwise, WwiseComponent) == 0x0000E0, "Member 'UPlotItem_PlayWwise::WwiseComponent' has a wrong offset!");

// Class Plot.PlotItem_StopWwise
// 0x0028 (0x00B8 - 0x0090)
class UPlotItem_StopWwise final : public UPlotItem
{
public:
	class FString                                 EventName;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_key;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_StopWwise">();
	}
	static class UPlotItem_StopWwise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_StopWwise>();
	}
};
static_assert(alignof(UPlotItem_StopWwise) == 0x000008, "Wrong alignment on UPlotItem_StopWwise");
static_assert(sizeof(UPlotItem_StopWwise) == 0x0000B8, "Wrong size on UPlotItem_StopWwise");
static_assert(offsetof(UPlotItem_StopWwise, EventName) == 0x000090, "Member 'UPlotItem_StopWwise::EventName' has a wrong offset!");
static_assert(offsetof(UPlotItem_StopWwise, Name_key) == 0x0000A0, "Member 'UPlotItem_StopWwise::Name_key' has a wrong offset!");
static_assert(offsetof(UPlotItem_StopWwise, FadeOutTime) == 0x0000B0, "Member 'UPlotItem_StopWwise::FadeOutTime' has a wrong offset!");

// Class Plot.PlotItem_SetVolumeScalue
// 0x0010 (0x00A0 - 0x0090)
class UPlotItem_SetVolumeScalue final : public UPlotItem
{
public:
	EWwiseVolumeType                              VolumeType;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetVolumeScalue">();
	}
	static class UPlotItem_SetVolumeScalue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetVolumeScalue>();
	}
};
static_assert(alignof(UPlotItem_SetVolumeScalue) == 0x000008, "Wrong alignment on UPlotItem_SetVolumeScalue");
static_assert(sizeof(UPlotItem_SetVolumeScalue) == 0x0000A0, "Wrong size on UPlotItem_SetVolumeScalue");
static_assert(offsetof(UPlotItem_SetVolumeScalue, VolumeType) == 0x000090, "Member 'UPlotItem_SetVolumeScalue::VolumeType' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVolumeScalue, Scale) == 0x000094, "Member 'UPlotItem_SetVolumeScalue::Scale' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVolumeScalue, FadeTime) == 0x000098, "Member 'UPlotItem_SetVolumeScalue::FadeTime' has a wrong offset!");

// Class Plot.PlotItem_RecallEffect
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_RecallEffect final : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTime;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_RecallEffect">();
	}
	static class UPlotItem_RecallEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_RecallEffect>();
	}
};
static_assert(alignof(UPlotItem_RecallEffect) == 0x000008, "Wrong alignment on UPlotItem_RecallEffect");
static_assert(sizeof(UPlotItem_RecallEffect) == 0x0000B0, "Wrong size on UPlotItem_RecallEffect");
static_assert(offsetof(UPlotItem_RecallEffect, OrderType) == 0x000090, "Member 'UPlotItem_RecallEffect::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_RecallEffect, OrderOffset) == 0x000094, "Member 'UPlotItem_RecallEffect::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_RecallEffect, bIsOpen) == 0x000098, "Member 'UPlotItem_RecallEffect::bIsOpen' has a wrong offset!");
static_assert(offsetof(UPlotItem_RecallEffect, TransitionTime) == 0x00009C, "Member 'UPlotItem_RecallEffect::TransitionTime' has a wrong offset!");

// Class Plot.PlotRoleActor
// 0x0078 (0x0300 - 0x0288)
class APlotRoleActor final : public APawn
{
public:
	class USkeletalMeshComponent*                 FacialMeshComponent;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayAnimEnd;                                     // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 WeaponActor;                                       // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 FaceToTargetActor;                                 // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FaceToTargetLocation(const struct FVector& InLocation, float LookAtSpeed);
	void Jump();
	void LookAtForward(float LookAtSpeed);
	void OnFaceToTarget();
	void OnPlayAnimEnd__DelegateSignature();
	void OnShowWeaponHandler(bool bIsShowWeapon);
	void OnStopFaceToTarget();
	void OnUpdate(const struct FPlotRoleControlArgs& InArgs);
	void PlayAnim(const struct FSoftObjectPath& InPath, int32 LoopNum);
	void SetData(const struct FPlotRoleControlArgs& InArgs);
	void UpdatePosAndRot(const struct FPlotRoleControlArgs& InArgs);
	void UpdateTargetRotation(const struct FRotator& InRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotRoleActor">();
	}
	static class APlotRoleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlotRoleActor>();
	}
};
static_assert(alignof(APlotRoleActor) == 0x000008, "Wrong alignment on APlotRoleActor");
static_assert(sizeof(APlotRoleActor) == 0x000300, "Wrong size on APlotRoleActor");
static_assert(offsetof(APlotRoleActor, FacialMeshComponent) == 0x000288, "Member 'APlotRoleActor::FacialMeshComponent' has a wrong offset!");
static_assert(offsetof(APlotRoleActor, OnPlayAnimEnd) == 0x000290, "Member 'APlotRoleActor::OnPlayAnimEnd' has a wrong offset!");
static_assert(offsetof(APlotRoleActor, WeaponActor) == 0x0002B0, "Member 'APlotRoleActor::WeaponActor' has a wrong offset!");
static_assert(offsetof(APlotRoleActor, FaceToTargetActor) == 0x0002B8, "Member 'APlotRoleActor::FaceToTargetActor' has a wrong offset!");

// Class Plot.PlotItem_RoleControl
// 0x00B8 (0x0148 - 0x0090)
class UPlotItem_RoleControl final : public UPlotItem
{
public:
	ERoleControlActionType                        ActionType;                                        // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlotRoleControlArgs                   Args;                                              // 0x0098(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlotRoleActor>          Role;                                              // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_RoleControl">();
	}
	static class UPlotItem_RoleControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_RoleControl>();
	}
};
static_assert(alignof(UPlotItem_RoleControl) == 0x000008, "Wrong alignment on UPlotItem_RoleControl");
static_assert(sizeof(UPlotItem_RoleControl) == 0x000148, "Wrong size on UPlotItem_RoleControl");
static_assert(offsetof(UPlotItem_RoleControl, ActionType) == 0x000090, "Member 'UPlotItem_RoleControl::ActionType' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleControl, Args) == 0x000098, "Member 'UPlotItem_RoleControl::Args' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleControl, Role) == 0x000140, "Member 'UPlotItem_RoleControl::Role' has a wrong offset!");

// Class Plot.PlotItem_RoleImgCtr
// 0x0038 (0x00C8 - 0x0090)
class UPlotItem_RoleImgCtr final : public UPlotItem
{
public:
	int32                                         Pos;                                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Speaker;                                           // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlendParameters                       ImageParameters;                                   // 0x00B4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bHide : 1;                                         // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideOthers : 1;                                   // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlackSelf : 1;                                    // 0x00C4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ZOrder;                                            // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_RoleImgCtr">();
	}
	static class UPlotItem_RoleImgCtr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_RoleImgCtr>();
	}
};
static_assert(alignof(UPlotItem_RoleImgCtr) == 0x000008, "Wrong alignment on UPlotItem_RoleImgCtr");
static_assert(sizeof(UPlotItem_RoleImgCtr) == 0x0000C8, "Wrong size on UPlotItem_RoleImgCtr");
static_assert(offsetof(UPlotItem_RoleImgCtr, Pos) == 0x000090, "Member 'UPlotItem_RoleImgCtr::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleImgCtr, Speaker) == 0x000098, "Member 'UPlotItem_RoleImgCtr::Speaker' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleImgCtr, Offset) == 0x0000A8, "Member 'UPlotItem_RoleImgCtr::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleImgCtr, Scale) == 0x0000B0, "Member 'UPlotItem_RoleImgCtr::Scale' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleImgCtr, ImageParameters) == 0x0000B4, "Member 'UPlotItem_RoleImgCtr::ImageParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_RoleImgCtr, ZOrder) == 0x0000C5, "Member 'UPlotItem_RoleImgCtr::ZOrder' has a wrong offset!");

// Class Plot.PlotItem_RollerSubtitles
// 0x0060 (0x00F0 - 0x0090)
class UPlotItem_RollerSubtitles final : public UPlotItem
{
public:
	class FString                                 PlotKey;                                           // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotWidgetOrderType                          OrderType;                                         // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBold;                                             // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomArea;                                       // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTalkRecord(const class FString& InContent, const class FString& InWwiseKey);
	TArray<struct FSubtitleRecord> GetHasPlayRecord();

	class FString GetTextByKey(const class FString& InKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_RollerSubtitles">();
	}
	static class UPlotItem_RollerSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_RollerSubtitles>();
	}
};
static_assert(alignof(UPlotItem_RollerSubtitles) == 0x000008, "Wrong alignment on UPlotItem_RollerSubtitles");
static_assert(sizeof(UPlotItem_RollerSubtitles) == 0x0000F0, "Wrong size on UPlotItem_RollerSubtitles");
static_assert(offsetof(UPlotItem_RollerSubtitles, PlotKey) == 0x000090, "Member 'UPlotItem_RollerSubtitles::PlotKey' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Speed) == 0x0000A0, "Member 'UPlotItem_RollerSubtitles::Speed' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, OrderType) == 0x0000A4, "Member 'UPlotItem_RollerSubtitles::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, OrderOffset) == 0x0000A8, "Member 'UPlotItem_RollerSubtitles::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Justification) == 0x0000AC, "Member 'UPlotItem_RollerSubtitles::Justification' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, bBold) == 0x0000AD, "Member 'UPlotItem_RollerSubtitles::bBold' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Color) == 0x0000B0, "Member 'UPlotItem_RollerSubtitles::Color' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Offset) == 0x0000C0, "Member 'UPlotItem_RollerSubtitles::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Width) == 0x0000C8, "Member 'UPlotItem_RollerSubtitles::Width' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, bCustomArea) == 0x0000CC, "Member 'UPlotItem_RollerSubtitles::bCustomArea' has a wrong offset!");
static_assert(offsetof(UPlotItem_RollerSubtitles, Size) == 0x0000D0, "Member 'UPlotItem_RollerSubtitles::Size' has a wrong offset!");

// Class Plot.PlotItem_ScreenChapter
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_ScreenChapter final : public UPlotItem
{
public:
	class FString                                 ChapterName;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChapterNumber;                                     // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ImgPath;                                           // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenChapter">();
	}
	static class UPlotItem_ScreenChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenChapter>();
	}
};
static_assert(alignof(UPlotItem_ScreenChapter) == 0x000008, "Wrong alignment on UPlotItem_ScreenChapter");
static_assert(sizeof(UPlotItem_ScreenChapter) == 0x0000D0, "Wrong size on UPlotItem_ScreenChapter");
static_assert(offsetof(UPlotItem_ScreenChapter, ChapterName) == 0x000090, "Member 'UPlotItem_ScreenChapter::ChapterName' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenChapter, ChapterNumber) == 0x0000A0, "Member 'UPlotItem_ScreenChapter::ChapterNumber' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenChapter, ImgPath) == 0x0000B0, "Member 'UPlotItem_ScreenChapter::ImgPath' has a wrong offset!");

// Class Plot.PlotItem_ScreenChapterEnd
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_ScreenChapterEnd final : public UPlotItem
{
public:
	class FString                                 Msg;                                               // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenChapterEnd">();
	}
	static class UPlotItem_ScreenChapterEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenChapterEnd>();
	}
};
static_assert(alignof(UPlotItem_ScreenChapterEnd) == 0x000008, "Wrong alignment on UPlotItem_ScreenChapterEnd");
static_assert(sizeof(UPlotItem_ScreenChapterEnd) == 0x0000B0, "Wrong size on UPlotItem_ScreenChapterEnd");
static_assert(offsetof(UPlotItem_ScreenChapterEnd, Msg) == 0x000090, "Member 'UPlotItem_ScreenChapterEnd::Msg' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenChapterEnd, Title) == 0x0000A0, "Member 'UPlotItem_ScreenChapterEnd::Title' has a wrong offset!");

// Class Plot.PlotItem_ScreenNoise
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_ScreenNoise final : public UPlotItem
{
public:
	bool                                          bIsOpen;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxScale;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x14];                                      // 0x009C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenNoise">();
	}
	static class UPlotItem_ScreenNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenNoise>();
	}
};
static_assert(alignof(UPlotItem_ScreenNoise) == 0x000008, "Wrong alignment on UPlotItem_ScreenNoise");
static_assert(sizeof(UPlotItem_ScreenNoise) == 0x0000B0, "Wrong size on UPlotItem_ScreenNoise");
static_assert(offsetof(UPlotItem_ScreenNoise, bIsOpen) == 0x000090, "Member 'UPlotItem_ScreenNoise::bIsOpen' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenNoise, MaxScale) == 0x000094, "Member 'UPlotItem_ScreenNoise::MaxScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenNoise, FadeTime) == 0x000098, "Member 'UPlotItem_ScreenNoise::FadeTime' has a wrong offset!");

// Class Plot.PlotItem_ScreenBlur
// 0x0038 (0x00C8 - 0x0090)
class UPlotItem_ScreenBlur final : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenBlur">();
	}
	static class UPlotItem_ScreenBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenBlur>();
	}
};
static_assert(alignof(UPlotItem_ScreenBlur) == 0x000008, "Wrong alignment on UPlotItem_ScreenBlur");
static_assert(sizeof(UPlotItem_ScreenBlur) == 0x0000C8, "Wrong size on UPlotItem_ScreenBlur");
static_assert(offsetof(UPlotItem_ScreenBlur, OrderType) == 0x000090, "Member 'UPlotItem_ScreenBlur::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenBlur, OrderOffset) == 0x000094, "Member 'UPlotItem_ScreenBlur::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenBlur, Duration) == 0x000098, "Member 'UPlotItem_ScreenBlur::Duration' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenBlur, Strength) == 0x00009C, "Member 'UPlotItem_ScreenBlur::Strength' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenBlur, FadeInTime) == 0x0000A0, "Member 'UPlotItem_ScreenBlur::FadeInTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenBlur, FadeOutTime) == 0x0000A4, "Member 'UPlotItem_ScreenBlur::FadeOutTime' has a wrong offset!");

// Class Plot.PlotItem_ScreenBlurEnd
// 0x0000 (0x0090 - 0x0090)
class UPlotItem_ScreenBlurEnd final : public UPlotItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenBlurEnd">();
	}
	static class UPlotItem_ScreenBlurEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenBlurEnd>();
	}
};
static_assert(alignof(UPlotItem_ScreenBlurEnd) == 0x000008, "Wrong alignment on UPlotItem_ScreenBlurEnd");
static_assert(sizeof(UPlotItem_ScreenBlurEnd) == 0x000090, "Wrong size on UPlotItem_ScreenBlurEnd");

// Class Plot.PlotItem_ScreenNoise_Line
// 0x0008 (0x0098 - 0x0090)
class UPlotItem_ScreenNoise_Line final : public UPlotItem
{
public:
	bool                                          bIsOpen;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenNoise_Line">();
	}
	static class UPlotItem_ScreenNoise_Line* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenNoise_Line>();
	}
};
static_assert(alignof(UPlotItem_ScreenNoise_Line) == 0x000008, "Wrong alignment on UPlotItem_ScreenNoise_Line");
static_assert(sizeof(UPlotItem_ScreenNoise_Line) == 0x000098, "Wrong size on UPlotItem_ScreenNoise_Line");
static_assert(offsetof(UPlotItem_ScreenNoise_Line, bIsOpen) == 0x000090, "Member 'UPlotItem_ScreenNoise_Line::bIsOpen' has a wrong offset!");

// Class Plot.PlotItem_ScreenShake
// 0x0070 (0x0100 - 0x0090)
class UPlotItem_ScreenShake final : public UPlotItem
{
public:
	EPlotWidgetOrderType                          OrderType;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderOffset;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseShakeScale;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVOscillator                           ShakeSetting;                                      // 0x00AC(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenShake">();
	}
	static class UPlotItem_ScreenShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenShake>();
	}
};
static_assert(alignof(UPlotItem_ScreenShake) == 0x000008, "Wrong alignment on UPlotItem_ScreenShake");
static_assert(sizeof(UPlotItem_ScreenShake) == 0x000100, "Wrong size on UPlotItem_ScreenShake");
static_assert(offsetof(UPlotItem_ScreenShake, OrderType) == 0x000090, "Member 'UPlotItem_ScreenShake::OrderType' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, OrderOffset) == 0x000094, "Member 'UPlotItem_ScreenShake::OrderOffset' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, Duration) == 0x000098, "Member 'UPlotItem_ScreenShake::Duration' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, Scale) == 0x00009C, "Member 'UPlotItem_ScreenShake::Scale' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, BaseShakeScale) == 0x0000A0, "Member 'UPlotItem_ScreenShake::BaseShakeScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, BlendInTime) == 0x0000A4, "Member 'UPlotItem_ScreenShake::BlendInTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, BlendOutTime) == 0x0000A8, "Member 'UPlotItem_ScreenShake::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenShake, ShakeSetting) == 0x0000AC, "Member 'UPlotItem_ScreenShake::ShakeSetting' has a wrong offset!");

// Class Plot.PlotItem_ScreenShakeEnd
// 0x0000 (0x0090 - 0x0090)
class UPlotItem_ScreenShakeEnd final : public UPlotItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenShakeEnd">();
	}
	static class UPlotItem_ScreenShakeEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenShakeEnd>();
	}
};
static_assert(alignof(UPlotItem_ScreenShakeEnd) == 0x000008, "Wrong alignment on UPlotItem_ScreenShakeEnd");
static_assert(sizeof(UPlotItem_ScreenShakeEnd) == 0x000090, "Wrong size on UPlotItem_ScreenShakeEnd");

// Class Plot.PlotItem_ScreenTransition
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_ScreenTransition final : public UPlotItem
{
public:
	EScreenTransitionEffectType                   EffectType;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendIn;                                          // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTime;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ScreenTransition">();
	}
	static class UPlotItem_ScreenTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ScreenTransition>();
	}
};
static_assert(alignof(UPlotItem_ScreenTransition) == 0x000008, "Wrong alignment on UPlotItem_ScreenTransition");
static_assert(sizeof(UPlotItem_ScreenTransition) == 0x0000B0, "Wrong size on UPlotItem_ScreenTransition");
static_assert(offsetof(UPlotItem_ScreenTransition, EffectType) == 0x000090, "Member 'UPlotItem_ScreenTransition::EffectType' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenTransition, bBlendIn) == 0x000091, "Member 'UPlotItem_ScreenTransition::bBlendIn' has a wrong offset!");
static_assert(offsetof(UPlotItem_ScreenTransition, TransitionTime) == 0x000094, "Member 'UPlotItem_ScreenTransition::TransitionTime' has a wrong offset!");

// Class Plot.PlotItem_Sequence
// 0x0018 (0x0130 - 0x0118)
class UPlotItem_Sequence final : public UPlotSaveItem
{
public:
	TArray<struct FSequenceItemStruct>            Sequence;                                          // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDoEndWhenLastItemSelected;                        // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSelect(int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Sequence">();
	}
	static class UPlotItem_Sequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Sequence>();
	}
};
static_assert(alignof(UPlotItem_Sequence) == 0x000008, "Wrong alignment on UPlotItem_Sequence");
static_assert(sizeof(UPlotItem_Sequence) == 0x000130, "Wrong size on UPlotItem_Sequence");
static_assert(offsetof(UPlotItem_Sequence, Sequence) == 0x000118, "Member 'UPlotItem_Sequence::Sequence' has a wrong offset!");
static_assert(offsetof(UPlotItem_Sequence, bDoEndWhenLastItemSelected) == 0x000128, "Member 'UPlotItem_Sequence::bDoEndWhenLastItemSelected' has a wrong offset!");

// Class Plot.PlotItem_Sequence_Item
// 0x0000 (0x0118 - 0x0118)
class UPlotItem_Sequence_Item final : public UPlotSaveItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Sequence_Item">();
	}
	static class UPlotItem_Sequence_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Sequence_Item>();
	}
};
static_assert(alignof(UPlotItem_Sequence_Item) == 0x000008, "Wrong alignment on UPlotItem_Sequence_Item");
static_assert(sizeof(UPlotItem_Sequence_Item) == 0x000118, "Wrong size on UPlotItem_Sequence_Item");

// Class Plot.PlotItem_SetBGM
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_SetBGM final : public UPlotItem
{
public:
	class FString                                 Music;                                             // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ambience;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetBGM">();
	}
	static class UPlotItem_SetBGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetBGM>();
	}
};
static_assert(alignof(UPlotItem_SetBGM) == 0x000008, "Wrong alignment on UPlotItem_SetBGM");
static_assert(sizeof(UPlotItem_SetBGM) == 0x0000B0, "Wrong size on UPlotItem_SetBGM");
static_assert(offsetof(UPlotItem_SetBGM, Music) == 0x000090, "Member 'UPlotItem_SetBGM::Music' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetBGM, Ambience) == 0x0000A0, "Member 'UPlotItem_SetBGM::Ambience' has a wrong offset!");

// Class Plot.PlotItem_SetCameraArgs
// 0x0058 (0x00E8 - 0x0090)
class UPlotItem_SetCameraArgs final : public UPlotItem
{
public:
	struct FPlotCameraInfo                        Args;                                              // 0x0090(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetCameraArgs">();
	}
	static class UPlotItem_SetCameraArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetCameraArgs>();
	}
};
static_assert(alignof(UPlotItem_SetCameraArgs) == 0x000008, "Wrong alignment on UPlotItem_SetCameraArgs");
static_assert(sizeof(UPlotItem_SetCameraArgs) == 0x0000E8, "Wrong size on UPlotItem_SetCameraArgs");
static_assert(offsetof(UPlotItem_SetCameraArgs, Args) == 0x000090, "Member 'UPlotItem_SetCameraArgs::Args' has a wrong offset!");

// Class Plot.PlotItem_SetVisibility
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_SetVisibility final : public UPlotItem
{
public:
	class FName                                   WidgetName;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotItemUINodeType                           UINodeType;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visibility;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Position;                                          // 0x009C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetVisibility">();
	}
	static class UPlotItem_SetVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetVisibility>();
	}
};
static_assert(alignof(UPlotItem_SetVisibility) == 0x000008, "Wrong alignment on UPlotItem_SetVisibility");
static_assert(sizeof(UPlotItem_SetVisibility) == 0x0000B0, "Wrong size on UPlotItem_SetVisibility");
static_assert(offsetof(UPlotItem_SetVisibility, WidgetName) == 0x000090, "Member 'UPlotItem_SetVisibility::WidgetName' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility, UINodeType) == 0x000098, "Member 'UPlotItem_SetVisibility::UINodeType' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility, Visibility) == 0x000099, "Member 'UPlotItem_SetVisibility::Visibility' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility, Position) == 0x00009C, "Member 'UPlotItem_SetVisibility::Position' has a wrong offset!");

// Class Plot.PlotItem_UIPlaceName
// 0x0060 (0x00F0 - 0x0090)
class UPlotItem_UIPlaceName final : public UPlotItem
{
public:
	EPlotOutShowType                              ShowType;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlaceName;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Time1;                                             // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Time2;                                             // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hide;                                              // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x23];                                      // 0x00CD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_UIPlaceName">();
	}
	static class UPlotItem_UIPlaceName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_UIPlaceName>();
	}
};
static_assert(alignof(UPlotItem_UIPlaceName) == 0x000008, "Wrong alignment on UPlotItem_UIPlaceName");
static_assert(sizeof(UPlotItem_UIPlaceName) == 0x0000F0, "Wrong size on UPlotItem_UIPlaceName");
static_assert(offsetof(UPlotItem_UIPlaceName, ShowType) == 0x000090, "Member 'UPlotItem_UIPlaceName::ShowType' has a wrong offset!");
static_assert(offsetof(UPlotItem_UIPlaceName, PlaceName) == 0x000098, "Member 'UPlotItem_UIPlaceName::PlaceName' has a wrong offset!");
static_assert(offsetof(UPlotItem_UIPlaceName, Time1) == 0x0000A8, "Member 'UPlotItem_UIPlaceName::Time1' has a wrong offset!");
static_assert(offsetof(UPlotItem_UIPlaceName, Time2) == 0x0000B8, "Member 'UPlotItem_UIPlaceName::Time2' has a wrong offset!");
static_assert(offsetof(UPlotItem_UIPlaceName, Duration) == 0x0000C8, "Member 'UPlotItem_UIPlaceName::Duration' has a wrong offset!");
static_assert(offsetof(UPlotItem_UIPlaceName, Hide) == 0x0000CC, "Member 'UPlotItem_UIPlaceName::Hide' has a wrong offset!");

// Class Plot.PlotItem_SetVisibility_New
// 0x0030 (0x00C0 - 0x0090)
class UPlotItem_SetVisibility_New final : public UPlotItem
{
public:
	class FName                                   WidgetName;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlotItemUINodeType                           UINodeType;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visibility;                                        // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SetVisibility_New">();
	}
	static class UPlotItem_SetVisibility_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SetVisibility_New>();
	}
};
static_assert(alignof(UPlotItem_SetVisibility_New) == 0x000008, "Wrong alignment on UPlotItem_SetVisibility_New");
static_assert(sizeof(UPlotItem_SetVisibility_New) == 0x0000C0, "Wrong size on UPlotItem_SetVisibility_New");
static_assert(offsetof(UPlotItem_SetVisibility_New, WidgetName) == 0x000090, "Member 'UPlotItem_SetVisibility_New::WidgetName' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility_New, UINodeType) == 0x000098, "Member 'UPlotItem_SetVisibility_New::UINodeType' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility_New, Visibility) == 0x000099, "Member 'UPlotItem_SetVisibility_New::Visibility' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility_New, FadeTime) == 0x00009C, "Member 'UPlotItem_SetVisibility_New::FadeTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_SetVisibility_New, Position) == 0x0000A0, "Member 'UPlotItem_SetVisibility_New::Position' has a wrong offset!");

// Class Plot.PlotItem_ShowBackground
// 0x0008 (0x0098 - 0x0090)
class UPlotItem_ShowBackground final : public UPlotItem
{
public:
	bool                                          bShowBackground;                                   // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBackgroundBlur;                               // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPlotCamera;                                    // 0x0092(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlotCameraActive;                                 // 0x0093(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_ShowBackground">();
	}
	static class UPlotItem_ShowBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_ShowBackground>();
	}
};
static_assert(alignof(UPlotItem_ShowBackground) == 0x000008, "Wrong alignment on UPlotItem_ShowBackground");
static_assert(sizeof(UPlotItem_ShowBackground) == 0x000098, "Wrong size on UPlotItem_ShowBackground");
static_assert(offsetof(UPlotItem_ShowBackground, bShowBackground) == 0x000090, "Member 'UPlotItem_ShowBackground::bShowBackground' has a wrong offset!");
static_assert(offsetof(UPlotItem_ShowBackground, bShowBackgroundBlur) == 0x000091, "Member 'UPlotItem_ShowBackground::bShowBackgroundBlur' has a wrong offset!");
static_assert(offsetof(UPlotItem_ShowBackground, bSetPlotCamera) == 0x000092, "Member 'UPlotItem_ShowBackground::bSetPlotCamera' has a wrong offset!");
static_assert(offsetof(UPlotItem_ShowBackground, bPlotCameraActive) == 0x000093, "Member 'UPlotItem_ShowBackground::bPlotCameraActive' has a wrong offset!");

// Class Plot.PlotItem_SpeedLineEffect
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_SpeedLineEffect final : public UPlotItem
{
public:
	float                                         Time;                                              // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendIn;                                          // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRandomValue;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x14];                                      // 0x009C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SpeedLineEffect">();
	}
	static class UPlotItem_SpeedLineEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SpeedLineEffect>();
	}
};
static_assert(alignof(UPlotItem_SpeedLineEffect) == 0x000008, "Wrong alignment on UPlotItem_SpeedLineEffect");
static_assert(sizeof(UPlotItem_SpeedLineEffect) == 0x0000B0, "Wrong size on UPlotItem_SpeedLineEffect");
static_assert(offsetof(UPlotItem_SpeedLineEffect, Time) == 0x000090, "Member 'UPlotItem_SpeedLineEffect::Time' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpeedLineEffect, bBlendIn) == 0x000094, "Member 'UPlotItem_SpeedLineEffect::bBlendIn' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpeedLineEffect, FRandomValue) == 0x000098, "Member 'UPlotItem_SpeedLineEffect::FRandomValue' has a wrong offset!");

// Class Plot.PlotItem_Spine
// 0x0070 (0x0100 - 0x0090)
class UPlotItem_Spine final : public UPlotItem
{
public:
	int32                                         Pos;                                               // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RoleName;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpineParameters                       SpineParameters;                                   // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bHide : 1;                                         // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideAll : 1;                                      // 0x00F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideOthers : 1;                                   // 0x00F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlackSelf : 1;                                    // 0x00F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Spine">();
	}
	static class UPlotItem_Spine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Spine>();
	}
};
static_assert(alignof(UPlotItem_Spine) == 0x000008, "Wrong alignment on UPlotItem_Spine");
static_assert(sizeof(UPlotItem_Spine) == 0x000100, "Wrong size on UPlotItem_Spine");
static_assert(offsetof(UPlotItem_Spine, Pos) == 0x000090, "Member 'UPlotItem_Spine::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_Spine, RoleName) == 0x000098, "Member 'UPlotItem_Spine::RoleName' has a wrong offset!");
static_assert(offsetof(UPlotItem_Spine, SpineParameters) == 0x0000A8, "Member 'UPlotItem_Spine::SpineParameters' has a wrong offset!");

// Class Plot.PlotItem_SpineChangeEffect
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_SpineChangeEffect final : public UPlotItem
{
public:
	ESpineChangeEffectType                        EffectType;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pos;                                               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0xC];                                       // 0x009C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SpineChangeEffect">();
	}
	static class UPlotItem_SpineChangeEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SpineChangeEffect>();
	}
};
static_assert(alignof(UPlotItem_SpineChangeEffect) == 0x000008, "Wrong alignment on UPlotItem_SpineChangeEffect");
static_assert(sizeof(UPlotItem_SpineChangeEffect) == 0x0000A8, "Wrong size on UPlotItem_SpineChangeEffect");
static_assert(offsetof(UPlotItem_SpineChangeEffect, EffectType) == 0x000090, "Member 'UPlotItem_SpineChangeEffect::EffectType' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineChangeEffect, Pos) == 0x000094, "Member 'UPlotItem_SpineChangeEffect::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineChangeEffect, Time) == 0x000098, "Member 'UPlotItem_SpineChangeEffect::Time' has a wrong offset!");

// Class Plot.PlotItem_Spine_Hide
// 0x0028 (0x00B8 - 0x0090)
class UPlotItem_Spine_Hide final : public UPlotItem
{
public:
	bool                                          bHideAll;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlotSpinePos>                         Pos;                                               // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0xC];                                       // 0x00AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Spine_Hide">();
	}
	static class UPlotItem_Spine_Hide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Spine_Hide>();
	}
};
static_assert(alignof(UPlotItem_Spine_Hide) == 0x000008, "Wrong alignment on UPlotItem_Spine_Hide");
static_assert(sizeof(UPlotItem_Spine_Hide) == 0x0000B8, "Wrong size on UPlotItem_Spine_Hide");
static_assert(offsetof(UPlotItem_Spine_Hide, bHideAll) == 0x000090, "Member 'UPlotItem_Spine_Hide::bHideAll' has a wrong offset!");
static_assert(offsetof(UPlotItem_Spine_Hide, Pos) == 0x000098, "Member 'UPlotItem_Spine_Hide::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_Spine_Hide, DelayTime) == 0x0000A8, "Member 'UPlotItem_Spine_Hide::DelayTime' has a wrong offset!");

// Class Plot.PlotItem_SpineTransform
// 0x0040 (0x00D0 - 0x0090)
class UPlotItem_SpineTransform final : public UPlotItem
{
public:
	EDoTweenType                                  MoveType;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pos;                                               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Amplitude;                                         // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        MoveCurve;                                         // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopTimes;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_SpineTransform">();
	}
	static class UPlotItem_SpineTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_SpineTransform>();
	}
};
static_assert(alignof(UPlotItem_SpineTransform) == 0x000008, "Wrong alignment on UPlotItem_SpineTransform");
static_assert(sizeof(UPlotItem_SpineTransform) == 0x0000D0, "Wrong size on UPlotItem_SpineTransform");
static_assert(offsetof(UPlotItem_SpineTransform, MoveType) == 0x000090, "Member 'UPlotItem_SpineTransform::MoveType' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, Pos) == 0x000094, "Member 'UPlotItem_SpineTransform::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, Amplitude) == 0x000098, "Member 'UPlotItem_SpineTransform::Amplitude' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, Multiplier) == 0x0000A0, "Member 'UPlotItem_SpineTransform::Multiplier' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, MoveCurve) == 0x0000A8, "Member 'UPlotItem_SpineTransform::MoveCurve' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, IsLoop) == 0x0000C0, "Member 'UPlotItem_SpineTransform::IsLoop' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, LoopTimes) == 0x0000C4, "Member 'UPlotItem_SpineTransform::LoopTimes' has a wrong offset!");
static_assert(offsetof(UPlotItem_SpineTransform, Duration) == 0x0000C8, "Member 'UPlotItem_SpineTransform::Duration' has a wrong offset!");

// Class Plot.PlotItem_KillSpineTransform
// 0x0010 (0x00A0 - 0x0090)
class UPlotItem_KillSpineTransform final : public UPlotItem
{
public:
	EDoTweenType                                  MoveType;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pos;                                               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Iscompleteflag;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_KillSpineTransform">();
	}
	static class UPlotItem_KillSpineTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_KillSpineTransform>();
	}
};
static_assert(alignof(UPlotItem_KillSpineTransform) == 0x000008, "Wrong alignment on UPlotItem_KillSpineTransform");
static_assert(sizeof(UPlotItem_KillSpineTransform) == 0x0000A0, "Wrong size on UPlotItem_KillSpineTransform");
static_assert(offsetof(UPlotItem_KillSpineTransform, MoveType) == 0x000090, "Member 'UPlotItem_KillSpineTransform::MoveType' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillSpineTransform, Pos) == 0x000094, "Member 'UPlotItem_KillSpineTransform::Pos' has a wrong offset!");
static_assert(offsetof(UPlotItem_KillSpineTransform, Iscompleteflag) == 0x000098, "Member 'UPlotItem_KillSpineTransform::Iscompleteflag' has a wrong offset!");

// Class Plot.PlotItem_Talk
// 0x0200 (0x0318 - 0x0118)
class UPlotItem_Talk final : public UPlotSaveItem
{
public:
	struct FTalkConfig                            TalkConfig;                                        // 0x0118(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSpineParameters                       SpineParameters;                                   // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WaitWWiseTime;                                     // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableMouseAnim;                                  // 0x019C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHide;                                             // 0x019D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOthers;                                       // 0x019E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlackSelf;                                        // 0x019F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlendParameters                       ImageParameters;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTalkTextChange;                                  // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsTextAnimComplete;                               // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseComponent*                        WwiseComponent;                                    // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x20];                                     // 0x01D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlotName2Img                          Name2Img;                                          // 0x01F0(0x0128)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnInput();
	void OnTalkTextChange__DelegateSignature(const class FString& TalkText, int32 MaxNumText);
	void OnWwiseCompleteHandler(class UWwiseComponent* InWwiseComponent);
	void StopCurPlayWwiseByWidget();

	class FString GetContentStr() const;
	const struct FSoftObjectPath GetImg() const;
	class FString GetSpeakerName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Talk">();
	}
	static class UPlotItem_Talk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Talk>();
	}
};
static_assert(alignof(UPlotItem_Talk) == 0x000008, "Wrong alignment on UPlotItem_Talk");
static_assert(sizeof(UPlotItem_Talk) == 0x000318, "Wrong size on UPlotItem_Talk");
static_assert(offsetof(UPlotItem_Talk, TalkConfig) == 0x000118, "Member 'UPlotItem_Talk::TalkConfig' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, SpineParameters) == 0x000148, "Member 'UPlotItem_Talk::SpineParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, WaitWWiseTime) == 0x000198, "Member 'UPlotItem_Talk::WaitWWiseTime' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, DisableMouseAnim) == 0x00019C, "Member 'UPlotItem_Talk::DisableMouseAnim' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, bHide) == 0x00019D, "Member 'UPlotItem_Talk::bHide' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, bHideOthers) == 0x00019E, "Member 'UPlotItem_Talk::bHideOthers' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, bBlackSelf) == 0x00019F, "Member 'UPlotItem_Talk::bBlackSelf' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, ImageParameters) == 0x0001A0, "Member 'UPlotItem_Talk::ImageParameters' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, OnTalkTextChange) == 0x0001B0, "Member 'UPlotItem_Talk::OnTalkTextChange' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, bIsTextAnimComplete) == 0x0001C0, "Member 'UPlotItem_Talk::bIsTextAnimComplete' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, WwiseComponent) == 0x0001C8, "Member 'UPlotItem_Talk::WwiseComponent' has a wrong offset!");
static_assert(offsetof(UPlotItem_Talk, Name2Img) == 0x0001F0, "Member 'UPlotItem_Talk::Name2Img' has a wrong offset!");

// Class Plot.PlotItem_Timeline
// 0x0018 (0x00A8 - 0x0090)
class UPlotItem_Timeline final : public UPlotItem
{
public:
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Timeline">();
	}
	static class UPlotItem_Timeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Timeline>();
	}
};
static_assert(alignof(UPlotItem_Timeline) == 0x000008, "Wrong alignment on UPlotItem_Timeline");
static_assert(sizeof(UPlotItem_Timeline) == 0x0000A8, "Wrong size on UPlotItem_Timeline");

// Class Plot.PlotItem_TransformAnimation
// 0x00A8 (0x0138 - 0x0090)
class UPlotItem_TransformAnimation final : public UPlotItem
{
public:
	EPlotWidgetType                               PlotWidgetType;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RolePosIndex;                                      // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x2];                                       // 0x0092(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            MoveBlend;                                         // 0x00A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndScale;                                          // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            ScaleBlend;                                        // 0x00D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x30];                                     // 0x0108(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_TransformAnimation">();
	}
	static class UPlotItem_TransformAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_TransformAnimation>();
	}
};
static_assert(alignof(UPlotItem_TransformAnimation) == 0x000008, "Wrong alignment on UPlotItem_TransformAnimation");
static_assert(sizeof(UPlotItem_TransformAnimation) == 0x000138, "Wrong size on UPlotItem_TransformAnimation");
static_assert(offsetof(UPlotItem_TransformAnimation, PlotWidgetType) == 0x000090, "Member 'UPlotItem_TransformAnimation::PlotWidgetType' has a wrong offset!");
static_assert(offsetof(UPlotItem_TransformAnimation, RolePosIndex) == 0x000091, "Member 'UPlotItem_TransformAnimation::RolePosIndex' has a wrong offset!");
static_assert(offsetof(UPlotItem_TransformAnimation, Offset) == 0x000094, "Member 'UPlotItem_TransformAnimation::Offset' has a wrong offset!");
static_assert(offsetof(UPlotItem_TransformAnimation, MoveBlend) == 0x0000A0, "Member 'UPlotItem_TransformAnimation::MoveBlend' has a wrong offset!");
static_assert(offsetof(UPlotItem_TransformAnimation, EndScale) == 0x0000D0, "Member 'UPlotItem_TransformAnimation::EndScale' has a wrong offset!");
static_assert(offsetof(UPlotItem_TransformAnimation, ScaleBlend) == 0x0000D8, "Member 'UPlotItem_TransformAnimation::ScaleBlend' has a wrong offset!");

// Class Plot.PlotItem_TwinkleEffect
// 0x0028 (0x00B8 - 0x0090)
class UPlotItem_TwinkleEffect final : public UPlotItem
{
public:
	float                                         Time;                                              // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_TwinkleEffect">();
	}
	static class UPlotItem_TwinkleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_TwinkleEffect>();
	}
};
static_assert(alignof(UPlotItem_TwinkleEffect) == 0x000008, "Wrong alignment on UPlotItem_TwinkleEffect");
static_assert(sizeof(UPlotItem_TwinkleEffect) == 0x0000B8, "Wrong size on UPlotItem_TwinkleEffect");
static_assert(offsetof(UPlotItem_TwinkleEffect, Time) == 0x000090, "Member 'UPlotItem_TwinkleEffect::Time' has a wrong offset!");
static_assert(offsetof(UPlotItem_TwinkleEffect, Strength) == 0x000094, "Member 'UPlotItem_TwinkleEffect::Strength' has a wrong offset!");
static_assert(offsetof(UPlotItem_TwinkleEffect, Color) == 0x000098, "Member 'UPlotItem_TwinkleEffect::Color' has a wrong offset!");

// Class Plot.PlotItem_Wwise_SetState
// 0x0020 (0x00B0 - 0x0090)
class UPlotItem_Wwise_SetState final : public UPlotItem
{
public:
	class FString                                 StateName;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeekPosition;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDuration;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotItem_Wwise_SetState">();
	}
	static class UPlotItem_Wwise_SetState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotItem_Wwise_SetState>();
	}
};
static_assert(alignof(UPlotItem_Wwise_SetState) == 0x000008, "Wrong alignment on UPlotItem_Wwise_SetState");
static_assert(sizeof(UPlotItem_Wwise_SetState) == 0x0000B0, "Wrong size on UPlotItem_Wwise_SetState");
static_assert(offsetof(UPlotItem_Wwise_SetState, StateName) == 0x000090, "Member 'UPlotItem_Wwise_SetState::StateName' has a wrong offset!");
static_assert(offsetof(UPlotItem_Wwise_SetState, SeekPosition) == 0x0000A0, "Member 'UPlotItem_Wwise_SetState::SeekPosition' has a wrong offset!");
static_assert(offsetof(UPlotItem_Wwise_SetState, FadeInDuration) == 0x0000A4, "Member 'UPlotItem_Wwise_SetState::FadeInDuration' has a wrong offset!");

// Class Plot.PlotLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlotLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearSequencerWidgetCallBack(class UWidget* InChildWidget);
	static void FindCameraEndLocationAndFOVInLevelSequence(class ULevelSequence* InSequence, struct FVector* OutEndLocation, float* OutFOV);
	static class APlotRoleActor* FindRoleByName(class UObject* WorldContextObject, const class FString& InName);
	static class FString GetCurrentPlotFileName(class UObject* WorldContextObject);
	static class UPlotWidget* GetCurrentPlotWidget(class UObject* WorldContextObject);
	static class USequencerUserWidget* GetCurrentSequencer(class UObject* WorldContextObject);
	static class FString GetDefaultSpineAnimationNameFromData(const TArray<class FString>& InData);
	static TArray<class UPlotItem*> GetPlotItemByClass(class UObject* WorldContextObject, class UClass* InClass);
	static const struct FPlotName2Img GetPlotName2ImageData(const class FString& InKey);
	static void GetPlotNameConfig(const class FString& InKey, class USpineAtlasAsset** OutAtlas, class USpineSkeletonDataAsset** OutSkeletonData);
	static struct FPlotRoleInfo GetPlotRoleConfig(int32 InId);
	static EDialogueOperationType GetTalkOperationType(class UPlotItem* InItem);
	static int32 LuaGetDataTableRowFromName(class UDataTable* Table, class FName RowName);
	static void RemoveLineBreaksInline(class FString& SourceString, class UPlot* InPlot);
	static void ReplaceHyperColorTag(class FString& SourceString, class UPlot* InPlot);
	static void SetNearClipPlaneForPlotSequencer(float InValue);
	static void SetPlotRoleTexture(const class FString& InKey, class UMaterialInstanceDynamic* RoleMaterial);
	static void SkipParentSequencerWidgetAnimation(class UWidget* InChildWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotLibrary">();
	}
	static class UPlotLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotLibrary>();
	}
};
static_assert(alignof(UPlotLibrary) == 0x000008, "Wrong alignment on UPlotLibrary");
static_assert(sizeof(UPlotLibrary) == 0x000028, "Wrong size on UPlotLibrary");

// Class Plot.PlotSaveGame
// 0x0018 (0x0040 - 0x0028)
class UPlotSaveGame final : public USaveGame
{
public:
	TArray<class FString>                         SaveKeys;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAutoPlay;                                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlotSaveGame* LoadPlotSaveGame();

	void Save();
	void SaveKey(const class FString& InKey);

	bool HasKey(const class FString& InKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSaveGame">();
	}
	static class UPlotSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSaveGame>();
	}
};
static_assert(alignof(UPlotSaveGame) == 0x000008, "Wrong alignment on UPlotSaveGame");
static_assert(sizeof(UPlotSaveGame) == 0x000040, "Wrong size on UPlotSaveGame");
static_assert(offsetof(UPlotSaveGame, SaveKeys) == 0x000028, "Member 'UPlotSaveGame::SaveKeys' has a wrong offset!");
static_assert(offsetof(UPlotSaveGame, bIsAutoPlay) == 0x000038, "Member 'UPlotSaveGame::bIsAutoPlay' has a wrong offset!");

// Class Plot.SpineActor
// 0x0078 (0x02A0 - 0x0228)
class ASpineActor final : public AActor
{
public:
	struct FSoftObjectPath                        CurveDataPath;                                     // 0x0228(0x0018)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        CurveColorDataPath;                                // 0x0240(0x0018)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           CurrentCurveData;                                  // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           CurrentCurveColorData;                             // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CurrentMaterial;                                   // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpineSkeletonAnimationComponent*       SpineAnimationComponent;                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpineSkeletonRendererComponent*        SpineRenderComponent;                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget2D;                                    // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineActor">();
	}
	static class ASpineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpineActor>();
	}
};
static_assert(alignof(ASpineActor) == 0x000008, "Wrong alignment on ASpineActor");
static_assert(sizeof(ASpineActor) == 0x0002A0, "Wrong size on ASpineActor");
static_assert(offsetof(ASpineActor, CurveDataPath) == 0x000228, "Member 'ASpineActor::CurveDataPath' has a wrong offset!");
static_assert(offsetof(ASpineActor, CurveColorDataPath) == 0x000240, "Member 'ASpineActor::CurveColorDataPath' has a wrong offset!");
static_assert(offsetof(ASpineActor, CurrentCurveData) == 0x000258, "Member 'ASpineActor::CurrentCurveData' has a wrong offset!");
static_assert(offsetof(ASpineActor, CurrentCurveColorData) == 0x000260, "Member 'ASpineActor::CurrentCurveColorData' has a wrong offset!");
static_assert(offsetof(ASpineActor, SceneCaptureComponent) == 0x000268, "Member 'ASpineActor::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, CurrentMaterial) == 0x000270, "Member 'ASpineActor::CurrentMaterial' has a wrong offset!");
static_assert(offsetof(ASpineActor, SpineAnimationComponent) == 0x000278, "Member 'ASpineActor::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, SpineRenderComponent) == 0x000280, "Member 'ASpineActor::SpineRenderComponent' has a wrong offset!");
static_assert(offsetof(ASpineActor, RenderTarget2D) == 0x000288, "Member 'ASpineActor::RenderTarget2D' has a wrong offset!");

// Class Plot.PlotSpineEffectImage
// 0x00C0 (0x02F0 - 0x0230)
class UPlotSpineEffectImage final : public UImage
{
public:
	class USpineSkeletonAnimationComponent*       SpineAnimationComponent;                           // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpineSkeletonRendererComponent*        SpineRenderComponent;                              // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpineActor*                            PlotSceneActor;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               NormalMaterial;                                    // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MessageMaterial;                                   // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               GhostMaterial;                                     // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               NormalDissolveMaterial;                            // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HalfBlackMaterial;                                 // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HalfBlackMessageMaterial;                          // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x78];                                     // 0x0278(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDataAndPlayAnimation(class USpineAtlasAsset* InAtlas, class USpineSkeletonDataAsset* InSkeletonData, const class FString& AnimationName, const struct FLinearColor& InColor, bool bLoop, float InSpineScale, const struct FVector2D& InAtlasOffset, float InBlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotSpineEffectImage">();
	}
	static class UPlotSpineEffectImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotSpineEffectImage>();
	}
};
static_assert(alignof(UPlotSpineEffectImage) == 0x000008, "Wrong alignment on UPlotSpineEffectImage");
static_assert(sizeof(UPlotSpineEffectImage) == 0x0002F0, "Wrong size on UPlotSpineEffectImage");
static_assert(offsetof(UPlotSpineEffectImage, SpineAnimationComponent) == 0x000230, "Member 'UPlotSpineEffectImage::SpineAnimationComponent' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, SpineRenderComponent) == 0x000238, "Member 'UPlotSpineEffectImage::SpineRenderComponent' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, PlotSceneActor) == 0x000240, "Member 'UPlotSpineEffectImage::PlotSceneActor' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, NormalMaterial) == 0x000248, "Member 'UPlotSpineEffectImage::NormalMaterial' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, MessageMaterial) == 0x000250, "Member 'UPlotSpineEffectImage::MessageMaterial' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, GhostMaterial) == 0x000258, "Member 'UPlotSpineEffectImage::GhostMaterial' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, NormalDissolveMaterial) == 0x000260, "Member 'UPlotSpineEffectImage::NormalDissolveMaterial' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, HalfBlackMaterial) == 0x000268, "Member 'UPlotSpineEffectImage::HalfBlackMaterial' has a wrong offset!");
static_assert(offsetof(UPlotSpineEffectImage, HalfBlackMessageMaterial) == 0x000270, "Member 'UPlotSpineEffectImage::HalfBlackMessageMaterial' has a wrong offset!");

// Class Plot.PlotWidget
// 0x0448 (0x06C8 - 0x0280)
class UPlotWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnInput;                                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelect;                                          // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsOpenDoubleScreen;                                // 0x02B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlotSingleScreenWidget*                FirstScreen;                                       // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCanvasPanel>            MaskContainer;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotSingleScreenWidget*                SecondScreen;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TWeakObjectPtr<class UUserWidget>> Path2WidgetCache;                                  // 0x02D0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWwiseComponent>         LastPlayWwiseComponent;                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalApplicationScale;                            // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        TalkRecords;                                       // 0x0330(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           RootPanel;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UUserWidget>             RollerTablePtr;                                    // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                TalkText;                                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                DialogueText;                                      // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                AsideText;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ControlView;                                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBorder*                                TalkContent;                                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           UINode;                                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Speaker;                                           // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotFightStyle*                        FightStyle;                                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UListView*                              BranchTalk_2D;                                     // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpliceImgBG*                           SpliceImgBG;                                       // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           OtherNode;                                         // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Dialogue_2D;                                       // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelRole;                                         // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Speaker_Stage2D;                                   // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                DialogueText_Stage2D;                              // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DefaultScreenImage;                                // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DefaultScreenSizeImage;                            // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImgRole;                                           // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotWidgetCover*                       WidgetCover;                                       // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelKeyInfo;                                      // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0xA8];                                     // 0x03F0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlotWidgetInteractionGame*             InteractionGame;                                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            HandDrawWidget;                                    // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextAreaMaxWidth;                                  // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableAddTalkRecords;                             // 0x04AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AD[0x83];                                     // 0x04AD(0x0083)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlotFindEvidenceWidget*                FindEvidenceWidget;                                // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TWeakObjectPtr<class USpineWidget>> FullscreenSpineMap;                                // 0x0538(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x138];                                    // 0x0588(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPaused;                                           // 0x06C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C1[0x7];                                      // 0x06C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Add2Root();
	void CheckAndUpdateViewState();
	void ControlHandDrawWidget(TArray<struct FHandDrawAxisParams>* HandDrawAxisOpenArray, bool bShowAll, bool bClearAll);
	class UWidget* CreateParticleImage(class UFXSystemAsset* InAsset, const struct FVector2D& AssetBounds, EPlotScreenType InScreenType, EPlotWidgetOrderType OrderType);
	void CreateWidget(const struct FSoftClassPath& InWidget);
	void DoTalk(class UPlotItem_Talk* InData);
	void EndPlot(EPlotCompleteType InCompleteType);
	void EnterChange();
	class UMaterialInterface* GetPostProcessMaterial(EPlotScreenType ScreenType, EPlotPostProcessEffectType InType, EPlotWidgetOrderType OrderType, int32 OrderOffset, bool bIsOpen);
	class UPlotSingleScreenWidget* GetScreen(EPlotScreenType ScreenType);
	void HideAllImagesExcept(uint8 InIndex, bool bHideOthers, bool bBlackSelf);
	void HideAllSpinesExcept(EPlotScreenType ScreenType, uint8 InIndex, bool bHideOthers, bool bBlackSelf);
	void JumpToSomeTextLine(const class FString& InText);
	void LoadHandDrawWidget(const struct FSoftClassPath& UMGDrawAsset, EPlotWidgetOrderType ZOrder, int32 OrderOffset, bool IsHide);
	class UCanvasPanel* LuaImpl_GetRootPanelByScreenType(EPlotScreenType InScreenType, EPlotWidgetOrderType ZOrder);
	class UPlotLuaImplWidget* NotifyBeginLuaImpl(const class FString& InPath, class UPlotItem* InOwner, bool IsPreview);
	void NotifyCleanScreenTransition(EScreenTransitionEffectType InEffectType);
	void NotifyPlayScreenTransition(EScreenTransitionEffectType InEffectType);
	float NotifyPlaySubWidgetAnimation(class UWidget* InWidget, const class FString& InAniName, int32 LoopTimes);
	void NotifySetPlaceName(const class FString& InLangKey);
	void NotifySetShowTime(const class FString& Time1, const class FString& Time2);
	void NotifySetWidgetZOrder(class UWidget* InWidget, EPlotWidgetOrderType InOrderType, int32 InOrderOffset);
	void NotifyTextAnimBegin(class UPlotItem_Talk* InItem, class UWidget* InWidget, const class FString& InSpeaker, uint8 InPosId);
	void NotifyTextAnimEnd(class UPlotItem_Talk* InItem, class UWidget* InWidget, bool InForce);
	void OnBtnClick();
	void OnEnd();
	void OnGamePaused();
	void OnInput__DelegateSignature();
	void OnSelect__DelegateSignature(int32 Index_0);
	void OnShowSelect(bool bShow, const TArray<struct FSelectItemData>& InDatas);
	void OnStart();
	void OnTalk(class UPlotItem_Talk* InData, bool InTalkSpeakerChanged);
	void OnTalkTextChange(const class FString& InText, int32 InMaxNumText);
	void OnTextInfoChange(class UWidget* InWidget, const class FText& InText, int32 InMaxNumText);
	void OnTextStyleChange(class UWidget* InWidget, const struct FSlateFontInfo& InFont);
	void PlayAnimByName(const class FString& InName);
	void PlayOpenAnimation();
	void PlaySpineInternal(uint8 PosID, bool bIsHide, const class FString& RoleName, const struct FSpineParameters& InParameters);
	void RemoveInRoot();
	void ReplaceFontAsset(class UTextBlock* InTextBlock);
	void ResetPlotState();
	void ResetToDefault(EPlotScreenType ScreenType);
	void RunLuaImplItem(class UPlotItem* Item);
	void SetCameraArgs(const struct FPlotCameraInfo& InCameraInfo);
	void SetPaused(uint8 bInPaused);
	void SetPlayItem(class UPlotItem* InItem);
	void SetReward(EPlotScreenType ScreenType, const struct FSoftObjectPath& InPath, const struct FBlendParameters& InParameters, bool bHide);
	void SetRoleImg(EPlotScreenType ScreenType, int32 InPos, uint8 ZOrder, const class FString& InSpeaker, const struct FBlendParameters& InParameters, const struct FVector& InPosAndScale, bool bHide, bool bHideOthers, bool bBlackSelf);
	void SetRollerSubtitlesEnd(class UUserWidget* RollerTable);
	void SetTextAnimSpeedRate(float InValue);
	void SetTextWrap(class UWidget* InWidget, bool InWrap);
	void StopCurPlayItemWwise();
	void StopCurRecordPlayWwise();
	void SwtichBGM(const class FString& InMusic, const class FString& InAmbience);
	void TryInitInteractionGame();
	bool TrySkip();

	void DeactivateParticleImage(class UWidget* InWidget) const;
	const struct FVector2D GetBackgroundImageSize() const;
	const struct FVector2D GetBackgroundSize() const;
	const class FString GetDefaultAnimationName(class UObject* InComponent, const class FString& InComparedString, const class FName& InAnimationStateName) const;
	class UTextBlock* GetDialogTextBlock(const EDialogueType& InType) const;
	EDialogueType GetDialogueType() const;
	class UPlot* GetPlot() const;
	const TArray<class UObject*> GetTalkRecords() const;
	const struct FSlateFontInfo GetTextFontInfo(class UWidget* InWidget) const;
	bool IsCurrentPlayItem(class UPlotItem* InItem) const;
	bool IsEnd() const;
	void PlayDefaultAnim() const;
	void SetWidgetRenderOpacity(const class FName& InName, float InRenderOpacity) const;
	void SetWidgetVisibility(const class FName& InName, ESlateVisibility InVisibility) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotWidget">();
	}
	static class UPlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotWidget>();
	}
};
static_assert(alignof(UPlotWidget) == 0x000008, "Wrong alignment on UPlotWidget");
static_assert(sizeof(UPlotWidget) == 0x0006C8, "Wrong size on UPlotWidget");
static_assert(offsetof(UPlotWidget, OnInput) == 0x000280, "Member 'UPlotWidget::OnInput' has a wrong offset!");
static_assert(offsetof(UPlotWidget, OnSelect) == 0x000290, "Member 'UPlotWidget::OnSelect' has a wrong offset!");
static_assert(offsetof(UPlotWidget, IsOpenDoubleScreen) == 0x0002B0, "Member 'UPlotWidget::IsOpenDoubleScreen' has a wrong offset!");
static_assert(offsetof(UPlotWidget, FirstScreen) == 0x0002B8, "Member 'UPlotWidget::FirstScreen' has a wrong offset!");
static_assert(offsetof(UPlotWidget, MaskContainer) == 0x0002C0, "Member 'UPlotWidget::MaskContainer' has a wrong offset!");
static_assert(offsetof(UPlotWidget, SecondScreen) == 0x0002C8, "Member 'UPlotWidget::SecondScreen' has a wrong offset!");
static_assert(offsetof(UPlotWidget, Path2WidgetCache) == 0x0002D0, "Member 'UPlotWidget::Path2WidgetCache' has a wrong offset!");
static_assert(offsetof(UPlotWidget, LastPlayWwiseComponent) == 0x000320, "Member 'UPlotWidget::LastPlayWwiseComponent' has a wrong offset!");
static_assert(offsetof(UPlotWidget, GlobalApplicationScale) == 0x000328, "Member 'UPlotWidget::GlobalApplicationScale' has a wrong offset!");
static_assert(offsetof(UPlotWidget, TalkRecords) == 0x000330, "Member 'UPlotWidget::TalkRecords' has a wrong offset!");
static_assert(offsetof(UPlotWidget, RootPanel) == 0x000340, "Member 'UPlotWidget::RootPanel' has a wrong offset!");
static_assert(offsetof(UPlotWidget, RollerTablePtr) == 0x000348, "Member 'UPlotWidget::RollerTablePtr' has a wrong offset!");
static_assert(offsetof(UPlotWidget, TalkText) == 0x000350, "Member 'UPlotWidget::TalkText' has a wrong offset!");
static_assert(offsetof(UPlotWidget, DialogueText) == 0x000358, "Member 'UPlotWidget::DialogueText' has a wrong offset!");
static_assert(offsetof(UPlotWidget, AsideText) == 0x000360, "Member 'UPlotWidget::AsideText' has a wrong offset!");
static_assert(offsetof(UPlotWidget, ControlView) == 0x000368, "Member 'UPlotWidget::ControlView' has a wrong offset!");
static_assert(offsetof(UPlotWidget, TalkContent) == 0x000370, "Member 'UPlotWidget::TalkContent' has a wrong offset!");
static_assert(offsetof(UPlotWidget, UINode) == 0x000378, "Member 'UPlotWidget::UINode' has a wrong offset!");
static_assert(offsetof(UPlotWidget, Speaker) == 0x000380, "Member 'UPlotWidget::Speaker' has a wrong offset!");
static_assert(offsetof(UPlotWidget, FightStyle) == 0x000388, "Member 'UPlotWidget::FightStyle' has a wrong offset!");
static_assert(offsetof(UPlotWidget, BranchTalk_2D) == 0x000390, "Member 'UPlotWidget::BranchTalk_2D' has a wrong offset!");
static_assert(offsetof(UPlotWidget, SpliceImgBG) == 0x000398, "Member 'UPlotWidget::SpliceImgBG' has a wrong offset!");
static_assert(offsetof(UPlotWidget, OtherNode) == 0x0003A0, "Member 'UPlotWidget::OtherNode' has a wrong offset!");
static_assert(offsetof(UPlotWidget, Dialogue_2D) == 0x0003A8, "Member 'UPlotWidget::Dialogue_2D' has a wrong offset!");
static_assert(offsetof(UPlotWidget, PanelRole) == 0x0003B0, "Member 'UPlotWidget::PanelRole' has a wrong offset!");
static_assert(offsetof(UPlotWidget, Speaker_Stage2D) == 0x0003B8, "Member 'UPlotWidget::Speaker_Stage2D' has a wrong offset!");
static_assert(offsetof(UPlotWidget, DialogueText_Stage2D) == 0x0003C0, "Member 'UPlotWidget::DialogueText_Stage2D' has a wrong offset!");
static_assert(offsetof(UPlotWidget, DefaultScreenImage) == 0x0003C8, "Member 'UPlotWidget::DefaultScreenImage' has a wrong offset!");
static_assert(offsetof(UPlotWidget, DefaultScreenSizeImage) == 0x0003D0, "Member 'UPlotWidget::DefaultScreenSizeImage' has a wrong offset!");
static_assert(offsetof(UPlotWidget, ImgRole) == 0x0003D8, "Member 'UPlotWidget::ImgRole' has a wrong offset!");
static_assert(offsetof(UPlotWidget, WidgetCover) == 0x0003E0, "Member 'UPlotWidget::WidgetCover' has a wrong offset!");
static_assert(offsetof(UPlotWidget, PanelKeyInfo) == 0x0003E8, "Member 'UPlotWidget::PanelKeyInfo' has a wrong offset!");
static_assert(offsetof(UPlotWidget, InteractionGame) == 0x000498, "Member 'UPlotWidget::InteractionGame' has a wrong offset!");
static_assert(offsetof(UPlotWidget, HandDrawWidget) == 0x0004A0, "Member 'UPlotWidget::HandDrawWidget' has a wrong offset!");
static_assert(offsetof(UPlotWidget, TextAreaMaxWidth) == 0x0004A8, "Member 'UPlotWidget::TextAreaMaxWidth' has a wrong offset!");
static_assert(offsetof(UPlotWidget, DisableAddTalkRecords) == 0x0004AC, "Member 'UPlotWidget::DisableAddTalkRecords' has a wrong offset!");
static_assert(offsetof(UPlotWidget, FindEvidenceWidget) == 0x000530, "Member 'UPlotWidget::FindEvidenceWidget' has a wrong offset!");
static_assert(offsetof(UPlotWidget, FullscreenSpineMap) == 0x000538, "Member 'UPlotWidget::FullscreenSpineMap' has a wrong offset!");
static_assert(offsetof(UPlotWidget, bPaused) == 0x0006C0, "Member 'UPlotWidget::bPaused' has a wrong offset!");

// Class Plot.PlotFightStyle
// 0x0058 (0x02D8 - 0x0280)
class UPlotFightStyle final : public UUserWidget
{
public:
	class UCurveVector*                           CurveData;                                         // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Voice;                                             // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Speaker;                                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                TalkText;                                          // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Role;                                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AllEnter;                                          // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ALLloop;                                           // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotWidget*                            ParentWidget;                                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               RoleMaterial;                                      // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoTalk(class UPlotWidget* InParent, class UPlotItem_Talk* InData);
	void OnTextInfoChange(class UWidget* InWidget, const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotFightStyle">();
	}
	static class UPlotFightStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotFightStyle>();
	}
};
static_assert(alignof(UPlotFightStyle) == 0x000008, "Wrong alignment on UPlotFightStyle");
static_assert(sizeof(UPlotFightStyle) == 0x0002D8, "Wrong size on UPlotFightStyle");
static_assert(offsetof(UPlotFightStyle, CurveData) == 0x000280, "Member 'UPlotFightStyle::CurveData' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, Voice) == 0x000288, "Member 'UPlotFightStyle::Voice' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, Speaker) == 0x000290, "Member 'UPlotFightStyle::Speaker' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, TalkText) == 0x000298, "Member 'UPlotFightStyle::TalkText' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, Role) == 0x0002A0, "Member 'UPlotFightStyle::Role' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, AllEnter) == 0x0002A8, "Member 'UPlotFightStyle::AllEnter' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, ALLloop) == 0x0002B0, "Member 'UPlotFightStyle::ALLloop' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, ParentWidget) == 0x0002B8, "Member 'UPlotFightStyle::ParentWidget' has a wrong offset!");
static_assert(offsetof(UPlotFightStyle, RoleMaterial) == 0x0002C0, "Member 'UPlotFightStyle::RoleMaterial' has a wrong offset!");

// Class Plot.PlotWidgetCover
// 0x0048 (0x02C8 - 0x0280)
class UPlotWidgetCover final : public UUserWidget
{
public:
	class UCanvasPanel*                           PanelStart;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TxtNum;                                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TxtName;                                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BG;                                                // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AnimStart;                                         // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PanelEnd;                                          // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TxtEndMsg;                                         // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TxtNum1;                                           // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       AnimEnd;                                           // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotWidgetCover">();
	}
	static class UPlotWidgetCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotWidgetCover>();
	}
};
static_assert(alignof(UPlotWidgetCover) == 0x000008, "Wrong alignment on UPlotWidgetCover");
static_assert(sizeof(UPlotWidgetCover) == 0x0002C8, "Wrong size on UPlotWidgetCover");
static_assert(offsetof(UPlotWidgetCover, PanelStart) == 0x000280, "Member 'UPlotWidgetCover::PanelStart' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, TxtNum) == 0x000288, "Member 'UPlotWidgetCover::TxtNum' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, TxtName) == 0x000290, "Member 'UPlotWidgetCover::TxtName' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, BG) == 0x000298, "Member 'UPlotWidgetCover::BG' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, AnimStart) == 0x0002A0, "Member 'UPlotWidgetCover::AnimStart' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, PanelEnd) == 0x0002A8, "Member 'UPlotWidgetCover::PanelEnd' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, TxtEndMsg) == 0x0002B0, "Member 'UPlotWidgetCover::TxtEndMsg' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, TxtNum1) == 0x0002B8, "Member 'UPlotWidgetCover::TxtNum1' has a wrong offset!");
static_assert(offsetof(UPlotWidgetCover, AnimEnd) == 0x0002C0, "Member 'UPlotWidgetCover::AnimEnd' has a wrong offset!");

// Class Plot.PlotWidgetInteractionGameClick
// 0x0018 (0x0298 - 0x0280)
class UPlotWidgetInteractionGameClick final : public UUserWidget
{
public:
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotWidgetInteractionGameClick">();
	}
	static class UPlotWidgetInteractionGameClick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotWidgetInteractionGameClick>();
	}
};
static_assert(alignof(UPlotWidgetInteractionGameClick) == 0x000008, "Wrong alignment on UPlotWidgetInteractionGameClick");
static_assert(sizeof(UPlotWidgetInteractionGameClick) == 0x000298, "Wrong size on UPlotWidgetInteractionGameClick");

// Class Plot.PlotWidgetInteractionGame
// 0x04A0 (0x0720 - 0x0280)
class UPlotWidgetInteractionGame final : public UUserWidget
{
public:
	class UCanvasPanel*                           PanelItems;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlotWidgetInteractionGameItem*         Btn1;                                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x9];                                      // 0x0290(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsComplete;                                        // 0x0299(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0xE];                                      // 0x029A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTalkTextChange;                                  // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTalkBegin;                                       // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWwiseBegin;                                      // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x448];                                    // 0x02D8(0x0448)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClose();
	void OnTalkBegin__DelegateSignature(const class FString& TalkText, const class FString& Speaker, const class FString& WwiseKey);
	void OnTalkTextChange__DelegateSignature(const class FString& TalkText, int32 MaxNumText, const class FString& Speaker);
	void OnWwiseBegin__DelegateSignature(const class FString& WwiseEventID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotWidgetInteractionGame">();
	}
	static class UPlotWidgetInteractionGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotWidgetInteractionGame>();
	}
};
static_assert(alignof(UPlotWidgetInteractionGame) == 0x000008, "Wrong alignment on UPlotWidgetInteractionGame");
static_assert(sizeof(UPlotWidgetInteractionGame) == 0x000720, "Wrong size on UPlotWidgetInteractionGame");
static_assert(offsetof(UPlotWidgetInteractionGame, PanelItems) == 0x000280, "Member 'UPlotWidgetInteractionGame::PanelItems' has a wrong offset!");
static_assert(offsetof(UPlotWidgetInteractionGame, Btn1) == 0x000288, "Member 'UPlotWidgetInteractionGame::Btn1' has a wrong offset!");
static_assert(offsetof(UPlotWidgetInteractionGame, IsComplete) == 0x000299, "Member 'UPlotWidgetInteractionGame::IsComplete' has a wrong offset!");
static_assert(offsetof(UPlotWidgetInteractionGame, OnTalkTextChange) == 0x0002A8, "Member 'UPlotWidgetInteractionGame::OnTalkTextChange' has a wrong offset!");
static_assert(offsetof(UPlotWidgetInteractionGame, OnTalkBegin) == 0x0002B8, "Member 'UPlotWidgetInteractionGame::OnTalkBegin' has a wrong offset!");
static_assert(offsetof(UPlotWidgetInteractionGame, OnWwiseBegin) == 0x0002C8, "Member 'UPlotWidgetInteractionGame::OnWwiseBegin' has a wrong offset!");

// Class Plot.PlotWidgetInteractionGameItem
// 0x0008 (0x0288 - 0x0280)
class UPlotWidgetInteractionGameItem final : public UUserWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExit();
	void OnStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlotWidgetInteractionGameItem">();
	}
	static class UPlotWidgetInteractionGameItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlotWidgetInteractionGameItem>();
	}
};
static_assert(alignof(UPlotWidgetInteractionGameItem) == 0x000008, "Wrong alignment on UPlotWidgetInteractionGameItem");
static_assert(sizeof(UPlotWidgetInteractionGameItem) == 0x000288, "Wrong size on UPlotWidgetInteractionGameItem");

// Class Plot.SequencerUserWidget
// 0x0118 (0x0398 - 0x0280)
class USequencerUserWidget final : public UUserWidget
{
public:
	class UPlot*                                  MainPlot;                                          // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0288(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DontCloseMediaPlayer;                              // 0x028C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutTime;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MediaCameraOffset;                                 // 0x0294(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BlackUI;                                           // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x58];                                     // 0x02A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSequencePlayer*                     SequencePlayer;                                    // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMovieClipSubUserWidget*                M_lpSubUserWidget;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMovieClipCanvasPanel*                  M_lpWrapContainer;                                 // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMovieClipBackgroundUserWidget*         M_lpBackgroundUserWidget;                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSequencePlayer*                     SubWidgetSequencePlayer;                           // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x70];                                     // 0x0328(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddSpecialName(const class FString& InName);

	void ClearFinishedCallback();
	void OnPostStart();
	void OnPreEnd();
	void OnWindowActivatedHandler();
	void OnWindowDeactivatedHandler();
	void PlayWwiseEvent(const class FString& InEventName);
	void SetEndCallBack(TDelegate<void()> OnEndHandler);
	void SetFadeOutCallBack(TDelegate<void()> OnFadeOutHandler);
	void SetFinishedCallBack(TDelegate<void()> OnEndHandler);
	void SetPause(bool InValue);
	void SkipSequencer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerUserWidget">();
	}
	static class USequencerUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerUserWidget>();
	}
};
static_assert(alignof(USequencerUserWidget) == 0x000008, "Wrong alignment on USequencerUserWidget");
static_assert(sizeof(USequencerUserWidget) == 0x000398, "Wrong size on USequencerUserWidget");
static_assert(offsetof(USequencerUserWidget, MainPlot) == 0x000280, "Member 'USequencerUserWidget::MainPlot' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, Offset) == 0x000288, "Member 'USequencerUserWidget::Offset' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, DontCloseMediaPlayer) == 0x00028C, "Member 'USequencerUserWidget::DontCloseMediaPlayer' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, FadeOutTime) == 0x000290, "Member 'USequencerUserWidget::FadeOutTime' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, MediaCameraOffset) == 0x000294, "Member 'USequencerUserWidget::MediaCameraOffset' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, BlackUI) == 0x0002A0, "Member 'USequencerUserWidget::BlackUI' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, SequencePlayer) == 0x000300, "Member 'USequencerUserWidget::SequencePlayer' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, M_lpSubUserWidget) == 0x000308, "Member 'USequencerUserWidget::M_lpSubUserWidget' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, M_lpWrapContainer) == 0x000310, "Member 'USequencerUserWidget::M_lpWrapContainer' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, M_lpBackgroundUserWidget) == 0x000318, "Member 'USequencerUserWidget::M_lpBackgroundUserWidget' has a wrong offset!");
static_assert(offsetof(USequencerUserWidget, SubWidgetSequencePlayer) == 0x000320, "Member 'USequencerUserWidget::SubWidgetSequencePlayer' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Richman

#include "Basic.hpp"

#include "ChessMap_classes.hpp"
#include "Engine_classes.hpp"
#include "Richman_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Richman.Richman_ChessGround
// 0x0010 (0x0288 - 0x0278)
class ARichman_ChessGround final : public AChessGround
{
public:
	TArray<class AChessObject*>                   BesideObjects;                                     // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	bool CheckObjectHasTag(const class FString& InTagName);
	class ARichman_BuildingObject* GetBuilding();
	TArray<class AChessObject*> GetObjectsByTag(const class FString& InTagName);
	bool HasProp();
	bool IsInFrontOfBuilding(class ARichman_BuildingObject* InBuilding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Richman_ChessGround">();
	}
	static class ARichman_ChessGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichman_ChessGround>();
	}
};
static_assert(alignof(ARichman_ChessGround) == 0x000008, "Wrong alignment on ARichman_ChessGround");
static_assert(sizeof(ARichman_ChessGround) == 0x000288, "Wrong size on ARichman_ChessGround");
static_assert(offsetof(ARichman_ChessGround, BesideObjects) == 0x000278, "Member 'ARichman_ChessGround::BesideObjects' has a wrong offset!");

// Class Richman.Richman_ChessObject
// 0x0000 (0x0258 - 0x0258)
class ARichman_ChessObject : public AChessObject
{
public:
	class FString GetTagParam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Richman_ChessObject">();
	}
	static class ARichman_ChessObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichman_ChessObject>();
	}
};
static_assert(alignof(ARichman_ChessObject) == 0x000008, "Wrong alignment on ARichman_ChessObject");
static_assert(sizeof(ARichman_ChessObject) == 0x000258, "Wrong size on ARichman_ChessObject");

// Class Richman.Richman_BuildingObject
// 0x0058 (0x02B0 - 0x0258)
class ARichman_BuildingObject final : public ARichman_ChessObject
{
public:
	int32                                         Level;                                             // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichman_BuildingObject*                ParentBuilding;                                    // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             NormalMaterials;                                   // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             GreyMaterials;                                     // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARichmanMgr>             RichmanMgr;                                        // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichman_BuildingObject*                ChildBuilding;                                     // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichman_BuildingBottomObject*          BottomBuilding;                                    // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ARichmanCharacter* GetOwnerCharacter();
	int32 GetRealLevel();
	int32 GetRealTplId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Richman_BuildingObject">();
	}
	static class ARichman_BuildingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichman_BuildingObject>();
	}
};
static_assert(alignof(ARichman_BuildingObject) == 0x000008, "Wrong alignment on ARichman_BuildingObject");
static_assert(sizeof(ARichman_BuildingObject) == 0x0002B0, "Wrong size on ARichman_BuildingObject");
static_assert(offsetof(ARichman_BuildingObject, Level) == 0x000258, "Member 'ARichman_BuildingObject::Level' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, ParentBuilding) == 0x000260, "Member 'ARichman_BuildingObject::ParentBuilding' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, MeshComponent) == 0x000268, "Member 'ARichman_BuildingObject::MeshComponent' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, NormalMaterials) == 0x000270, "Member 'ARichman_BuildingObject::NormalMaterials' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, GreyMaterials) == 0x000280, "Member 'ARichman_BuildingObject::GreyMaterials' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, RichmanMgr) == 0x000290, "Member 'ARichman_BuildingObject::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, ChildBuilding) == 0x000298, "Member 'ARichman_BuildingObject::ChildBuilding' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingObject, BottomBuilding) == 0x0002A0, "Member 'ARichman_BuildingObject::BottomBuilding' has a wrong offset!");

// Class Richman.Richman_BuildingBottomObject
// 0x0068 (0x02C0 - 0x0258)
class ARichman_BuildingBottomObject final : public ARichman_ChessObject
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     GreyMaterials;                                     // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x58];                                     // 0x0268(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Richman_BuildingBottomObject">();
	}
	static class ARichman_BuildingBottomObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichman_BuildingBottomObject>();
	}
};
static_assert(alignof(ARichman_BuildingBottomObject) == 0x000008, "Wrong alignment on ARichman_BuildingBottomObject");
static_assert(sizeof(ARichman_BuildingBottomObject) == 0x0002C0, "Wrong size on ARichman_BuildingBottomObject");
static_assert(offsetof(ARichman_BuildingBottomObject, MeshComponent) == 0x000258, "Member 'ARichman_BuildingBottomObject::MeshComponent' has a wrong offset!");
static_assert(offsetof(ARichman_BuildingBottomObject, GreyMaterials) == 0x000260, "Member 'ARichman_BuildingBottomObject::GreyMaterials' has a wrong offset!");

// Class Richman.RichmanAIController
// 0x00A0 (0x0340 - 0x02A0)
class ARichmanAIController final : public AController
{
public:
	class ARichmanGameMode*                       GameMode;                                          // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanCharacter*                      CurrentChar;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AChessGround*>                   PathActors;                                        // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          IsUIMode;                                          // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0xF];                                      // 0x02C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRunSpeed;                                       // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeed;                                      // 0x02D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSmall;                                           // 0x02D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanMgr*                            RichmanMgr;                                        // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterMovementComponent*            TempMovement;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitCallback;                                      // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AChessGround*                           LastShowDirGround;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x40];                                     // 0x0300(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExplosiveContinueMove();
	void ExplosiveFinishMove();
	void FixRotation();
	void LookAtTarget(class AChessBase* InActor);
	void RemoveMoveGroundTip();
	void ResetRichmanState();
	void SetScale(float InValue);
	void ShowDirEffect();
	void StartMoving(int32 Steps, bool InForce, bool IsCustomFlag);
	void StopMovementImmediately();
	void UpdateWalkState(bool IsRun, bool IsWalk);

	class ARichmanCharacter* GetCurrentChar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanAIController">();
	}
	static class ARichmanAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanAIController>();
	}
};
static_assert(alignof(ARichmanAIController) == 0x000008, "Wrong alignment on ARichmanAIController");
static_assert(sizeof(ARichmanAIController) == 0x000340, "Wrong size on ARichmanAIController");
static_assert(offsetof(ARichmanAIController, GameMode) == 0x0002A0, "Member 'ARichmanAIController::GameMode' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, CurrentChar) == 0x0002A8, "Member 'ARichmanAIController::CurrentChar' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, PathActors) == 0x0002B0, "Member 'ARichmanAIController::PathActors' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, IsUIMode) == 0x0002C0, "Member 'ARichmanAIController::IsUIMode' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, MaxRunSpeed) == 0x0002D0, "Member 'ARichmanAIController::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, MaxWalkSpeed) == 0x0002D4, "Member 'ARichmanAIController::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, IsSmall) == 0x0002D8, "Member 'ARichmanAIController::IsSmall' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, RichmanMgr) == 0x0002E0, "Member 'ARichmanAIController::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, TempMovement) == 0x0002E8, "Member 'ARichmanAIController::TempMovement' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, WaitCallback) == 0x0002F0, "Member 'ARichmanAIController::WaitCallback' has a wrong offset!");
static_assert(offsetof(ARichmanAIController, LastShowDirGround) == 0x0002F8, "Member 'ARichmanAIController::LastShowDirGround' has a wrong offset!");

// Class Richman.RichmanAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class URichmanAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsPush;                                            // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRun;                                             // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWalk;                                            // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceToMoveDir;                                  // 0x02BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToControllerAngle;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleHorizontalSpeed;                              // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpeed;                                   // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanAnimInstance">();
	}
	static class URichmanAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanAnimInstance>();
	}
};
static_assert(alignof(URichmanAnimInstance) == 0x000010, "Wrong alignment on URichmanAnimInstance");
static_assert(sizeof(URichmanAnimInstance) == 0x0002D0, "Wrong size on URichmanAnimInstance");
static_assert(offsetof(URichmanAnimInstance, IsPush) == 0x0002B8, "Member 'URichmanAnimInstance::IsPush' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, IsRun) == 0x0002B9, "Member 'URichmanAnimInstance::IsRun' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, IsWalk) == 0x0002BA, "Member 'URichmanAnimInstance::IsWalk' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, bIsFaceToMoveDir) == 0x0002BB, "Member 'URichmanAnimInstance::bIsFaceToMoveDir' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, Speed) == 0x0002BC, "Member 'URichmanAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, MoveToControllerAngle) == 0x0002C0, "Member 'URichmanAnimInstance::MoveToControllerAngle' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, ScaleHorizontalSpeed) == 0x0002C4, "Member 'URichmanAnimInstance::ScaleHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, HorizontalSpeed) == 0x0002C8, "Member 'URichmanAnimInstance::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(URichmanAnimInstance, MaxSpeed) == 0x0002CC, "Member 'URichmanAnimInstance::MaxSpeed' has a wrong offset!");

// Class Richman.AnimNotify_OnRichmanFootLanding
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnRichmanFootLanding final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnRichmanFootLanding">();
	}
	static class UAnimNotify_OnRichmanFootLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnRichmanFootLanding>();
	}
};
static_assert(alignof(UAnimNotify_OnRichmanFootLanding) == 0x000008, "Wrong alignment on UAnimNotify_OnRichmanFootLanding");
static_assert(sizeof(UAnimNotify_OnRichmanFootLanding) == 0x000038, "Wrong size on UAnimNotify_OnRichmanFootLanding");

// Class Richman.RichmanCameraFollow
// 0x0078 (0x02A0 - 0x0228)
class ARichmanCameraFollow final : public AActor
{
public:
	class AActor*                                 Target;                                            // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FollowActor;                                       // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanPlayerController*               PlayerController;                                  // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ShowTarget;                                        // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanCameraFollowType                      FollowType;                                        // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxViewSize;                                       // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinViewSize;                                       // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightShowDistance;                                 // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerformSpeed;                                      // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x3C];                                     // 0x0264(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAutoFollowComplete();
	bool GetLockControl();
	bool IsSlidingView();
	void OnMouseMove(const struct FVector2D& DeltaPos);
	void OnZoomChange(float InZoom);
	void RefreshCameraRange(class AChessRegion* Region);
	void ResetCamera();
	void SetCameraShowTarget(class AActor* InTarget);
	void SetFollowTarget(class AActor* InCharacter, bool Immediately);
	void SetLockControl(bool InLockControl);
	void SetSlidingView(bool bSlid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanCameraFollow">();
	}
	static class ARichmanCameraFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanCameraFollow>();
	}
};
static_assert(alignof(ARichmanCameraFollow) == 0x000008, "Wrong alignment on ARichmanCameraFollow");
static_assert(sizeof(ARichmanCameraFollow) == 0x0002A0, "Wrong size on ARichmanCameraFollow");
static_assert(offsetof(ARichmanCameraFollow, Target) == 0x000228, "Member 'ARichmanCameraFollow::Target' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, RichmanMgr) == 0x000230, "Member 'ARichmanCameraFollow::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, FollowActor) == 0x000238, "Member 'ARichmanCameraFollow::FollowActor' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, PlayerController) == 0x000240, "Member 'ARichmanCameraFollow::PlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, ShowTarget) == 0x000248, "Member 'ARichmanCameraFollow::ShowTarget' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, FollowType) == 0x000250, "Member 'ARichmanCameraFollow::FollowType' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, MaxViewSize) == 0x000254, "Member 'ARichmanCameraFollow::MaxViewSize' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, MinViewSize) == 0x000258, "Member 'ARichmanCameraFollow::MinViewSize' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, LightShowDistance) == 0x00025C, "Member 'ARichmanCameraFollow::LightShowDistance' has a wrong offset!");
static_assert(offsetof(ARichmanCameraFollow, PerformSpeed) == 0x000260, "Member 'ARichmanCameraFollow::PerformSpeed' has a wrong offset!");

// Class Richman.RichmanCharacter
// 0x0080 (0x0550 - 0x04D0)
class ARichmanCharacter final : public AChessNpcBase
{
public:
	class UWidgetComponent*                       WidgetComponent;                                   // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichmanPlayerMovementComponent*        CharMoveComp;                                      // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegionId;                                          // 0x04D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanPlayerController*               PlayerController;                                  // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRun;                                             // 0x04E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWalk;                                            // 0x04E9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocalPlayer;                                     // 0x04EA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRounding;                                        // 0x04EB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasTransfer;                                       // 0x04EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanCharacterState                        FlowState;                                         // 0x04ED(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EE[0x2];                                      // 0x04EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ARichmanMgr*                            RichmanMgr;                                        // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TplId;                                             // 0x04F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityId;                                         // 0x04FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityParam1;                                     // 0x0500(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityParam2;                                     // 0x0510(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_520[0x18];                                     // 0x0520(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllRotateLerpSeconds;                              // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurSpeed;                                          // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInHospital;                                      // 0x0548(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFishing;                                         // 0x0549(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBankruptcy;                                      // 0x054A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54B[0x5];                                      // 0x054B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ApplyBuyLand();
	bool CheckHasObjectByParam(const class FString& InParam);
	bool CheckLandAvailabilityForPurchase();
	void EntryHospital(int32 InDay);
	class ARichmanAIController* GetAIController();
	class ARichman_ChessGround* GetChessGround();
	class FString GetHeadIconId();
	class FString GetLangNameKey();
	int32 GetNpcUID();
	struct FIntVector GetPosition();
	int32 GetRegionId();
	int32 GetTeamId();
	void GotoFlowState(ERichmanCharacterState InNewState);
	bool IsAnyMontagePlaying();
	void LeaveFishing();
	void LeaveHospital();
	bool MoveTo(class AChessRegion* InRegion, int32 InPosX, int32 InPosY, bool InUpdate3DPos);
	void OnAnimHappyEnd();
	void OnAnimHitEnd();
	void OnAnimSadEnd();
	void OnMoveEnd(class ARichman_ChessGround* Ground);
	void PlayAnimHappy();
	void PlayAnimHit();
	void PlayAnimSad();
	void PlayTopEffect(int32 ID);
	void ResetPosition();
	void SetGroundActor(class AChessGround* InGroundActor);
	void StartMoving(int32 Steps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanCharacter">();
	}
	static class ARichmanCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanCharacter>();
	}
};
static_assert(alignof(ARichmanCharacter) == 0x000010, "Wrong alignment on ARichmanCharacter");
static_assert(sizeof(ARichmanCharacter) == 0x000550, "Wrong size on ARichmanCharacter");
static_assert(offsetof(ARichmanCharacter, WidgetComponent) == 0x0004C8, "Member 'ARichmanCharacter::WidgetComponent' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, CharMoveComp) == 0x0004D0, "Member 'ARichmanCharacter::CharMoveComp' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, RegionId) == 0x0004D8, "Member 'ARichmanCharacter::RegionId' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, PlayerController) == 0x0004E0, "Member 'ARichmanCharacter::PlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsRun) == 0x0004E8, "Member 'ARichmanCharacter::IsRun' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsWalk) == 0x0004E9, "Member 'ARichmanCharacter::IsWalk' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsLocalPlayer) == 0x0004EA, "Member 'ARichmanCharacter::IsLocalPlayer' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsRounding) == 0x0004EB, "Member 'ARichmanCharacter::IsRounding' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, HasTransfer) == 0x0004EC, "Member 'ARichmanCharacter::HasTransfer' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, FlowState) == 0x0004ED, "Member 'ARichmanCharacter::FlowState' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, RichmanMgr) == 0x0004F0, "Member 'ARichmanCharacter::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, TplId) == 0x0004F8, "Member 'ARichmanCharacter::TplId' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, AbilityId) == 0x0004FC, "Member 'ARichmanCharacter::AbilityId' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, AbilityParam1) == 0x000500, "Member 'ARichmanCharacter::AbilityParam1' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, AbilityParam2) == 0x000510, "Member 'ARichmanCharacter::AbilityParam2' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, AllRotateLerpSeconds) == 0x000538, "Member 'ARichmanCharacter::AllRotateLerpSeconds' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, MinSpeed) == 0x00053C, "Member 'ARichmanCharacter::MinSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, MaxSpeed) == 0x000540, "Member 'ARichmanCharacter::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, CurSpeed) == 0x000544, "Member 'ARichmanCharacter::CurSpeed' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsInHospital) == 0x000548, "Member 'ARichmanCharacter::IsInHospital' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsFishing) == 0x000549, "Member 'ARichmanCharacter::IsFishing' has a wrong offset!");
static_assert(offsetof(ARichmanCharacter, IsBankruptcy) == 0x00054A, "Member 'ARichmanCharacter::IsBankruptcy' has a wrong offset!");

// Class Richman.RichmanGameMode
// 0x0070 (0x0380 - 0x0310)
class ARichmanGameMode final : public AGameMode
{
public:
	TArray<class ARichmanPlayerController*>       PlayerControllers;                                 // 0x0310(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UFXSystemComponent*>        AllEffects;                                        // 0x0328(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyEffect(int32 InEffectId);
	void LuaStartPlay();
	void PlayCustomAnim(const class FString& InPath, class AActor* TargetActor, bool bLooping);
	int32 PlayEffect(const class FString& InPath, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	int32 PlayEffectAttached(const class FString& InPath, class USceneComponent* AttachToComponent, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	void UpdateItemPanel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanGameMode">();
	}
	static class ARichmanGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanGameMode>();
	}
};
static_assert(alignof(ARichmanGameMode) == 0x000008, "Wrong alignment on ARichmanGameMode");
static_assert(sizeof(ARichmanGameMode) == 0x000380, "Wrong size on ARichmanGameMode");
static_assert(offsetof(ARichmanGameMode, PlayerControllers) == 0x000310, "Member 'ARichmanGameMode::PlayerControllers' has a wrong offset!");
static_assert(offsetof(ARichmanGameMode, RichmanMgr) == 0x000320, "Member 'ARichmanGameMode::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanGameMode, AllEffects) == 0x000328, "Member 'ARichmanGameMode::AllEffects' has a wrong offset!");

// Class Richman.RichmanGroundSelector
// 0x0070 (0x0298 - 0x0228)
class ARichmanGroundSelector final : public AActor
{
public:
	TDelegate<void(int32 InStep)>                 OnSelected;                                        // 0x0228(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class ARichmanCharacter*                      Character;                                         // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanCharacter*                      BlinkCharacter;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AChessGround*>                   Grounds;                                           // 0x0250(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AChessGround*>                   GroundCustomDiceArray;                             // 0x0260(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x28];                                     // 0x0270(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cleanup();
	void GetAllCanReachGridsByCard(class ARichmanCharacter* InCharacter, int32 InStep, const class FString& FindType);
	void OnDirGroundSelected(int32 Index_0);
	void ReadyForPutBarrierOrBomb();
	void Reset();
	void Reset_CustomDice();
	void SelectGroundByIndex(int32 Index_0);
	void SetBombOrBarrier(class ARichmanCharacter* InCharacter, int32 InStep, bool CleanFlag);
	void SetCharacter(class ARichmanCharacter* InCharacter, int32 InStep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanGroundSelector">();
	}
	static class ARichmanGroundSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanGroundSelector>();
	}
};
static_assert(alignof(ARichmanGroundSelector) == 0x000008, "Wrong alignment on ARichmanGroundSelector");
static_assert(sizeof(ARichmanGroundSelector) == 0x000298, "Wrong size on ARichmanGroundSelector");
static_assert(offsetof(ARichmanGroundSelector, OnSelected) == 0x000228, "Member 'ARichmanGroundSelector::OnSelected' has a wrong offset!");
static_assert(offsetof(ARichmanGroundSelector, Character) == 0x000238, "Member 'ARichmanGroundSelector::Character' has a wrong offset!");
static_assert(offsetof(ARichmanGroundSelector, BlinkCharacter) == 0x000240, "Member 'ARichmanGroundSelector::BlinkCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanGroundSelector, RichmanMgr) == 0x000248, "Member 'ARichmanGroundSelector::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanGroundSelector, Grounds) == 0x000250, "Member 'ARichmanGroundSelector::Grounds' has a wrong offset!");
static_assert(offsetof(ARichmanGroundSelector, GroundCustomDiceArray) == 0x000260, "Member 'ARichmanGroundSelector::GroundCustomDiceArray' has a wrong offset!");

// Class Richman.RichmanItemObject
// 0x0018 (0x0040 - 0x0028)
class URichmanItemObject final : public UObject
{
public:
	class ARichmanCharacter*                      CurrentCharacter;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentItemUId;                                    // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentItemTplId;                                  // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnClick();
	void OnReset();
	void OnUse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanItemObject">();
	}
	static class URichmanItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanItemObject>();
	}
};
static_assert(alignof(URichmanItemObject) == 0x000008, "Wrong alignment on URichmanItemObject");
static_assert(sizeof(URichmanItemObject) == 0x000040, "Wrong size on URichmanItemObject");
static_assert(offsetof(URichmanItemObject, CurrentCharacter) == 0x000028, "Member 'URichmanItemObject::CurrentCharacter' has a wrong offset!");
static_assert(offsetof(URichmanItemObject, CurrentItemUId) == 0x000030, "Member 'URichmanItemObject::CurrentItemUId' has a wrong offset!");
static_assert(offsetof(URichmanItemObject, CurrentItemTplId) == 0x000034, "Member 'URichmanItemObject::CurrentItemTplId' has a wrong offset!");
static_assert(offsetof(URichmanItemObject, RichmanMgr) == 0x000038, "Member 'URichmanItemObject::RichmanMgr' has a wrong offset!");

// Class Richman.RichmanLibrary
// 0x0000 (0x0028 - 0x0028)
class URichmanLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ARichmanCharacter* AISelectCardTarget(class ARichmanMgr* InMgr, class ARichmanCharacter* Character);
	static class ARichmanCharacter* AISelectCardTargetFromArray(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter, const TArray<class ARichmanCharacter*>& CanSelectCharacters);
	static TArray<struct FBombVictimData> ChainExplosion(class ARichmanMgr* InMgr, class ARichman_ChessGround* Ground, class ARichmanCharacter* Character, TArray<struct FBombExistData>* BombExistDatas);
	static TArray<struct FBombVictimData> ChainExplosion_Nearest(class ARichmanMgr* InMgr, class ARichman_ChessGround* Ground, class ARichmanCharacter* Character, TArray<struct FBombExistData>* BombExistDatas);
	static bool CheckCanLevelup(class ARichmanMgr* InMgr, class ARichman_ChessObject* InChessObject);
	static bool CheckObjectIsBuilding(class ARichmanMgr* InMgr, class ARichman_ChessObject* InGround);
	static int32 GetAllMoveDirs(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround, TArray<int32>* AllCanReachGirds, int32* BackDir);
	static TArray<class ARichmanCharacter*> GetAllSurviveCharacter(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter, bool CanInHospital, bool CanIncludeSelf);
	static TArray<class ARichman_ChessGround*> GetAllSurviveCharacterForwardGround(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter);
	static int32 GetBuildingBuyPrice(class ARichmanMgr* InMgr, int32 InTplId);
	static int32 GetBuildingBuyPriceSrc(class ARichmanMgr* InMgr, int32 InTplId);
	static class FString GetBuildingDescKey(class ARichmanMgr* InMgr, int32 InTplId);
	static int32 GetBuildingLevelUpId(class ARichmanMgr* InMgr, int32 InTplId);
	static int32 GetBuildingLevelUpIdByGround(class ARichmanMgr* InMgr, class AChessGround* InGround);
	static int32 GetBuildingLevelUpPrice(class ARichmanMgr* InMgr, int32 InTplId);
	static class FString GetBuildingNameKey(class ARichmanMgr* InMgr, int32 InTplId);
	static class ARichmanCharacter* GetBuildingOwnerCharacter(class ARichman_BuildingObject* InBuilding);
	static int32 GetBuildingOwnerCharacterTeamId(class ARichman_BuildingObject* InBuilding);
	static int32 GetBuildingTollPrice(class ARichmanMgr* InMgr, int32 InTplId);
	static int32 GetBuildingToMaxLevel(class ARichmanMgr* InMgr, int32 InTplId);
	static int32 GetBuildingTplId(class ARichmanMgr* InMgr, int32 InBaseTplId, int32 InLevel);
	static TArray<class ARichman_BuildingObject*> GetCharacterBuildings(class ARichmanCharacter* InCharacter);
	static int32 GetDiceThrow(int32 Max, int32 Min);
	static int32 GetDropIdFromRandomItemGround(class ARichmanMgr* InMgr, class ARichman_ChessGround* Ground);
	static TArray<class ARichman_BuildingObject*> GetNearbyBuilding(class ARichman_BuildingObject* InBuilding, class ARichmanCharacter* InCharacter);
	static TArray<class ARichman_BuildingObject*> GetNoOwnerBuildings(class ARichmanMgr* InMgr);
	static int32 GetRandomItemIdFromRandomGround(class ARichmanMgr* InMgr, class ARichman_ChessGround* Ground);
	static bool IsBarrierHere(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground);
	static TArray<struct FBombVictimData> IsBomb_item(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, TArray<struct FBombExistData>* BombExistDatas);
	static TArray<struct FBombVictimData> IsBomb_item_Nearest(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, TArray<struct FBombExistData>* BombExistDatas);
	static TArray<struct FBombVictimData> IsBomb_SmallNormal(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, TArray<struct FBombExistData>* BombExistDatas);
	static TArray<struct FBombVictimData> IsBomb_SmallNormal_Nearest(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, TArray<struct FBombExistData>* BombExistDatas);
	static int32 IsCanUseCardtoOccupy(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround, float Rate);
	static bool IsEmptyGround(class ARichmanMgr* InMgr, int32 InTplId);
	static struct FBombVictimData IsExplosiveHere(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground);
	static struct FBombVictimData IslandmineHere(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, bool IsPlayEffect);
	static struct FBombVictimData IsTelephoneHere(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, class ARichman_ChessGround* Ground, bool IsPlayEffect);
	static bool IsTownhouse(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter, class ARichman_BuildingObject* InBuilding);
	static void LandmineisActive(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, const struct FBombVictimData& BombVictimData, ERichmanGameType Gametype);
	static void MissileisActive(class ARichmanMgr* InMgr, class ARichmanCharacter* Character);
	static class ARichmanCharacter* RandomSelectNpc(const TArray<class ARichmanCharacter*>& CanSelectCharacter);
	static void RemoveObjectAndPlayEffect(class ARichmanMgr* InMgr, class ARichman_ChessGround* InGround, EFaceObjectType Type);
	static bool SetSelectWalkDirection(class ARichmanMgr* InMgr, class ARichmanCharacter* InCharacter);
	static TMap<class ARichmanCharacter*, int32> SortCharactersByLengthToBomb(class ARichmanMgr* InMgr, class ARichman_ChessGround* Ground);
	static void TelephoneisActive(class ARichmanMgr* InMgr, class ARichmanCharacter* Character, const struct FBombVictimData& BombVictimData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanLibrary">();
	}
	static class URichmanLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanLibrary>();
	}
};
static_assert(alignof(URichmanLibrary) == 0x000008, "Wrong alignment on URichmanLibrary");
static_assert(sizeof(URichmanLibrary) == 0x000028, "Wrong size on URichmanLibrary");

// Class Richman.RichmanMgr
// 0x0690 (0x08B8 - 0x0228)
class ARichmanMgr final : public AActor
{
public:
	class AChessMapActor*                         ChessMapActor;                                     // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanRoundMgr*                       RoundManager;                                      // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanSave*                           SaveActor;                                         // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichmanGameType                              Gametype;                                          // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARichmanCharacter*>              AllCharacters;                                     // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class ARichmanCameraFollow*                   CameraFollow;                                      // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanGameMode*                       GameMode;                                          // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichmanItemObject*                     CurrentItemObject;                                 // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanGroundSelector*                 GroundSelector;                                    // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnClickRichmanItem;                           // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnUseRichmanItem;                             // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnResetRichmanItem;                           // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AChessObject*                           Hospital;                                          // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AChessGround*                           HospitalStandGround;                               // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AChessGround*                           HospitalGround;                                    // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigDayPriceRise;                                // 0x02C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x14];                                     // 0x02C4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitCardNum;                                       // 0x02D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCardNum;                                        // 0x02DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRound;                                          // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitMoney;                                         // 0x02E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMoney;                                          // 0x02E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameOver;                                        // 0x02EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ArrayRoleId;                                       // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AllGrounds;                                        // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class ARichmanPlayerController*               LocalPlayerController;                             // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cfg_building_buy_multi;                            // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cfg_building_levelup_multi;                        // 0x031C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cfg_building_toll_multi;                           // 0x0320(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cfg_npc_buy_rate;                                  // 0x0324(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cfg_npc_levelup_rate;                              // 0x0328(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x58C];                                    // 0x032C(0x058C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ARichmanCharacter* FindCharacterByUID(int32 Uid);
	void GetAllCharacters(TArray<class ARichmanCharacter*>* InArray);
	void GetAllRichmanActor(TArray<class AChessObject*>* InArray);
	int32 GetInHospitalTime(int32 Times);
	class ARichmanCharacter* GetLocalCharacter();
	void InitMapConfig(int32 InMapId);
	int32 PlayEffectAttachedById(int32 ID, class USceneComponent* AttachToComponent, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	int32 PlayEffectById(int32 ID, const struct FVector& InLocation, const struct FRotator& InRotate, bool IsPersistent);
	void ResetMap();
	void SetCurrentItem(class ARichmanCharacter* InCharacter, int32 InItemUId, int32 InItemTplId);
	void SetFreeModeParam(int32 Money, int32 PriceRise, int32 Round, const TArray<int32>& ArrayRole);
	void StartGame(const class FString& InDlcId, int32 InMapId, int32 InRegionId, const class FString& InSaved, const class FString& InDataPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanMgr">();
	}
	static class ARichmanMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanMgr>();
	}
};
static_assert(alignof(ARichmanMgr) == 0x000008, "Wrong alignment on ARichmanMgr");
static_assert(sizeof(ARichmanMgr) == 0x0008B8, "Wrong size on ARichmanMgr");
static_assert(offsetof(ARichmanMgr, ChessMapActor) == 0x000228, "Member 'ARichmanMgr::ChessMapActor' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, RoundManager) == 0x000230, "Member 'ARichmanMgr::RoundManager' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, SaveActor) == 0x000238, "Member 'ARichmanMgr::SaveActor' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Gametype) == 0x000240, "Member 'ARichmanMgr::Gametype' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, AllCharacters) == 0x000248, "Member 'ARichmanMgr::AllCharacters' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, CameraFollow) == 0x000258, "Member 'ARichmanMgr::CameraFollow' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, GameMode) == 0x000260, "Member 'ARichmanMgr::GameMode' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, CurrentItemObject) == 0x000268, "Member 'ARichmanMgr::CurrentItemObject' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, GroundSelector) == 0x000270, "Member 'ARichmanMgr::GroundSelector' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, EventOnClickRichmanItem) == 0x000278, "Member 'ARichmanMgr::EventOnClickRichmanItem' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, EventOnUseRichmanItem) == 0x000288, "Member 'ARichmanMgr::EventOnUseRichmanItem' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, EventOnResetRichmanItem) == 0x000298, "Member 'ARichmanMgr::EventOnResetRichmanItem' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Hospital) == 0x0002A8, "Member 'ARichmanMgr::Hospital' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, HospitalStandGround) == 0x0002B0, "Member 'ARichmanMgr::HospitalStandGround' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, HospitalGround) == 0x0002B8, "Member 'ARichmanMgr::HospitalGround' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, ConfigDayPriceRise) == 0x0002C0, "Member 'ARichmanMgr::ConfigDayPriceRise' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, InitCardNum) == 0x0002D8, "Member 'ARichmanMgr::InitCardNum' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, MaxCardNum) == 0x0002DC, "Member 'ARichmanMgr::MaxCardNum' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, MaxRound) == 0x0002E0, "Member 'ARichmanMgr::MaxRound' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, InitMoney) == 0x0002E4, "Member 'ARichmanMgr::InitMoney' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, MaxMoney) == 0x0002E8, "Member 'ARichmanMgr::MaxMoney' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, IsGameOver) == 0x0002EC, "Member 'ARichmanMgr::IsGameOver' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, ArrayRoleId) == 0x0002F0, "Member 'ARichmanMgr::ArrayRoleId' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, AllGrounds) == 0x000300, "Member 'ARichmanMgr::AllGrounds' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, LocalPlayerController) == 0x000310, "Member 'ARichmanMgr::LocalPlayerController' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Cfg_building_buy_multi) == 0x000318, "Member 'ARichmanMgr::Cfg_building_buy_multi' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Cfg_building_levelup_multi) == 0x00031C, "Member 'ARichmanMgr::Cfg_building_levelup_multi' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Cfg_building_toll_multi) == 0x000320, "Member 'ARichmanMgr::Cfg_building_toll_multi' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Cfg_npc_buy_rate) == 0x000324, "Member 'ARichmanMgr::Cfg_npc_buy_rate' has a wrong offset!");
static_assert(offsetof(ARichmanMgr, Cfg_npc_levelup_rate) == 0x000328, "Member 'ARichmanMgr::Cfg_npc_levelup_rate' has a wrong offset!");

// Class Richman.RichmanPlayer
// 0x0000 (0x04C0 - 0x04C0)
class ARichmanPlayer final : public ACharacter
{
public:
	class ARichmanMgr*                            RichmanMgr;                                        // 0x04B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanPlayer">();
	}
	static class ARichmanPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanPlayer>();
	}
};
static_assert(alignof(ARichmanPlayer) == 0x000010, "Wrong alignment on ARichmanPlayer");
static_assert(sizeof(ARichmanPlayer) == 0x0004C0, "Wrong size on ARichmanPlayer");
static_assert(offsetof(ARichmanPlayer, RichmanMgr) == 0x0004B8, "Member 'ARichmanPlayer::RichmanMgr' has a wrong offset!");

// Class Richman.RichmanPlayerController
// 0x0018 (0x0590 - 0x0578)
class ARichmanPlayerController final : public APlayerController
{
public:
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0578(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanGameMode*                       GameMode;                                          // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanCharacter*                      CurrentCharacter;                                  // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyBuyLand();
	int32 GetBuyPrice(int32 SrcPrice);
	class AActor* GetClickActor(bool IgnoreGround);
	class ARichmanCharacter* GetCurrentChar();
	int32 GetLevelUpPrice(int32 SrcPrice);
	int32 GetTollPrice(int32 SrcPrice);
	void NotifyLuaStart();
	void OnTouch();
	void SetMoveByMouse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanPlayerController">();
	}
	static class ARichmanPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanPlayerController>();
	}
};
static_assert(alignof(ARichmanPlayerController) == 0x000008, "Wrong alignment on ARichmanPlayerController");
static_assert(sizeof(ARichmanPlayerController) == 0x000590, "Wrong size on ARichmanPlayerController");
static_assert(offsetof(ARichmanPlayerController, RichmanMgr) == 0x000578, "Member 'ARichmanPlayerController::RichmanMgr' has a wrong offset!");
static_assert(offsetof(ARichmanPlayerController, GameMode) == 0x000580, "Member 'ARichmanPlayerController::GameMode' has a wrong offset!");
static_assert(offsetof(ARichmanPlayerController, CurrentCharacter) == 0x000588, "Member 'ARichmanPlayerController::CurrentCharacter' has a wrong offset!");

// Class Richman.RichmanPlayerMovementComponent
// 0x0010 (0x0B10 - 0x0B00)
class URichmanPlayerMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B00[0x10];                                     // 0x0B00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanPlayerMovementComponent">();
	}
	static class URichmanPlayerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichmanPlayerMovementComponent>();
	}
};
static_assert(alignof(URichmanPlayerMovementComponent) == 0x000010, "Wrong alignment on URichmanPlayerMovementComponent");
static_assert(sizeof(URichmanPlayerMovementComponent) == 0x000B10, "Wrong size on URichmanPlayerMovementComponent");

// Class Richman.RichmanRoundMgr
// 0x0158 (0x0380 - 0x0228)
class ARichmanRoundMgr final : public AActor
{
public:
	TArray<class ARichmanCharacter*>              AllPlayer;                                         // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnGameStart;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterEntryRound;                        // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterSelectDirection;                   // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterExitRound;                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterDataChanged;                       // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterMoneyChanged;                      // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnNewDay;                                     // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterMoveEnd;                           // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterFaceObject;                        // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterFaceExplosive;                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterFreeCardConsume;                   // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterTranferCardConsume;                // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterLeaveHospital;                     // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnCharacterStateChanged;                      // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnPlayVoiceDelegate;                          // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnThink;                                      // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PopUpPrompt;                                       // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRichmanGameOver;                                 // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventOnShowUITip;                                  // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ARichmanCharacter*                      CurCharacter;                                      // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            RichmanMgr;                                        // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameOver(ERichmanOverType Type);
	int32 GetCurIndex();
	void GotoNextRound();
	void OnEntryRound(class ARichmanCharacter* InCharacter);
	void OnExitRound(class ARichmanCharacter* InCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanRoundMgr">();
	}
	static class ARichmanRoundMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanRoundMgr>();
	}
};
static_assert(alignof(ARichmanRoundMgr) == 0x000008, "Wrong alignment on ARichmanRoundMgr");
static_assert(sizeof(ARichmanRoundMgr) == 0x000380, "Wrong size on ARichmanRoundMgr");
static_assert(offsetof(ARichmanRoundMgr, AllPlayer) == 0x000228, "Member 'ARichmanRoundMgr::AllPlayer' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnGameStart) == 0x000238, "Member 'ARichmanRoundMgr::EventOnGameStart' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterEntryRound) == 0x000248, "Member 'ARichmanRoundMgr::EventOnCharacterEntryRound' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterSelectDirection) == 0x000258, "Member 'ARichmanRoundMgr::EventOnCharacterSelectDirection' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterExitRound) == 0x000268, "Member 'ARichmanRoundMgr::EventOnCharacterExitRound' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterDataChanged) == 0x000278, "Member 'ARichmanRoundMgr::EventOnCharacterDataChanged' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterMoneyChanged) == 0x000288, "Member 'ARichmanRoundMgr::EventOnCharacterMoneyChanged' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnNewDay) == 0x000298, "Member 'ARichmanRoundMgr::EventOnNewDay' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterMoveEnd) == 0x0002A8, "Member 'ARichmanRoundMgr::EventOnCharacterMoveEnd' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterFaceObject) == 0x0002B8, "Member 'ARichmanRoundMgr::EventOnCharacterFaceObject' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterFaceExplosive) == 0x0002C8, "Member 'ARichmanRoundMgr::EventOnCharacterFaceExplosive' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterFreeCardConsume) == 0x0002D8, "Member 'ARichmanRoundMgr::EventOnCharacterFreeCardConsume' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterTranferCardConsume) == 0x0002E8, "Member 'ARichmanRoundMgr::EventOnCharacterTranferCardConsume' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterLeaveHospital) == 0x0002F8, "Member 'ARichmanRoundMgr::EventOnCharacterLeaveHospital' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnCharacterStateChanged) == 0x000308, "Member 'ARichmanRoundMgr::EventOnCharacterStateChanged' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnPlayVoiceDelegate) == 0x000318, "Member 'ARichmanRoundMgr::EventOnPlayVoiceDelegate' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnThink) == 0x000328, "Member 'ARichmanRoundMgr::EventOnThink' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, PopUpPrompt) == 0x000338, "Member 'ARichmanRoundMgr::PopUpPrompt' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, OnRichmanGameOver) == 0x000348, "Member 'ARichmanRoundMgr::OnRichmanGameOver' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, EventOnShowUITip) == 0x000358, "Member 'ARichmanRoundMgr::EventOnShowUITip' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, CurCharacter) == 0x000368, "Member 'ARichmanRoundMgr::CurCharacter' has a wrong offset!");
static_assert(offsetof(ARichmanRoundMgr, RichmanMgr) == 0x000370, "Member 'ARichmanRoundMgr::RichmanMgr' has a wrong offset!");

// Class Richman.RichmanSave
// 0x0070 (0x0298 - 0x0228)
class ARichmanSave final : public AActor
{
public:
	uint8                                         Pad_228[0x48];                                     // 0x0228(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Day;                                               // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x8];                                      // 0x0274(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x027C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARichmanMgr*                            Mgr;                                               // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddMoney(class ARichmanCharacter* InCharacter, int32 InNum, const class FString& InCostWay);
	int32 AddNpcState(class ARichmanCharacter* InCharacter, ERichmanNpcState InState, int32 InDay);
	int32 ApplyAddItem(class ARichmanCharacter* InCharacter, int32 InItemTplId);
	bool ApplyBuyLand(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround);
	bool ApplyCharacterUseFreeCard(class ARichmanCharacter* InCharacter);
	bool ApplyCharacterUseTranferCard(class ARichmanCharacter* InCharacter, class ARichmanCharacter* TargetCharacter);
	bool ApplyLandLevelUp(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround);
	bool ApplyLandToCharacter(class ARichmanCharacter* InCharacter, const TArray<class ARichman_BuildingObject*>& InBuildings);
	bool ApplyLandToMaxLevel(class ARichmanCharacter* InCharacter, class ARichman_BuildingObject* InBuilding);
	bool ApplyOccupation(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround, float InMoneyRate);
	void ApplyRemoveAllItem(class ARichmanCharacter* InCharacter);
	bool ApplyUseItem(class ARichmanCharacter* InCharacter, int32 InUId);
	void ChangeBuildingOwner(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround);
	bool CheckCharacterHasSpecCard(class ARichmanCharacter* InCharacter, int32 TplId, bool IsComsume, class ARichmanCharacter* TargetCharacter);
	bool CheckNpcMoveable(class ARichmanCharacter* InCharacter);
	void ClearObstaclesOnGridGrounds(class ARichmanCharacter* InCharacter, class ARichman_ChessGround* InGround, bool IsFromRemoveCard);
	void DiscardPopOut(class ARichmanCharacter* InCharacter, int32 InUId);
	bool DynamicAddObjectByCard(const class FString& Cardname, class ARichman_ChessGround* InGround, const TMap<class FString, class FString>& MapParam);
	TArray<class ARichmanCharacter*> FindNearNpc(class ARichmanCharacter* InCharacter, int32 Size);
	int32 GetBuildingLevel(class ARichman_BuildingObject* InBuilding);
	int32 GetBuildingLevelByGround(class ARichman_ChessGround* InGround);
	int32 GetBuildingOwnerId(class ARichman_ChessGround* InGround);
	int32 GetBuildingOwnerTeamIdId(class ARichman_ChessGround* InGround);
	int32 GetBuildingTeamID(class ARichman_BuildingObject* InBuilding);
	int32 GetDay();
	bool GetIsTotalDeath(int32 TeamID);
	int32 GetItemCount(class ARichmanCharacter* InCharacter);
	int32 GetItemTplIdByIndex(class ARichmanCharacter* InCharacter, int32 Index_0);
	int32 GetItemUIdByIndex(class ARichmanCharacter* InCharacter, int32 Index_0);
	int32 GetMoney(int32 InUId);
	int32 GetPrice();
	int32 GetStateLastDay(class ARichmanCharacter* InCharacter, ERichmanNpcState InState);
	bool GetTeamDeath(int32 TeamID);
	int32 GetTeamId(int32 InUId);
	int32 GetTeamMoney(int32 TeamID);
	int32 IsCanUseClearCard(class ARichmanCharacter* InCharacter);
	bool IsCharacterCanAvoidDamage(class ARichmanCharacter* InCharacter);
	int32 IsCharacterCanAvoidFine(class ARichmanCharacter* InCharacter);
	bool LoadSaved(const class FString& InContent);
	bool NpcHasState(class ARichmanCharacter* InCharacter, ERichmanNpcState InState);
	class ARichmanCharacter* RandomSelectNpc(const TArray<class ARichmanCharacter*>& CanStealCharacter);
	void RemoveBuildingByCharacter(class ARichmanCharacter* InCharacter);
	class FString Save();
	int32 StealNpcCard(class ARichmanCharacter* TargetCharacter, class ARichmanCharacter* Selfcharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichmanSave">();
	}
	static class ARichmanSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARichmanSave>();
	}
};
static_assert(alignof(ARichmanSave) == 0x000008, "Wrong alignment on ARichmanSave");
static_assert(sizeof(ARichmanSave) == 0x000298, "Wrong size on ARichmanSave");
static_assert(offsetof(ARichmanSave, Day) == 0x000270, "Member 'ARichmanSave::Day' has a wrong offset!");
static_assert(offsetof(ARichmanSave, Price) == 0x00027C, "Member 'ARichmanSave::Price' has a wrong offset!");
static_assert(offsetof(ARichmanSave, Mgr) == 0x000280, "Member 'ARichmanSave::Mgr' has a wrong offset!");

}


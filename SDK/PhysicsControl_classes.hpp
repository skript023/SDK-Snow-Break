#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PhysicsControl

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsControl_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class PhysicsControl.PhysicsControlComponent
// 0x0080 (0x0280 - 0x0200)
class UPhysicsControlComponent : public USceneComponent
{
public:
	TSoftObjectPtr<class UPhysicsControlAsset>    PhysicsControlAsset;                               // 0x01F8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDistanceThreshold;                         // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportRotationThreshold;                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugVisualization;                           // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisualizationSizeScale;                            // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugControlList;                             // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugControlDetailFilter;                          // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugBodyModifierList;                        // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugBodyModifierDetailFilter;                     // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityPredictionTime;                            // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumControlsOrModifiersPerName;                  // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnAboutInvalidNames;                            // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x17];                                     // 0x0269(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBodyModifiersToSet(struct FPhysicsControlNames* NewSet, const TArray<class FName>& BodyModifiers, const class FName Set);
	void AddBodyModifierToSet(struct FPhysicsControlNames* NewSet, const class FName BodyModifier, const class FName Set);
	void AddControlsToSet(struct FPhysicsControlNames* NewSet, const TArray<class FName>& Controls, const class FName Set);
	void AddControlToSet(struct FPhysicsControlNames* NewSet, const class FName Control, const class FName Set);
	class FName CreateBodyModifier(class UMeshComponent* MeshComponent, const class FName BoneName, const class FName Set, const EPhysicsMovementType MovementType, const ECollisionEnabled CollisionType, const float GravityMultiplier, const float PhysicsBlendWeight, const bool bUseSkeletalAnimation, const bool bUpdateKinematicFromSimulation);
	TMap<class FName, struct FPhysicsControlNames> CreateBodyModifiersFromLimbBones(struct FPhysicsControlNames* AllBodyModifiers, const TMap<class FName, struct FPhysicsControlLimbBones>& LimbBones, const EPhysicsMovementType MovementType, const ECollisionEnabled CollisionType, const float GravityMultiplier, const float PhysicsBlendWeight, const bool bUseSkeletalAnimation, const bool bUpdateKinematicFromSimulation);
	TArray<class FName> CreateBodyModifiersFromSkeletalMeshBelow(class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName, const bool bIncludeSelf, const class FName Set, const EPhysicsMovementType MovementType, const ECollisionEnabled CollisionType, const float GravityMultiplier, const float PhysicsBlendWeight, const bool bUseSkeletalAnimation, const bool bUpdateKinematicFromSimulation);
	class FName CreateControl(class UMeshComponent* ParentMeshComponent, class FName ParentBoneName, class UMeshComponent* ChildMeshComponent, const class FName ChildBoneName, const struct FPhysicsControlData& ControlData, const struct FPhysicsControlTarget& ControlTarget, const struct FPhysicsControlSettings& ControlSettings, class FName Set, const bool bEnabled);
	void CreateControlsAndBodyModifiersFromLimbBones(struct FPhysicsControlNames* AllWorldSpaceControls, TMap<class FName, struct FPhysicsControlNames>* LimbWorldSpaceControls, struct FPhysicsControlNames* AllParentSpaceControls, TMap<class FName, struct FPhysicsControlNames>* LimbParentSpaceControls, struct FPhysicsControlNames* AllBodyModifiers, TMap<class FName, struct FPhysicsControlNames>* LimbBodyModifiers, class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FPhysicsControlLimbSetupData>& LimbSetupData, const struct FPhysicsControlData& WorldSpaceControlData, const struct FPhysicsControlSettings& WorldSpaceControlSettings, const bool bEnableWorldSpaceControls, const struct FPhysicsControlData& ParentSpaceControlData, const struct FPhysicsControlSettings& ParentSpaceControlSettings, const bool bEnableParentSpaceControls, const EPhysicsMovementType PhysicsMovementType, const float GravityMultiplier, const float PhysicsBlendWeight);
	bool CreateControlsAndBodyModifiersFromPhysicsControlAsset(class USkeletalMeshComponent* SkeletalMeshComponent);
	TMap<class FName, struct FPhysicsControlNames> CreateControlsFromLimbBones(struct FPhysicsControlNames* AllControls, const TMap<class FName, struct FPhysicsControlLimbBones>& LimbBones, const EPhysicsControlType ControlType, const struct FPhysicsControlData& ControlData, const struct FPhysicsControlSettings& ControlSettings, const bool bEnabled);
	TMap<class FName, struct FPhysicsControlNames> CreateControlsFromLimbBonesAndConstraintProfile(struct FPhysicsControlNames* AllControls, const TMap<class FName, struct FPhysicsControlLimbBones>& LimbBones, const class FName ConstraintProfile, const bool bEnabled);
	TArray<class FName> CreateControlsFromSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames, const EPhysicsControlType ControlType, const struct FPhysicsControlData& ControlData, const struct FPhysicsControlSettings& ControlSettings, const class FName Set, const bool bEnabled);
	TArray<class FName> CreateControlsFromSkeletalMeshAndConstraintProfile(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames, const class FName ConstraintProfile, const class FName Set, const bool bEnabled);
	TArray<class FName> CreateControlsFromSkeletalMeshAndConstraintProfileBelow(class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName, const bool bIncludeSelf, const class FName ConstraintProfile, const class FName Set, const bool bEnabled);
	TArray<class FName> CreateControlsFromSkeletalMeshBelow(class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName, const bool bIncludeSelf, const EPhysicsControlType ControlType, const struct FPhysicsControlData& ControlData, const struct FPhysicsControlSettings& ControlSettings, const class FName Set, const bool bEnabled);
	bool CreateNamedBodyModifier(const class FName Name_0, class UMeshComponent* MeshComponent, const class FName BoneName, const class FName Set, const EPhysicsMovementType MovementType, const ECollisionEnabled CollisionType, const float GravityMultiplier, const float PhysicsBlendWeight, const bool bUseSkeletalAnimation, const bool bUpdateKinematicFromSimulation);
	bool CreateNamedControl(class FName Name_0, class UMeshComponent* ParentMeshComponent, const class FName ParentBoneName, class UMeshComponent* ChildMeshComponent, const class FName ChildBoneName, const struct FPhysicsControlData& ControlData, const struct FPhysicsControlTarget& ControlTarget, const struct FPhysicsControlSettings& ControlSettings, const class FName Set, const bool bEnabled);
	bool DestroyBodyModifier(const class FName Name_0);
	void DestroyBodyModifiers(const TArray<class FName>& Names);
	void DestroyBodyModifiersInSet(const class FName Set);
	bool DestroyControl(const class FName Name_0);
	void DestroyControls(const TArray<class FName>& Names);
	void DestroyControlsInSet(const class FName Set);
	void DestroyRecords();
	TArray<struct FVector> GetCachedBoneAngularVelocities(const class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames);
	struct FVector GetCachedBoneAngularVelocity(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName);
	struct FRotator GetCachedBoneOrientation(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName);
	TArray<struct FRotator> GetCachedBoneOrientations(const class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames);
	struct FVector GetCachedBonePosition(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName);
	TArray<struct FVector> GetCachedBonePositions(const class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames);
	struct FTransform GetCachedBoneTransform(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName);
	TArray<struct FTransform> GetCachedBoneTransforms(const class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames);
	TArray<struct FVector> GetCachedBoneVelocities(const class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class FName>& BoneNames);
	struct FVector GetCachedBoneVelocity(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName);
	bool InvokeControlProfile(class FName ProfileName);
	void ResetBodyModifiersInSetToCachedBoneTransforms(const class FName SetName, const EResetToCachedTargetBehavior Behavior);
	void ResetBodyModifiersToCachedBoneTransforms(const TArray<class FName>& Names, const EResetToCachedTargetBehavior Behavior);
	bool ResetBodyModifierToCachedBoneTransform(const class FName Name_0, const EResetToCachedTargetBehavior Behavior);
	bool ResetControlPoint(const class FName Name_0);
	bool SetBodyModifierCollisionType(const class FName Name_0, const ECollisionEnabled CollisionType);
	bool SetBodyModifierGravityMultiplier(const class FName Name_0, const float GravityMultiplier);
	bool SetBodyModifierKinematicTarget(const class FName Name_0, const struct FVector& KinematicTargetPosition, const struct FRotator& KinematicTargetOrienation, const bool bMakeKinematic);
	bool SetBodyModifierMovementType(const class FName Name_0, const EPhysicsMovementType MovementType);
	bool SetBodyModifierPhysicsBlendWeight(const class FName Name_0, const float PhysicsBlendWeight);
	void SetBodyModifiersCollisionType(const TArray<class FName>& Names, const ECollisionEnabled CollisionType);
	void SetBodyModifiersGravityMultiplier(const TArray<class FName>& Names, const float GravityMultiplier);
	void SetBodyModifiersInSetCollisionType(const class FName Set, const ECollisionEnabled CollisionType);
	void SetBodyModifiersInSetGravityMultiplier(const class FName Set, const float GravityMultiplier);
	void SetBodyModifiersInSetMovementType(const class FName Set, const EPhysicsMovementType MovementType);
	void SetBodyModifiersInSetPhysicsBlendWeight(const class FName Set, const float PhysicsBlendWeight);
	void SetBodyModifiersInSetUpdateKinematicFromSimulation(const class FName Set, const bool bUpdateKinematicFromSimulation);
	void SetBodyModifiersInSetUseSkeletalAnimation(const class FName Set, const bool bUseSkeletalAnimation);
	void SetBodyModifiersMovementType(const TArray<class FName>& Names, const EPhysicsMovementType MovementType);
	void SetBodyModifiersPhysicsBlendWeight(const TArray<class FName>& Names, const float PhysicsBlendWeight);
	void SetBodyModifiersUpdateKinematicFromSimulation(const TArray<class FName>& Names, const bool bUpdateKinematicFromSimulation);
	void SetBodyModifiersUseSkeletalAnimation(const TArray<class FName>& Names, const bool bUseSkeletalAnimation);
	bool SetBodyModifierUpdateKinematicFromSimulation(const class FName Name_0, const bool bUpdateKinematicFromSimulation);
	bool SetBodyModifierUseSkeletalAnimation(const class FName Name_0, const bool bUseSkeletalAnimation);
	bool SetCachedBoneData(const class USkeletalMeshComponent* SkeletalMeshComponent, const class FName BoneName, const struct FTransform& TM, const struct FVector& Velocity, const struct FVector& AngularVelocity);
	bool SetControlAngularData(const class FName Name_0, const float Strength, const float DampingRatio, const float ExtraDamping, const float MaxTorque, const bool bEnableControl);
	bool SetControlAutoDisable(const class FName Name_0, const bool bAutoDisable);
	bool SetControlData(const class FName Name_0, const struct FPhysicsControlData& ControlData, const bool bEnableControl);
	void SetControlDatas(const TArray<class FName>& Names, const struct FPhysicsControlData& ControlData, const bool bEnableControl);
	void SetControlDatasInSet(const class FName Set, const struct FPhysicsControlData& ControlData, const bool bEnableControl);
	bool SetControlDisableCollision(const class FName Name_0, const bool bDisableCollision);
	bool SetControlEnabled(const class FName Name_0, const bool bEnable);
	bool SetControlLinearData(const class FName Name_0, const float Strength, const float DampingRatio, const float ExtraDamping, const float MaxForce, const bool bEnableControl);
	bool SetControlMultiplier(const class FName Name_0, const struct FPhysicsControlMultiplier& ControlMultiplier, const bool bEnableControl);
	void SetControlMultipliers(const TArray<class FName>& Names, const struct FPhysicsControlMultiplier& ControlMultiplier, const bool bEnableControl);
	void SetControlMultipliersInSet(const class FName Set, const struct FPhysicsControlMultiplier& ControlMultiplier, const bool bEnableControl);
	bool SetControlPoint(const class FName Name_0, const struct FVector& Position);
	void SetControlsAutoDisable(const TArray<class FName>& Names, const bool bAutoDisable);
	void SetControlsDisableCollision(const TArray<class FName>& Names, const bool bDisableCollision);
	void SetControlsEnabled(const TArray<class FName>& Names, const bool bEnable);
	void SetControlsInSetAutoDisable(const class FName Set, const bool bAutoDisable);
	void SetControlsInSetDisableCollision(const class FName Set, const bool bDisableCollision);
	void SetControlsInSetEnabled(const class FName Set, const bool bEnable);
	void SetControlsInSetUseSkeletalAnimation(const class FName Set, const bool bUseSkeletalAnimation, const float SkeletalAnimationVelocityMultiplier);
	void SetControlsUseSkeletalAnimation(const TArray<class FName>& Names, const bool bUseSkeletalAnimation, const float SkeletalAnimationVelocityMultiplier);
	bool SetControlTarget(const class FName Name_0, const struct FPhysicsControlTarget& ControlTarget, const bool bEnableControl);
	bool SetControlTargetOrientation(const class FName Name_0, const struct FRotator& Orientation, const float AngularVelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetOrientations(const TArray<class FName>& Names, const struct FRotator& Orientation, const float AngularVelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	bool SetControlTargetOrientationsFromArray(const TArray<class FName>& Names, const TArray<struct FRotator>& Orientations, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetOrientationsInSet(const class FName SetName, const struct FRotator& Orientation, const float AngularVelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	bool SetControlTargetPoses(const class FName Name_0, const struct FVector& ParentPosition, const struct FRotator& ParentOrientation, const struct FVector& ChildPosition, const struct FRotator& ChildOrientation, const float VelocityDeltaTime, const bool bEnableControl);
	bool SetControlTargetPosition(const class FName Name_0, const struct FVector& Position, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	bool SetControlTargetPositionAndOrientation(const class FName Name_0, const struct FVector& Position, const struct FRotator& Orientation, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetPositions(const TArray<class FName>& Names, const struct FVector& Position, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetPositionsAndOrientations(const TArray<class FName>& Names, const struct FVector& Position, const struct FRotator& Orientation, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	bool SetControlTargetPositionsAndOrientationsFromArray(const TArray<class FName>& Names, const TArray<struct FVector>& Positions, const TArray<struct FRotator>& Orientations, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetPositionsAndOrientationsInSet(const class FName SetName, const struct FVector& Position, const struct FRotator& Orientation, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	bool SetControlTargetPositionsFromArray(const TArray<class FName>& Names, const TArray<struct FVector>& Positions, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargetPositionsInSet(const class FName SetName, const struct FVector& Position, const float VelocityDeltaTime, const bool bEnableControl, const bool bApplyControlPointToTarget);
	void SetControlTargets(const TArray<class FName>& Names, const struct FPhysicsControlTarget& ControlTarget, const bool bEnableControl);
	void SetControlTargetsInSet(const class FName Set, const struct FPhysicsControlTarget& ControlTarget, const bool bEnableControl);
	bool SetControlUseSkeletalAnimation(const class FName Name_0, const bool bUseSkeletalAnimation, const float SkeletalAnimationVelocityMultiplier);
	void UpdateControls(float DeltaTime);
	void UpdateTargetCaches(float DeltaTime);

	const TArray<class FName> GetAllBodyModifierNames() const;
	const TArray<class FName> GetAllControlNames() const;
	const TArray<class FName> GetBodyModifierNamesInSet(const class FName Set) const;
	bool GetControlAutoDisable(const class FName Name_0) const;
	bool GetControlData(const class FName Name_0, struct FPhysicsControlData* ControlData) const;
	bool GetControlEnabled(const class FName Name_0) const;
	bool GetControlMultiplier(const class FName Name_0, struct FPhysicsControlMultiplier* ControlMultiplier) const;
	const TArray<class FName> GetControlNamesInSet(const class FName Set) const;
	bool GetControlTarget(const class FName Name_0, struct FPhysicsControlTarget* ControlTarget) const;
	TMap<class FName, struct FPhysicsControlLimbBones> GetLimbBonesFromSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FPhysicsControlLimbSetupData>& LimbSetupData) const;
	TArray<class FName> GetSetsContainingBodyModifier(const class FName Control) const;
	TArray<class FName> GetSetsContainingControl(const class FName Control) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlComponent">();
	}
	static class UPhysicsControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlComponent>();
	}
};
static_assert(alignof(UPhysicsControlComponent) == 0x000010, "Wrong alignment on UPhysicsControlComponent");
static_assert(sizeof(UPhysicsControlComponent) == 0x000280, "Wrong size on UPhysicsControlComponent");
static_assert(offsetof(UPhysicsControlComponent, PhysicsControlAsset) == 0x0001F8, "Member 'UPhysicsControlComponent::PhysicsControlAsset' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, TeleportDistanceThreshold) == 0x000220, "Member 'UPhysicsControlComponent::TeleportDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, TeleportRotationThreshold) == 0x000224, "Member 'UPhysicsControlComponent::TeleportRotationThreshold' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, bShowDebugVisualization) == 0x000228, "Member 'UPhysicsControlComponent::bShowDebugVisualization' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, VisualizationSizeScale) == 0x00022C, "Member 'UPhysicsControlComponent::VisualizationSizeScale' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, bShowDebugControlList) == 0x000230, "Member 'UPhysicsControlComponent::bShowDebugControlList' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, DebugControlDetailFilter) == 0x000238, "Member 'UPhysicsControlComponent::DebugControlDetailFilter' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, bShowDebugBodyModifierList) == 0x000248, "Member 'UPhysicsControlComponent::bShowDebugBodyModifierList' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, DebugBodyModifierDetailFilter) == 0x000250, "Member 'UPhysicsControlComponent::DebugBodyModifierDetailFilter' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, VelocityPredictionTime) == 0x000260, "Member 'UPhysicsControlComponent::VelocityPredictionTime' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, MaxNumControlsOrModifiersPerName) == 0x000264, "Member 'UPhysicsControlComponent::MaxNumControlsOrModifiersPerName' has a wrong offset!");
static_assert(offsetof(UPhysicsControlComponent, bWarnAboutInvalidNames) == 0x000268, "Member 'UPhysicsControlComponent::bWarnAboutInvalidNames' has a wrong offset!");

// Class PhysicsControl.PhysControlDataProcessorInterface
// 0x0010 (0x0038 - 0x0028)
class UPhysControlDataProcessorInterface : public UObject
{
public:
	bool                                          bIsWorldSpace;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsControlComponent*               ProcessorOwner;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EndProcessor();
	void StartProcessor(class UPhysicsControlComponent* PhysicsControlComponent);
	void TickPhysControlData(struct FControlUpdateData* UpdateData, const struct FPhysicsControlContextData& ControlData, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlDataProcessorInterface">();
	}
	static class UPhysControlDataProcessorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlDataProcessorInterface>();
	}
};
static_assert(alignof(UPhysControlDataProcessorInterface) == 0x000008, "Wrong alignment on UPhysControlDataProcessorInterface");
static_assert(sizeof(UPhysControlDataProcessorInterface) == 0x000038, "Wrong size on UPhysControlDataProcessorInterface");
static_assert(offsetof(UPhysControlDataProcessorInterface, bIsWorldSpace) == 0x000028, "Member 'UPhysControlDataProcessorInterface::bIsWorldSpace' has a wrong offset!");
static_assert(offsetof(UPhysControlDataProcessorInterface, ProcessorOwner) == 0x000030, "Member 'UPhysControlDataProcessorInterface::ProcessorOwner' has a wrong offset!");

// Class PhysicsControl.PhysControlDataProcessorBase
// 0x00A8 (0x00E0 - 0x0038)
class UPhysControlDataProcessorBase : public UPhysControlDataProcessorInterface
{
public:
	TSet<class FName>                             ControlSetName;                                    // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSet<EPhysUpdateParamType>                    ParamSet;                                          // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	EPhysicsControlUpdateApplyType                ApplyType;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlDataProcessorBase">();
	}
	static class UPhysControlDataProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlDataProcessorBase>();
	}
};
static_assert(alignof(UPhysControlDataProcessorBase) == 0x000008, "Wrong alignment on UPhysControlDataProcessorBase");
static_assert(sizeof(UPhysControlDataProcessorBase) == 0x0000E0, "Wrong size on UPhysControlDataProcessorBase");
static_assert(offsetof(UPhysControlDataProcessorBase, ControlSetName) == 0x000038, "Member 'UPhysControlDataProcessorBase::ControlSetName' has a wrong offset!");
static_assert(offsetof(UPhysControlDataProcessorBase, ParamSet) == 0x000088, "Member 'UPhysControlDataProcessorBase::ParamSet' has a wrong offset!");
static_assert(offsetof(UPhysControlDataProcessorBase, ApplyType) == 0x0000D8, "Member 'UPhysControlDataProcessorBase::ApplyType' has a wrong offset!");

// Class PhysicsControl.BaseGamePhysicsControlComponent
// 0x01B0 (0x0430 - 0x0280)
class UBaseGamePhysicsControlComponent : public UPhysicsControlComponent
{
public:
	class UPhysicsControlDataAsset*               PhysicsControlDataAsset;                           // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UBasePhysControlsDataUpdateAsset*> ProcessorAssets;                                   // 0x0288(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAnimNodePhysics;                                // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPhysControlDataProcessorInterface*> ResidentProcessors;                                // 0x02E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UPhysControlSingleUseProcessorInterface*> SingleUseProcessors;                               // 0x02F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           PendingControlProfiles;                            // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           PendingConstraintProfiles;                         // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bControlDirty : 1;                                 // 0x0328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_329[0x107];                                    // 0x0329(0x0107)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddControlUpdateProcessor(class UBasePhysControlsDataUpdateAsset* ProcessorAsset);
	void AddRigidBodyGrabUpdateData(const struct FRigidBodyGrabUpdateData& UpdateData);
	void AnimNode_SetControlModifierParamters(const struct FPhysicsControlNamedModifierParameters& ModifierUpdate, bool bOverride);
	void AnimNode_SetControlParameters(const struct FPhysicsControlNamedControlParameters& ControlUpdate, bool bOverride);
	bool ConditionalCreateAdditionalControl(class FName Name_0, class UMeshComponent* ParentMeshComponent, const class FName ParentBoneName, class UMeshComponent* ChildMeshComponent, const class FName ChildBoneName, const class FName Set, const class FName AdditionalSetName);
	bool ConditionalDestroyControl(const class FName Name_0);
	void ConditionalDestroyControlsInSet(const class FName Set);
	bool ConditionalResetControlPoint(const class FName SetName);
	void ConditionalSetBodyModifiersPhysicsBlendWeight(const class FName SetName, const float PhysicsBlendWeight);
	void ConditionalSetBodyModifiersPhysicsBlendWeightAndMovementType(const class FName SetName, const float PhysicsBlendWeight, const EPhysicsMovementType MovementType);
	bool ConditionalSetControlPoint(const class FName SetName, const struct FVector& Position);
	bool ConditionalSetControlsUseSkeletalAnimation(const class FName SetName, const bool bUseSkeletalAnimation, const float SkeletalAnimationVelocityMultiplier);
	bool ConditionalSetControlTarget(const class FName Name_0, const struct FPhysicsControlTarget& ControlTarget);
	void InitPhysicsControl();
	void InitPhysicsControlProcessor();
	void OnOwnerMeshPhysicsCreated();
	void SetConstraintProfileForAll(class FName ProfileName);
	void SetOverridePhysicsAsset(class UPhysicsAsset* InAsset, bool bForceReInit);
	void SetOverridePhysicsControlAsset(class UPhysicsControlAsset* InAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGamePhysicsControlComponent">();
	}
	static class UBaseGamePhysicsControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGamePhysicsControlComponent>();
	}
};
static_assert(alignof(UBaseGamePhysicsControlComponent) == 0x000010, "Wrong alignment on UBaseGamePhysicsControlComponent");
static_assert(sizeof(UBaseGamePhysicsControlComponent) == 0x000430, "Wrong size on UBaseGamePhysicsControlComponent");
static_assert(offsetof(UBaseGamePhysicsControlComponent, PhysicsControlDataAsset) == 0x000280, "Member 'UBaseGamePhysicsControlComponent::PhysicsControlDataAsset' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, ProcessorAssets) == 0x000288, "Member 'UBaseGamePhysicsControlComponent::ProcessorAssets' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, bIsAnimNodePhysics) == 0x0002D8, "Member 'UBaseGamePhysicsControlComponent::bIsAnimNodePhysics' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, OwnerMesh) == 0x0002E0, "Member 'UBaseGamePhysicsControlComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, ResidentProcessors) == 0x0002E8, "Member 'UBaseGamePhysicsControlComponent::ResidentProcessors' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, SingleUseProcessors) == 0x0002F8, "Member 'UBaseGamePhysicsControlComponent::SingleUseProcessors' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, PendingControlProfiles) == 0x000308, "Member 'UBaseGamePhysicsControlComponent::PendingControlProfiles' has a wrong offset!");
static_assert(offsetof(UBaseGamePhysicsControlComponent, PendingConstraintProfiles) == 0x000318, "Member 'UBaseGamePhysicsControlComponent::PendingConstraintProfiles' has a wrong offset!");

// Class PhysicsControl.AnimRigidBodyControlDataSource
// 0x0000 (0x0028 - 0x0028)
class IAnimRigidBodyControlDataSource final : public IInterface
{
public:
	void AnimNode_SetModifierMovementType(const class FName& ModifierName, EPhysicsMovementType MovementType);
	void GetAdditionalControlData(TArray<struct FAdditionalControlUpdateData>* ControlUpdateDatas);
	void GetAnimNodeAddForce(TMap<class FName, struct FVector>* ForceMap);
	void GetAnimNodeControlCreateData(struct FAnimRigidBodyControlCreationData* RigidBodyData);
	void GetAnimNodeControlUpdateData(struct FRigidBodyKinematicTargets* KinematicTarget, struct FRigidBodyControlTargets* InControlTargets, struct FPhysicsControlControlAndModifierUpdates* ControlUpdates, TArray<class FName>* InControlAndModifierProfiles, TArray<class FName>* InConstraintProfiles);
	void GetRigidBodyGrabUpdateData(TArray<struct FRigidBodyGrabUpdateData>* GrabUpdateDatas);

	bool GetIsEnableAnimNodeControl(const class USkeletalMeshComponent* InOwnerMesh) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimRigidBodyControlDataSource">();
	}
	static class IAnimRigidBodyControlDataSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimRigidBodyControlDataSource>();
	}
};
static_assert(alignof(IAnimRigidBodyControlDataSource) == 0x000008, "Wrong alignment on IAnimRigidBodyControlDataSource");
static_assert(sizeof(IAnimRigidBodyControlDataSource) == 0x000028, "Wrong size on IAnimRigidBodyControlDataSource");

// Class PhysicsControl.PhysicsControlDataAsset
// 0x0178 (0x01A8 - 0x0030)
class UPhysicsControlDataAsset final : public UDataAsset
{
public:
	TSoftObjectPtr<class UPhysicsAsset>           DefaultPhysicsAsset;                               // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsControlLimbSetupData>   LimbSetupData;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlData                    WorldSpaceControlData;                             // 0x0068(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                WorldSpaceControlSettings;                         // 0x0088(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlData                    ParentSpaceControlData;                            // 0x00A0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                ParentSpaceControlSettings;                        // 0x00C0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldSpaceControls;                         // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableParentSpaceControls;                        // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityMultiplier;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPhysicsControlNames> ControlSets;                                       // 0x00E8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPhysicsControlNames> BodyModifiersSets;                                 // 0x0138(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSetCustomControlDatas>         CustomControlDataInSet;                            // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSetMovementDatas>              MovementTypesInSet;                                // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlDataAsset">();
	}
	static class UPhysicsControlDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlDataAsset>();
	}
};
static_assert(alignof(UPhysicsControlDataAsset) == 0x000008, "Wrong alignment on UPhysicsControlDataAsset");
static_assert(sizeof(UPhysicsControlDataAsset) == 0x0001A8, "Wrong size on UPhysicsControlDataAsset");
static_assert(offsetof(UPhysicsControlDataAsset, DefaultPhysicsAsset) == 0x000030, "Member 'UPhysicsControlDataAsset::DefaultPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, LimbSetupData) == 0x000058, "Member 'UPhysicsControlDataAsset::LimbSetupData' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, WorldSpaceControlData) == 0x000068, "Member 'UPhysicsControlDataAsset::WorldSpaceControlData' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, WorldSpaceControlSettings) == 0x000088, "Member 'UPhysicsControlDataAsset::WorldSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, ParentSpaceControlData) == 0x0000A0, "Member 'UPhysicsControlDataAsset::ParentSpaceControlData' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, ParentSpaceControlSettings) == 0x0000C0, "Member 'UPhysicsControlDataAsset::ParentSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, bEnableWorldSpaceControls) == 0x0000D8, "Member 'UPhysicsControlDataAsset::bEnableWorldSpaceControls' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, bEnableParentSpaceControls) == 0x0000D9, "Member 'UPhysicsControlDataAsset::bEnableParentSpaceControls' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, GravityMultiplier) == 0x0000DC, "Member 'UPhysicsControlDataAsset::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, PhysicsBlendWeight) == 0x0000E0, "Member 'UPhysicsControlDataAsset::PhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, ControlSets) == 0x0000E8, "Member 'UPhysicsControlDataAsset::ControlSets' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, BodyModifiersSets) == 0x000138, "Member 'UPhysicsControlDataAsset::BodyModifiersSets' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, CustomControlDataInSet) == 0x000188, "Member 'UPhysicsControlDataAsset::CustomControlDataInSet' has a wrong offset!");
static_assert(offsetof(UPhysicsControlDataAsset, MovementTypesInSet) == 0x000198, "Member 'UPhysicsControlDataAsset::MovementTypesInSet' has a wrong offset!");

// Class PhysicsControl.BasePhysControlsDataUpdateAsset
// 0x0008 (0x0038 - 0x0030)
class UBasePhysControlsDataUpdateAsset final : public UDataAsset
{
public:
	class UPhysControlDataProcessorInterface*     Processor;                                         // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePhysControlsDataUpdateAsset">();
	}
	static class UBasePhysControlsDataUpdateAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePhysControlsDataUpdateAsset>();
	}
};
static_assert(alignof(UBasePhysControlsDataUpdateAsset) == 0x000008, "Wrong alignment on UBasePhysControlsDataUpdateAsset");
static_assert(sizeof(UBasePhysControlsDataUpdateAsset) == 0x000038, "Wrong size on UBasePhysControlsDataUpdateAsset");
static_assert(offsetof(UBasePhysControlsDataUpdateAsset, Processor) == 0x000030, "Member 'UBasePhysControlsDataUpdateAsset::Processor' has a wrong offset!");

// Class PhysicsControl.PhysControlSingleUseProcessorInterface
// 0x0008 (0x0040 - 0x0038)
class UPhysControlSingleUseProcessorInterface : public UPhysControlDataProcessorInterface
{
public:
	float                                         ApplyTime;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDuration(float Duration);

	bool IsExpired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlSingleUseProcessorInterface">();
	}
	static class UPhysControlSingleUseProcessorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlSingleUseProcessorInterface>();
	}
};
static_assert(alignof(UPhysControlSingleUseProcessorInterface) == 0x000008, "Wrong alignment on UPhysControlSingleUseProcessorInterface");
static_assert(sizeof(UPhysControlSingleUseProcessorInterface) == 0x000040, "Wrong size on UPhysControlSingleUseProcessorInterface");
static_assert(offsetof(UPhysControlSingleUseProcessorInterface, ApplyTime) == 0x000038, "Member 'UPhysControlSingleUseProcessorInterface::ApplyTime' has a wrong offset!");

// Class PhysicsControl.PhysControlSingleUseProcessorBase
// 0x00A8 (0x00E8 - 0x0040)
class UPhysControlSingleUseProcessorBase : public UPhysControlSingleUseProcessorInterface
{
public:
	TSet<class FName>                             ControlSetName;                                    // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSet<EPhysUpdateParamType>                    ParamSet;                                          // 0x0090(0x0050)(Edit, NativeAccessSpecifierPublic)
	EPhysicsControlUpdateApplyType                ApplyType;                                         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlSingleUseProcessorBase">();
	}
	static class UPhysControlSingleUseProcessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlSingleUseProcessorBase>();
	}
};
static_assert(alignof(UPhysControlSingleUseProcessorBase) == 0x000008, "Wrong alignment on UPhysControlSingleUseProcessorBase");
static_assert(sizeof(UPhysControlSingleUseProcessorBase) == 0x0000E8, "Wrong size on UPhysControlSingleUseProcessorBase");
static_assert(offsetof(UPhysControlSingleUseProcessorBase, ControlSetName) == 0x000040, "Member 'UPhysControlSingleUseProcessorBase::ControlSetName' has a wrong offset!");
static_assert(offsetof(UPhysControlSingleUseProcessorBase, ParamSet) == 0x000090, "Member 'UPhysControlSingleUseProcessorBase::ParamSet' has a wrong offset!");
static_assert(offsetof(UPhysControlSingleUseProcessorBase, ApplyType) == 0x0000E0, "Member 'UPhysControlSingleUseProcessorBase::ApplyType' has a wrong offset!");

// Class PhysicsControl.PhysControlStandaloneAnimCurveProcessor
// 0x0018 (0x0100 - 0x00E8)
class UPhysControlStandaloneAnimCurveProcessor final : public UPhysControlSingleUseProcessorBase
{
public:
	class FString                                 AnimCurveSuffix;                                   // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CuveValueOffset;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlStandaloneAnimCurveProcessor">();
	}
	static class UPhysControlStandaloneAnimCurveProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlStandaloneAnimCurveProcessor>();
	}
};
static_assert(alignof(UPhysControlStandaloneAnimCurveProcessor) == 0x000008, "Wrong alignment on UPhysControlStandaloneAnimCurveProcessor");
static_assert(sizeof(UPhysControlStandaloneAnimCurveProcessor) == 0x000100, "Wrong size on UPhysControlStandaloneAnimCurveProcessor");
static_assert(offsetof(UPhysControlStandaloneAnimCurveProcessor, AnimCurveSuffix) == 0x0000E8, "Member 'UPhysControlStandaloneAnimCurveProcessor::AnimCurveSuffix' has a wrong offset!");
static_assert(offsetof(UPhysControlStandaloneAnimCurveProcessor, CuveValueOffset) == 0x0000F8, "Member 'UPhysControlStandaloneAnimCurveProcessor::CuveValueOffset' has a wrong offset!");

// Class PhysicsControl.PhysControlDurationDisableProcessor
// 0x0010 (0x0050 - 0x0040)
class UPhysControlDurationDisableProcessor final : public UPhysControlSingleUseProcessorInterface
{
public:
	TArray<class FName>                           ApplyNames;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysControlDurationDisableProcessor">();
	}
	static class UPhysControlDurationDisableProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysControlDurationDisableProcessor>();
	}
};
static_assert(alignof(UPhysControlDurationDisableProcessor) == 0x000008, "Wrong alignment on UPhysControlDurationDisableProcessor");
static_assert(sizeof(UPhysControlDurationDisableProcessor) == 0x000050, "Wrong size on UPhysControlDurationDisableProcessor");
static_assert(offsetof(UPhysControlDurationDisableProcessor, ApplyNames) == 0x000040, "Member 'UPhysControlDurationDisableProcessor::ApplyNames' has a wrong offset!");

// Class PhysicsControl.BasePhysicsControlActorInterface
// 0x0000 (0x0028 - 0x0028)
class IBasePhysicsControlActorInterface final : public IInterface
{
public:
	class USkeletalMeshComponent* GetOwnerMesh(class UBaseGamePhysicsControlComponent* InComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePhysicsControlActorInterface">();
	}
	static class IBasePhysicsControlActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBasePhysicsControlActorInterface>();
	}
};
static_assert(alignof(IBasePhysicsControlActorInterface) == 0x000008, "Wrong alignment on IBasePhysicsControlActorInterface");
static_assert(sizeof(IBasePhysicsControlActorInterface) == 0x000028, "Wrong size on IBasePhysicsControlActorInterface");

// Class PhysicsControl.PhysicsControlInitializerComponent
// 0x0140 (0x0340 - 0x0200)
class UPhysicsControlInitializerComponent final : public USceneComponent
{
public:
	struct FInitialCharacterControls              InitialCharacterControls;                          // 0x01F8(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInitialPhysicsControl> InitialControls;                                   // 0x0290(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInitialBodyModifier> InitialBodyModifiers;                              // 0x02E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCreateControlsAtBeginPlay;                        // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0xF];                                      // 0x0331(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateControls(class UPhysicsControlComponent* PhysicsControlComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlInitializerComponent">();
	}
	static class UPhysicsControlInitializerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlInitializerComponent>();
	}
};
static_assert(alignof(UPhysicsControlInitializerComponent) == 0x000010, "Wrong alignment on UPhysicsControlInitializerComponent");
static_assert(sizeof(UPhysicsControlInitializerComponent) == 0x000340, "Wrong size on UPhysicsControlInitializerComponent");
static_assert(offsetof(UPhysicsControlInitializerComponent, InitialCharacterControls) == 0x0001F8, "Member 'UPhysicsControlInitializerComponent::InitialCharacterControls' has a wrong offset!");
static_assert(offsetof(UPhysicsControlInitializerComponent, InitialControls) == 0x000290, "Member 'UPhysicsControlInitializerComponent::InitialControls' has a wrong offset!");
static_assert(offsetof(UPhysicsControlInitializerComponent, InitialBodyModifiers) == 0x0002E0, "Member 'UPhysicsControlInitializerComponent::InitialBodyModifiers' has a wrong offset!");
static_assert(offsetof(UPhysicsControlInitializerComponent, bCreateControlsAtBeginPlay) == 0x000330, "Member 'UPhysicsControlInitializerComponent::bCreateControlsAtBeginPlay' has a wrong offset!");

// Class PhysicsControl.PhysicsControlActor
// 0x0010 (0x0238 - 0x0228)
class APhysicsControlActor final : public AActor
{
public:
	class UPhysicsControlComponent*               ControlComponent;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsControlInitializerComponent*    ControlInitializerComponent;                       // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlActor">();
	}
	static class APhysicsControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsControlActor>();
	}
};
static_assert(alignof(APhysicsControlActor) == 0x000008, "Wrong alignment on APhysicsControlActor");
static_assert(sizeof(APhysicsControlActor) == 0x000238, "Wrong size on APhysicsControlActor");
static_assert(offsetof(APhysicsControlActor, ControlComponent) == 0x000228, "Member 'APhysicsControlActor::ControlComponent' has a wrong offset!");
static_assert(offsetof(APhysicsControlActor, ControlInitializerComponent) == 0x000230, "Member 'APhysicsControlActor::ControlInitializerComponent' has a wrong offset!");

// Class PhysicsControl.PhysicsControlAsset
// 0x0120 (0x0148 - 0x0028)
class UPhysicsControlAsset final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicsControlCharacterSetupData      CharacterSetupData;                                // 0x0030(0x0098)(NativeAccessSpecifierPublic)
	struct FPhysicsControlSetUpdates              AdditionalSets;                                    // 0x00C8(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FPhysicsControlControlAndModifierUpdates> InitialControlAndModifierUpdates;                  // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FPhysicsControlControlAndModifierUpdates> Profiles;                                          // 0x00F8(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlAsset">();
	}
	static class UPhysicsControlAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlAsset>();
	}
};
static_assert(alignof(UPhysicsControlAsset) == 0x000008, "Wrong alignment on UPhysicsControlAsset");
static_assert(sizeof(UPhysicsControlAsset) == 0x000148, "Wrong size on UPhysicsControlAsset");
static_assert(offsetof(UPhysicsControlAsset, CharacterSetupData) == 0x000030, "Member 'UPhysicsControlAsset::CharacterSetupData' has a wrong offset!");
static_assert(offsetof(UPhysicsControlAsset, AdditionalSets) == 0x0000C8, "Member 'UPhysicsControlAsset::AdditionalSets' has a wrong offset!");
static_assert(offsetof(UPhysicsControlAsset, InitialControlAndModifierUpdates) == 0x0000E8, "Member 'UPhysicsControlAsset::InitialControlAndModifierUpdates' has a wrong offset!");
static_assert(offsetof(UPhysicsControlAsset, Profiles) == 0x0000F8, "Member 'UPhysicsControlAsset::Profiles' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterInteraction

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CharacterInteraction_structs.hpp"
#include "SeasunAnimGraph_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PhysicsControl_structs.hpp"


namespace SDK
{

// Class CharacterInteraction.InteractionArchivementComponent
// 0x0038 (0x00E8 - 0x00B0)
class UInteractionArchivementComponent final : public UActorComponent
{
public:
	TArray<int32>                                 CompleteConditions;                                // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 CompleteArchivements;                              // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 PlayedArchivements;                                // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             ArchivementDataTable;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetEggLevelSeqs(TArray<class ULevelSequence*>* OutLevelSeqs);
	void SetArchievementPlayed(int32 ID);
	void SetArchivementComplete(int32 ID);
	void SetConditionComplete(int32 ID);
	void SetConditionCompleteAdnRefresh(int32 ID);

	bool IsArchivementComplete(int32 ID) const;
	bool IsArchivementPlayed(int32 ID) const;
	bool IsConditionComplete(int32 ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionArchivementComponent">();
	}
	static class UInteractionArchivementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionArchivementComponent>();
	}
};
static_assert(alignof(UInteractionArchivementComponent) == 0x000008, "Wrong alignment on UInteractionArchivementComponent");
static_assert(sizeof(UInteractionArchivementComponent) == 0x0000E8, "Wrong size on UInteractionArchivementComponent");
static_assert(offsetof(UInteractionArchivementComponent, CompleteConditions) == 0x0000B0, "Member 'UInteractionArchivementComponent::CompleteConditions' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponent, CompleteArchivements) == 0x0000C0, "Member 'UInteractionArchivementComponent::CompleteArchivements' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponent, PlayedArchivements) == 0x0000D0, "Member 'UInteractionArchivementComponent::PlayedArchivements' has a wrong offset!");
static_assert(offsetof(UInteractionArchivementComponent, ArchivementDataTable) == 0x0000E0, "Member 'UInteractionArchivementComponent::ArchivementDataTable' has a wrong offset!");

// Class CharacterInteraction.CharacterInteractionComponent
// 0x01D0 (0x0280 - 0x00B0)
class UCharacterInteractionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionOperate*>            InstancedResistentOperates;                        // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ECharacterInteractionState                    InteractionState;                                  // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x13];                                      // 0x00C9(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastStandByID;                                     // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInteractionStandByEvent*>       StandByEvents;                                     // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UInteractionStandByEventContext*        StandByEventContext;                               // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionShowEvent*>          ShowEvents;                                        // 0x0118(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UInteractionShowEventContext*           ShowEventContext;                                  // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ShowElementMontage;                                // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ShowElementFacialMontage;                          // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomShowElement*                     CurCustomShowElement;                              // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionOperate*                    CurrentOperate;                                    // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionOperate*>            ResidentOperates;                                  // 0x0178(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractionOperate*>            ActiveOperates;                                    // 0x0188(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionExtraSequenceProcessor*> ExtraSequenceProcesses;                            // 0x01A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractionExtraStandByProcessor*> ExtraStandByProcesses;                             // 0x01B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x1];                                      // 0x01C8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasFinishedInteractionTutorial;                   // 0x01C9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA[0x2];                                      // 0x01CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPendingInteractionState               PendingState;                                      // 0x01CC(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLastFrameAnimData                     LastFrameAnimData;                                 // 0x01D8(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bExplicitFobirdEyeFollow;                          // 0x0208(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMouseFollowLookAtCamera;                          // 0x0209(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A[0x2];                                      // 0x020A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              EyesLookAtPosition;                                // 0x020C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOperateEyeFollow;                                 // 0x0214(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShutDownKawaii;                                   // 0x0215(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_216[0x2];                                      // 0x0216(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KawaiiAlpha;                                       // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KawaiiBlendDuration;                               // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KawaiiShutdownSpeed;                               // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnableKawaiiBlendCurve;                         // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EnableKawaiiBlendCurve;                            // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DisableKawaiiBlendCurve;                           // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x4];                                      // 0x0238(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KawaiBlendSpeedScale;                              // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayingAnim;                                    // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateKawaii;                                     // 0x0241(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMontages;                                     // 0x0242(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243[0x5];                                      // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             PropsInteractionDelegate;                          // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsHideBone;                                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoneNames;                                         // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsInteractionInterface;                           // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInteractionAnimInstance* GetInteractionAnimInstance();
	class UInteractionHeadAnimInstance* GetInteractionHeadAnimInstance();
	void OnPropsInteractionEnd();
	void PlayShowSequence(int32 ShowSequenceID);
	void PlayWeightedVoice(const TArray<struct FWeightedVoice>& VoiceIDs);
	void ResetInteraction();
	void SetbIsPlayingAnim(bool bIsPlaying);
	void SetExplicitForbitEyeFollow(bool bInExplicitForbit);
	void SetFinishedInteractionTutorial(bool IsFinished);
	void SetIsInteractionInterface(bool NewBool);
	void SetOperateEyeFollow(bool bEyeFollow);
	void StartStandby(int32 StandByID);
	void UpdateKawaii(float NewBlendCounter, bool NewShutDownKawaii);

	bool GetIsInteractionInterface() const;
	float GetKawaiiAlphaValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInteractionComponent">();
	}
	static class UCharacterInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInteractionComponent>();
	}
};
static_assert(alignof(UCharacterInteractionComponent) == 0x000008, "Wrong alignment on UCharacterInteractionComponent");
static_assert(sizeof(UCharacterInteractionComponent) == 0x000280, "Wrong size on UCharacterInteractionComponent");
static_assert(offsetof(UCharacterInteractionComponent, InstancedResistentOperates) == 0x0000B8, "Member 'UCharacterInteractionComponent::InstancedResistentOperates' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, InteractionState) == 0x0000C8, "Member 'UCharacterInteractionComponent::InteractionState' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, LastStandByID) == 0x0000DC, "Member 'UCharacterInteractionComponent::LastStandByID' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, StandByEvents) == 0x0000E0, "Member 'UCharacterInteractionComponent::StandByEvents' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, StandByEventContext) == 0x0000F0, "Member 'UCharacterInteractionComponent::StandByEventContext' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ShowEvents) == 0x000118, "Member 'UCharacterInteractionComponent::ShowEvents' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ShowEventContext) == 0x000128, "Member 'UCharacterInteractionComponent::ShowEventContext' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ShowElementMontage) == 0x000140, "Member 'UCharacterInteractionComponent::ShowElementMontage' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ShowElementFacialMontage) == 0x000148, "Member 'UCharacterInteractionComponent::ShowElementFacialMontage' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, CurCustomShowElement) == 0x000150, "Member 'UCharacterInteractionComponent::CurCustomShowElement' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, CurrentOperate) == 0x000160, "Member 'UCharacterInteractionComponent::CurrentOperate' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ResidentOperates) == 0x000178, "Member 'UCharacterInteractionComponent::ResidentOperates' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ActiveOperates) == 0x000188, "Member 'UCharacterInteractionComponent::ActiveOperates' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ExtraSequenceProcesses) == 0x0001A8, "Member 'UCharacterInteractionComponent::ExtraSequenceProcesses' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, ExtraStandByProcesses) == 0x0001B8, "Member 'UCharacterInteractionComponent::ExtraStandByProcesses' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bHasFinishedInteractionTutorial) == 0x0001C9, "Member 'UCharacterInteractionComponent::bHasFinishedInteractionTutorial' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, PendingState) == 0x0001CC, "Member 'UCharacterInteractionComponent::PendingState' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, LastFrameAnimData) == 0x0001D8, "Member 'UCharacterInteractionComponent::LastFrameAnimData' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bExplicitFobirdEyeFollow) == 0x000208, "Member 'UCharacterInteractionComponent::bExplicitFobirdEyeFollow' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bMouseFollowLookAtCamera) == 0x000209, "Member 'UCharacterInteractionComponent::bMouseFollowLookAtCamera' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, EyesLookAtPosition) == 0x00020C, "Member 'UCharacterInteractionComponent::EyesLookAtPosition' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bOperateEyeFollow) == 0x000214, "Member 'UCharacterInteractionComponent::bOperateEyeFollow' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bShutDownKawaii) == 0x000215, "Member 'UCharacterInteractionComponent::bShutDownKawaii' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, KawaiiAlpha) == 0x000218, "Member 'UCharacterInteractionComponent::KawaiiAlpha' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, KawaiiBlendDuration) == 0x00021C, "Member 'UCharacterInteractionComponent::KawaiiBlendDuration' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, KawaiiShutdownSpeed) == 0x000220, "Member 'UCharacterInteractionComponent::KawaiiShutdownSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bIsEnableKawaiiBlendCurve) == 0x000224, "Member 'UCharacterInteractionComponent::bIsEnableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, EnableKawaiiBlendCurve) == 0x000228, "Member 'UCharacterInteractionComponent::EnableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, DisableKawaiiBlendCurve) == 0x000230, "Member 'UCharacterInteractionComponent::DisableKawaiiBlendCurve' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, KawaiBlendSpeedScale) == 0x00023C, "Member 'UCharacterInteractionComponent::KawaiBlendSpeedScale' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bIsPlayingAnim) == 0x000240, "Member 'UCharacterInteractionComponent::bIsPlayingAnim' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bUpdateKawaii) == 0x000241, "Member 'UCharacterInteractionComponent::bUpdateKawaii' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bStopMontages) == 0x000242, "Member 'UCharacterInteractionComponent::bStopMontages' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, PropsInteractionDelegate) == 0x000248, "Member 'UCharacterInteractionComponent::PropsInteractionDelegate' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bIsHideBone) == 0x000260, "Member 'UCharacterInteractionComponent::bIsHideBone' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, BoneNames) == 0x000268, "Member 'UCharacterInteractionComponent::BoneNames' has a wrong offset!");
static_assert(offsetof(UCharacterInteractionComponent, bIsInteractionInterface) == 0x000278, "Member 'UCharacterInteractionComponent::bIsInteractionInterface' has a wrong offset!");

// Class CharacterInteraction.FlowerMouseOverInterface
// 0x0000 (0x0028 - 0x0028)
class IFlowerMouseOverInterface final : public IInterface
{
public:
	void OnMouseOver(const struct FVector2D& OverDistance, const struct FVector2D& TargetPosition, const struct FVector2D& LastMousePos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowerMouseOverInterface">();
	}
	static class IFlowerMouseOverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlowerMouseOverInterface>();
	}
};
static_assert(alignof(IFlowerMouseOverInterface) == 0x000008, "Wrong alignment on IFlowerMouseOverInterface");
static_assert(sizeof(IFlowerMouseOverInterface) == 0x000028, "Wrong size on IFlowerMouseOverInterface");

// Class CharacterInteraction.InteractionOperate
// 0x00A8 (0x00D0 - 0x0028)
class UInteractionOperate : public UObject
{
public:
	TArray<TSoftObjectPtr<class UInteractionOperateEventAsset>> InteractionEvents;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimSequence>           FacialAnim;                                        // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSyncOperate>                   SyncOperates;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractionHolyLightData>      HolyLights;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeightedVoice>                 VoiceIDs;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           PhysOperates;                                      // 0x0090(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractionOperateEvent*>       Events;                                            // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UInteractionOperateEventContext*        EventContext;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDraging;                                        // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStop;                                           // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FacialAnimMontage;                                 // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionEnd(class AInteractionCharacter* Actor);
	void OnInteractionRemove(class AInteractionCharacter* Actor);
	void OnInteractionReuse(class AInteractionCharacter* Actor);
	void OnInteractionStart(class AInteractionCharacter* Actor);
	void OnInteractionUpdate(class AInteractionCharacter* Actor, float DeltaTime);
	void OnScenarioChange(int32 ScenarioID);
	void OnStandByChange(int32 ScenarioID);
	void SetIsStop(bool bInStop);
	bool ShouldRemove(class AInteractionCharacter* Actor);

	bool GetIsStop() const;
	bool IsBlockOperate() const;
	void OnInteractionResume(class AInteractionCharacter* Actor) const;
	void OnInteractionStop(class AInteractionCharacter* Actor) const;
	bool ShouldStopOnRelease() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperate">();
	}
	static class UInteractionOperate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperate>();
	}
};
static_assert(alignof(UInteractionOperate) == 0x000008, "Wrong alignment on UInteractionOperate");
static_assert(sizeof(UInteractionOperate) == 0x0000D0, "Wrong size on UInteractionOperate");
static_assert(offsetof(UInteractionOperate, InteractionEvents) == 0x000028, "Member 'UInteractionOperate::InteractionEvents' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, FacialAnim) == 0x000038, "Member 'UInteractionOperate::FacialAnim' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, SyncOperates) == 0x000060, "Member 'UInteractionOperate::SyncOperates' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, HolyLights) == 0x000070, "Member 'UInteractionOperate::HolyLights' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, VoiceIDs) == 0x000080, "Member 'UInteractionOperate::VoiceIDs' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, PhysOperates) == 0x000090, "Member 'UInteractionOperate::PhysOperates' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, Events) == 0x0000A0, "Member 'UInteractionOperate::Events' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, EventContext) == 0x0000B0, "Member 'UInteractionOperate::EventContext' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, bIsDraging) == 0x0000B8, "Member 'UInteractionOperate::bIsDraging' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, bIsStop) == 0x0000B9, "Member 'UInteractionOperate::bIsStop' has a wrong offset!");
static_assert(offsetof(UInteractionOperate, FacialAnimMontage) == 0x0000C0, "Member 'UInteractionOperate::FacialAnimMontage' has a wrong offset!");

// Class CharacterInteraction.DragInteraction
// 0x0090 (0x0160 - 0x00D0)
class UDragInteraction : public UInteractionOperate
{
public:
	struct FDragControlData                       DragControl;                                       // 0x00D0(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FIKFixData>                     FixBones;                                          // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FExtraFixData>                  ExtraFixDatas;                                     // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bBlockStandby;                                     // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlush;                                          // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEyeLookAtCamera;                             // 0x013A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x1];                                      // 0x013B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LookAtPosition;                                    // 0x013C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x1C];                                     // 0x0144(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateDrag(class AInteractionCharacter* Actor, float DeltaSecond);
	void UpdateRecover(class AInteractionCharacter* Actor, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragInteraction">();
	}
	static class UDragInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragInteraction>();
	}
};
static_assert(alignof(UDragInteraction) == 0x000008, "Wrong alignment on UDragInteraction");
static_assert(sizeof(UDragInteraction) == 0x000160, "Wrong size on UDragInteraction");
static_assert(offsetof(UDragInteraction, DragControl) == 0x0000D0, "Member 'UDragInteraction::DragControl' has a wrong offset!");
static_assert(offsetof(UDragInteraction, FixBones) == 0x000118, "Member 'UDragInteraction::FixBones' has a wrong offset!");
static_assert(offsetof(UDragInteraction, ExtraFixDatas) == 0x000128, "Member 'UDragInteraction::ExtraFixDatas' has a wrong offset!");
static_assert(offsetof(UDragInteraction, bBlockStandby) == 0x000138, "Member 'UDragInteraction::bBlockStandby' has a wrong offset!");
static_assert(offsetof(UDragInteraction, bIsBlush) == 0x000139, "Member 'UDragInteraction::bIsBlush' has a wrong offset!");
static_assert(offsetof(UDragInteraction, bForceEyeLookAtCamera) == 0x00013A, "Member 'UDragInteraction::bForceEyeLookAtCamera' has a wrong offset!");
static_assert(offsetof(UDragInteraction, LookAtPosition) == 0x00013C, "Member 'UDragInteraction::LookAtPosition' has a wrong offset!");

// Class CharacterInteraction.MouseOverFlowerInteraction
// 0x0010 (0x0170 - 0x0160)
class UMouseOverFlowerInteraction final : public UDragInteraction
{
public:
	float                                         SampleInterval;                                    // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0xC];                                      // 0x0164(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseOverFlowerInteraction">();
	}
	static class UMouseOverFlowerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseOverFlowerInteraction>();
	}
};
static_assert(alignof(UMouseOverFlowerInteraction) == 0x000008, "Wrong alignment on UMouseOverFlowerInteraction");
static_assert(sizeof(UMouseOverFlowerInteraction) == 0x000170, "Wrong size on UMouseOverFlowerInteraction");
static_assert(offsetof(UMouseOverFlowerInteraction, SampleInterval) == 0x000160, "Member 'UMouseOverFlowerInteraction::SampleInterval' has a wrong offset!");

// Class CharacterInteraction.PropsUpdateInterface
// 0x0000 (0x0028 - 0x0028)
class IPropsUpdateInterface final : public IInterface
{
public:
	void PropsUpdate(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropsUpdateInterface">();
	}
	static class IPropsUpdateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPropsUpdateInterface>();
	}
};
static_assert(alignof(IPropsUpdateInterface) == 0x000008, "Wrong alignment on IPropsUpdateInterface");
static_assert(sizeof(IPropsUpdateInterface) == 0x000028, "Wrong size on IPropsUpdateInterface");

// Class CharacterInteraction.PropsClickedInterface
// 0x0000 (0x0028 - 0x0028)
class IPropsClickedInterface final : public IInterface
{
public:
	void PropsClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropsClickedInterface">();
	}
	static class IPropsClickedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPropsClickedInterface>();
	}
};
static_assert(alignof(IPropsClickedInterface) == 0x000008, "Wrong alignment on IPropsClickedInterface");
static_assert(sizeof(IPropsClickedInterface) == 0x000028, "Wrong size on IPropsClickedInterface");

// Class CharacterInteraction.FBAnimationDefinition
// 0x0280 (0x02B0 - 0x0030)
class UFBAnimationDefinition final : public UDataAsset
{
public:
	int32                                         InteractionName;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragSpeedMultiplying;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleInterval;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationEnergyPerSecond;                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeAttenuationThreshold;                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinClickEnergy;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxClickEnergy;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEnergy;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalInversion;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotatorOffer;                                      // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxShortAnimTriggerTime;                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSubtract;                                   // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SubtractBoneNames;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditive;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AdditiveBoneNames;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AnimA_BlendInTime;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimA_BlendOutTime;                                // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimSequence>>   AnimA;                                             // 0x0098(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FaceAnimA;                                         // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FaceAnimAMontage;                                  // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimB;                                             // 0x00D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FaceAnimB;                                         // 0x0100(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimB1_BlendInTime;                                // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimB1_BlendOutTime;                               // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           AnimB1;                                            // 0x0130(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           FaceAnimB1;                                        // 0x0158(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimC;                                             // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FaceAnimC;                                         // 0x01A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPropA_BlendInTime;                             // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPropA_BlendOutTime;                            // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           AnimPropA;                                         // 0x01D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimPropB;                                         // 0x0200(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPropB1_BlendInTime;                            // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPropB1_BlendOutTime;                           // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           AnimPropB1;                                        // 0x0230(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimPropC;                                         // 0x0258(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeightedVoice>                 AnimAVoiceIDs;                                     // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeightedVoice>                 AnimBVoiceIDs;                                     // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeightedVoice>                 AnimCVoiceIDs;                                     // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FBAnimationDefinition">();
	}
	static class UFBAnimationDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFBAnimationDefinition>();
	}
};
static_assert(alignof(UFBAnimationDefinition) == 0x000008, "Wrong alignment on UFBAnimationDefinition");
static_assert(sizeof(UFBAnimationDefinition) == 0x0002B0, "Wrong size on UFBAnimationDefinition");
static_assert(offsetof(UFBAnimationDefinition, InteractionName) == 0x000030, "Member 'UFBAnimationDefinition::InteractionName' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, DragSpeedMultiplying) == 0x000034, "Member 'UFBAnimationDefinition::DragSpeedMultiplying' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, SampleInterval) == 0x000038, "Member 'UFBAnimationDefinition::SampleInterval' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AttenuationEnergyPerSecond) == 0x00003C, "Member 'UFBAnimationDefinition::AttenuationEnergyPerSecond' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, TimeAttenuationThreshold) == 0x000040, "Member 'UFBAnimationDefinition::TimeAttenuationThreshold' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, MinClickEnergy) == 0x000044, "Member 'UFBAnimationDefinition::MinClickEnergy' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, MaxClickEnergy) == 0x000048, "Member 'UFBAnimationDefinition::MaxClickEnergy' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, MaxEnergy) == 0x00004C, "Member 'UFBAnimationDefinition::MaxEnergy' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, NormalInversion) == 0x000050, "Member 'UFBAnimationDefinition::NormalInversion' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, RotatorOffer) == 0x000054, "Member 'UFBAnimationDefinition::RotatorOffer' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, MaxShortAnimTriggerTime) == 0x000060, "Member 'UFBAnimationDefinition::MaxShortAnimTriggerTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, bEnableSubtract) == 0x000064, "Member 'UFBAnimationDefinition::bEnableSubtract' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, SubtractBoneNames) == 0x000068, "Member 'UFBAnimationDefinition::SubtractBoneNames' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, bEnableAdditive) == 0x000078, "Member 'UFBAnimationDefinition::bEnableAdditive' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AdditiveBoneNames) == 0x000080, "Member 'UFBAnimationDefinition::AdditiveBoneNames' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimA_BlendInTime) == 0x000090, "Member 'UFBAnimationDefinition::AnimA_BlendInTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimA_BlendOutTime) == 0x000094, "Member 'UFBAnimationDefinition::AnimA_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimA) == 0x000098, "Member 'UFBAnimationDefinition::AnimA' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, FaceAnimA) == 0x0000A8, "Member 'UFBAnimationDefinition::FaceAnimA' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, FaceAnimAMontage) == 0x0000D0, "Member 'UFBAnimationDefinition::FaceAnimAMontage' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimB) == 0x0000D8, "Member 'UFBAnimationDefinition::AnimB' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, FaceAnimB) == 0x000100, "Member 'UFBAnimationDefinition::FaceAnimB' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimB1_BlendInTime) == 0x000128, "Member 'UFBAnimationDefinition::AnimB1_BlendInTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimB1_BlendOutTime) == 0x00012C, "Member 'UFBAnimationDefinition::AnimB1_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimB1) == 0x000130, "Member 'UFBAnimationDefinition::AnimB1' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, FaceAnimB1) == 0x000158, "Member 'UFBAnimationDefinition::FaceAnimB1' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimC) == 0x000180, "Member 'UFBAnimationDefinition::AnimC' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, FaceAnimC) == 0x0001A8, "Member 'UFBAnimationDefinition::FaceAnimC' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropA_BlendInTime) == 0x0001D0, "Member 'UFBAnimationDefinition::AnimPropA_BlendInTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropA_BlendOutTime) == 0x0001D4, "Member 'UFBAnimationDefinition::AnimPropA_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropA) == 0x0001D8, "Member 'UFBAnimationDefinition::AnimPropA' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropB) == 0x000200, "Member 'UFBAnimationDefinition::AnimPropB' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropB1_BlendInTime) == 0x000228, "Member 'UFBAnimationDefinition::AnimPropB1_BlendInTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropB1_BlendOutTime) == 0x00022C, "Member 'UFBAnimationDefinition::AnimPropB1_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropB1) == 0x000230, "Member 'UFBAnimationDefinition::AnimPropB1' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimPropC) == 0x000258, "Member 'UFBAnimationDefinition::AnimPropC' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimAVoiceIDs) == 0x000280, "Member 'UFBAnimationDefinition::AnimAVoiceIDs' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimBVoiceIDs) == 0x000290, "Member 'UFBAnimationDefinition::AnimBVoiceIDs' has a wrong offset!");
static_assert(offsetof(UFBAnimationDefinition, AnimCVoiceIDs) == 0x0002A0, "Member 'UFBAnimationDefinition::AnimCVoiceIDs' has a wrong offset!");

// Class CharacterInteraction.InteractionPropsDrag
// 0x01B0 (0x0310 - 0x0160)
class UInteractionPropsDrag final : public UDragInteraction
{
public:
	bool                                          EnableInteractionUpdate;                           // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTickOperateIndex;                           // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle;                                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UFBAnimationDefinition*> PropsAnimDefinition;                               // 0x0170(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         ShortAnimTriggerTime;                              // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInteractionCharacter*                  InteractionCharacter;                              // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterInteractionComponent*         InteractionComponent;                              // 0x01D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFBAnimationDefinition*                 CurrentFBAnimationDefinition;                      // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentEnergy;                                     // 0x01E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeCounter;                                       // 0x01E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTimeAttenuationThreshold;                   // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionPropsDrag*                  CurrentTickOperate;                                // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractionCharacter*                  CurrentProp;                                       // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           AnimAMontage;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           AnimBMontage;                                      // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           AnimBEndMontage;                                   // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           AnimCMontage;                                      // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x98];                                     // 0x0220(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaSeconds;                                      // 0x02B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x02C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bShowMouseCursor;                                  // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayAnimC;                                        // 0x02F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayAnimB;                                        // 0x02F2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F3[0x5];                                      // 0x02F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          AnimInstance;                                      // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0300(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReSetCurrentEnergy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPropsDrag">();
	}
	static class UInteractionPropsDrag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionPropsDrag>();
	}
};
static_assert(alignof(UInteractionPropsDrag) == 0x000010, "Wrong alignment on UInteractionPropsDrag");
static_assert(sizeof(UInteractionPropsDrag) == 0x000310, "Wrong size on UInteractionPropsDrag");
static_assert(offsetof(UInteractionPropsDrag, EnableInteractionUpdate) == 0x000160, "Member 'UInteractionPropsDrag::EnableInteractionUpdate' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentTickOperateIndex) == 0x000164, "Member 'UInteractionPropsDrag::CurrentTickOperateIndex' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, TiltAngle) == 0x000168, "Member 'UInteractionPropsDrag::TiltAngle' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, YawAngle) == 0x00016C, "Member 'UInteractionPropsDrag::YawAngle' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, PropsAnimDefinition) == 0x000170, "Member 'UInteractionPropsDrag::PropsAnimDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, ShortAnimTriggerTime) == 0x0001C0, "Member 'UInteractionPropsDrag::ShortAnimTriggerTime' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, InteractionCharacter) == 0x0001C8, "Member 'UInteractionPropsDrag::InteractionCharacter' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, InteractionComponent) == 0x0001D0, "Member 'UInteractionPropsDrag::InteractionComponent' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentFBAnimationDefinition) == 0x0001D8, "Member 'UInteractionPropsDrag::CurrentFBAnimationDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentEnergy) == 0x0001E0, "Member 'UInteractionPropsDrag::CurrentEnergy' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, TimeCounter) == 0x0001E4, "Member 'UInteractionPropsDrag::TimeCounter' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentTimeAttenuationThreshold) == 0x0001E8, "Member 'UInteractionPropsDrag::CurrentTimeAttenuationThreshold' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentTickOperate) == 0x0001F0, "Member 'UInteractionPropsDrag::CurrentTickOperate' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, CurrentProp) == 0x0001F8, "Member 'UInteractionPropsDrag::CurrentProp' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, AnimAMontage) == 0x000200, "Member 'UInteractionPropsDrag::AnimAMontage' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, AnimBMontage) == 0x000208, "Member 'UInteractionPropsDrag::AnimBMontage' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, AnimBEndMontage) == 0x000210, "Member 'UInteractionPropsDrag::AnimBEndMontage' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, AnimCMontage) == 0x000218, "Member 'UInteractionPropsDrag::AnimCMontage' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, DeltaSeconds) == 0x0002B8, "Member 'UInteractionPropsDrag::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, HitTransform) == 0x0002C0, "Member 'UInteractionPropsDrag::HitTransform' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, bShowMouseCursor) == 0x0002F0, "Member 'UInteractionPropsDrag::bShowMouseCursor' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, bPlayAnimC) == 0x0002F1, "Member 'UInteractionPropsDrag::bPlayAnimC' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, bPlayAnimB) == 0x0002F2, "Member 'UInteractionPropsDrag::bPlayAnimB' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, AnimInstance) == 0x0002F8, "Member 'UInteractionPropsDrag::AnimInstance' has a wrong offset!");
static_assert(offsetof(UInteractionPropsDrag, TimerHandle) == 0x000300, "Member 'UInteractionPropsDrag::TimerHandle' has a wrong offset!");

// Class CharacterInteraction.PropUpdateDefinition
// 0x0050 (0x0080 - 0x0030)
class UPropUpdateDefinition final : public UDataAsset
{
public:
	float                                         DragSpeedMultiplying;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalInversion;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotatorOffer;                                      // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSubtract;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SubtractBoneNames;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableAdditive;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AdditiveBoneNames;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInteractionOperateEventAsset*          EventAsset;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropUpdateDefinition">();
	}
	static class UPropUpdateDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropUpdateDefinition>();
	}
};
static_assert(alignof(UPropUpdateDefinition) == 0x000008, "Wrong alignment on UPropUpdateDefinition");
static_assert(sizeof(UPropUpdateDefinition) == 0x000080, "Wrong size on UPropUpdateDefinition");
static_assert(offsetof(UPropUpdateDefinition, DragSpeedMultiplying) == 0x000030, "Member 'UPropUpdateDefinition::DragSpeedMultiplying' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, NormalInversion) == 0x000034, "Member 'UPropUpdateDefinition::NormalInversion' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, RotatorOffer) == 0x000038, "Member 'UPropUpdateDefinition::RotatorOffer' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, ErrorTolerance) == 0x000044, "Member 'UPropUpdateDefinition::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, bEnableSubtract) == 0x000048, "Member 'UPropUpdateDefinition::bEnableSubtract' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, SubtractBoneNames) == 0x000050, "Member 'UPropUpdateDefinition::SubtractBoneNames' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, bEnableAdditive) == 0x000060, "Member 'UPropUpdateDefinition::bEnableAdditive' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, AdditiveBoneNames) == 0x000068, "Member 'UPropUpdateDefinition::AdditiveBoneNames' has a wrong offset!");
static_assert(offsetof(UPropUpdateDefinition, EventAsset) == 0x000078, "Member 'UPropUpdateDefinition::EventAsset' has a wrong offset!");

// Class CharacterInteraction.InteractionPropsUpdate
// 0x0108 (0x0268 - 0x0160)
class UInteractionPropsUpdate final : public UDragInteraction
{
public:
	float                                         TiltAngle;                                         // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UPropUpdateDefinition*> PropsDefinition;                                   // 0x0168(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UPropUpdateDefinition*                  CurrentDefinition;                                 // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractionCharacter*                  CurrentProp;                                       // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHitResult                             OutHit;                                            // 0x01C8(0x008C)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FVector                                DeltaLocation;                                     // 0x0254(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeltaSeconds;                                      // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPropsUpdate">();
	}
	static class UInteractionPropsUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionPropsUpdate>();
	}
};
static_assert(alignof(UInteractionPropsUpdate) == 0x000008, "Wrong alignment on UInteractionPropsUpdate");
static_assert(sizeof(UInteractionPropsUpdate) == 0x000268, "Wrong size on UInteractionPropsUpdate");
static_assert(offsetof(UInteractionPropsUpdate, TiltAngle) == 0x000160, "Member 'UInteractionPropsUpdate::TiltAngle' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, YawAngle) == 0x000164, "Member 'UInteractionPropsUpdate::YawAngle' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, PropsDefinition) == 0x000168, "Member 'UInteractionPropsUpdate::PropsDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, CurrentDefinition) == 0x0001B8, "Member 'UInteractionPropsUpdate::CurrentDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, CurrentProp) == 0x0001C0, "Member 'UInteractionPropsUpdate::CurrentProp' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, OutHit) == 0x0001C8, "Member 'UInteractionPropsUpdate::OutHit' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, DeltaLocation) == 0x000254, "Member 'UInteractionPropsUpdate::DeltaLocation' has a wrong offset!");
static_assert(offsetof(UInteractionPropsUpdate, DeltaSeconds) == 0x000260, "Member 'UInteractionPropsUpdate::DeltaSeconds' has a wrong offset!");

// Class CharacterInteraction.HolyLightComponent
// 0x0058 (0x0108 - 0x00B0)
class UHolyLightComponent final : public UActorComponent
{
public:
	TMap<class FName, struct FInteractionHolyLightRuntimeDataArray> HolyLightRuntimeData;                              // 0x00B0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HolyLightComponent">();
	}
	static class UHolyLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHolyLightComponent>();
	}
};
static_assert(alignof(UHolyLightComponent) == 0x000008, "Wrong alignment on UHolyLightComponent");
static_assert(sizeof(UHolyLightComponent) == 0x000108, "Wrong size on UHolyLightComponent");
static_assert(offsetof(UHolyLightComponent, HolyLightRuntimeData) == 0x0000B0, "Member 'UHolyLightComponent::HolyLightRuntimeData' has a wrong offset!");

// Class CharacterInteraction.InteractionAnimInstance
// 0x0230 (0x04F0 - 0x02C0)
class UInteractionAnimInstance final : public UAnimInstance
{
public:
	bool                                          bHeadModifyUseYawMove;                             // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimStandBy;                                       // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          StandByBlendTarget;                                // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandByAnimBlendRatio;                             // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              HeadModifyOffset;                                  // 0x02D4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseFollowHeadOffset;                             // 0x02DC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadRotator;                                       // 0x02E4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeSpineWeight                    RuntimeSpineDatas;                                 // 0x02F0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractionBlendSpaceData>     BlendSpaceDatas;                                   // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         BlendSpaceCount;                                   // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x19C];                                    // 0x0354(0x019C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ScenarioInitializeAnimation();
	void SetIsDebugDraw(bool bInDebugDraw);

	bool GetIsDebugDraw() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimInstance">();
	}
	static class UInteractionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimInstance>();
	}
};
static_assert(alignof(UInteractionAnimInstance) == 0x000010, "Wrong alignment on UInteractionAnimInstance");
static_assert(sizeof(UInteractionAnimInstance) == 0x0004F0, "Wrong size on UInteractionAnimInstance");
static_assert(offsetof(UInteractionAnimInstance, bHeadModifyUseYawMove) == 0x0002B8, "Member 'UInteractionAnimInstance::bHeadModifyUseYawMove' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, AnimStandBy) == 0x0002C0, "Member 'UInteractionAnimInstance::AnimStandBy' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, StandByBlendTarget) == 0x0002C8, "Member 'UInteractionAnimInstance::StandByBlendTarget' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, StandByAnimBlendRatio) == 0x0002D0, "Member 'UInteractionAnimInstance::StandByAnimBlendRatio' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, HeadModifyOffset) == 0x0002D4, "Member 'UInteractionAnimInstance::HeadModifyOffset' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, MouseFollowHeadOffset) == 0x0002DC, "Member 'UInteractionAnimInstance::MouseFollowHeadOffset' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, HeadRotator) == 0x0002E4, "Member 'UInteractionAnimInstance::HeadRotator' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, RuntimeSpineDatas) == 0x0002F0, "Member 'UInteractionAnimInstance::RuntimeSpineDatas' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, BlendSpaceDatas) == 0x000340, "Member 'UInteractionAnimInstance::BlendSpaceDatas' has a wrong offset!");
static_assert(offsetof(UInteractionAnimInstance, BlendSpaceCount) == 0x000350, "Member 'UInteractionAnimInstance::BlendSpaceCount' has a wrong offset!");

// Class CharacterInteraction.InteractionCableComponent
// 0x00D0 (0x0570 - 0x04A0)
class UInteractionCableComponent final : public UMeshComponent
{
public:
	bool                                          bAttachStart;                                      // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachEnd;                                        // 0x04A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A2[0x6];                                      // 0x04A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentReference                    AttachEndTo;                                       // 0x04A8(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   AttachEndToSocketName;                             // 0x04D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x04D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCableLength;                            // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubstepTime;                                       // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SolverIterations;                                  // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStiffness;                                  // 0x04F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSubstepping;                                   // 0x04F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipInteractionCableUpdateWhenNotVisible;         // 0x04F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipInteractionCableUpdateWhenNotOwnerRecentlyRendered; // 0x04F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionFriction;                                 // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionCableForce;                             // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCableGravityScale;                      // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCableWidth;                             // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileMaterial;                                      // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVertexColor;                                   // 0x051C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51D[0x1B];                                     // 0x051D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GrabForce;                                         // 0x0538(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrabIndex;                                         // 0x0544(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsXPBD;                                           // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SolverIterationsXPBD;                              // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaMultiply;                                     // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebug;                                      // 0x0564(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_565[0xB];                                      // 0x0565(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddConstraint(int32 IndexA, int32 IndexB);
	void GrabParticles(const int32 ParticleIndex, const struct FVector& DragForce);
	void IntegrateParticles(float DeltaTime);
	void SetAttachEndTo(class AActor* Actor, class FName ComponentProperty, class FName SocketName);
	void SetAttachEndToComponent(class USceneComponent* Component, class FName SocketName);
	void SolveDistanceConstraints(float DeltaTime);
	void UpdateVelocities(float DeltaTime);

	void DebugDraw() const;
	class AActor* GetAttachedActor() const;
	class USceneComponent* GetAttachedComponent() const;
	void GetInteractionCableParticleLocations(TArray<struct FVector>* Locations) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCableComponent">();
	}
	static class UInteractionCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCableComponent>();
	}
};
static_assert(alignof(UInteractionCableComponent) == 0x000010, "Wrong alignment on UInteractionCableComponent");
static_assert(sizeof(UInteractionCableComponent) == 0x000570, "Wrong size on UInteractionCableComponent");
static_assert(offsetof(UInteractionCableComponent, bAttachStart) == 0x0004A0, "Member 'UInteractionCableComponent::bAttachStart' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bAttachEnd) == 0x0004A1, "Member 'UInteractionCableComponent::bAttachEnd' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, AttachEndTo) == 0x0004A8, "Member 'UInteractionCableComponent::AttachEndTo' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, AttachEndToSocketName) == 0x0004D0, "Member 'UInteractionCableComponent::AttachEndToSocketName' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, EndLocation) == 0x0004D8, "Member 'UInteractionCableComponent::EndLocation' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, InteractionCableLength) == 0x0004E4, "Member 'UInteractionCableComponent::InteractionCableLength' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, NumSegments) == 0x0004E8, "Member 'UInteractionCableComponent::NumSegments' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, SubstepTime) == 0x0004EC, "Member 'UInteractionCableComponent::SubstepTime' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, SolverIterations) == 0x0004F0, "Member 'UInteractionCableComponent::SolverIterations' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bEnableStiffness) == 0x0004F4, "Member 'UInteractionCableComponent::bEnableStiffness' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bUseSubstepping) == 0x0004F5, "Member 'UInteractionCableComponent::bUseSubstepping' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bSkipInteractionCableUpdateWhenNotVisible) == 0x0004F6, "Member 'UInteractionCableComponent::bSkipInteractionCableUpdateWhenNotVisible' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bSkipInteractionCableUpdateWhenNotOwnerRecentlyRendered) == 0x0004F7, "Member 'UInteractionCableComponent::bSkipInteractionCableUpdateWhenNotOwnerRecentlyRendered' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bEnableCollision) == 0x0004F8, "Member 'UInteractionCableComponent::bEnableCollision' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, CollisionFriction) == 0x0004FC, "Member 'UInteractionCableComponent::CollisionFriction' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, InteractionCableForce) == 0x000500, "Member 'UInteractionCableComponent::InteractionCableForce' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, InteractionCableGravityScale) == 0x00050C, "Member 'UInteractionCableComponent::InteractionCableGravityScale' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, InteractionCableWidth) == 0x000510, "Member 'UInteractionCableComponent::InteractionCableWidth' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, NumSides) == 0x000514, "Member 'UInteractionCableComponent::NumSides' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, TileMaterial) == 0x000518, "Member 'UInteractionCableComponent::TileMaterial' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bUseVertexColor) == 0x00051C, "Member 'UInteractionCableComponent::bUseVertexColor' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, GrabForce) == 0x000538, "Member 'UInteractionCableComponent::GrabForce' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, GrabIndex) == 0x000544, "Member 'UInteractionCableComponent::GrabIndex' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bIsXPBD) == 0x000558, "Member 'UInteractionCableComponent::bIsXPBD' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, SolverIterationsXPBD) == 0x00055C, "Member 'UInteractionCableComponent::SolverIterationsXPBD' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, AlphaMultiply) == 0x000560, "Member 'UInteractionCableComponent::AlphaMultiply' has a wrong offset!");
static_assert(offsetof(UInteractionCableComponent, bEnableDebug) == 0x000564, "Member 'UInteractionCableComponent::bEnableDebug' has a wrong offset!");

// Class CharacterInteraction.InteractionCharacter
// 0x0098 (0x02C0 - 0x0228)
class AInteractionCharacter : public AActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 HeadMeshComponent;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterInteractionComponent*         InteractionComponent;                              // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOVRLipSyncPlaybackActorComponent*      LipSyncComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsControlComponent*               PhysicsControlComponent;                           // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsHandleComponent*                PhysicsHandleComponent;                            // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractionDirector*                   Director;                                          // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InteractionID;                                     // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TestVoiceID;                                       // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnalyzerVoiceID;                                   // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StandByTable;                                      // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ShowSequenceTable;                                 // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ShowElementTable;                                  // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             InteractionOperateTable;                           // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CharacterInteractionName;                          // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReceiveInteraction;                               // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFollowMainCharacter;                              // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDraw;                                        // 0x029A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B[0x25];                                     // 0x029B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlendPhysics(float TimelineLength);
	bool GetStandByConfig(int32 StandByID, struct FInteractionStandByConfig* Config);
	void InteractionStartBlush();
	void InteractionStopBlush();
	void OnLipSyncDataReady();
	void SetPhysicsBlendWeight(class FName SetName, float StartBlend, float Target, float BlendSpeed, bool CompleteClose);
	void SetReceiveInteraction(bool bInReceive);

	class USkeletalMeshComponent* GetBodyComponent() const;
	class USkeletalMeshComponent* GetHeadComponent() const;
	class FName GetInteractionName() const;
	bool GetIsDebugDraw() const;
	bool GetReceiveInteraction() const;
	int32 GetSkinID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCharacter">();
	}
	static class AInteractionCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionCharacter>();
	}
};
static_assert(alignof(AInteractionCharacter) == 0x000008, "Wrong alignment on AInteractionCharacter");
static_assert(sizeof(AInteractionCharacter) == 0x0002C0, "Wrong size on AInteractionCharacter");
static_assert(offsetof(AInteractionCharacter, SkeletalMeshComponent) == 0x000228, "Member 'AInteractionCharacter::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, HeadMeshComponent) == 0x000230, "Member 'AInteractionCharacter::HeadMeshComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, InteractionComponent) == 0x000238, "Member 'AInteractionCharacter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, LipSyncComponent) == 0x000240, "Member 'AInteractionCharacter::LipSyncComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, PhysicsControlComponent) == 0x000248, "Member 'AInteractionCharacter::PhysicsControlComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, PhysicsHandleComponent) == 0x000250, "Member 'AInteractionCharacter::PhysicsHandleComponent' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, Director) == 0x000258, "Member 'AInteractionCharacter::Director' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, InteractionID) == 0x000260, "Member 'AInteractionCharacter::InteractionID' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, TestVoiceID) == 0x000264, "Member 'AInteractionCharacter::TestVoiceID' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, AnalyzerVoiceID) == 0x000268, "Member 'AInteractionCharacter::AnalyzerVoiceID' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, StandByTable) == 0x000270, "Member 'AInteractionCharacter::StandByTable' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, ShowSequenceTable) == 0x000278, "Member 'AInteractionCharacter::ShowSequenceTable' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, ShowElementTable) == 0x000280, "Member 'AInteractionCharacter::ShowElementTable' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, InteractionOperateTable) == 0x000288, "Member 'AInteractionCharacter::InteractionOperateTable' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, CharacterInteractionName) == 0x000290, "Member 'AInteractionCharacter::CharacterInteractionName' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, bReceiveInteraction) == 0x000298, "Member 'AInteractionCharacter::bReceiveInteraction' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, bFollowMainCharacter) == 0x000299, "Member 'AInteractionCharacter::bFollowMainCharacter' has a wrong offset!");
static_assert(offsetof(AInteractionCharacter, bDebugDraw) == 0x00029A, "Member 'AInteractionCharacter::bDebugDraw' has a wrong offset!");

// Class CharacterInteraction.InteractionExtraSequenceProcessor
// 0x0008 (0x0030 - 0x0028)
class UInteractionExtraSequenceProcessor : public UObject
{
public:
	class UInteractionProcessSequenceContext*     Context;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSequenceBegin();
	void OnSequenceEnd();
	void OnTickSequence(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionExtraSequenceProcessor">();
	}
	static class UInteractionExtraSequenceProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionExtraSequenceProcessor>();
	}
};
static_assert(alignof(UInteractionExtraSequenceProcessor) == 0x000008, "Wrong alignment on UInteractionExtraSequenceProcessor");
static_assert(sizeof(UInteractionExtraSequenceProcessor) == 0x000030, "Wrong size on UInteractionExtraSequenceProcessor");
static_assert(offsetof(UInteractionExtraSequenceProcessor, Context) == 0x000028, "Member 'UInteractionExtraSequenceProcessor::Context' has a wrong offset!");

// Class CharacterInteraction.InteractionSequenceConfession
// 0x0030 (0x0060 - 0x0030)
class UInteractionSequenceConfession final : public UInteractionExtraSequenceProcessor
{
public:
	class UDataTable*                             ConfessionDataTable;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ConfessionStandByDataTable;                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           KeepPosMontage;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          KeepPosAnim;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSequenceConfession">();
	}
	static class UInteractionSequenceConfession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionSequenceConfession>();
	}
};
static_assert(alignof(UInteractionSequenceConfession) == 0x000008, "Wrong alignment on UInteractionSequenceConfession");
static_assert(sizeof(UInteractionSequenceConfession) == 0x000060, "Wrong size on UInteractionSequenceConfession");
static_assert(offsetof(UInteractionSequenceConfession, ConfessionDataTable) == 0x000030, "Member 'UInteractionSequenceConfession::ConfessionDataTable' has a wrong offset!");
static_assert(offsetof(UInteractionSequenceConfession, ConfessionStandByDataTable) == 0x000038, "Member 'UInteractionSequenceConfession::ConfessionStandByDataTable' has a wrong offset!");
static_assert(offsetof(UInteractionSequenceConfession, KeepPosMontage) == 0x000040, "Member 'UInteractionSequenceConfession::KeepPosMontage' has a wrong offset!");
static_assert(offsetof(UInteractionSequenceConfession, KeepPosAnim) == 0x000048, "Member 'UInteractionSequenceConfession::KeepPosAnim' has a wrong offset!");

// Class CharacterInteraction.InteractionExtraStandByProcessor
// 0x0008 (0x0030 - 0x0028)
class UInteractionExtraStandByProcessor : public UObject
{
public:
	class UInteractionProcessStandByContext*      Context;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMenuEvent(int32 ID);
	void OnStandByBegin();
	void OnStandByEnd();
	void OnTickStandBy(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionExtraStandByProcessor">();
	}
	static class UInteractionExtraStandByProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionExtraStandByProcessor>();
	}
};
static_assert(alignof(UInteractionExtraStandByProcessor) == 0x000008, "Wrong alignment on UInteractionExtraStandByProcessor");
static_assert(sizeof(UInteractionExtraStandByProcessor) == 0x000030, "Wrong size on UInteractionExtraStandByProcessor");
static_assert(offsetof(UInteractionExtraStandByProcessor, Context) == 0x000028, "Member 'UInteractionExtraStandByProcessor::Context' has a wrong offset!");

// Class CharacterInteraction.InteractionStandByConfession
// 0x0018 (0x0048 - 0x0030)
class UInteractionStandByConfession final : public UInteractionExtraStandByProcessor
{
public:
	class UDataTable*                             ConfessionDataTable;                               // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStandByConfession">();
	}
	static class UInteractionStandByConfession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStandByConfession>();
	}
};
static_assert(alignof(UInteractionStandByConfession) == 0x000008, "Wrong alignment on UInteractionStandByConfession");
static_assert(sizeof(UInteractionStandByConfession) == 0x000048, "Wrong size on UInteractionStandByConfession");
static_assert(offsetof(UInteractionStandByConfession, ConfessionDataTable) == 0x000030, "Member 'UInteractionStandByConfession::ConfessionDataTable' has a wrong offset!");

// Class CharacterInteraction.InteractionDirector
// 0x0188 (0x03B0 - 0x0228)
class AInteractionDirector : public AActor
{
public:
	uint8                                         Pad_228[0x40];                                     // 0x0228(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionArchivementComponent*       ArchivementComponent;                              // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHolyLightComponent*                    HolyLightComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionLittleGameComponent*        LittleGameComponent;                               // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class AInteractionCharacter*> Characters;                                        // 0x0280(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             CameraLevelSequenceMapping;                        // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x50];                                     // 0x02D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ScenarioInitialTable;                              // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x4];                                      // 0x0330(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentPropName;                                   // 0x0334(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CurrentTransform;                                  // 0x0340(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UpdateingProp;                                     // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0xF];                                      // 0x0371(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0380(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class AInteractionDirector* GetInteractionDirector(class UObject* WorldContextObject);

	class AInteractionCharacter* CreateInteractionCharacter(TSubclassOf<class AInteractionCharacter> Type, class FName InteractionCharacterName);
	const struct FInteractionCollisionEventData GetCollisionEventData();
	class UInteractionLittleGameComponent* GetLittleGameComponent();
	struct FVector2D GetMousePosition();
	struct FVector2D GetMousePressPosition();
	bool HaveLittleGame();
	void RemoveInteractionCharacter(const class FName& Name_0);
	void SetIsInLittleGame(bool bIsInGame);
	void SetIsMouseInScreen(bool bInIsMouseInScreen);
	void SetIsMousePressed(bool bInIsMousePressed);
	void SetMousePosition(const struct FVector2D& Pos);
	void SetMousePressPosition(const struct FVector2D& Pos);
	void StartLittleGame(int32 ID);
	void StopLittleGame(bool bIsVictory);

	TMap<class FName, class AInteractionCharacter*> GetAllInteractionCharacters() const;
	class UInteractionArchivementComponent* GetArchivementComponent() const;
	class UHolyLightComponent* GetHolyLightComponent() const;
	class AInteractionCharacter* GetInteractionCharacterByName(const class FName& Name_0) const;
	bool IsInLittleGame() const;
	bool IsMobilePlatform() const;
	bool IsMouseInScreen() const;
	bool IsMousePressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDirector">();
	}
	static class AInteractionDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionDirector>();
	}
};
static_assert(alignof(AInteractionDirector) == 0x000010, "Wrong alignment on AInteractionDirector");
static_assert(sizeof(AInteractionDirector) == 0x0003B0, "Wrong size on AInteractionDirector");
static_assert(offsetof(AInteractionDirector, ArchivementComponent) == 0x000268, "Member 'AInteractionDirector::ArchivementComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, HolyLightComponent) == 0x000270, "Member 'AInteractionDirector::HolyLightComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, LittleGameComponent) == 0x000278, "Member 'AInteractionDirector::LittleGameComponent' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, Characters) == 0x000280, "Member 'AInteractionDirector::Characters' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, CameraLevelSequenceMapping) == 0x0002D0, "Member 'AInteractionDirector::CameraLevelSequenceMapping' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, ScenarioInitialTable) == 0x000328, "Member 'AInteractionDirector::ScenarioInitialTable' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, CurrentPropName) == 0x000334, "Member 'AInteractionDirector::CurrentPropName' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, CurrentTransform) == 0x000340, "Member 'AInteractionDirector::CurrentTransform' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, UpdateingProp) == 0x000370, "Member 'AInteractionDirector::UpdateingProp' has a wrong offset!");
static_assert(offsetof(AInteractionDirector, HitTransform) == 0x000380, "Member 'AInteractionDirector::HitTransform' has a wrong offset!");

// Class CharacterInteraction.InteractionHeadAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UInteractionHeadAnimInstance final : public UAnimInstance
{
public:
	struct FVector2D                              MouseFollowEyeOffset;                              // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          AnimStandBy;                                       // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            EyeBlend;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionHeadAnimInstance">();
	}
	static class UInteractionHeadAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionHeadAnimInstance>();
	}
};
static_assert(alignof(UInteractionHeadAnimInstance) == 0x000010, "Wrong alignment on UInteractionHeadAnimInstance");
static_assert(sizeof(UInteractionHeadAnimInstance) == 0x0002D0, "Wrong size on UInteractionHeadAnimInstance");
static_assert(offsetof(UInteractionHeadAnimInstance, MouseFollowEyeOffset) == 0x0002B8, "Member 'UInteractionHeadAnimInstance::MouseFollowEyeOffset' has a wrong offset!");
static_assert(offsetof(UInteractionHeadAnimInstance, AnimStandBy) == 0x0002C0, "Member 'UInteractionHeadAnimInstance::AnimStandBy' has a wrong offset!");
static_assert(offsetof(UInteractionHeadAnimInstance, EyeBlend) == 0x0002C8, "Member 'UInteractionHeadAnimInstance::EyeBlend' has a wrong offset!");

// Class CharacterInteraction.InteractionLib
// 0x0000 (0x0028 - 0x0028)
class UInteractionLib final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateQuadraticBezierPoint(float T, const struct FVector& P0, const struct FVector& P1, const struct FVector& P2);
	static class UAnimSequence* GetCharacterAnimation(const class FString& AnimName, const class FString& GirlName, const class FString& SkinAnimNameSuffix);
	static TArray<struct FCanvasUVTri> GetSkeletonMeshTriangle(class USkeletalMeshComponent* Mesh, const struct FVector2D& CanvasSize, const struct FVector& WorldPosition, const struct FVector& Dir, struct FVector2D* HitPosition, bool* Hit, int32 LOD);
	static void GetSkeletonTriangleInfo(class USkeletalMeshComponent* Mesh, const struct FVector& WorldPosition, const struct FVector& Dir, struct FVector2D* HitUV, struct FLinearColor* HitColor, bool* Hit, int32 LOD);
	static void NotifyEasterEggSequence(const class ULevelSequence* EasterEgg);
	static void NotifyLeaveFeatureScenario();
	static void NotifyOperateState(int32 State);
	static void NotifyTutorialPlayShowSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLib">();
	}
	static class UInteractionLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLib>();
	}
};
static_assert(alignof(UInteractionLib) == 0x000008, "Wrong alignment on UInteractionLib");
static_assert(sizeof(UInteractionLib) == 0x000028, "Wrong size on UInteractionLib");

// Class CharacterInteraction.InteractionLittleGame
// 0x0030 (0x0058 - 0x0028)
class UInteractionLittleGame : public UObject
{
public:
	ELittleGameInputType                          GameInputType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIType;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ButtonPosition;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterGame(int32 ID);
	void LeaveGame();
	void UpdateGame(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLittleGame">();
	}
	static class UInteractionLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLittleGame>();
	}
};
static_assert(alignof(UInteractionLittleGame) == 0x000008, "Wrong alignment on UInteractionLittleGame");
static_assert(sizeof(UInteractionLittleGame) == 0x000058, "Wrong size on UInteractionLittleGame");
static_assert(offsetof(UInteractionLittleGame, GameInputType) == 0x000028, "Member 'UInteractionLittleGame::GameInputType' has a wrong offset!");
static_assert(offsetof(UInteractionLittleGame, UIType) == 0x000030, "Member 'UInteractionLittleGame::UIType' has a wrong offset!");
static_assert(offsetof(UInteractionLittleGame, ButtonPosition) == 0x000040, "Member 'UInteractionLittleGame::ButtonPosition' has a wrong offset!");
static_assert(offsetof(UInteractionLittleGame, DelayTime) == 0x000050, "Member 'UInteractionLittleGame::DelayTime' has a wrong offset!");

// Class CharacterInteraction.InteractionLittleGameAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionLittleGameAsset final : public UDataAsset
{
public:
	class UInteractionLittleGame*                 LittleGameData;                                    // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLittleGameAsset">();
	}
	static class UInteractionLittleGameAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLittleGameAsset>();
	}
};
static_assert(alignof(UInteractionLittleGameAsset) == 0x000008, "Wrong alignment on UInteractionLittleGameAsset");
static_assert(sizeof(UInteractionLittleGameAsset) == 0x000038, "Wrong size on UInteractionLittleGameAsset");
static_assert(offsetof(UInteractionLittleGameAsset, LittleGameData) == 0x000030, "Member 'UInteractionLittleGameAsset::LittleGameData' has a wrong offset!");

// Class CharacterInteraction.InteractionLittleGameComponent
// 0x0010 (0x00C0 - 0x00B0)
class UInteractionLittleGameComponent final : public UActorComponent
{
public:
	bool                                          bIsInLittleGame;                                   // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionLittleGame*                 CurLittleGame;                                     // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Clear();
	void SetIsInLittleGame(bool bIsInGame);
	void StartLittleGame(int32 ID);
	void StopLittleGame();

	bool GetIsInLittleGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLittleGameComponent">();
	}
	static class UInteractionLittleGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLittleGameComponent>();
	}
};
static_assert(alignof(UInteractionLittleGameComponent) == 0x000008, "Wrong alignment on UInteractionLittleGameComponent");
static_assert(sizeof(UInteractionLittleGameComponent) == 0x0000C0, "Wrong size on UInteractionLittleGameComponent");
static_assert(offsetof(UInteractionLittleGameComponent, bIsInLittleGame) == 0x0000B0, "Member 'UInteractionLittleGameComponent::bIsInLittleGame' has a wrong offset!");
static_assert(offsetof(UInteractionLittleGameComponent, CurLittleGame) == 0x0000B8, "Member 'UInteractionLittleGameComponent::CurLittleGame' has a wrong offset!");

// Class CharacterInteraction.OverridePhysicsControl
// 0x0178 (0x01A8 - 0x0030)
class UOverridePhysicsControl final : public UDataAsset
{
public:
	TSoftObjectPtr<class UPhysicsAsset>           OverridePhysicsAsset;                              // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsControlLimbSetupData>   LimbSetupData;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FParamNameToSet>     BodyModifiersToSet;                                // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMovementTypeInSet>             MovementTypesInSet;                                // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FParamNameToSet>     ControlToSet;                                      // 0x00C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FControlDataInSet>              InSetControlData;                                  // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlData                    WorldSpaceControlData;                             // 0x0128(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                WorldSpaceControlSettings;                         // 0x0148(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldSpaceControls;                         // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicsControlData                    ParentSpaceControlData;                            // 0x0164(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPhysicsControlSettings                ParentSpaceControlSettings;                        // 0x0184(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableParentSpaceControls;                        // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsMovementType                          PhysicsMovementType;                               // 0x019D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E[0x2];                                      // 0x019E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityMultiplier;                                 // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverridePhysicsControl">();
	}
	static class UOverridePhysicsControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverridePhysicsControl>();
	}
};
static_assert(alignof(UOverridePhysicsControl) == 0x000008, "Wrong alignment on UOverridePhysicsControl");
static_assert(sizeof(UOverridePhysicsControl) == 0x0001A8, "Wrong size on UOverridePhysicsControl");
static_assert(offsetof(UOverridePhysicsControl, OverridePhysicsAsset) == 0x000030, "Member 'UOverridePhysicsControl::OverridePhysicsAsset' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, LimbSetupData) == 0x000058, "Member 'UOverridePhysicsControl::LimbSetupData' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, BodyModifiersToSet) == 0x000068, "Member 'UOverridePhysicsControl::BodyModifiersToSet' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, MovementTypesInSet) == 0x0000B8, "Member 'UOverridePhysicsControl::MovementTypesInSet' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, ControlToSet) == 0x0000C8, "Member 'UOverridePhysicsControl::ControlToSet' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, InSetControlData) == 0x000118, "Member 'UOverridePhysicsControl::InSetControlData' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, WorldSpaceControlData) == 0x000128, "Member 'UOverridePhysicsControl::WorldSpaceControlData' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, WorldSpaceControlSettings) == 0x000148, "Member 'UOverridePhysicsControl::WorldSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, bEnableWorldSpaceControls) == 0x000160, "Member 'UOverridePhysicsControl::bEnableWorldSpaceControls' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, ParentSpaceControlData) == 0x000164, "Member 'UOverridePhysicsControl::ParentSpaceControlData' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, ParentSpaceControlSettings) == 0x000184, "Member 'UOverridePhysicsControl::ParentSpaceControlSettings' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, bEnableParentSpaceControls) == 0x00019C, "Member 'UOverridePhysicsControl::bEnableParentSpaceControls' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, PhysicsMovementType) == 0x00019D, "Member 'UOverridePhysicsControl::PhysicsMovementType' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, GravityMultiplier) == 0x0001A0, "Member 'UOverridePhysicsControl::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(UOverridePhysicsControl, PhysicsBlendWeight) == 0x0001A4, "Member 'UOverridePhysicsControl::PhysicsBlendWeight' has a wrong offset!");

// Class CharacterInteraction.PhyOperate
// 0x0000 (0x0028 - 0x0028)
class UPhyOperate final : public UObject
{
public:
	void DoEndOperate(class AInteractionCharacter* Character);
	void DoStartOperate(class AInteractionCharacter* Character);
	void DoUpdateOperate(class AInteractionCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhyOperate">();
	}
	static class UPhyOperate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhyOperate>();
	}
};
static_assert(alignof(UPhyOperate) == 0x000008, "Wrong alignment on UPhyOperate");
static_assert(sizeof(UPhyOperate) == 0x000028, "Wrong size on UPhyOperate");

// Class CharacterInteraction.PhysicsControlDataProfiles
// 0x0050 (0x0080 - 0x0030)
class UPhysicsControlDataProfiles final : public UDataAsset
{
public:
	TMap<class FName, struct FPhysicsControlControlAndModifierUpdates> Profiles;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsControlDataProfiles">();
	}
	static class UPhysicsControlDataProfiles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsControlDataProfiles>();
	}
};
static_assert(alignof(UPhysicsControlDataProfiles) == 0x000008, "Wrong alignment on UPhysicsControlDataProfiles");
static_assert(sizeof(UPhysicsControlDataProfiles) == 0x000080, "Wrong size on UPhysicsControlDataProfiles");
static_assert(offsetof(UPhysicsControlDataProfiles, Profiles) == 0x000030, "Member 'UPhysicsControlDataProfiles::Profiles' has a wrong offset!");

// Class CharacterInteraction.PhyOperateAsset
// 0x0050 (0x0080 - 0x0030)
class UPhyOperateAsset final : public UDataAsset
{
public:
	TMap<class FName, class UPhyOperate*>         PhyOperates;                                       // 0x0030(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhyOperateAsset">();
	}
	static class UPhyOperateAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhyOperateAsset>();
	}
};
static_assert(alignof(UPhyOperateAsset) == 0x000008, "Wrong alignment on UPhyOperateAsset");
static_assert(sizeof(UPhyOperateAsset) == 0x000080, "Wrong size on UPhyOperateAsset");
static_assert(offsetof(UPhyOperateAsset, PhyOperates) == 0x000030, "Member 'UPhyOperateAsset::PhyOperates' has a wrong offset!");

// Class CharacterInteraction.PhyControlDataTemplateSet
// 0x0050 (0x0080 - 0x0030)
class UPhyControlDataTemplateSet final : public UDataAsset
{
public:
	TMap<class FName, struct FPhysicsControlData> ControlDatas;                                      // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhyControlDataTemplateSet">();
	}
	static class UPhyControlDataTemplateSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhyControlDataTemplateSet>();
	}
};
static_assert(alignof(UPhyControlDataTemplateSet) == 0x000008, "Wrong alignment on UPhyControlDataTemplateSet");
static_assert(sizeof(UPhyControlDataTemplateSet) == 0x000080, "Wrong size on UPhyControlDataTemplateSet");
static_assert(offsetof(UPhyControlDataTemplateSet, ControlDatas) == 0x000030, "Member 'UPhyControlDataTemplateSet::ControlDatas' has a wrong offset!");

// Class CharacterInteraction.ExtraPhysicsBlendInterface
// 0x0000 (0x0028 - 0x0028)
class IExtraPhysicsBlendInterface final : public IInterface
{
public:
	void ExtraEndBlend();
	void ExtraStartBlend();
	void ExtraUpdatingBlend(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtraPhysicsBlendInterface">();
	}
	static class IExtraPhysicsBlendInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExtraPhysicsBlendInterface>();
	}
};
static_assert(alignof(IExtraPhysicsBlendInterface) == 0x000008, "Wrong alignment on IExtraPhysicsBlendInterface");
static_assert(sizeof(IExtraPhysicsBlendInterface) == 0x000028, "Wrong size on IExtraPhysicsBlendInterface");

// Class CharacterInteraction.InteractionPhysComponent
// 0x0320 (0x03D0 - 0x00B0)
class UInteractionPhysComponent final : public UActorComponent
{
public:
	struct FVector                                DeltaLocation;                                     // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DragLocation;                                      // 0x00BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DragBoneName;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DragLocationBoneName;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragScale;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDraging;                                        // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOverridePhysicsControl> PhysicsControlConfig;                              // 0x00E0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             InteractionPhysTable;                              // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AInteractionCharacter*                  Owner;                                             // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsControlComponent*               TargetPcc;                                         // 0x0118(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitPhysics;                                      // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsControlDataProfiles*            PhysicsControlDataProfiles;                        // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhyOperateAsset*                       PhyOperateAsset;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPhyControlDataTemplateSet*>     PhyControlDataTemplateSets;                        // 0x0138(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FInteractionPhysicsControlData         InitParam;                                         // 0x0148(0x0188)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FPhysicsControlData> ControlDataTemplates;                              // 0x02D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WorldSpaceCurve;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ParentSpaceCurve;                                  // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PhysicsWeightBlendCurve;                           // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimeline                              Timeline;                                          // 0x0338(0x0098)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void CreatePhysicsControl(const struct FInteractionPhysicsControlData& Data);
	void DestroyPhysicsControl();
	void DisableBreastPhysicsControl();
	void DisableHipPhysicsControl();
	void GetControlDataTemplate(const class FName& Name_0, bool* bHasData, struct FPhysicsControlData* OutData);
	void InitPhysicsControl();
	void InitTineLine();
	bool InvokeControlProfile(class FName ProfileName);
	bool IsEnableBreastPhy();
	bool IsEnableHipPhy();
	void OnTimelineFinished();
	void PlayTimeLineFromStart(float TimelineLength);
	void StopPhysicsBlendTimeLine();
	void TimelineReturn_SetParentMultipliers(float Value);
	void TimelineReturn_SetPhysicsBlendWeight(float Value);
	void TimelineReturn_SetWorldMultipliers(float Value);
	void UpdateBodyModifiersMovementType(float Duration, bool bIsEnable);

	struct FInteractionPhysicsControlData GetInitParam() const;
	const struct FInteractionPhysicsControlData GetInteractionPhysConfig(class FName ID) const;
	class UPhysicsControlDataProfiles* GetPhysicsControlProfiles() const;
	class UPhysicsControlComponent* GetTargetPcc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPhysComponent">();
	}
	static class UInteractionPhysComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionPhysComponent>();
	}
};
static_assert(alignof(UInteractionPhysComponent) == 0x000008, "Wrong alignment on UInteractionPhysComponent");
static_assert(sizeof(UInteractionPhysComponent) == 0x0003D0, "Wrong size on UInteractionPhysComponent");
static_assert(offsetof(UInteractionPhysComponent, DeltaLocation) == 0x0000B0, "Member 'UInteractionPhysComponent::DeltaLocation' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, DragLocation) == 0x0000BC, "Member 'UInteractionPhysComponent::DragLocation' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, DragBoneName) == 0x0000C8, "Member 'UInteractionPhysComponent::DragBoneName' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, DragLocationBoneName) == 0x0000D0, "Member 'UInteractionPhysComponent::DragLocationBoneName' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, DragScale) == 0x0000D8, "Member 'UInteractionPhysComponent::DragScale' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, bIsDraging) == 0x0000DC, "Member 'UInteractionPhysComponent::bIsDraging' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, PhysicsControlConfig) == 0x0000E0, "Member 'UInteractionPhysComponent::PhysicsControlConfig' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, InteractionPhysTable) == 0x000108, "Member 'UInteractionPhysComponent::InteractionPhysTable' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, Owner) == 0x000110, "Member 'UInteractionPhysComponent::Owner' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, TargetPcc) == 0x000118, "Member 'UInteractionPhysComponent::TargetPcc' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, bInitPhysics) == 0x000120, "Member 'UInteractionPhysComponent::bInitPhysics' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, PhysicsControlDataProfiles) == 0x000128, "Member 'UInteractionPhysComponent::PhysicsControlDataProfiles' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, PhyOperateAsset) == 0x000130, "Member 'UInteractionPhysComponent::PhyOperateAsset' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, PhyControlDataTemplateSets) == 0x000138, "Member 'UInteractionPhysComponent::PhyControlDataTemplateSets' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, InitParam) == 0x000148, "Member 'UInteractionPhysComponent::InitParam' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, ControlDataTemplates) == 0x0002D0, "Member 'UInteractionPhysComponent::ControlDataTemplates' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, WorldSpaceCurve) == 0x000320, "Member 'UInteractionPhysComponent::WorldSpaceCurve' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, ParentSpaceCurve) == 0x000328, "Member 'UInteractionPhysComponent::ParentSpaceCurve' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, PhysicsWeightBlendCurve) == 0x000330, "Member 'UInteractionPhysComponent::PhysicsWeightBlendCurve' has a wrong offset!");
static_assert(offsetof(UInteractionPhysComponent, Timeline) == 0x000338, "Member 'UInteractionPhysComponent::Timeline' has a wrong offset!");

// Class CharacterInteraction.InteractionEventContext
// 0x0010 (0x0038 - 0x0028)
class UInteractionEventContext : public UObject
{
public:
	class AInteractionCharacter*                  Character;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterInteractionComponent*         Comp;                                              // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionEventContext">();
	}
	static class UInteractionEventContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionEventContext>();
	}
};
static_assert(alignof(UInteractionEventContext) == 0x000008, "Wrong alignment on UInteractionEventContext");
static_assert(sizeof(UInteractionEventContext) == 0x000038, "Wrong size on UInteractionEventContext");
static_assert(offsetof(UInteractionEventContext, Character) == 0x000028, "Member 'UInteractionEventContext::Character' has a wrong offset!");
static_assert(offsetof(UInteractionEventContext, Comp) == 0x000030, "Member 'UInteractionEventContext::Comp' has a wrong offset!");

// Class CharacterInteraction.InteractionOperateEventContext
// 0x0008 (0x0040 - 0x0038)
class UInteractionOperateEventContext final : public UInteractionEventContext
{
public:
	class UInteractionOperate*                    Interaction;                                       // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateEventContext">();
	}
	static class UInteractionOperateEventContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateEventContext>();
	}
};
static_assert(alignof(UInteractionOperateEventContext) == 0x000008, "Wrong alignment on UInteractionOperateEventContext");
static_assert(sizeof(UInteractionOperateEventContext) == 0x000040, "Wrong size on UInteractionOperateEventContext");
static_assert(offsetof(UInteractionOperateEventContext, Interaction) == 0x000038, "Member 'UInteractionOperateEventContext::Interaction' has a wrong offset!");

// Class CharacterInteraction.InteractionShowEventContext
// 0x0000 (0x0038 - 0x0038)
class UInteractionShowEventContext final : public UInteractionEventContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionShowEventContext">();
	}
	static class UInteractionShowEventContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionShowEventContext>();
	}
};
static_assert(alignof(UInteractionShowEventContext) == 0x000008, "Wrong alignment on UInteractionShowEventContext");
static_assert(sizeof(UInteractionShowEventContext) == 0x000038, "Wrong size on UInteractionShowEventContext");

// Class CharacterInteraction.InteractionStandByEventContext
// 0x0000 (0x0038 - 0x0038)
class UInteractionStandByEventContext final : public UInteractionEventContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStandByEventContext">();
	}
	static class UInteractionStandByEventContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStandByEventContext>();
	}
};
static_assert(alignof(UInteractionStandByEventContext) == 0x000008, "Wrong alignment on UInteractionStandByEventContext");
static_assert(sizeof(UInteractionStandByEventContext) == 0x000038, "Wrong size on UInteractionStandByEventContext");

// Class CharacterInteraction.InteractionAction
// 0x0000 (0x0028 - 0x0028)
class UInteractionAction : public UObject
{
public:
	void DoAction(class UInteractionEventContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAction">();
	}
	static class UInteractionAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAction>();
	}
};
static_assert(alignof(UInteractionAction) == 0x000008, "Wrong alignment on UInteractionAction");
static_assert(sizeof(UInteractionAction) == 0x000028, "Wrong size on UInteractionAction");

// Class CharacterInteraction.PlayShowSequenceAction
// 0x0008 (0x0030 - 0x0028)
class UPlayShowSequenceAction final : public UInteractionAction
{
public:
	int32                                         ShowSequenceID;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyTutorialShowSequence;                       // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayShowSequenceAction">();
	}
	static class UPlayShowSequenceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayShowSequenceAction>();
	}
};
static_assert(alignof(UPlayShowSequenceAction) == 0x000008, "Wrong alignment on UPlayShowSequenceAction");
static_assert(sizeof(UPlayShowSequenceAction) == 0x000030, "Wrong size on UPlayShowSequenceAction");
static_assert(offsetof(UPlayShowSequenceAction, ShowSequenceID) == 0x000028, "Member 'UPlayShowSequenceAction::ShowSequenceID' has a wrong offset!");
static_assert(offsetof(UPlayShowSequenceAction, bNotifyTutorialShowSequence) == 0x00002C, "Member 'UPlayShowSequenceAction::bNotifyTutorialShowSequence' has a wrong offset!");

// Class CharacterInteraction.SyncPlayShowSequenceAction
// 0x0020 (0x0048 - 0x0028)
class USyncPlayShowSequenceAction final : public UInteractionAction
{
public:
	int32                                         SelfShowSequenceID;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSyncPlayData>                  SyncPlayData;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bNotifyTutorialShowSequence;                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SyncPlayShowSequenceAction">();
	}
	static class USyncPlayShowSequenceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USyncPlayShowSequenceAction>();
	}
};
static_assert(alignof(USyncPlayShowSequenceAction) == 0x000008, "Wrong alignment on USyncPlayShowSequenceAction");
static_assert(sizeof(USyncPlayShowSequenceAction) == 0x000048, "Wrong size on USyncPlayShowSequenceAction");
static_assert(offsetof(USyncPlayShowSequenceAction, SelfShowSequenceID) == 0x000028, "Member 'USyncPlayShowSequenceAction::SelfShowSequenceID' has a wrong offset!");
static_assert(offsetof(USyncPlayShowSequenceAction, SyncPlayData) == 0x000030, "Member 'USyncPlayShowSequenceAction::SyncPlayData' has a wrong offset!");
static_assert(offsetof(USyncPlayShowSequenceAction, bNotifyTutorialShowSequence) == 0x000040, "Member 'USyncPlayShowSequenceAction::bNotifyTutorialShowSequence' has a wrong offset!");

// Class CharacterInteraction.ChangeStandByAction
// 0x0008 (0x0030 - 0x0028)
class UChangeStandByAction final : public UInteractionAction
{
public:
	int32                                         StandByID;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeStandByAction">();
	}
	static class UChangeStandByAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeStandByAction>();
	}
};
static_assert(alignof(UChangeStandByAction) == 0x000008, "Wrong alignment on UChangeStandByAction");
static_assert(sizeof(UChangeStandByAction) == 0x000030, "Wrong size on UChangeStandByAction");
static_assert(offsetof(UChangeStandByAction, StandByID) == 0x000028, "Member 'UChangeStandByAction::StandByID' has a wrong offset!");

// Class CharacterInteraction.InteractionCustomActionAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionCustomActionAsset final : public UDataAsset
{
public:
	class UInteractionAction*                     CustomAction;                                      // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCustomActionAsset">();
	}
	static class UInteractionCustomActionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCustomActionAsset>();
	}
};
static_assert(alignof(UInteractionCustomActionAsset) == 0x000008, "Wrong alignment on UInteractionCustomActionAsset");
static_assert(sizeof(UInteractionCustomActionAsset) == 0x000038, "Wrong size on UInteractionCustomActionAsset");
static_assert(offsetof(UInteractionCustomActionAsset, CustomAction) == 0x000030, "Member 'UInteractionCustomActionAsset::CustomAction' has a wrong offset!");

// Class CharacterInteraction.InteractionTrigger
// 0x0018 (0x0040 - 0x0028)
class UInteractionTrigger : public UObject
{
public:
	bool                                          bEnablePhysicsBlend;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendTime;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MultiplayerNames;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void PhysicsBlend(class UInteractionEventContext* Context) const;
	bool ShouldTrigger(class UInteractionEventContext* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionTrigger">();
	}
	static class UInteractionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionTrigger>();
	}
};
static_assert(alignof(UInteractionTrigger) == 0x000008, "Wrong alignment on UInteractionTrigger");
static_assert(sizeof(UInteractionTrigger) == 0x000040, "Wrong size on UInteractionTrigger");
static_assert(offsetof(UInteractionTrigger, bEnablePhysicsBlend) == 0x000028, "Member 'UInteractionTrigger::bEnablePhysicsBlend' has a wrong offset!");
static_assert(offsetof(UInteractionTrigger, BlendTime) == 0x00002C, "Member 'UInteractionTrigger::BlendTime' has a wrong offset!");
static_assert(offsetof(UInteractionTrigger, MultiplayerNames) == 0x000030, "Member 'UInteractionTrigger::MultiplayerNames' has a wrong offset!");

// Class CharacterInteraction.InteractionEmptyTrigger
// 0x0000 (0x0040 - 0x0040)
class UInteractionEmptyTrigger final : public UInteractionTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionEmptyTrigger">();
	}
	static class UInteractionEmptyTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionEmptyTrigger>();
	}
};
static_assert(alignof(UInteractionEmptyTrigger) == 0x000008, "Wrong alignment on UInteractionEmptyTrigger");
static_assert(sizeof(UInteractionEmptyTrigger) == 0x000040, "Wrong size on UInteractionEmptyTrigger");

// Class CharacterInteraction.InteractionOperateTrigger
// 0x0000 (0x0040 - 0x0040)
class UInteractionOperateTrigger : public UInteractionTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateTrigger">();
	}
	static class UInteractionOperateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateTrigger>();
	}
};
static_assert(alignof(UInteractionOperateTrigger) == 0x000008, "Wrong alignment on UInteractionOperateTrigger");
static_assert(sizeof(UInteractionOperateTrigger) == 0x000040, "Wrong size on UInteractionOperateTrigger");

// Class CharacterInteraction.InteractionDragTrigger
// 0x0010 (0x0050 - 0x0040)
class UInteractionDragTrigger final : public UInteractionOperateTrigger
{
public:
	struct FVector2D                              DragLimit;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionDragTriggerCompare                XCompareType;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionDragTriggerCompare                YCompareType;                                      // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompareLength;                                  // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDragTrigger">();
	}
	static class UInteractionDragTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDragTrigger>();
	}
};
static_assert(alignof(UInteractionDragTrigger) == 0x000008, "Wrong alignment on UInteractionDragTrigger");
static_assert(sizeof(UInteractionDragTrigger) == 0x000050, "Wrong size on UInteractionDragTrigger");
static_assert(offsetof(UInteractionDragTrigger, DragLimit) == 0x000040, "Member 'UInteractionDragTrigger::DragLimit' has a wrong offset!");
static_assert(offsetof(UInteractionDragTrigger, XCompareType) == 0x000048, "Member 'UInteractionDragTrigger::XCompareType' has a wrong offset!");
static_assert(offsetof(UInteractionDragTrigger, YCompareType) == 0x000049, "Member 'UInteractionDragTrigger::YCompareType' has a wrong offset!");
static_assert(offsetof(UInteractionDragTrigger, bIsCompareLength) == 0x00004A, "Member 'UInteractionDragTrigger::bIsCompareLength' has a wrong offset!");

// Class CharacterInteraction.PlayAnimsequenceTrigger
// 0x0008 (0x0048 - 0x0040)
class UPlayAnimsequenceTrigger final : public UInteractionOperateTrigger
{
public:
	float                                         Threshold;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAnimsequenceTrigger">();
	}
	static class UPlayAnimsequenceTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAnimsequenceTrigger>();
	}
};
static_assert(alignof(UPlayAnimsequenceTrigger) == 0x000008, "Wrong alignment on UPlayAnimsequenceTrigger");
static_assert(sizeof(UPlayAnimsequenceTrigger) == 0x000048, "Wrong size on UPlayAnimsequenceTrigger");
static_assert(offsetof(UPlayAnimsequenceTrigger, Threshold) == 0x000040, "Member 'UPlayAnimsequenceTrigger::Threshold' has a wrong offset!");

// Class CharacterInteraction.InteractionShowTrigger
// 0x0000 (0x0040 - 0x0040)
class UInteractionShowTrigger : public UInteractionTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionShowTrigger">();
	}
	static class UInteractionShowTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionShowTrigger>();
	}
};
static_assert(alignof(UInteractionShowTrigger) == 0x000008, "Wrong alignment on UInteractionShowTrigger");
static_assert(sizeof(UInteractionShowTrigger) == 0x000040, "Wrong size on UInteractionShowTrigger");

// Class CharacterInteraction.InteractionShowTrueTrigger
// 0x0000 (0x0040 - 0x0040)
class UInteractionShowTrueTrigger final : public UInteractionShowTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionShowTrueTrigger">();
	}
	static class UInteractionShowTrueTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionShowTrueTrigger>();
	}
};
static_assert(alignof(UInteractionShowTrueTrigger) == 0x000008, "Wrong alignment on UInteractionShowTrueTrigger");
static_assert(sizeof(UInteractionShowTrueTrigger) == 0x000040, "Wrong size on UInteractionShowTrueTrigger");

// Class CharacterInteraction.InteractionEvent
// 0x0018 (0x0040 - 0x0028)
class UInteractionEvent : public UObject
{
public:
	class UInteractionTrigger*                    Trigger;                                           // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionAction*                     Action;                                            // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsTriggered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionEvent">();
	}
	static class UInteractionEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionEvent>();
	}
};
static_assert(alignof(UInteractionEvent) == 0x000008, "Wrong alignment on UInteractionEvent");
static_assert(sizeof(UInteractionEvent) == 0x000040, "Wrong size on UInteractionEvent");
static_assert(offsetof(UInteractionEvent, Trigger) == 0x000028, "Member 'UInteractionEvent::Trigger' has a wrong offset!");
static_assert(offsetof(UInteractionEvent, Action) == 0x000030, "Member 'UInteractionEvent::Action' has a wrong offset!");

// Class CharacterInteraction.InteractionOperateEvent
// 0x0008 (0x0048 - 0x0040)
class UInteractionOperateEvent final : public UInteractionEvent
{
public:
	EInteractionOperateEventType                  EventType;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateEvent">();
	}
	static class UInteractionOperateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateEvent>();
	}
};
static_assert(alignof(UInteractionOperateEvent) == 0x000008, "Wrong alignment on UInteractionOperateEvent");
static_assert(sizeof(UInteractionOperateEvent) == 0x000048, "Wrong size on UInteractionOperateEvent");
static_assert(offsetof(UInteractionOperateEvent, EventType) == 0x000040, "Member 'UInteractionOperateEvent::EventType' has a wrong offset!");

// Class CharacterInteraction.InteractionOperateEventAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionOperateEventAsset final : public UDataAsset
{
public:
	class UInteractionOperateEvent*               InteractionEvent;                                  // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateEventAsset">();
	}
	static class UInteractionOperateEventAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateEventAsset>();
	}
};
static_assert(alignof(UInteractionOperateEventAsset) == 0x000008, "Wrong alignment on UInteractionOperateEventAsset");
static_assert(sizeof(UInteractionOperateEventAsset) == 0x000038, "Wrong size on UInteractionOperateEventAsset");
static_assert(offsetof(UInteractionOperateEventAsset, InteractionEvent) == 0x000030, "Member 'UInteractionOperateEventAsset::InteractionEvent' has a wrong offset!");

// Class CharacterInteraction.InteractionShowEvent
// 0x0008 (0x0048 - 0x0040)
class UInteractionShowEvent final : public UInteractionEvent
{
public:
	EInteractionShowEventType                     EventType;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionShowEvent">();
	}
	static class UInteractionShowEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionShowEvent>();
	}
};
static_assert(alignof(UInteractionShowEvent) == 0x000008, "Wrong alignment on UInteractionShowEvent");
static_assert(sizeof(UInteractionShowEvent) == 0x000048, "Wrong size on UInteractionShowEvent");
static_assert(offsetof(UInteractionShowEvent, EventType) == 0x000040, "Member 'UInteractionShowEvent::EventType' has a wrong offset!");

// Class CharacterInteraction.InteractionShowEventAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionShowEventAsset final : public UDataAsset
{
public:
	class UInteractionShowEvent*                  InteractionEvent;                                  // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionShowEventAsset">();
	}
	static class UInteractionShowEventAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionShowEventAsset>();
	}
};
static_assert(alignof(UInteractionShowEventAsset) == 0x000008, "Wrong alignment on UInteractionShowEventAsset");
static_assert(sizeof(UInteractionShowEventAsset) == 0x000038, "Wrong size on UInteractionShowEventAsset");
static_assert(offsetof(UInteractionShowEventAsset, InteractionEvent) == 0x000030, "Member 'UInteractionShowEventAsset::InteractionEvent' has a wrong offset!");

// Class CharacterInteraction.InteractionStandByEvent
// 0x0008 (0x0048 - 0x0040)
class UInteractionStandByEvent final : public UInteractionEvent
{
public:
	EInteractionStandByEventType                  EventType;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStandByEvent">();
	}
	static class UInteractionStandByEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStandByEvent>();
	}
};
static_assert(alignof(UInteractionStandByEvent) == 0x000008, "Wrong alignment on UInteractionStandByEvent");
static_assert(sizeof(UInteractionStandByEvent) == 0x000048, "Wrong size on UInteractionStandByEvent");
static_assert(offsetof(UInteractionStandByEvent, EventType) == 0x000040, "Member 'UInteractionStandByEvent::EventType' has a wrong offset!");

// Class CharacterInteraction.InteractionStandByEventAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionStandByEventAsset final : public UDataAsset
{
public:
	class UInteractionStandByEvent*               InteractionEvent;                                  // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStandByEventAsset">();
	}
	static class UInteractionStandByEventAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStandByEventAsset>();
	}
};
static_assert(alignof(UInteractionStandByEventAsset) == 0x000008, "Wrong alignment on UInteractionStandByEventAsset");
static_assert(sizeof(UInteractionStandByEventAsset) == 0x000038, "Wrong size on UInteractionStandByEventAsset");
static_assert(offsetof(UInteractionStandByEventAsset, InteractionEvent) == 0x000030, "Member 'UInteractionStandByEventAsset::InteractionEvent' has a wrong offset!");

// Class CharacterInteraction.CustomShowElement
// 0x0000 (0x0028 - 0x0028)
class UCustomShowElement : public UObject
{
public:
	void EndShowElement(class AInteractionCharacter* Character);
	void PlayShowElement(class AInteractionCharacter* Character);
	void UpdateShowElement(class AInteractionCharacter* Character, float DeltaTime);

	bool IsShowEnd(class AInteractionCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomShowElement">();
	}
	static class UCustomShowElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomShowElement>();
	}
};
static_assert(alignof(UCustomShowElement) == 0x000008, "Wrong alignment on UCustomShowElement");
static_assert(sizeof(UCustomShowElement) == 0x000028, "Wrong size on UCustomShowElement");

// Class CharacterInteraction.CustomShowElementAsset
// 0x0008 (0x0038 - 0x0030)
class UCustomShowElementAsset final : public UDataAsset
{
public:
	class UCustomShowElement*                     CustomShowElement;                                 // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomShowElementAsset">();
	}
	static class UCustomShowElementAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomShowElementAsset>();
	}
};
static_assert(alignof(UCustomShowElementAsset) == 0x000008, "Wrong alignment on UCustomShowElementAsset");
static_assert(sizeof(UCustomShowElementAsset) == 0x000038, "Wrong size on UCustomShowElementAsset");
static_assert(offsetof(UCustomShowElementAsset, CustomShowElement) == 0x000030, "Member 'UCustomShowElementAsset::CustomShowElement' has a wrong offset!");

// Class CharacterInteraction.BlendShowElement
// 0x0038 (0x0060 - 0x0028)
class UBlendShowElement final : public UCustomShowElement
{
public:
	float                                         BlendTime;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimSequence>           TargetSeq;                                         // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendShowElement">();
	}
	static class UBlendShowElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendShowElement>();
	}
};
static_assert(alignof(UBlendShowElement) == 0x000008, "Wrong alignment on UBlendShowElement");
static_assert(sizeof(UBlendShowElement) == 0x000060, "Wrong size on UBlendShowElement");
static_assert(offsetof(UBlendShowElement, BlendTime) == 0x000028, "Member 'UBlendShowElement::BlendTime' has a wrong offset!");
static_assert(offsetof(UBlendShowElement, TargetSeq) == 0x000030, "Member 'UBlendShowElement::TargetSeq' has a wrong offset!");

// Class CharacterInteraction.ReplaceShow
// 0x0000 (0x0028 - 0x0028)
class UReplaceShow final : public UCustomShowElement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaceShow">();
	}
	static class UReplaceShow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplaceShow>();
	}
};
static_assert(alignof(UReplaceShow) == 0x000008, "Wrong alignment on UReplaceShow");
static_assert(sizeof(UReplaceShow) == 0x000028, "Wrong size on UReplaceShow");

// Class CharacterInteraction.ScenarioInitialActionBase
// 0x0000 (0x0028 - 0x0028)
class UScenarioInitialActionBase : public UObject
{
public:
	void DoAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioInitialActionBase">();
	}
	static class UScenarioInitialActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioInitialActionBase>();
	}
};
static_assert(alignof(UScenarioInitialActionBase) == 0x000008, "Wrong alignment on UScenarioInitialActionBase");
static_assert(sizeof(UScenarioInitialActionBase) == 0x000028, "Wrong size on UScenarioInitialActionBase");

// Class CharacterInteraction.ScenarioExitActionBase
// 0x0000 (0x0028 - 0x0028)
class UScenarioExitActionBase : public UObject
{
public:
	void DoAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioExitActionBase">();
	}
	static class UScenarioExitActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioExitActionBase>();
	}
};
static_assert(alignof(UScenarioExitActionBase) == 0x000008, "Wrong alignment on UScenarioExitActionBase");
static_assert(sizeof(UScenarioExitActionBase) == 0x000028, "Wrong size on UScenarioExitActionBase");

// Class CharacterInteraction.CreateActorAction
// 0x0010 (0x0038 - 0x0028)
class UCreateActorAction final : public UScenarioInitialActionBase
{
public:
	TArray<struct FScenarioCreateCharacterData>   InitialDatas;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateActorAction">();
	}
	static class UCreateActorAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateActorAction>();
	}
};
static_assert(alignof(UCreateActorAction) == 0x000008, "Wrong alignment on UCreateActorAction");
static_assert(sizeof(UCreateActorAction) == 0x000038, "Wrong size on UCreateActorAction");
static_assert(offsetof(UCreateActorAction, InitialDatas) == 0x000028, "Member 'UCreateActorAction::InitialDatas' has a wrong offset!");

// Class CharacterInteraction.RemoveActorAction
// 0x0010 (0x0038 - 0x0028)
class URemoveActorAction final : public UScenarioExitActionBase
{
public:
	TArray<struct FScenarioRemoveCharacterData>   RemoveDatas;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveActorAction">();
	}
	static class URemoveActorAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveActorAction>();
	}
};
static_assert(alignof(URemoveActorAction) == 0x000008, "Wrong alignment on URemoveActorAction");
static_assert(sizeof(URemoveActorAction) == 0x000038, "Wrong size on URemoveActorAction");
static_assert(offsetof(URemoveActorAction, RemoveDatas) == 0x000028, "Member 'URemoveActorAction::RemoveDatas' has a wrong offset!");

// Class CharacterInteraction.ScenarioInitilalActionAsset
// 0x0008 (0x0038 - 0x0030)
class UScenarioInitilalActionAsset final : public UDataAsset
{
public:
	class UScenarioInitialActionBase*             ScenarioInitialAction;                             // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioInitilalActionAsset">();
	}
	static class UScenarioInitilalActionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioInitilalActionAsset>();
	}
};
static_assert(alignof(UScenarioInitilalActionAsset) == 0x000008, "Wrong alignment on UScenarioInitilalActionAsset");
static_assert(sizeof(UScenarioInitilalActionAsset) == 0x000038, "Wrong size on UScenarioInitilalActionAsset");
static_assert(offsetof(UScenarioInitilalActionAsset, ScenarioInitialAction) == 0x000030, "Member 'UScenarioInitilalActionAsset::ScenarioInitialAction' has a wrong offset!");

// Class CharacterInteraction.ScenarioExitActionAsset
// 0x0008 (0x0038 - 0x0030)
class UScenarioExitActionAsset final : public UDataAsset
{
public:
	class UScenarioExitActionBase*                ScenarioInitialAction;                             // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScenarioExitActionAsset">();
	}
	static class UScenarioExitActionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScenarioExitActionAsset>();
	}
};
static_assert(alignof(UScenarioExitActionAsset) == 0x000008, "Wrong alignment on UScenarioExitActionAsset");
static_assert(sizeof(UScenarioExitActionAsset) == 0x000038, "Wrong size on UScenarioExitActionAsset");
static_assert(offsetof(UScenarioExitActionAsset, ScenarioInitialAction) == 0x000030, "Member 'UScenarioExitActionAsset::ScenarioInitialAction' has a wrong offset!");

// Class CharacterInteraction.InteractionOperateAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionOperateAsset final : public UDataAsset
{
public:
	class UInteractionOperate*                    Interaction;                                       // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOperateAsset">();
	}
	static class UInteractionOperateAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOperateAsset>();
	}
};
static_assert(alignof(UInteractionOperateAsset) == 0x000008, "Wrong alignment on UInteractionOperateAsset");
static_assert(sizeof(UInteractionOperateAsset) == 0x000038, "Wrong size on UInteractionOperateAsset");
static_assert(offsetof(UInteractionOperateAsset, Interaction) == 0x000030, "Member 'UInteractionOperateAsset::Interaction' has a wrong offset!");

// Class CharacterInteraction.InteractionLinkShowSequence
// 0x0008 (0x00D8 - 0x00D0)
class UInteractionLinkShowSequence final : public UInteractionOperate
{
public:
	int32                                         ShowSequenceID;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLinkShowSequence">();
	}
	static class UInteractionLinkShowSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLinkShowSequence>();
	}
};
static_assert(alignof(UInteractionLinkShowSequence) == 0x000008, "Wrong alignment on UInteractionLinkShowSequence");
static_assert(sizeof(UInteractionLinkShowSequence) == 0x0000D8, "Wrong size on UInteractionLinkShowSequence");
static_assert(offsetof(UInteractionLinkShowSequence, ShowSequenceID) == 0x0000D0, "Member 'UInteractionLinkShowSequence::ShowSequenceID' has a wrong offset!");

// Class CharacterInteraction.IKInteraction
// 0x0030 (0x0190 - 0x0160)
class UIKInteraction : public UDragInteraction
{
public:
	class FName                                   IKBoneName;                                        // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JointControl;                                      // 0x0168(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle;                                         // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SyncBoneNames;                                     // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKInteraction">();
	}
	static class UIKInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKInteraction>();
	}
};
static_assert(alignof(UIKInteraction) == 0x000008, "Wrong alignment on UIKInteraction");
static_assert(sizeof(UIKInteraction) == 0x000190, "Wrong size on UIKInteraction");
static_assert(offsetof(UIKInteraction, IKBoneName) == 0x000160, "Member 'UIKInteraction::IKBoneName' has a wrong offset!");
static_assert(offsetof(UIKInteraction, JointControl) == 0x000168, "Member 'UIKInteraction::JointControl' has a wrong offset!");
static_assert(offsetof(UIKInteraction, TiltAngle) == 0x000174, "Member 'UIKInteraction::TiltAngle' has a wrong offset!");
static_assert(offsetof(UIKInteraction, YawAngle) == 0x000178, "Member 'UIKInteraction::YawAngle' has a wrong offset!");
static_assert(offsetof(UIKInteraction, SyncBoneNames) == 0x000180, "Member 'UIKInteraction::SyncBoneNames' has a wrong offset!");

// Class CharacterInteraction.IKInteractionWithIKSynFix
// 0x0068 (0x01F8 - 0x0190)
class UIKInteractionWithIKSynFix final : public UIKInteraction
{
public:
	struct FRelativeIKData                        RelativeIKData;                                    // 0x0190(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        IKOffSet;                                          // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x50];                                     // 0x01A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKInteractionWithIKSynFix">();
	}
	static class UIKInteractionWithIKSynFix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKInteractionWithIKSynFix>();
	}
};
static_assert(alignof(UIKInteractionWithIKSynFix) == 0x000008, "Wrong alignment on UIKInteractionWithIKSynFix");
static_assert(sizeof(UIKInteractionWithIKSynFix) == 0x0001F8, "Wrong size on UIKInteractionWithIKSynFix");
static_assert(offsetof(UIKInteractionWithIKSynFix, RelativeIKData) == 0x000190, "Member 'UIKInteractionWithIKSynFix::RelativeIKData' has a wrong offset!");
static_assert(offsetof(UIKInteractionWithIKSynFix, IKOffSet) == 0x000198, "Member 'UIKInteractionWithIKSynFix::IKOffSet' has a wrong offset!");

// Class CharacterInteraction.IKInteractionTrace
// 0x0008 (0x0198 - 0x0190)
class UIKInteractionTrace final : public UIKInteraction
{
public:
	bool                                          bDownwardTrace;                                    // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceFixValue;                                     // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKInteractionTrace">();
	}
	static class UIKInteractionTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKInteractionTrace>();
	}
};
static_assert(alignof(UIKInteractionTrace) == 0x000008, "Wrong alignment on UIKInteractionTrace");
static_assert(sizeof(UIKInteractionTrace) == 0x000198, "Wrong size on UIKInteractionTrace");
static_assert(offsetof(UIKInteractionTrace, bDownwardTrace) == 0x000190, "Member 'UIKInteractionTrace::bDownwardTrace' has a wrong offset!");
static_assert(offsetof(UIKInteractionTrace, TraceFixValue) == 0x000194, "Member 'UIKInteractionTrace::TraceFixValue' has a wrong offset!");

// Class CharacterInteraction.IKInteractionJoint
// 0x0000 (0x0190 - 0x0190)
class UIKInteractionJoint final : public UIKInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKInteractionJoint">();
	}
	static class UIKInteractionJoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKInteractionJoint>();
	}
};
static_assert(alignof(UIKInteractionJoint) == 0x000008, "Wrong alignment on UIKInteractionJoint");
static_assert(sizeof(UIKInteractionJoint) == 0x000190, "Wrong size on UIKInteractionJoint");

// Class CharacterInteraction.InteractionPhysicalDrag
// 0x00B8 (0x0218 - 0x0160)
class UInteractionPhysicalDrag final : public UDragInteraction
{
public:
	class FName                                   DragBoneName;                                      // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DragLocationBoneName;                              // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragScale;                                         // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltAngle;                                         // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x9C];                                     // 0x017C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPhysicalDrag">();
	}
	static class UInteractionPhysicalDrag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionPhysicalDrag>();
	}
};
static_assert(alignof(UInteractionPhysicalDrag) == 0x000008, "Wrong alignment on UInteractionPhysicalDrag");
static_assert(sizeof(UInteractionPhysicalDrag) == 0x000218, "Wrong size on UInteractionPhysicalDrag");
static_assert(offsetof(UInteractionPhysicalDrag, DragBoneName) == 0x000160, "Member 'UInteractionPhysicalDrag::DragBoneName' has a wrong offset!");
static_assert(offsetof(UInteractionPhysicalDrag, DragLocationBoneName) == 0x000168, "Member 'UInteractionPhysicalDrag::DragLocationBoneName' has a wrong offset!");
static_assert(offsetof(UInteractionPhysicalDrag, DragScale) == 0x000170, "Member 'UInteractionPhysicalDrag::DragScale' has a wrong offset!");
static_assert(offsetof(UInteractionPhysicalDrag, TiltAngle) == 0x000174, "Member 'UInteractionPhysicalDrag::TiltAngle' has a wrong offset!");
static_assert(offsetof(UInteractionPhysicalDrag, YawAngle) == 0x000178, "Member 'UInteractionPhysicalDrag::YawAngle' has a wrong offset!");

// Class CharacterInteraction.BlendspaceInteraction
// 0x0038 (0x0198 - 0x0160)
class UBlendspaceInteraction final : public UDragInteraction
{
public:
	TSoftObjectPtr<class UBlendSpace>             BlendSpace;                                        // 0x0160(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UBlendSpace>>     BlendSpaces;                                       // 0x0188(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendspaceInteraction">();
	}
	static class UBlendspaceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendspaceInteraction>();
	}
};
static_assert(alignof(UBlendspaceInteraction) == 0x000008, "Wrong alignment on UBlendspaceInteraction");
static_assert(sizeof(UBlendspaceInteraction) == 0x000198, "Wrong size on UBlendspaceInteraction");
static_assert(offsetof(UBlendspaceInteraction, BlendSpace) == 0x000160, "Member 'UBlendspaceInteraction::BlendSpace' has a wrong offset!");
static_assert(offsetof(UBlendspaceInteraction, BlendSpaces) == 0x000188, "Member 'UBlendspaceInteraction::BlendSpaces' has a wrong offset!");

// Class CharacterInteraction.HeadModifyInteraction
// 0x00B8 (0x0218 - 0x0160)
class UHeadModifyInteraction final : public UDragInteraction
{
public:
	bool                                          UseYawChange;                                      // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FModifyHeadSyncIK>              SyncIKDatas;                                       // 0x0168(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x50];                                     // 0x0178(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      Weights;                                           // 0x01C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadModifyInteraction">();
	}
	static class UHeadModifyInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadModifyInteraction>();
	}
};
static_assert(alignof(UHeadModifyInteraction) == 0x000008, "Wrong alignment on UHeadModifyInteraction");
static_assert(sizeof(UHeadModifyInteraction) == 0x000218, "Wrong size on UHeadModifyInteraction");
static_assert(offsetof(UHeadModifyInteraction, UseYawChange) == 0x000160, "Member 'UHeadModifyInteraction::UseYawChange' has a wrong offset!");
static_assert(offsetof(UHeadModifyInteraction, SyncIKDatas) == 0x000168, "Member 'UHeadModifyInteraction::SyncIKDatas' has a wrong offset!");
static_assert(offsetof(UHeadModifyInteraction, Weights) == 0x0001C8, "Member 'UHeadModifyInteraction::Weights' has a wrong offset!");

// Class CharacterInteraction.MouseFollowScenarioData
// 0x0050 (0x0080 - 0x0030)
class UMouseFollowScenarioData final : public UDataAsset
{
public:
	TMap<int32, class UMouseFollowInteraction*>   ScenarioConfigs;                                   // 0x0030(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseFollowScenarioData">();
	}
	static class UMouseFollowScenarioData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseFollowScenarioData>();
	}
};
static_assert(alignof(UMouseFollowScenarioData) == 0x000008, "Wrong alignment on UMouseFollowScenarioData");
static_assert(sizeof(UMouseFollowScenarioData) == 0x000080, "Wrong size on UMouseFollowScenarioData");
static_assert(offsetof(UMouseFollowScenarioData, ScenarioConfigs) == 0x000030, "Member 'UMouseFollowScenarioData::ScenarioConfigs' has a wrong offset!");

// Class CharacterInteraction.MouseFollowInteraction
// 0x0020 (0x0180 - 0x0160)
class UMouseFollowInteraction final : public UDragInteraction
{
public:
	struct FVector2D                              HeadOffSetScale;                                   // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMouseFollowInteraction*                DefaultValue;                                      // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMouseFollowScenarioData*               ScenarioData;                                      // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseFollowInteraction">();
	}
	static class UMouseFollowInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseFollowInteraction>();
	}
};
static_assert(alignof(UMouseFollowInteraction) == 0x000008, "Wrong alignment on UMouseFollowInteraction");
static_assert(sizeof(UMouseFollowInteraction) == 0x000180, "Wrong size on UMouseFollowInteraction");
static_assert(offsetof(UMouseFollowInteraction, HeadOffSetScale) == 0x000160, "Member 'UMouseFollowInteraction::HeadOffSetScale' has a wrong offset!");
static_assert(offsetof(UMouseFollowInteraction, DefaultValue) == 0x000168, "Member 'UMouseFollowInteraction::DefaultValue' has a wrong offset!");
static_assert(offsetof(UMouseFollowInteraction, ScenarioData) == 0x000170, "Member 'UMouseFollowInteraction::ScenarioData' has a wrong offset!");

// Class CharacterInteraction.InteractionLoopAnim
// 0x00D0 (0x01A0 - 0x00D0)
class UInteractionLoopAnim final : public UInteractionOperate
{
public:
	TSoftObjectPtr<class UAnimSequence>           EndAnim;                                           // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EndMontage;                                        // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            LoopMontageRes;                                    // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopMontage;                                       // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimSequence>           FaceEndAnim;                                       // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FaceEndMontage;                                    // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            FaceLoopMontageRes;                                // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FaceLoopMontage;                                   // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCloseInteractionInAnimPlaying;                    // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCloseKawaii;                                      // 0x0191(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInteractionComponent*         InteractionComponent;                              // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionLoopAnim">();
	}
	static class UInteractionLoopAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionLoopAnim>();
	}
};
static_assert(alignof(UInteractionLoopAnim) == 0x000008, "Wrong alignment on UInteractionLoopAnim");
static_assert(sizeof(UInteractionLoopAnim) == 0x0001A0, "Wrong size on UInteractionLoopAnim");
static_assert(offsetof(UInteractionLoopAnim, EndAnim) == 0x0000D0, "Member 'UInteractionLoopAnim::EndAnim' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, EndMontage) == 0x0000F8, "Member 'UInteractionLoopAnim::EndMontage' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, LoopMontageRes) == 0x000100, "Member 'UInteractionLoopAnim::LoopMontageRes' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, LoopMontage) == 0x000128, "Member 'UInteractionLoopAnim::LoopMontage' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, FaceEndAnim) == 0x000130, "Member 'UInteractionLoopAnim::FaceEndAnim' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, FaceEndMontage) == 0x000158, "Member 'UInteractionLoopAnim::FaceEndMontage' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, FaceLoopMontageRes) == 0x000160, "Member 'UInteractionLoopAnim::FaceLoopMontageRes' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, FaceLoopMontage) == 0x000188, "Member 'UInteractionLoopAnim::FaceLoopMontage' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, bCloseInteractionInAnimPlaying) == 0x000190, "Member 'UInteractionLoopAnim::bCloseInteractionInAnimPlaying' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, bCloseKawaii) == 0x000191, "Member 'UInteractionLoopAnim::bCloseKawaii' has a wrong offset!");
static_assert(offsetof(UInteractionLoopAnim, InteractionComponent) == 0x000198, "Member 'UInteractionLoopAnim::InteractionComponent' has a wrong offset!");

// Class CharacterInteraction.PlayAnimseqInteraction
// 0x00B8 (0x0218 - 0x0160)
class UPlayAnimseqInteraction : public UDragInteraction
{
public:
	TSoftObjectPtr<class UAnimSequence>           InteractionAnim;                                   // 0x0160(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Direction;                                         // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UAnimSequence>>   SyncInteractionAnim;                               // 0x0190(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimSequence>           BreathAnim;                                        // 0x01A0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UAnimSequence>>   SyncBreathAnim;                                    // 0x01C8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UAnimMontage*                           InteractionMontage;                                // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           BreathMontage;                                     // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   SyncBreathMontages;                                // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   SyncMontages;                                      // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAnimseqInteraction">();
	}
	static class UPlayAnimseqInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAnimseqInteraction>();
	}
};
static_assert(alignof(UPlayAnimseqInteraction) == 0x000008, "Wrong alignment on UPlayAnimseqInteraction");
static_assert(sizeof(UPlayAnimseqInteraction) == 0x000218, "Wrong size on UPlayAnimseqInteraction");
static_assert(offsetof(UPlayAnimseqInteraction, InteractionAnim) == 0x000160, "Member 'UPlayAnimseqInteraction::InteractionAnim' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, Direction) == 0x000188, "Member 'UPlayAnimseqInteraction::Direction' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, SyncInteractionAnim) == 0x000190, "Member 'UPlayAnimseqInteraction::SyncInteractionAnim' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, BreathAnim) == 0x0001A0, "Member 'UPlayAnimseqInteraction::BreathAnim' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, SyncBreathAnim) == 0x0001C8, "Member 'UPlayAnimseqInteraction::SyncBreathAnim' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, InteractionMontage) == 0x0001D8, "Member 'UPlayAnimseqInteraction::InteractionMontage' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, BreathMontage) == 0x0001E0, "Member 'UPlayAnimseqInteraction::BreathMontage' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, SyncBreathMontages) == 0x0001E8, "Member 'UPlayAnimseqInteraction::SyncBreathMontages' has a wrong offset!");
static_assert(offsetof(UPlayAnimseqInteraction, SyncMontages) == 0x0001F8, "Member 'UPlayAnimseqInteraction::SyncMontages' has a wrong offset!");

// Class CharacterInteraction.PlayAnimSeqInteractionWithBack
// 0x0010 (0x0228 - 0x0218)
class UPlayAnimSeqInteractionWithBack final : public UPlayAnimseqInteraction
{
public:
	float                                         RecoverPlaySpeed;                                  // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenAutoPlay;                                      // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoPlayPercent;                                   // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenAutoBackPlay;                                  // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAnimSeqInteractionWithBack">();
	}
	static class UPlayAnimSeqInteractionWithBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAnimSeqInteractionWithBack>();
	}
};
static_assert(alignof(UPlayAnimSeqInteractionWithBack) == 0x000008, "Wrong alignment on UPlayAnimSeqInteractionWithBack");
static_assert(sizeof(UPlayAnimSeqInteractionWithBack) == 0x000228, "Wrong size on UPlayAnimSeqInteractionWithBack");
static_assert(offsetof(UPlayAnimSeqInteractionWithBack, RecoverPlaySpeed) == 0x000218, "Member 'UPlayAnimSeqInteractionWithBack::RecoverPlaySpeed' has a wrong offset!");
static_assert(offsetof(UPlayAnimSeqInteractionWithBack, OpenAutoPlay) == 0x00021C, "Member 'UPlayAnimSeqInteractionWithBack::OpenAutoPlay' has a wrong offset!");
static_assert(offsetof(UPlayAnimSeqInteractionWithBack, AutoPlayPercent) == 0x000220, "Member 'UPlayAnimSeqInteractionWithBack::AutoPlayPercent' has a wrong offset!");
static_assert(offsetof(UPlayAnimSeqInteractionWithBack, OpenAutoBackPlay) == 0x000224, "Member 'UPlayAnimSeqInteractionWithBack::OpenAutoBackPlay' has a wrong offset!");

// Class CharacterInteraction.InteractionProcessSequenceContext
// 0x0020 (0x0048 - 0x0028)
class UInteractionProcessSequenceContext final : public UObject
{
public:
	class AInteractionCharacter*                  Character;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterInteractionComponent*         Comp;                                              // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProcessSequenceContext">();
	}
	static class UInteractionProcessSequenceContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProcessSequenceContext>();
	}
};
static_assert(alignof(UInteractionProcessSequenceContext) == 0x000008, "Wrong alignment on UInteractionProcessSequenceContext");
static_assert(sizeof(UInteractionProcessSequenceContext) == 0x000048, "Wrong size on UInteractionProcessSequenceContext");
static_assert(offsetof(UInteractionProcessSequenceContext, Character) == 0x000028, "Member 'UInteractionProcessSequenceContext::Character' has a wrong offset!");
static_assert(offsetof(UInteractionProcessSequenceContext, Comp) == 0x000030, "Member 'UInteractionProcessSequenceContext::Comp' has a wrong offset!");

// Class CharacterInteraction.InteractionExtraSequenceProcessorAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionExtraSequenceProcessorAsset final : public UDataAsset
{
public:
	class UInteractionExtraSequenceProcessor*     ExtraProcessor;                                    // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionExtraSequenceProcessorAsset">();
	}
	static class UInteractionExtraSequenceProcessorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionExtraSequenceProcessorAsset>();
	}
};
static_assert(alignof(UInteractionExtraSequenceProcessorAsset) == 0x000008, "Wrong alignment on UInteractionExtraSequenceProcessorAsset");
static_assert(sizeof(UInteractionExtraSequenceProcessorAsset) == 0x000038, "Wrong size on UInteractionExtraSequenceProcessorAsset");
static_assert(offsetof(UInteractionExtraSequenceProcessorAsset, ExtraProcessor) == 0x000030, "Member 'UInteractionExtraSequenceProcessorAsset::ExtraProcessor' has a wrong offset!");

// Class CharacterInteraction.InteractionProcessStandByContext
// 0x0018 (0x0040 - 0x0028)
class UInteractionProcessStandByContext final : public UObject
{
public:
	class AInteractionCharacter*                  Character;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterInteractionComponent*         Comp;                                              // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProcessStandByContext">();
	}
	static class UInteractionProcessStandByContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProcessStandByContext>();
	}
};
static_assert(alignof(UInteractionProcessStandByContext) == 0x000008, "Wrong alignment on UInteractionProcessStandByContext");
static_assert(sizeof(UInteractionProcessStandByContext) == 0x000040, "Wrong size on UInteractionProcessStandByContext");
static_assert(offsetof(UInteractionProcessStandByContext, Character) == 0x000028, "Member 'UInteractionProcessStandByContext::Character' has a wrong offset!");
static_assert(offsetof(UInteractionProcessStandByContext, Comp) == 0x000030, "Member 'UInteractionProcessStandByContext::Comp' has a wrong offset!");

// Class CharacterInteraction.InteractionExtraStandByProcessorAsset
// 0x0008 (0x0038 - 0x0030)
class UInteractionExtraStandByProcessorAsset final : public UDataAsset
{
public:
	class UInteractionExtraStandByProcessor*      ExtraProcessor;                                    // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionExtraStandByProcessorAsset">();
	}
	static class UInteractionExtraStandByProcessorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionExtraStandByProcessorAsset>();
	}
};
static_assert(alignof(UInteractionExtraStandByProcessorAsset) == 0x000008, "Wrong alignment on UInteractionExtraStandByProcessorAsset");
static_assert(sizeof(UInteractionExtraStandByProcessorAsset) == 0x000038, "Wrong size on UInteractionExtraStandByProcessorAsset");
static_assert(offsetof(UInteractionExtraStandByProcessorAsset, ExtraProcessor) == 0x000030, "Member 'UInteractionExtraStandByProcessorAsset::ExtraProcessor' has a wrong offset!");

// Class CharacterInteraction.PropsInteractionLittleGame
// 0x0028 (0x0080 - 0x0058)
class UPropsInteractionLittleGame final : public UInteractionLittleGame
{
public:
	FMulticastInlineDelegateProperty_             CurrentEnergyReset;                                // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPropsData>                     PropsData;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInteractionPropData                   InteractionPropData;                               // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropsInteractionLittleGame">();
	}
	static class UPropsInteractionLittleGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropsInteractionLittleGame>();
	}
};
static_assert(alignof(UPropsInteractionLittleGame) == 0x000008, "Wrong alignment on UPropsInteractionLittleGame");
static_assert(sizeof(UPropsInteractionLittleGame) == 0x000080, "Wrong size on UPropsInteractionLittleGame");
static_assert(offsetof(UPropsInteractionLittleGame, CurrentEnergyReset) == 0x000058, "Member 'UPropsInteractionLittleGame::CurrentEnergyReset' has a wrong offset!");
static_assert(offsetof(UPropsInteractionLittleGame, PropsData) == 0x000068, "Member 'UPropsInteractionLittleGame::PropsData' has a wrong offset!");
static_assert(offsetof(UPropsInteractionLittleGame, InteractionPropData) == 0x000078, "Member 'UPropsInteractionLittleGame::InteractionPropData' has a wrong offset!");

// Class CharacterInteraction.SimpleQTE
// 0x0060 (0x00B8 - 0x0058)
class USimpleQTE final : public UInteractionLittleGame
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CharacterNames;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         QTEShowSequence;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VictoryShowSequence;                               // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailedShowSequence;                                // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumProgressSegment;                                // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QTEProgressDuration;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QTEClickSpeedDownRatio;                            // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressDecSpeed;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecSpeedIncreAcc;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProgressDecSpeed;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayNotifyStartLittleGame(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleQTE">();
	}
	static class USimpleQTE* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleQTE>();
	}
};
static_assert(alignof(USimpleQTE) == 0x000008, "Wrong alignment on USimpleQTE");
static_assert(sizeof(USimpleQTE) == 0x0000B8, "Wrong size on USimpleQTE");
static_assert(offsetof(USimpleQTE, CharacterNames) == 0x000080, "Member 'USimpleQTE::CharacterNames' has a wrong offset!");
static_assert(offsetof(USimpleQTE, QTEShowSequence) == 0x000090, "Member 'USimpleQTE::QTEShowSequence' has a wrong offset!");
static_assert(offsetof(USimpleQTE, VictoryShowSequence) == 0x000094, "Member 'USimpleQTE::VictoryShowSequence' has a wrong offset!");
static_assert(offsetof(USimpleQTE, FailedShowSequence) == 0x000098, "Member 'USimpleQTE::FailedShowSequence' has a wrong offset!");
static_assert(offsetof(USimpleQTE, NumProgressSegment) == 0x00009C, "Member 'USimpleQTE::NumProgressSegment' has a wrong offset!");
static_assert(offsetof(USimpleQTE, QTEProgressDuration) == 0x0000A0, "Member 'USimpleQTE::QTEProgressDuration' has a wrong offset!");
static_assert(offsetof(USimpleQTE, QTEClickSpeedDownRatio) == 0x0000A4, "Member 'USimpleQTE::QTEClickSpeedDownRatio' has a wrong offset!");
static_assert(offsetof(USimpleQTE, ProgressDecSpeed) == 0x0000A8, "Member 'USimpleQTE::ProgressDecSpeed' has a wrong offset!");
static_assert(offsetof(USimpleQTE, DecSpeedIncreAcc) == 0x0000AC, "Member 'USimpleQTE::DecSpeedIncreAcc' has a wrong offset!");
static_assert(offsetof(USimpleQTE, MaxProgressDecSpeed) == 0x0000B0, "Member 'USimpleQTE::MaxProgressDecSpeed' has a wrong offset!");

// Class CharacterInteraction.SwimRingShow
// 0x0020 (0x0078 - 0x0058)
class USwimRingShow final : public UInteractionLittleGame
{
public:
	TArray<class FName>                           CharacterNames;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 InputType, int32 ControlID)> OnLittleGameInputDelegate;                         // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwimRingShow">();
	}
	static class USwimRingShow* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwimRingShow>();
	}
};
static_assert(alignof(USwimRingShow) == 0x000008, "Wrong alignment on USwimRingShow");
static_assert(sizeof(USwimRingShow) == 0x000078, "Wrong size on USwimRingShow");
static_assert(offsetof(USwimRingShow, CharacterNames) == 0x000058, "Member 'USwimRingShow::CharacterNames' has a wrong offset!");
static_assert(offsetof(USwimRingShow, OnLittleGameInputDelegate) == 0x000068, "Member 'USwimRingShow::OnLittleGameInputDelegate' has a wrong offset!");

}

